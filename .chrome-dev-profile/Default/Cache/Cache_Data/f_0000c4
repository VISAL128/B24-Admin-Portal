import {NumberFormatter as $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5} from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/@internationalized/number/dist/NumberFormatter.mjs?v=1214a853";

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp('^.*\\(.*\\).*$');
const $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
    'latn',
    'arab',
    'hanidec',
    'deva',
    'beng'
];
class $6c7bd7858deea686$export$cd11ab140839f11d {
    /**
   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
   */ parse(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
    }
    /**
   * Returns whether the given string could potentially be a valid number. This should be used to
   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
   * of the minus/plus sign characters can be checked.
   */ isValidPartialNumber(value, minValue, maxValue) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
    }
    /**
   * Returns a numbering system for which the given string is valid in the current locale.
   * If no numbering system could be detected, the default numbering system for the current
   * locale is returned.
   */ getNumberingSystem(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        this.options = options;
    }
}
const $6c7bd7858deea686$var$numberParserCache = new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
    // First try the default numbering system for the provided locale
    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
    // If that doesn't match, and the locale doesn't include a hard coded numbering system,
    // try each of the other supported numbering systems until we find one that matches.
    if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {
        for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {
            let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);
            if (parser.isValidPartialNumber(value)) return parser;
        }
    }
    return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : '');
    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
    if (!parser) {
        parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
        $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
    }
    return parser;
}
// The actual number parser implementation. Instances of this class are cached
// based on the locale, options, and detected numbering system.
class $6c7bd7858deea686$var$NumberParserImpl {
    parse(value) {
        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'
        let fullySanitizedValue = this.sanitize(value);
        if (this.symbols.group) // Remove group characters, and replace decimal points and numerals with ASCII values.
        fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, '');
        if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, '.');
        if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, '-');
        fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
        if (this.options.style === 'percent') {
            // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing
            let isNegative = fullySanitizedValue.indexOf('-');
            fullySanitizedValue = fullySanitizedValue.replace('-', '');
            fullySanitizedValue = fullySanitizedValue.replace('+', '');
            let index = fullySanitizedValue.indexOf('.');
            if (index === -1) index = fullySanitizedValue.length;
            fullySanitizedValue = fullySanitizedValue.replace('.', '');
            if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
            else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
            else if (index - 2 === -2) fullySanitizedValue = '0.00';
            else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
            if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
        }
        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
        if (isNaN(newValue)) return NaN;
        if (this.options.style === 'percent') {
            var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
            // extra step for rounding percents to what our formatter would output
            let options = {
                ...this.options,
                style: 'decimal',
                minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
                maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
            };
            return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
        }
        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again
        if (this.options.currencySign === 'accounting' && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
        return newValue;
    }
    sanitize(value) {
        // Remove literals and whitespace, which are allowed anywhere in the string
        value = value.replace(this.symbols.literals, '');
        // Replace the ASCII minus sign with the minus sign used in the current locale
        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.
        if (this.symbols.minusSign) value = value.replace('-', this.symbols.minusSign);
        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that
        // instead they use the , (44) character or apparently the (1548) character.
        if (this.options.numberingSystem === 'arab') {
            if (this.symbols.decimal) {
                value = value.replace(',', this.symbols.decimal);
                value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
            }
            if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, '.', this.symbols.group);
        }
        // fr-FR group character is narrow non-breaking space, char code 8239 (U+202F), but that's not a key on the french keyboard,
        // so allow space and non-breaking space as a group char as well
        if (this.options.locale === 'fr-FR' && this.symbols.group) {
            value = $6c7bd7858deea686$var$replaceAll(value, ' ', this.symbols.group);
            value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
        }
        return value;
    }
    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
        value = this.sanitize(value);
        // Remove minus or plus sign, which must be at the start of the string.
        if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
        // Numbers cannot start with a group separator
        if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
        // Numbers that can't have any decimal values fail if a decimal character is typed
        if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
        // Remove numerals, groups, and decimals
        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, '');
        value = value.replace(this.symbols.numeral, '');
        if (this.symbols.decimal) value = value.replace(this.symbols.decimal, '');
        // The number is valid if there are no remaining characters
        return value.length === 0;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        // see https://tc39.es/ecma402/#sec-setnfdigitoptions, when using roundingIncrement, the maximumFractionDigits and minimumFractionDigits must be equal
        // by default, they are 0 and 3 respectively, so we set them to 0 if neither are set
        if (options.roundingIncrement !== 1 && options.roundingIncrement != null) {
            if (options.maximumFractionDigits == null && options.minimumFractionDigits == null) {
                options.maximumFractionDigits = 0;
                options.minimumFractionDigits = 0;
            } else if (options.maximumFractionDigits == null) options.maximumFractionDigits = options.minimumFractionDigits;
            else if (options.minimumFractionDigits == null) options.minimumFractionDigits = options.maximumFractionDigits;
        // if both are specified, let the normal Range Error be thrown
        }
        this.formatter = new Intl.NumberFormat(locale, options);
        this.options = this.formatter.resolvedOptions();
        this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
        var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
        if (this.options.style === 'percent' && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn('NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.');
    }
}
const $6c7bd7858deea686$var$nonLiteralParts = new Set([
    'decimal',
    'fraction',
    'integer',
    'minusSign',
    'plusSign',
    'group'
]);
// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes
// all unique numbers which we need to check in order to determine all the plural forms for a given locale.
// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script
const $6c7bd7858deea686$var$pluralNumbers = [
    0,
    4,
    2,
    1,
    11,
    20,
    3,
    7,
    100,
    21,
    0.1,
    1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
    // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set
    let symbolFormatter = new Intl.NumberFormat(locale, {
        ...intlOptions,
        // Resets so we get the full range of symbols
        minimumSignificantDigits: 1,
        maximumSignificantDigits: 21,
        roundingIncrement: 1,
        roundingPriority: 'auto',
        roundingMode: 'halfExpand'
    });
    // Note: some locale's don't add a group symbol until there is a ten thousands place
    let allParts = symbolFormatter.formatToParts(-10000.111);
    let posAllParts = symbolFormatter.formatToParts(10000.111);
    let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n)=>symbolFormatter.formatToParts(n));
    var _allParts_find_value;
    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p)=>p.type === 'minusSign')) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : '-';
    let plusSign = (_posAllParts_find = posAllParts.find((p)=>p.type === 'plusSign')) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
    // Safari does not support the signDisplay option, but our number parser polyfills it.
    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.
    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'exceptZero' || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'always')) plusSign = '+';
    // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters
    // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal
    let decimalParts = new Intl.NumberFormat(locale, {
        ...intlOptions,
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).formatToParts(0.001);
    let decimal = (_decimalParts_find = decimalParts.find((p)=>p.type === 'decimal')) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
    let group = (_allParts_find1 = allParts.find((p)=>p.type === 'group')) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that
    // don't contribute to the numerical value
    let allPartsLiterals = allParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value));
    let pluralPartsLiterals = pluralParts.flatMap((p)=>p.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)));
    let sortedLiterals = [
        ...new Set([
            ...allPartsLiterals,
            ...pluralPartsLiterals
        ])
    ].sort((a, b)=>b.length - a.length);
    let literals = sortedLiterals.length === 0 ? new RegExp('[\\p{White_Space}]', 'gu') : new RegExp(`${sortedLiterals.join('|')}|[\\p{White_Space}]`, 'gu');
    // These are for replacing non-latn characters with the latn equivalent
    let numerals = [
        ...new Intl.NumberFormat(intlOptions.locale, {
            useGrouping: false
        }).format(9876543210)
    ].reverse();
    let indexes = new Map(numerals.map((d, i)=>[
            d,
            i
        ]));
    let numeral = new RegExp(`[${numerals.join('')}]`, 'g');
    let index = (d)=>String(indexes.get(d));
    return {
        minusSign: minusSign,
        plusSign: plusSign,
        decimal: decimal,
        group: group,
        literals: literals,
        numeral: numeral,
        index: index
    };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
    if (str.replaceAll) return str.replaceAll(find, replace);
    return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}


export {$6c7bd7858deea686$export$cd11ab140839f11d as NumberParser};
                                               

//# sourceMappingURL=data:application/json;base64,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SyxJQUNyQyxJQUFJLE9BQU8sc0JBQXNCLFFBQ2pDLElBQUksT0FBTyxHQUFHLGVBQWUsSUFBSSxDQUFDLEtBQUssbUJBQW1CLENBQUMsRUFBRTtJQUVqRSx1RUFBdUU7SUFDdkUsSUFBSSxXQUFXO1dBQUksSUFBSSxLQUFLLFlBQVksQ0FBQyxZQUFZLE1BQU0sRUFBRTtZQUFDLGFBQWE7UUFBSyxHQUFHLE1BQU0sQ0FBQztLQUFZLENBQUMsT0FBTztJQUM5RyxJQUFJLFVBQVUsSUFBSSxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFNO1lBQUM7WUFBRztTQUFFO0lBQ25ELElBQUksVUFBVSxJQUFJLE9BQU8sQ0FBQyxDQUFDLEVBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtJQUNuRCxJQUFJLFFBQVEsQ0FBQSxJQUFLLE9BQU8sUUFBUSxHQUFHLENBQUM7SUFFcEMsT0FBTzttQkFBQztrQkFBVztpQkFBVTtlQUFTO2tCQUFPO2lCQUFVO2VBQVM7SUFBSztBQUN2RTtBQUVBLFNBQVMsaUNBQVcsR0FBVyxFQUFFLElBQXFCLEVBQUUsT0FBZTtJQUNyRSxJQUFJLElBQUksVUFBVSxFQUNoQixPQUFPLElBQUksVUFBVSxDQUFDLE1BQU07SUFHOUIsT0FBTyxJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQztBQUM5QjtBQUVBLFNBQVMsa0NBQVksTUFBYztJQUNqQyxPQUFPLE9BQU8sT0FBTyxDQUFDLHVCQUF1QjtBQUMvQyIsInNvdXJjZXMiOlsicGFja2FnZXMvQGludGVybmF0aW9uYWxpemVkL251bWJlci9zcmMvTnVtYmVyUGFyc2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge051bWJlckZvcm1hdHRlcn0gZnJvbSAnLi9OdW1iZXJGb3JtYXR0ZXInO1xuXG5pbnRlcmZhY2UgU3ltYm9scyB7XG4gIG1pbnVzU2lnbj86IHN0cmluZyxcbiAgcGx1c1NpZ24/OiBzdHJpbmcsXG4gIGRlY2ltYWw/OiBzdHJpbmcsXG4gIGdyb3VwPzogc3RyaW5nLFxuICBsaXRlcmFsczogUmVnRXhwLFxuICBudW1lcmFsOiBSZWdFeHAsXG4gIGluZGV4OiAodjogc3RyaW5nKSA9PiBzdHJpbmdcbn1cblxuY29uc3QgQ1VSUkVOQ1lfU0lHTl9SRUdFWCA9IG5ldyBSZWdFeHAoJ14uKlxcXFwoLipcXFxcKS4qJCcpO1xuY29uc3QgTlVNQkVSSU5HX1NZU1RFTVMgPSBbJ2xhdG4nLCAnYXJhYicsICdoYW5pZGVjJywgJ2RldmEnLCAnYmVuZyddO1xuXG4vKipcbiAqIEEgTnVtYmVyUGFyc2VyIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbG9jYWxlLWF3YXJlIHBhcnNpbmcgb2YgbnVtYmVycyBmcm9tIFVuaWNvZGUgc3RyaW5ncyxcbiAqIGFzIHdlbGwgYXMgdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHVzZXIgaW5wdXQuIEl0IGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICogdXNlZCBpbiB0aGUgaW5wdXQsIGFuZCBzdXBwb3J0cyBwYXJzaW5nIGRlY2ltYWxzLCBwZXJjZW50YWdlcywgY3VycmVuY3kgdmFsdWVzLCBhbmQgdW5pdHNcbiAqIGFjY29yZGluZyB0byB0aGUgbG9jYWxlLlxuICovXG5leHBvcnQgY2xhc3MgTnVtYmVyUGFyc2VyIHtcbiAgcHJpdmF0ZSBsb2NhbGU6IHN0cmluZztcbiAgcHJpdmF0ZSBvcHRpb25zOiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnM7XG5cbiAgY29uc3RydWN0b3IobG9jYWxlOiBzdHJpbmcsIG9wdGlvbnM6IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIHN0cmluZyB0byBhIG51bWJlci4gUmV0dXJucyBOYU4gaWYgYSB2YWxpZCBudW1iZXIgY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICovXG4gIHBhcnNlKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiBnZXROdW1iZXJQYXJzZXJJbXBsKHRoaXMubG9jYWxlLCB0aGlzLm9wdGlvbnMsIHZhbHVlKS5wYXJzZSh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgY291bGQgcG90ZW50aWFsbHkgYmUgYSB2YWxpZCBudW1iZXIuIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG9cbiAgICogdmFsaWRhdGUgdXNlciBpbnB1dCBhcyB0aGUgdXNlciB0eXBlcy4gSWYgYSBgbWluVmFsdWVgIG9yIGBtYXhWYWx1ZWAgaXMgcHJvdmlkZWQsIHRoZSB2YWxpZGl0eVxuICAgKiBvZiB0aGUgbWludXMvcGx1cyBzaWduIGNoYXJhY3RlcnMgY2FuIGJlIGNoZWNrZWQuXG4gICAqL1xuICBpc1ZhbGlkUGFydGlhbE51bWJlcih2YWx1ZTogc3RyaW5nLCBtaW5WYWx1ZT86IG51bWJlciwgbWF4VmFsdWU/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZ2V0TnVtYmVyUGFyc2VySW1wbCh0aGlzLmxvY2FsZSwgdGhpcy5vcHRpb25zLCB2YWx1ZSkuaXNWYWxpZFBhcnRpYWxOdW1iZXIodmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG51bWJlcmluZyBzeXN0ZW0gZm9yIHdoaWNoIHRoZSBnaXZlbiBzdHJpbmcgaXMgdmFsaWQgaW4gdGhlIGN1cnJlbnQgbG9jYWxlLlxuICAgKiBJZiBubyBudW1iZXJpbmcgc3lzdGVtIGNvdWxkIGJlIGRldGVjdGVkLCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIGZvciB0aGUgY3VycmVudFxuICAgKiBsb2NhbGUgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXROdW1iZXJpbmdTeXN0ZW0odmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGdldE51bWJlclBhcnNlckltcGwodGhpcy5sb2NhbGUsIHRoaXMub3B0aW9ucywgdmFsdWUpLm9wdGlvbnMubnVtYmVyaW5nU3lzdGVtO1xuICB9XG59XG5cbmNvbnN0IG51bWJlclBhcnNlckNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIE51bWJlclBhcnNlckltcGw+KCk7XG5mdW5jdGlvbiBnZXROdW1iZXJQYXJzZXJJbXBsKGxvY2FsZTogc3RyaW5nLCBvcHRpb25zOiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMsIHZhbHVlOiBzdHJpbmcpIHtcbiAgLy8gRmlyc3QgdHJ5IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gZm9yIHRoZSBwcm92aWRlZCBsb2NhbGVcbiAgbGV0IGRlZmF1bHRQYXJzZXIgPSBnZXRDYWNoZWROdW1iZXJQYXJzZXIobG9jYWxlLCBvcHRpb25zKTtcblxuICAvLyBJZiB0aGF0IGRvZXNuJ3QgbWF0Y2gsIGFuZCB0aGUgbG9jYWxlIGRvZXNuJ3QgaW5jbHVkZSBhIGhhcmQgY29kZWQgbnVtYmVyaW5nIHN5c3RlbSxcbiAgLy8gdHJ5IGVhY2ggb2YgdGhlIG90aGVyIHN1cHBvcnRlZCBudW1iZXJpbmcgc3lzdGVtcyB1bnRpbCB3ZSBmaW5kIG9uZSB0aGF0IG1hdGNoZXMuXG4gIGlmICghbG9jYWxlLmluY2x1ZGVzKCctbnUtJykgJiYgIWRlZmF1bHRQYXJzZXIuaXNWYWxpZFBhcnRpYWxOdW1iZXIodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgbnVtYmVyaW5nU3lzdGVtIG9mIE5VTUJFUklOR19TWVNURU1TKSB7XG4gICAgICBpZiAobnVtYmVyaW5nU3lzdGVtICE9PSBkZWZhdWx0UGFyc2VyLm9wdGlvbnMubnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgICAgIGxldCBwYXJzZXIgPSBnZXRDYWNoZWROdW1iZXJQYXJzZXIobG9jYWxlICsgKGxvY2FsZS5pbmNsdWRlcygnLXUtJykgPyAnLW51LScgOiAnLXUtbnUtJykgKyBudW1iZXJpbmdTeXN0ZW0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocGFyc2VyLmlzVmFsaWRQYXJ0aWFsTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFBhcnNlcjtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGVkTnVtYmVyUGFyc2VyKGxvY2FsZTogc3RyaW5nLCBvcHRpb25zOiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMpIHtcbiAgbGV0IGNhY2hlS2V5ID0gbG9jYWxlICsgKG9wdGlvbnMgPyBPYmplY3QuZW50cmllcyhvcHRpb25zKS5zb3J0KChhLCBiKSA9PiBhWzBdIDwgYlswXSA/IC0xIDogMSkuam9pbigpIDogJycpO1xuICBsZXQgcGFyc2VyID0gbnVtYmVyUGFyc2VyQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFwYXJzZXIpIHtcbiAgICBwYXJzZXIgPSBuZXcgTnVtYmVyUGFyc2VySW1wbChsb2NhbGUsIG9wdGlvbnMpO1xuICAgIG51bWJlclBhcnNlckNhY2hlLnNldChjYWNoZUtleSwgcGFyc2VyKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXI7XG59XG5cbi8vIFRoZSBhY3R1YWwgbnVtYmVyIHBhcnNlciBpbXBsZW1lbnRhdGlvbi4gSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGNhY2hlZFxuLy8gYmFzZWQgb24gdGhlIGxvY2FsZSwgb3B0aW9ucywgYW5kIGRldGVjdGVkIG51bWJlcmluZyBzeXN0ZW0uXG5jbGFzcyBOdW1iZXJQYXJzZXJJbXBsIHtcbiAgZm9ybWF0dGVyOiBJbnRsLk51bWJlckZvcm1hdDtcbiAgb3B0aW9uczogSW50bC5SZXNvbHZlZE51bWJlckZvcm1hdE9wdGlvbnM7XG4gIHN5bWJvbHM6IFN5bWJvbHM7XG4gIGxvY2FsZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZTogc3RyaW5nLCBvcHRpb25zOiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgIC8vIHNlZSBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLXNldG5mZGlnaXRvcHRpb25zLCB3aGVuIHVzaW5nIHJvdW5kaW5nSW5jcmVtZW50LCB0aGUgbWF4aW11bUZyYWN0aW9uRGlnaXRzIGFuZCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgbXVzdCBiZSBlcXVhbFxuICAgIC8vIGJ5IGRlZmF1bHQsIHRoZXkgYXJlIDAgYW5kIDMgcmVzcGVjdGl2ZWx5LCBzbyB3ZSBzZXQgdGhlbSB0byAwIGlmIG5laXRoZXIgYXJlIHNldFxuICAgIGlmIChvcHRpb25zLnJvdW5kaW5nSW5jcmVtZW50ICE9PSAxICYmIG9wdGlvbnMucm91bmRpbmdJbmNyZW1lbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMubWF4aW11bUZyYWN0aW9uRGlnaXRzID09IG51bGwgJiYgb3B0aW9ucy5taW5pbXVtRnJhY3Rpb25EaWdpdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLm1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IDA7XG4gICAgICAgIG9wdGlvbnMubWluaW11bUZyYWN0aW9uRGlnaXRzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tYXhpbXVtRnJhY3Rpb25EaWdpdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLm1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IG9wdGlvbnMubWluaW11bUZyYWN0aW9uRGlnaXRzO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMubWluaW11bUZyYWN0aW9uRGlnaXRzID0gb3B0aW9ucy5tYXhpbXVtRnJhY3Rpb25EaWdpdHM7XG4gICAgICB9XG4gICAgICAvLyBpZiBib3RoIGFyZSBzcGVjaWZpZWQsIGxldCB0aGUgbm9ybWFsIFJhbmdlIEVycm9yIGJlIHRocm93blxuICAgIH1cbiAgICB0aGlzLmZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuZm9ybWF0dGVyLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIHRoaXMuc3ltYm9scyA9IGdldFN5bWJvbHMobG9jYWxlLCB0aGlzLmZvcm1hdHRlciwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlID09PSAncGVyY2VudCcgJiYgKCh0aGlzLm9wdGlvbnMubWluaW11bUZyYWN0aW9uRGlnaXRzID8/IDApID4gMTggfHwgKHRoaXMub3B0aW9ucy5tYXhpbXVtRnJhY3Rpb25EaWdpdHMgPz8gMCkgPiAxOCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignTnVtYmVyUGFyc2VyIGNhbm5vdCBoYW5kbGUgcGVyY2VudGFnZXMgd2l0aCBncmVhdGVyIHRoYW4gMTggZGVjaW1hbCBwbGFjZXMsIHBsZWFzZSByZWR1Y2UgdGhlIG51bWJlciBpbiB5b3VyIG9wdGlvbnMuJyk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2UodmFsdWU6IHN0cmluZykge1xuICAgIC8vIHRvIHBhcnNlIHRoZSBudW1iZXIsIHdlIG5lZWQgdG8gcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXNuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgbnVtYmVyLCBmb3IgZXhhbXBsZSB3ZSB3YW50ICctMTAuNDAnIG5vdCAnLTEwLjQwIFVTRCdcbiAgICBsZXQgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IHRoaXMuc2FuaXRpemUodmFsdWUpO1xuXG4gICAgaWYgKHRoaXMuc3ltYm9scy5ncm91cCkge1xuICAgICAgLy8gUmVtb3ZlIGdyb3VwIGNoYXJhY3RlcnMsIGFuZCByZXBsYWNlIGRlY2ltYWwgcG9pbnRzIGFuZCBudW1lcmFscyB3aXRoIEFTQ0lJIHZhbHVlcy5cbiAgICAgIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSByZXBsYWNlQWxsKGZ1bGx5U2FuaXRpemVkVmFsdWUsIHRoaXMuc3ltYm9scy5ncm91cCwgJycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zeW1ib2xzLmRlY2ltYWwpIHtcbiAgICAgIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBmdWxseVNhbml0aXplZFZhbHVlLnJlcGxhY2UodGhpcy5zeW1ib2xzLmRlY2ltYWwhLCAnLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zeW1ib2xzLm1pbnVzU2lnbikge1xuICAgICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMubWludXNTaWduISwgJy0nKTtcbiAgICB9XG4gICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMubnVtZXJhbCwgdGhpcy5zeW1ib2xzLmluZGV4KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUgPT09ICdwZXJjZW50Jykge1xuICAgICAgLy8gamF2YXNjcmlwdCBpcyBiYWQgYXQgZGl2aWRpbmcgYnkgMTAwIGFuZCBtYWludGFpbmluZyB0aGUgc2FtZSBzaWduaWZpY2FudCBmaWd1cmVzLCBzbyBwZXJmb3JtIGl0IG9uIHRoZSBzdHJpbmcgYmVmb3JlIHBhcnNpbmdcbiAgICAgIGxldCBpc05lZ2F0aXZlID0gZnVsbHlTYW5pdGl6ZWRWYWx1ZS5pbmRleE9mKCctJyk7XG4gICAgICBmdWxseVNhbml0aXplZFZhbHVlID0gZnVsbHlTYW5pdGl6ZWRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZSgnKycsICcnKTtcbiAgICAgIGxldCBpbmRleCA9IGZ1bGx5U2FuaXRpemVkVmFsdWUuaW5kZXhPZignLicpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpbmRleCA9IGZ1bGx5U2FuaXRpemVkVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZSgnLicsICcnKTtcbiAgICAgIGlmIChpbmRleCAtIDIgPT09IDApIHtcbiAgICAgICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGAwLiR7ZnVsbHlTYW5pdGl6ZWRWYWx1ZX1gO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCAtIDIgPT09IC0xKSB7XG4gICAgICAgIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBgMC4wJHtmdWxseVNhbml0aXplZFZhbHVlfWA7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4IC0gMiA9PT0gLTIpIHtcbiAgICAgICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9ICcwLjAwJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBgJHtmdWxseVNhbml0aXplZFZhbHVlLnNsaWNlKDAsIGluZGV4IC0gMil9LiR7ZnVsbHlTYW5pdGl6ZWRWYWx1ZS5zbGljZShpbmRleCAtIDIpfWA7XG4gICAgICB9XG4gICAgICBpZiAoaXNOZWdhdGl2ZSA+IC0xKSB7XG4gICAgICAgIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBgLSR7ZnVsbHlTYW5pdGl6ZWRWYWx1ZX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBuZXdWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUgPyArZnVsbHlTYW5pdGl6ZWRWYWx1ZSA6IE5hTjtcbiAgICBpZiAoaXNOYU4obmV3VmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUgPT09ICdwZXJjZW50Jykge1xuICAgICAgLy8gZXh0cmEgc3RlcCBmb3Igcm91bmRpbmcgcGVyY2VudHMgdG8gd2hhdCBvdXIgZm9ybWF0dGVyIHdvdWxkIG91dHB1dFxuICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgc3R5bGU6ICdkZWNpbWFsJyBhcyBjb25zdCxcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBNYXRoLm1pbigodGhpcy5vcHRpb25zLm1pbmltdW1GcmFjdGlvbkRpZ2l0cyA/PyAwKSArIDIsIDIwKSxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBNYXRoLm1pbigodGhpcy5vcHRpb25zLm1heGltdW1GcmFjdGlvbkRpZ2l0cyA/PyAwKSArIDIsIDIwKVxuICAgICAgfTtcbiAgICAgIHJldHVybiAobmV3IE51bWJlclBhcnNlcih0aGlzLmxvY2FsZSwgb3B0aW9ucykpLnBhcnNlKG5ldyBOdW1iZXJGb3JtYXR0ZXIodGhpcy5sb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChuZXdWYWx1ZSkpO1xuICAgIH1cblxuICAgIC8vIGFjY291bnRpbmcgd2lsbCBhbHdheXMgYmUgc3RyaXBwZWQgdG8gYSBwb3NpdGl2ZSBudW1iZXIsIHNvIGlmIGl0J3MgYWNjb3VudGluZyBhbmQgaGFzIGEgKCkgYXJvdW5kIGV2ZXJ5dGhpbmcsIHRoZW4gd2UgbmVlZCB0byBtYWtlIGl0IG5lZ2F0aXZlIGFnYWluXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW5jeVNpZ24gPT09ICdhY2NvdW50aW5nJyAmJiBDVVJSRU5DWV9TSUdOX1JFR0VYLnRlc3QodmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IC0xICogbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9XG5cbiAgc2FuaXRpemUodmFsdWU6IHN0cmluZykge1xuICAgIC8vIFJlbW92ZSBsaXRlcmFscyBhbmQgd2hpdGVzcGFjZSwgd2hpY2ggYXJlIGFsbG93ZWQgYW55d2hlcmUgaW4gdGhlIHN0cmluZ1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMubGl0ZXJhbHMsICcnKTtcblxuICAgIC8vIFJlcGxhY2UgdGhlIEFTQ0lJIG1pbnVzIHNpZ24gd2l0aCB0aGUgbWludXMgc2lnbiB1c2VkIGluIHRoZSBjdXJyZW50IGxvY2FsZVxuICAgIC8vIHNvIHRoYXQgYm90aCBhcmUgYWxsb3dlZCBpbiBjYXNlIHRoZSB1c2VyJ3Mga2V5Ym9hcmQgZG9lc24ndCBoYXZlIHRoZSBsb2NhbGUncyBtaW51cyBzaWduLlxuICAgIGlmICh0aGlzLnN5bWJvbHMubWludXNTaWduKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy0nLCB0aGlzLnN5bWJvbHMubWludXNTaWduKTtcbiAgICB9XG5cbiAgICAvLyBJbiBhcmFiIG51bWVyYWwgc3lzdGVtLCB0aGVpciBkZWNpbWFsIGNoYXJhY3RlciBpcyAxNjQzLCBidXQgbW9zdCBrZXlib2FyZHMgZG9uJ3QgdHlwZSB0aGF0XG4gICAgLy8gaW5zdGVhZCB0aGV5IHVzZSB0aGUgLCAoNDQpIGNoYXJhY3RlciBvciBhcHBhcmVudGx5IHRoZSAoMTU0OCkgY2hhcmFjdGVyLlxuICAgIGlmICh0aGlzLm9wdGlvbnMubnVtYmVyaW5nU3lzdGVtID09PSAnYXJhYicpIHtcbiAgICAgIGlmICh0aGlzLnN5bWJvbHMuZGVjaW1hbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJywnLCB0aGlzLnN5bWJvbHMuZGVjaW1hbCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShTdHJpbmcuZnJvbUNoYXJDb2RlKDE1NDgpLCB0aGlzLnN5bWJvbHMuZGVjaW1hbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zeW1ib2xzLmdyb3VwKSB7XG4gICAgICAgIHZhbHVlID0gcmVwbGFjZUFsbCh2YWx1ZSwgJy4nLCB0aGlzLnN5bWJvbHMuZ3JvdXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZyLUZSIGdyb3VwIGNoYXJhY3RlciBpcyBuYXJyb3cgbm9uLWJyZWFraW5nIHNwYWNlLCBjaGFyIGNvZGUgODIzOSAoVSsyMDJGKSwgYnV0IHRoYXQncyBub3QgYSBrZXkgb24gdGhlIGZyZW5jaCBrZXlib2FyZCxcbiAgICAvLyBzbyBhbGxvdyBzcGFjZSBhbmQgbm9uLWJyZWFraW5nIHNwYWNlIGFzIGEgZ3JvdXAgY2hhciBhcyB3ZWxsXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhbGUgPT09ICdmci1GUicgJiYgdGhpcy5zeW1ib2xzLmdyb3VwKSB7XG4gICAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsICcgJywgdGhpcy5zeW1ib2xzLmdyb3VwKTtcbiAgICAgIHZhbHVlID0gcmVwbGFjZUFsbCh2YWx1ZSwgL1xcdTAwQTAvZywgdGhpcy5zeW1ib2xzLmdyb3VwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpc1ZhbGlkUGFydGlhbE51bWJlcih2YWx1ZTogc3RyaW5nLCBtaW5WYWx1ZTogbnVtYmVyID0gLUluZmluaXR5LCBtYXhWYWx1ZTogbnVtYmVyID0gSW5maW5pdHkpOiBib29sZWFuIHtcbiAgICB2YWx1ZSA9IHRoaXMuc2FuaXRpemUodmFsdWUpO1xuXG4gICAgLy8gUmVtb3ZlIG1pbnVzIG9yIHBsdXMgc2lnbiwgd2hpY2ggbXVzdCBiZSBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZy5cbiAgICBpZiAodGhpcy5zeW1ib2xzLm1pbnVzU2lnbiAmJiB2YWx1ZS5zdGFydHNXaXRoKHRoaXMuc3ltYm9scy5taW51c1NpZ24pICYmIG1pblZhbHVlIDwgMCkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSh0aGlzLnN5bWJvbHMubWludXNTaWduLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN5bWJvbHMucGx1c1NpZ24gJiYgdmFsdWUuc3RhcnRzV2l0aCh0aGlzLnN5bWJvbHMucGx1c1NpZ24pICYmIG1heFZhbHVlID4gMCkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSh0aGlzLnN5bWJvbHMucGx1c1NpZ24ubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBOdW1iZXJzIGNhbm5vdCBzdGFydCB3aXRoIGEgZ3JvdXAgc2VwYXJhdG9yXG4gICAgaWYgKHRoaXMuc3ltYm9scy5ncm91cCAmJiB2YWx1ZS5zdGFydHNXaXRoKHRoaXMuc3ltYm9scy5ncm91cCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBOdW1iZXJzIHRoYXQgY2FuJ3QgaGF2ZSBhbnkgZGVjaW1hbCB2YWx1ZXMgZmFpbCBpZiBhIGRlY2ltYWwgY2hhcmFjdGVyIGlzIHR5cGVkXG4gICAgaWYgKHRoaXMuc3ltYm9scy5kZWNpbWFsICYmIHZhbHVlLmluZGV4T2YodGhpcy5zeW1ib2xzLmRlY2ltYWwpID4gLTEgJiYgdGhpcy5vcHRpb25zLm1heGltdW1GcmFjdGlvbkRpZ2l0cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBudW1lcmFscywgZ3JvdXBzLCBhbmQgZGVjaW1hbHNcbiAgICBpZiAodGhpcy5zeW1ib2xzLmdyb3VwKSB7XG4gICAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsIHRoaXMuc3ltYm9scy5ncm91cCwgJycpO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UodGhpcy5zeW1ib2xzLm51bWVyYWwsICcnKTtcbiAgICBpZiAodGhpcy5zeW1ib2xzLmRlY2ltYWwpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMuZGVjaW1hbCwgJycpO1xuICAgIH1cblxuICAgIC8vIFRoZSBudW1iZXIgaXMgdmFsaWQgaWYgdGhlcmUgYXJlIG5vIHJlbWFpbmluZyBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgfVxufVxuXG5jb25zdCBub25MaXRlcmFsUGFydHMgPSBuZXcgU2V0KFsnZGVjaW1hbCcsICdmcmFjdGlvbicsICdpbnRlZ2VyJywgJ21pbnVzU2lnbicsICdwbHVzU2lnbicsICdncm91cCddKTtcblxuLy8gVGhpcyBsaXN0IGlzIGRlcml2ZWQgZnJvbSBodHRwczovL3d3dy51bmljb2RlLm9yZy9jbGRyL2NoYXJ0cy80My9zdXBwbGVtZW50YWwvbGFuZ3VhZ2VfcGx1cmFsX3J1bGVzLmh0bWwjY29tcGFyaXNvbiBhbmQgaW5jbHVkZXNcbi8vIGFsbCB1bmlxdWUgbnVtYmVycyB3aGljaCB3ZSBuZWVkIHRvIGNoZWNrIGluIG9yZGVyIHRvIGRldGVybWluZSBhbGwgdGhlIHBsdXJhbCBmb3JtcyBmb3IgYSBnaXZlbiBsb2NhbGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9wdWxsLzUxMzQvZmlsZXMjcjEzMzcwMzc4NTUgZm9yIHVzZWQgc2NyaXB0XG5jb25zdCBwbHVyYWxOdW1iZXJzID0gW1xuICAwLCA0LCAyLCAxLCAxMSwgMjAsIDMsIDcsIDEwMCwgMjEsIDAuMSwgMS4xXG5dO1xuXG5mdW5jdGlvbiBnZXRTeW1ib2xzKGxvY2FsZTogc3RyaW5nLCBmb3JtYXR0ZXI6IEludGwuTnVtYmVyRm9ybWF0LCBpbnRsT3B0aW9uczogSW50bC5SZXNvbHZlZE51bWJlckZvcm1hdE9wdGlvbnMsIG9yaWdpbmFsT3B0aW9uczogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKTogU3ltYm9scyB7XG4gIC8vIGZvcm1hdHRlciBuZWVkcyBhY2Nlc3MgdG8gYWxsIGRlY2ltYWwgcGxhY2VzIGluIG9yZGVyIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IGxpdGVyYWwgc3RyaW5ncyBmb3IgdGhlIHBsdXJhbCBzZXRcbiAgbGV0IHN5bWJvbEZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHsuLi5pbnRsT3B0aW9ucyxcbiAgICAvLyBSZXNldHMgc28gd2UgZ2V0IHRoZSBmdWxsIHJhbmdlIG9mIHN5bWJvbHNcbiAgICBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHM6IDEsXG4gICAgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzOiAyMSxcbiAgICByb3VuZGluZ0luY3JlbWVudDogMSxcbiAgICByb3VuZGluZ1ByaW9yaXR5OiAnYXV0bycsXG4gICAgcm91bmRpbmdNb2RlOiAnaGFsZkV4cGFuZCdcbiAgfSk7XG4gIC8vIE5vdGU6IHNvbWUgbG9jYWxlJ3MgZG9uJ3QgYWRkIGEgZ3JvdXAgc3ltYm9sIHVudGlsIHRoZXJlIGlzIGEgdGVuIHRob3VzYW5kcyBwbGFjZVxuICBsZXQgYWxsUGFydHMgPSBzeW1ib2xGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cygtMTAwMDAuMTExKTtcbiAgbGV0IHBvc0FsbFBhcnRzID0gc3ltYm9sRm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoMTAwMDAuMTExKTtcbiAgbGV0IHBsdXJhbFBhcnRzID0gcGx1cmFsTnVtYmVycy5tYXAobiA9PiBzeW1ib2xGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuKSk7XG5cbiAgbGV0IG1pbnVzU2lnbiA9IGFsbFBhcnRzLmZpbmQocCA9PiBwLnR5cGUgPT09ICdtaW51c1NpZ24nKT8udmFsdWUgPz8gJy0nO1xuICBsZXQgcGx1c1NpZ24gPSBwb3NBbGxQYXJ0cy5maW5kKHAgPT4gcC50eXBlID09PSAncGx1c1NpZ24nKT8udmFsdWU7XG5cbiAgLy8gU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgdGhlIHNpZ25EaXNwbGF5IG9wdGlvbiwgYnV0IG91ciBudW1iZXIgcGFyc2VyIHBvbHlmaWxscyBpdC5cbiAgLy8gSWYgbm8gcGx1cyBzaWduIHdhcyByZXR1cm5lZCwgYnV0IHRoZSBvcmlnaW5hbCBvcHRpb25zIGNvbnRhaW5lZCBzaWduRGlzcGxheSwgZGVmYXVsdCB0byB0aGUgJysnIGNoYXJhY3Rlci5cbiAgaWYgKCFwbHVzU2lnbiAmJiAob3JpZ2luYWxPcHRpb25zPy5zaWduRGlzcGxheSA9PT0gJ2V4Y2VwdFplcm8nIHx8IG9yaWdpbmFsT3B0aW9ucz8uc2lnbkRpc3BsYXkgPT09ICdhbHdheXMnKSkge1xuICAgIHBsdXNTaWduID0gJysnO1xuICB9XG5cbiAgLy8gSWYgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzIGlzIDEgKHRoZSBtaW5pbXVtKSB0aGVuIHdlIHdvbid0IGdldCBkZWNpbWFsIGNoYXJhY3RlcnMgb3V0IG9mIHRoZSBhYm92ZSBmb3JtYXR0ZXJzXG4gIC8vIFBlcmNlbnQgYWxzbyBkZWZhdWx0cyB0byAwIGZyYWN0aW9uRGlnaXRzLCBzbyB3ZSBuZWVkIHRvIG1ha2UgYSBuZXcgb25lIHRoYXQgaXNuJ3QgcGVyY2VudCB0byBnZXQgYW4gYWNjdXJhdGUgZGVjaW1hbFxuICBsZXQgZGVjaW1hbFBhcnRzID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgey4uLmludGxPcHRpb25zLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMn0pLmZvcm1hdFRvUGFydHMoMC4wMDEpO1xuXG4gIGxldCBkZWNpbWFsID0gZGVjaW1hbFBhcnRzLmZpbmQocCA9PiBwLnR5cGUgPT09ICdkZWNpbWFsJyk/LnZhbHVlO1xuICBsZXQgZ3JvdXAgPSBhbGxQYXJ0cy5maW5kKHAgPT4gcC50eXBlID09PSAnZ3JvdXAnKT8udmFsdWU7XG5cbiAgLy8gdGhpcyBzZXQgaXMgYWxzbyBmb3IgYSByZWdleCwgaXQncyBhbGwgbGl0ZXJhbHMgdGhhdCBtaWdodCBiZSBpbiB0aGUgc3RyaW5nIHdlIHdhbnQgdG8gZXZlbnR1YWxseSBwYXJzZSB0aGF0XG4gIC8vIGRvbid0IGNvbnRyaWJ1dGUgdG8gdGhlIG51bWVyaWNhbCB2YWx1ZVxuICBsZXQgYWxsUGFydHNMaXRlcmFscyA9IGFsbFBhcnRzLmZpbHRlcihwID0+ICFub25MaXRlcmFsUGFydHMuaGFzKHAudHlwZSkpLm1hcChwID0+IGVzY2FwZVJlZ2V4KHAudmFsdWUpKTtcbiAgbGV0IHBsdXJhbFBhcnRzTGl0ZXJhbHMgPSBwbHVyYWxQYXJ0cy5mbGF0TWFwKHAgPT4gcC5maWx0ZXIocCA9PiAhbm9uTGl0ZXJhbFBhcnRzLmhhcyhwLnR5cGUpKS5tYXAocCA9PiBlc2NhcGVSZWdleChwLnZhbHVlKSkpO1xuICBsZXQgc29ydGVkTGl0ZXJhbHMgPSBbLi4ubmV3IFNldChbLi4uYWxsUGFydHNMaXRlcmFscywgLi4ucGx1cmFsUGFydHNMaXRlcmFsc10pXS5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcblxuICBsZXQgbGl0ZXJhbHMgPSBzb3J0ZWRMaXRlcmFscy5sZW5ndGggPT09IDAgP1xuICAgICAgbmV3IFJlZ0V4cCgnW1xcXFxwe1doaXRlX1NwYWNlfV0nLCAnZ3UnKSA6XG4gICAgICBuZXcgUmVnRXhwKGAke3NvcnRlZExpdGVyYWxzLmpvaW4oJ3wnKX18W1xcXFxwe1doaXRlX1NwYWNlfV1gLCAnZ3UnKTtcblxuICAvLyBUaGVzZSBhcmUgZm9yIHJlcGxhY2luZyBub24tbGF0biBjaGFyYWN0ZXJzIHdpdGggdGhlIGxhdG4gZXF1aXZhbGVudFxuICBsZXQgbnVtZXJhbHMgPSBbLi4ubmV3IEludGwuTnVtYmVyRm9ybWF0KGludGxPcHRpb25zLmxvY2FsZSwge3VzZUdyb3VwaW5nOiBmYWxzZX0pLmZvcm1hdCg5ODc2NTQzMjEwKV0ucmV2ZXJzZSgpO1xuICBsZXQgaW5kZXhlcyA9IG5ldyBNYXAobnVtZXJhbHMubWFwKChkLCBpKSA9PiBbZCwgaV0pKTtcbiAgbGV0IG51bWVyYWwgPSBuZXcgUmVnRXhwKGBbJHtudW1lcmFscy5qb2luKCcnKX1dYCwgJ2cnKTtcbiAgbGV0IGluZGV4ID0gZCA9PiBTdHJpbmcoaW5kZXhlcy5nZXQoZCkpO1xuXG4gIHJldHVybiB7bWludXNTaWduLCBwbHVzU2lnbiwgZGVjaW1hbCwgZ3JvdXAsIGxpdGVyYWxzLCBudW1lcmFsLCBpbmRleH07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VBbGwoc3RyOiBzdHJpbmcsIGZpbmQ6IHN0cmluZyB8IFJlZ0V4cCwgcmVwbGFjZTogc3RyaW5nKSB7XG4gIGlmIChzdHIucmVwbGFjZUFsbCkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZUFsbChmaW5kLCByZXBsYWNlKTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3BsaXQoZmluZCkuam9pbihyZXBsYWNlKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyaW5nOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuIl0sIm5hbWVzIjpbXSwidmVyc2lvbiI6MywiZmlsZSI6Ik51bWJlclBhcnNlci5tb2R1bGUuanMubWFwIiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzBdfQ==