import { debounce, memo, notUndefined, approxEqual } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/@tanstack/virtual-core/dist/esm/utils.js?v=1214a853";
const getRect = (element) => {
  const { offsetWidth, offsetHeight } = element;
  return { width: offsetWidth, height: offsetHeight };
};
const defaultKeyExtractor = (index) => index;
const defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
};
const observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(getRect(element));
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(getRect(element));
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
const addEventListenerOptions = {
  passive: true
};
const observeWindowRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const handler = () => {
    cb({ width: element.innerWidth, height: element.innerHeight });
  };
  handler();
  element.addEventListener("resize", handler, addEventListenerOptions);
  return () => {
    element.removeEventListener("resize", handler);
  };
};
const supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
const observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
const observeWindowOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    offset = element[instance.options.horizontal ? "scrollX" : "scrollY"];
    fallback();
    cb(offset, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
const measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size;
    }
  }
  return element[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
};
const windowScroll = (offset, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
const elementScroll = (offset, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
class Virtualizer {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a;
          (_a = get()) == null ? void 0 : _a.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined") delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a, _b;
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d) => d());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? "forward" : "backward" : null;
            this.scrollOffset = offset;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m = index - 1; m >= 0; m--) {
        const measurement = measurements[m];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {
        if (a.end === b.end) {
          return a.index - b.index;
        }
        return a.end - b.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min);
        for (let i = min; i < count; i++) {
          const key = getItemKey(i);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i);
          const end = start + size;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;
          measurements[i] = {
            index: i,
            start,
            size,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range = this.calculateRange();
        if (range) {
          startIndex = range.startIndex;
          endIndex = range.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count
        });
      },
      {
        key: "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index = this.indexFromElement(node);
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index, size) => {
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k = 0, len = indexes.length; k < len; k++) {
          const i = indexes[k];
          const measurement = measurements[i];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index) => notUndefined(measurements[index]).start,
          offset
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size) / 2;
      } else if (align === "end") {
        toOffset -= size;
      }
      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index, align = "auto") => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      const item = this.measurementsCache[index];
      if (!item) {
        return void 0;
      }
      const size = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index, { align: initialAlign = "auto", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      index = Math.max(0, Math.min(index, this.options.count - 1));
      let attempts = 0;
      const maxAttempts = 10;
      const tryScroll = (currentAlign) => {
        if (!this.targetWindow) return;
        const offsetInfo = this.getOffsetForIndex(index, currentAlign);
        if (!offsetInfo) {
          console.warn("Failed to get offset for index:", index);
          return;
        }
        const [offset, align] = offsetInfo;
        this._scrollToOffset(offset, { adjustments: void 0, behavior });
        this.targetWindow.requestAnimationFrame(() => {
          const currentOffset = this.getScrollOffset();
          const afterInfo = this.getOffsetForIndex(index, align);
          if (!afterInfo) {
            console.warn("Failed to get offset for index:", index);
            return;
          }
          if (!approxEqual(afterInfo[0], currentOffset)) {
            scheduleRetry(align);
          }
        });
      };
      const scheduleRetry = (align) => {
        if (!this.targetWindow) return;
        attempts++;
        if (attempts < maxAttempts) {
          if (this.options.debug) {
            console.info("Schedule retry", attempts, maxAttempts);
          }
          this.targetWindow.requestAnimationFrame(() => tryScroll(align));
        } else {
          console.warn(
            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`
          );
        }
      };
      tryScroll(initialAlign);
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex >= 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
}
const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset = (index) => measurements[index].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}
export {
  Virtualizer,
  approxEqual,
  debounce,
  defaultKeyExtractor,
  defaultRangeExtractor,
  elementScroll,
  measureElement,
  memo,
  notUndefined,
  observeElementOffset,
  observeElementRect,
  observeWindowOffset,
  observeWindowRect,
  windowScroll
};

//# sourceMappingURL=data:application/json;base64,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QUFTO0FBQ3hDLFFBQU0sWUFBWSxDQUFDLFVBQWtCLGFBQWEsS0FBSyxFQUFHO0FBR3RELG1CQUFhLFVBQVUsT0FBTztBQUN6QjtBQUFBLE1BQ0wsWUFBWTtBQUFBLE1BQ1osVUFBVTtBQUFBLElBQ1o7QUFBQTtBQUdGLE1BQUksYUFBYTtBQUFBLElBQ2Y7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0EsTUFBSSxXQUFXO0FBRWYsTUFBSSxVQUFVLEdBQUc7QUFDZixXQUNFLFdBQVcsYUFDWCxhQUFhLFFBQVEsRUFBRyxNQUFNLGVBQWUsV0FDN0M7QUFDQTtBQUFBO0FBQUEsRUFDRixXQUNTLFFBQVEsR0FBRztBQUdwQixVQUFNLGFBQWEsTUFBTSxLQUFLLEVBQUUsS0FBSyxDQUFDO0FBRXBDLHNCQUFXLGFBQ1gsV0FBVyxLQUFLLENBQUMsUUFBUSxNQUFNLGVBQWUsU0FBUyxHQUN2RDtBQUNNLG1CQUFPLGFBQWEsUUFBUTtBQUN2QixzQkFBSyxJQUFJLElBQUksS0FBSztBQUM3QjtBQUFBO0FBS0YsVUFBTSxlQUFlLE1BQU0sS0FBSyxFQUFFLEtBQUssZUFBZSxTQUFTO0FBQ3hELHlCQUFjLEtBQUssYUFBYSxLQUFLLENBQUMsUUFBUSxPQUFPLFlBQVksR0FBRztBQUNuRSxtQkFBTyxhQUFhLFVBQVU7QUFDdkIsd0JBQUssSUFBSSxJQUFJLEtBQUs7QUFDL0I7QUFBQTtBQUlGLGlCQUFhLEtBQUssSUFBSSxHQUFHLGFBQWMsYUFBYSxLQUFNO0FBRTFELGVBQVcsS0FBSyxJQUFJLFdBQVcsWUFBWSxRQUFRLElBQUssV0FBVyxNQUFPO0FBQUE7QUFHckUsV0FBRSxZQUFZLFNBQVM7QUFDaEMiLCJuYW1lcyI6WyJvcHRzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHByb3hFcXVhbCwgZGVib3VuY2UsIG1lbW8sIG5vdFVuZGVmaW5lZCB9IGZyb20gJy4vdXRpbHMnXG5cbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMnXG5cbi8vXG5cbnR5cGUgU2Nyb2xsRGlyZWN0aW9uID0gJ2ZvcndhcmQnIHwgJ2JhY2t3YXJkJ1xuXG50eXBlIFNjcm9sbEFsaWdubWVudCA9ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnIHwgJ2F1dG8nXG5cbnR5cGUgU2Nyb2xsQmVoYXZpb3IgPSAnYXV0bycgfCAnc21vb3RoJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbFRvT3B0aW9ucyB7XG4gIGFsaWduPzogU2Nyb2xsQWxpZ25tZW50XG4gIGJlaGF2aW9yPzogU2Nyb2xsQmVoYXZpb3Jcbn1cblxudHlwZSBTY3JvbGxUb09mZnNldE9wdGlvbnMgPSBTY3JvbGxUb09wdGlvbnNcblxudHlwZSBTY3JvbGxUb0luZGV4T3B0aW9ucyA9IFNjcm9sbFRvT3B0aW9uc1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhbmdlIHtcbiAgc3RhcnRJbmRleDogbnVtYmVyXG4gIGVuZEluZGV4OiBudW1iZXJcbiAgb3ZlcnNjYW46IG51bWJlclxuICBjb3VudDogbnVtYmVyXG59XG5cbnR5cGUgS2V5ID0gbnVtYmVyIHwgc3RyaW5nIHwgYmlnaW50XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlydHVhbEl0ZW0ge1xuICBrZXk6IEtleVxuICBpbmRleDogbnVtYmVyXG4gIHN0YXJ0OiBudW1iZXJcbiAgZW5kOiBudW1iZXJcbiAgc2l6ZTogbnVtYmVyXG4gIGxhbmU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY3Qge1xuICB3aWR0aDogbnVtYmVyXG4gIGhlaWdodDogbnVtYmVyXG59XG5cbi8vXG5cbmNvbnN0IGdldFJlY3QgPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBSZWN0ID0+IHtcbiAgY29uc3QgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSBlbGVtZW50XG4gIHJldHVybiB7IHdpZHRoOiBvZmZzZXRXaWR0aCwgaGVpZ2h0OiBvZmZzZXRIZWlnaHQgfVxufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdEtleUV4dHJhY3RvciA9IChpbmRleDogbnVtYmVyKSA9PiBpbmRleFxuXG5leHBvcnQgY29uc3QgZGVmYXVsdFJhbmdlRXh0cmFjdG9yID0gKHJhbmdlOiBSYW5nZSkgPT4ge1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0SW5kZXggLSByYW5nZS5vdmVyc2NhbiwgMClcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocmFuZ2UuZW5kSW5kZXggKyByYW5nZS5vdmVyc2NhbiwgcmFuZ2UuY291bnQgLSAxKVxuXG4gIGNvbnN0IGFyciA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgYXJyLnB1c2goaSlcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZXhwb3J0IGNvbnN0IG9ic2VydmVFbGVtZW50UmVjdCA9IDxUIGV4dGVuZHMgRWxlbWVudD4oXG4gIGluc3RhbmNlOiBWaXJ0dWFsaXplcjxULCBhbnk+LFxuICBjYjogKHJlY3Q6IFJlY3QpID0+IHZvaWQsXG4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gaW5zdGFuY2UudGFyZ2V0V2luZG93XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBoYW5kbGVyID0gKHJlY3Q6IFJlY3QpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJlY3RcbiAgICBjYih7IHdpZHRoOiBNYXRoLnJvdW5kKHdpZHRoKSwgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodCkgfSlcbiAgfVxuXG4gIGhhbmRsZXIoZ2V0UmVjdChlbGVtZW50IGFzIHVua25vd24gYXMgSFRNTEVsZW1lbnQpKVxuXG4gIGlmICghdGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgcmV0dXJuICgpID0+IHt9XG4gIH1cblxuICBjb25zdCBvYnNlcnZlciA9IG5ldyB0YXJnZXRXaW5kb3cuUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF1cbiAgICAgIGlmIChlbnRyeT8uYm9yZGVyQm94U2l6ZSkge1xuICAgICAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdXG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICBoYW5kbGVyKHsgd2lkdGg6IGJveC5pbmxpbmVTaXplLCBoZWlnaHQ6IGJveC5ibG9ja1NpemUgfSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlcihnZXRSZWN0KGVsZW1lbnQgYXMgdW5rbm93biBhcyBIVE1MRWxlbWVudCkpXG4gICAgfVxuXG4gICAgaW5zdGFuY2Uub3B0aW9ucy51c2VBbmltYXRpb25GcmFtZVdpdGhSZXNpemVPYnNlcnZlclxuICAgICAgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKVxuICAgICAgOiBydW4oKVxuICB9KVxuXG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwgeyBib3g6ICdib3JkZXItYm94JyB9KVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpXG4gIH1cbn1cblxuY29uc3QgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7XG4gIHBhc3NpdmU6IHRydWUsXG59XG5cbmV4cG9ydCBjb25zdCBvYnNlcnZlV2luZG93UmVjdCA9IChcbiAgaW5zdGFuY2U6IFZpcnR1YWxpemVyPFdpbmRvdywgYW55PixcbiAgY2I6IChyZWN0OiBSZWN0KSA9PiB2b2lkLFxuKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICBjYih7IHdpZHRoOiBlbGVtZW50LmlubmVyV2lkdGgsIGhlaWdodDogZWxlbWVudC5pbm5lckhlaWdodCB9KVxuICB9XG4gIGhhbmRsZXIoKVxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpXG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gIH1cbn1cblxuY29uc3Qgc3VwcG9ydHNTY3JvbGxlbmQgPVxuICB0eXBlb2Ygd2luZG93ID09ICd1bmRlZmluZWQnID8gdHJ1ZSA6ICdvbnNjcm9sbGVuZCcgaW4gd2luZG93XG5cbnR5cGUgT2JzZXJ2ZU9mZnNldENhbGxCYWNrID0gKG9mZnNldDogbnVtYmVyLCBpc1Njcm9sbGluZzogYm9vbGVhbikgPT4gdm9pZFxuXG5leHBvcnQgY29uc3Qgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQgPSA8VCBleHRlbmRzIEVsZW1lbnQ+KFxuICBpbnN0YW5jZTogVmlydHVhbGl6ZXI8VCwgYW55PixcbiAgY2I6IE9ic2VydmVPZmZzZXRDYWxsQmFjayxcbikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3dcbiAgaWYgKCF0YXJnZXRXaW5kb3cpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBvZmZzZXQgPSAwXG4gIGNvbnN0IGZhbGxiYWNrID1cbiAgICBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kXG4gICAgICA/ICgpID0+IHVuZGVmaW5lZFxuICAgICAgOiBkZWJvdW5jZShcbiAgICAgICAgICB0YXJnZXRXaW5kb3csXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgY2Iob2Zmc2V0LCBmYWxzZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc3RhbmNlLm9wdGlvbnMuaXNTY3JvbGxpbmdSZXNldERlbGF5LFxuICAgICAgICApXG5cbiAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChpc1Njcm9sbGluZzogYm9vbGVhbikgPT4gKCkgPT4ge1xuICAgIGNvbnN0IHsgaG9yaXpvbnRhbCwgaXNSdGwgfSA9IGluc3RhbmNlLm9wdGlvbnNcbiAgICBvZmZzZXQgPSBob3Jpem9udGFsXG4gICAgICA/IGVsZW1lbnRbJ3Njcm9sbExlZnQnXSAqICgoaXNSdGwgJiYgLTEpIHx8IDEpXG4gICAgICA6IGVsZW1lbnRbJ3Njcm9sbFRvcCddXG4gICAgZmFsbGJhY2soKVxuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpXG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIodHJ1ZSlcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpXG4gIGVuZEhhbmRsZXIoKVxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpXG4gIGNvbnN0IHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQgPVxuICAgIGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmRcbiAgaWYgKHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbGVuZCcsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKVxuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyKVxuICAgIGlmIChyZWdpc3RlclNjcm9sbGVuZEV2ZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbGVuZCcsIGVuZEhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvYnNlcnZlV2luZG93T2Zmc2V0ID0gKFxuICBpbnN0YW5jZTogVmlydHVhbGl6ZXI8V2luZG93LCBhbnk+LFxuICBjYjogT2JzZXJ2ZU9mZnNldENhbGxCYWNrLFxuKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IGluc3RhbmNlLnRhcmdldFdpbmRvd1xuICBpZiAoIXRhcmdldFdpbmRvdykge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IG9mZnNldCA9IDBcbiAgY29uc3QgZmFsbGJhY2sgPVxuICAgIGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmRcbiAgICAgID8gKCkgPT4gdW5kZWZpbmVkXG4gICAgICA6IGRlYm91bmNlKFxuICAgICAgICAgIHRhcmdldFdpbmRvdyxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjYihvZmZzZXQsIGZhbHNlKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5zdGFuY2Uub3B0aW9ucy5pc1Njcm9sbGluZ1Jlc2V0RGVsYXksXG4gICAgICAgIClcblxuICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGlzU2Nyb2xsaW5nOiBib29sZWFuKSA9PiAoKSA9PiB7XG4gICAgb2Zmc2V0ID0gZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyAnc2Nyb2xsWCcgOiAnc2Nyb2xsWSddXG4gICAgZmFsbGJhY2soKVxuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpXG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIodHJ1ZSlcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpXG4gIGVuZEhhbmRsZXIoKVxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpXG4gIGNvbnN0IHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQgPVxuICAgIGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmRcbiAgaWYgKHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbGVuZCcsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKVxuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyKVxuICAgIGlmIChyZWdpc3RlclNjcm9sbGVuZEV2ZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbGVuZCcsIGVuZEhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZWFzdXJlRWxlbWVudCA9IDxUSXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihcbiAgZWxlbWVudDogVEl0ZW1FbGVtZW50LFxuICBlbnRyeTogUmVzaXplT2JzZXJ2ZXJFbnRyeSB8IHVuZGVmaW5lZCxcbiAgaW5zdGFuY2U6IFZpcnR1YWxpemVyPGFueSwgVEl0ZW1FbGVtZW50PixcbikgPT4ge1xuICBpZiAoZW50cnk/LmJvcmRlckJveFNpemUpIHtcbiAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdXG4gICAgaWYgKGJveCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoXG4gICAgICAgIGJveFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyAnaW5saW5lU2l6ZScgOiAnYmxvY2tTaXplJ10sXG4gICAgICApXG4gICAgICByZXR1cm4gc2l6ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZWxlbWVudCBhcyB1bmtub3duIGFzIEhUTUxFbGVtZW50KVtcbiAgICBpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyAnb2Zmc2V0V2lkdGgnIDogJ29mZnNldEhlaWdodCdcbiAgXVxufVxuXG5leHBvcnQgY29uc3Qgd2luZG93U2Nyb2xsID0gPFQgZXh0ZW5kcyBXaW5kb3c+KFxuICBvZmZzZXQ6IG51bWJlcixcbiAge1xuICAgIGFkanVzdG1lbnRzID0gMCxcbiAgICBiZWhhdmlvcixcbiAgfTogeyBhZGp1c3RtZW50cz86IG51bWJlcjsgYmVoYXZpb3I/OiBTY3JvbGxCZWhhdmlvciB9LFxuICBpbnN0YW5jZTogVmlydHVhbGl6ZXI8VCwgYW55PixcbikgPT4ge1xuICBjb25zdCB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzXG5cbiAgaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudD8uc2Nyb2xsVG8/Lih7XG4gICAgW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnXTogdG9PZmZzZXQsXG4gICAgYmVoYXZpb3IsXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBlbGVtZW50U2Nyb2xsID0gPFQgZXh0ZW5kcyBFbGVtZW50PihcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHtcbiAgICBhZGp1c3RtZW50cyA9IDAsXG4gICAgYmVoYXZpb3IsXG4gIH06IHsgYWRqdXN0bWVudHM/OiBudW1iZXI7IGJlaGF2aW9yPzogU2Nyb2xsQmVoYXZpb3IgfSxcbiAgaW5zdGFuY2U6IFZpcnR1YWxpemVyPFQsIGFueT4sXG4pID0+IHtcbiAgY29uc3QgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50c1xuXG4gIGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ/LnNjcm9sbFRvPy4oe1xuICAgIFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJ106IHRvT2Zmc2V0LFxuICAgIGJlaGF2aW9yLFxuICB9KVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpcnR1YWxpemVyT3B0aW9uczxcbiAgVFNjcm9sbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHwgV2luZG93LFxuICBUSXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuPiB7XG4gIC8vIFJlcXVpcmVkIGZyb20gdGhlIHVzZXJcbiAgY291bnQ6IG51bWJlclxuICBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiBUU2Nyb2xsRWxlbWVudCB8IG51bGxcbiAgZXN0aW1hdGVTaXplOiAoaW5kZXg6IG51bWJlcikgPT4gbnVtYmVyXG5cbiAgLy8gUmVxdWlyZWQgZnJvbSB0aGUgZnJhbWV3b3JrIGFkYXB0ZXIgKGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbilcbiAgc2Nyb2xsVG9GbjogKFxuICAgIG9mZnNldDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IHsgYWRqdXN0bWVudHM/OiBudW1iZXI7IGJlaGF2aW9yPzogU2Nyb2xsQmVoYXZpb3IgfSxcbiAgICBpbnN0YW5jZTogVmlydHVhbGl6ZXI8VFNjcm9sbEVsZW1lbnQsIFRJdGVtRWxlbWVudD4sXG4gICkgPT4gdm9pZFxuICBvYnNlcnZlRWxlbWVudFJlY3Q6IChcbiAgICBpbnN0YW5jZTogVmlydHVhbGl6ZXI8VFNjcm9sbEVsZW1lbnQsIFRJdGVtRWxlbWVudD4sXG4gICAgY2I6IChyZWN0OiBSZWN0KSA9PiB2b2lkLFxuICApID0+IHZvaWQgfCAoKCkgPT4gdm9pZClcbiAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQ6IChcbiAgICBpbnN0YW5jZTogVmlydHVhbGl6ZXI8VFNjcm9sbEVsZW1lbnQsIFRJdGVtRWxlbWVudD4sXG4gICAgY2I6IE9ic2VydmVPZmZzZXRDYWxsQmFjayxcbiAgKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpXG4gIC8vIE9wdGlvbmFsXG4gIGRlYnVnPzogYm9vbGVhblxuICBpbml0aWFsUmVjdD86IFJlY3RcbiAgb25DaGFuZ2U/OiAoXG4gICAgaW5zdGFuY2U6IFZpcnR1YWxpemVyPFRTY3JvbGxFbGVtZW50LCBUSXRlbUVsZW1lbnQ+LFxuICAgIHN5bmM6IGJvb2xlYW4sXG4gICkgPT4gdm9pZFxuICBtZWFzdXJlRWxlbWVudD86IChcbiAgICBlbGVtZW50OiBUSXRlbUVsZW1lbnQsXG4gICAgZW50cnk6IFJlc2l6ZU9ic2VydmVyRW50cnkgfCB1bmRlZmluZWQsXG4gICAgaW5zdGFuY2U6IFZpcnR1YWxpemVyPFRTY3JvbGxFbGVtZW50LCBUSXRlbUVsZW1lbnQ+LFxuICApID0+IG51bWJlclxuICBvdmVyc2Nhbj86IG51bWJlclxuICBob3Jpem9udGFsPzogYm9vbGVhblxuICBwYWRkaW5nU3RhcnQ/OiBudW1iZXJcbiAgcGFkZGluZ0VuZD86IG51bWJlclxuICBzY3JvbGxQYWRkaW5nU3RhcnQ/OiBudW1iZXJcbiAgc2Nyb2xsUGFkZGluZ0VuZD86IG51bWJlclxuICBpbml0aWFsT2Zmc2V0PzogbnVtYmVyIHwgKCgpID0+IG51bWJlcilcbiAgZ2V0SXRlbUtleT86IChpbmRleDogbnVtYmVyKSA9PiBLZXlcbiAgcmFuZ2VFeHRyYWN0b3I/OiAocmFuZ2U6IFJhbmdlKSA9PiBBcnJheTxudW1iZXI+XG4gIHNjcm9sbE1hcmdpbj86IG51bWJlclxuICBnYXA/OiBudW1iZXJcbiAgaW5kZXhBdHRyaWJ1dGU/OiBzdHJpbmdcbiAgaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlPzogQXJyYXk8VmlydHVhbEl0ZW0+XG4gIGxhbmVzPzogbnVtYmVyXG4gIGlzU2Nyb2xsaW5nUmVzZXREZWxheT86IG51bWJlclxuICB1c2VTY3JvbGxlbmRFdmVudD86IGJvb2xlYW5cbiAgZW5hYmxlZD86IGJvb2xlYW5cbiAgaXNSdGw/OiBib29sZWFuXG4gIHVzZUFuaW1hdGlvbkZyYW1lV2l0aFJlc2l6ZU9ic2VydmVyPzogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgVmlydHVhbGl6ZXI8XG4gIFRTY3JvbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IFdpbmRvdyxcbiAgVEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbj4ge1xuICBwcml2YXRlIHVuc3ViczogQXJyYXk8dm9pZCB8ICgoKSA9PiB2b2lkKT4gPSBbXVxuICBvcHRpb25zITogUmVxdWlyZWQ8VmlydHVhbGl6ZXJPcHRpb25zPFRTY3JvbGxFbGVtZW50LCBUSXRlbUVsZW1lbnQ+PlxuICBzY3JvbGxFbGVtZW50OiBUU2Nyb2xsRWxlbWVudCB8IG51bGwgPSBudWxsXG4gIHRhcmdldFdpbmRvdzogKFdpbmRvdyAmIHR5cGVvZiBnbG9iYWxUaGlzKSB8IG51bGwgPSBudWxsXG4gIGlzU2Nyb2xsaW5nID0gZmFsc2VcbiAgbWVhc3VyZW1lbnRzQ2FjaGU6IEFycmF5PFZpcnR1YWxJdGVtPiA9IFtdXG4gIHByaXZhdGUgaXRlbVNpemVDYWNoZSA9IG5ldyBNYXA8S2V5LCBudW1iZXI+KClcbiAgcHJpdmF0ZSBwZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXM6IEFycmF5PG51bWJlcj4gPSBbXVxuICBzY3JvbGxSZWN0OiBSZWN0IHwgbnVsbCA9IG51bGxcbiAgc2Nyb2xsT2Zmc2V0OiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBzY3JvbGxEaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbiB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgc2Nyb2xsQWRqdXN0bWVudHMgPSAwXG4gIHNob3VsZEFkanVzdFNjcm9sbFBvc2l0aW9uT25JdGVtU2l6ZUNoYW5nZTpcbiAgICB8IHVuZGVmaW5lZFxuICAgIHwgKChcbiAgICAgICAgaXRlbTogVmlydHVhbEl0ZW0sXG4gICAgICAgIGRlbHRhOiBudW1iZXIsXG4gICAgICAgIGluc3RhbmNlOiBWaXJ0dWFsaXplcjxUU2Nyb2xsRWxlbWVudCwgVEl0ZW1FbGVtZW50PixcbiAgICAgICkgPT4gYm9vbGVhbilcbiAgZWxlbWVudHNDYWNoZSA9IG5ldyBNYXA8S2V5LCBUSXRlbUVsZW1lbnQ+KClcbiAgcHJpdmF0ZSBvYnNlcnZlciA9ICgoKSA9PiB7XG4gICAgbGV0IF9ybzogUmVzaXplT2JzZXJ2ZXIgfCBudWxsID0gbnVsbFxuXG4gICAgY29uc3QgZ2V0ID0gKCkgPT4ge1xuICAgICAgaWYgKF9ybykge1xuICAgICAgICByZXR1cm4gX3JvXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy50YXJnZXRXaW5kb3cgfHwgIXRoaXMudGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoX3JvID0gbmV3IHRoaXMudGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChlbnRyeS50YXJnZXQgYXMgVEl0ZW1FbGVtZW50LCBlbnRyeSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnVzZUFuaW1hdGlvbkZyYW1lV2l0aFJlc2l6ZU9ic2VydmVyXG4gICAgICAgICAgICA/IHJlcXVlc3RBbmltYXRpb25GcmFtZShydW4pXG4gICAgICAgICAgICA6IHJ1bigpXG4gICAgICAgIH0pXG4gICAgICB9KSlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgICBnZXQoKT8uZGlzY29ubmVjdCgpXG4gICAgICAgIF9ybyA9IG51bGxcbiAgICAgIH0sXG4gICAgICBvYnNlcnZlOiAodGFyZ2V0OiBFbGVtZW50KSA9PlxuICAgICAgICBnZXQoKT8ub2JzZXJ2ZSh0YXJnZXQsIHsgYm94OiAnYm9yZGVyLWJveCcgfSksXG4gICAgICB1bm9ic2VydmU6ICh0YXJnZXQ6IEVsZW1lbnQpID0+IGdldCgpPy51bm9ic2VydmUodGFyZ2V0KSxcbiAgICB9XG4gIH0pKClcbiAgcmFuZ2U6IHsgc3RhcnRJbmRleDogbnVtYmVyOyBlbmRJbmRleDogbnVtYmVyIH0gfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKG9wdHM6IFZpcnR1YWxpemVyT3B0aW9uczxUU2Nyb2xsRWxlbWVudCwgVEl0ZW1FbGVtZW50Pikge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRzKVxuICB9XG5cbiAgc2V0T3B0aW9ucyA9IChvcHRzOiBWaXJ0dWFsaXplck9wdGlvbnM8VFNjcm9sbEVsZW1lbnQsIFRJdGVtRWxlbWVudD4pID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhvcHRzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSBkZWxldGUgKG9wdHMgYXMgYW55KVtrZXldXG4gICAgfSlcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgIGluaXRpYWxPZmZzZXQ6IDAsXG4gICAgICBvdmVyc2NhbjogMSxcbiAgICAgIHBhZGRpbmdTdGFydDogMCxcbiAgICAgIHBhZGRpbmdFbmQ6IDAsXG4gICAgICBzY3JvbGxQYWRkaW5nU3RhcnQ6IDAsXG4gICAgICBzY3JvbGxQYWRkaW5nRW5kOiAwLFxuICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICBnZXRJdGVtS2V5OiBkZWZhdWx0S2V5RXh0cmFjdG9yLFxuICAgICAgcmFuZ2VFeHRyYWN0b3I6IGRlZmF1bHRSYW5nZUV4dHJhY3RvcixcbiAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIG1lYXN1cmVFbGVtZW50LFxuICAgICAgaW5pdGlhbFJlY3Q6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LFxuICAgICAgc2Nyb2xsTWFyZ2luOiAwLFxuICAgICAgZ2FwOiAwLFxuICAgICAgaW5kZXhBdHRyaWJ1dGU6ICdkYXRhLWluZGV4JyxcbiAgICAgIGluaXRpYWxNZWFzdXJlbWVudHNDYWNoZTogW10sXG4gICAgICBsYW5lczogMSxcbiAgICAgIGlzU2Nyb2xsaW5nUmVzZXREZWxheTogMTUwLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGlzUnRsOiBmYWxzZSxcbiAgICAgIHVzZVNjcm9sbGVuZEV2ZW50OiBmYWxzZSxcbiAgICAgIHVzZUFuaW1hdGlvbkZyYW1lV2l0aFJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgIC4uLm9wdHMsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBub3RpZnkgPSAoc3luYzogYm9vbGVhbikgPT4ge1xuICAgIHRoaXMub3B0aW9ucy5vbkNoYW5nZT8uKHRoaXMsIHN5bmMpXG4gIH1cblxuICBwcml2YXRlIG1heWJlTm90aWZ5ID0gbWVtbyhcbiAgICAoKSA9PiB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZVJhbmdlKClcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyxcbiAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2Uuc3RhcnRJbmRleCA6IG51bGwsXG4gICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbCxcbiAgICAgIF1cbiAgICB9LFxuICAgIChpc1Njcm9sbGluZykgPT4ge1xuICAgICAgdGhpcy5ub3RpZnkoaXNTY3JvbGxpbmcpXG4gICAgfSxcbiAgICB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgJ21heWJlTm90aWZ5JyxcbiAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWcsXG4gICAgICBpbml0aWFsRGVwczogW1xuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nLFxuICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5zdGFydEluZGV4IDogbnVsbCxcbiAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2UuZW5kSW5kZXggOiBudWxsLFxuICAgICAgXSBhcyBbYm9vbGVhbiwgbnVtYmVyIHwgbnVsbCwgbnVtYmVyIHwgbnVsbF0sXG4gICAgfSxcbiAgKVxuXG4gIHByaXZhdGUgY2xlYW51cCA9ICgpID0+IHtcbiAgICB0aGlzLnVuc3Vicy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgoZCkgPT4gZCEoKSlcbiAgICB0aGlzLnVuc3VicyA9IFtdXG4gICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy50YXJnZXRXaW5kb3cgPSBudWxsXG4gIH1cblxuICBfZGlkTW91bnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYW51cCgpXG4gICAgfVxuICB9XG5cbiAgX3dpbGxVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMub3B0aW9ucy5lbmFibGVkXG4gICAgICA/IHRoaXMub3B0aW9ucy5nZXRTY3JvbGxFbGVtZW50KClcbiAgICAgIDogbnVsbFxuXG4gICAgaWYgKHRoaXMuc2Nyb2xsRWxlbWVudCAhPT0gc2Nyb2xsRWxlbWVudCkge1xuICAgICAgdGhpcy5jbGVhbnVwKClcblxuICAgICAgaWYgKCFzY3JvbGxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudFxuXG4gICAgICBpZiAodGhpcy5zY3JvbGxFbGVtZW50ICYmICdvd25lckRvY3VtZW50JyBpbiB0aGlzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQ/LndpbmRvdyA/PyBudWxsXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5mb3JFYWNoKChjYWNoZWQpID0+IHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKGNhY2hlZClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCksIHtcbiAgICAgICAgYWRqdXN0bWVudHM6IHVuZGVmaW5lZCxcbiAgICAgICAgYmVoYXZpb3I6IHVuZGVmaW5lZCxcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMudW5zdWJzLnB1c2goXG4gICAgICAgIHRoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudFJlY3QodGhpcywgKHJlY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSByZWN0XG4gICAgICAgICAgdGhpcy5tYXliZU5vdGlmeSgpXG4gICAgICAgIH0pLFxuICAgICAgKVxuXG4gICAgICB0aGlzLnVuc3Vicy5wdXNoKFxuICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRPZmZzZXQodGhpcywgKG9mZnNldCwgaXNTY3JvbGxpbmcpID0+IHtcbiAgICAgICAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMFxuICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gaXNTY3JvbGxpbmdcbiAgICAgICAgICAgID8gdGhpcy5nZXRTY3JvbGxPZmZzZXQoKSA8IG9mZnNldFxuICAgICAgICAgICAgICA/ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICA6ICdiYWNrd2FyZCdcbiAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gb2Zmc2V0XG4gICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IGlzU2Nyb2xsaW5nXG5cbiAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KClcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRTaXplID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc2Nyb2xsUmVjdCA9IG51bGxcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxSZWN0ID0gdGhpcy5zY3JvbGxSZWN0ID8/IHRoaXMub3B0aW9ucy5pbml0aWFsUmVjdFxuXG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsUmVjdFt0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J11cbiAgfVxuXG4gIHByaXZhdGUgZ2V0U2Nyb2xsT2Zmc2V0ID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gbnVsbFxuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9XG4gICAgICB0aGlzLnNjcm9sbE9mZnNldCA/P1xuICAgICAgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0KClcbiAgICAgICAgOiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldClcblxuICAgIHJldHVybiB0aGlzLnNjcm9sbE9mZnNldFxuICB9XG5cbiAgcHJpdmF0ZSBnZXRGdXJ0aGVzdE1lYXN1cmVtZW50ID0gKFxuICAgIG1lYXN1cmVtZW50czogQXJyYXk8VmlydHVhbEl0ZW0+LFxuICAgIGluZGV4OiBudW1iZXIsXG4gICkgPT4ge1xuICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQgPSBuZXcgTWFwPG51bWJlciwgdHJ1ZT4oKVxuICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnRzID0gbmV3IE1hcDxudW1iZXIsIFZpcnR1YWxJdGVtPigpXG4gICAgZm9yIChsZXQgbSA9IGluZGV4IC0gMTsgbSA+PSAwOyBtLS0pIHtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW21dIVxuXG4gICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5oYXMobWVhc3VyZW1lbnQubGFuZSkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID0gZnVydGhlc3RNZWFzdXJlbWVudHMuZ2V0KFxuICAgICAgICBtZWFzdXJlbWVudC5sYW5lLFxuICAgICAgKVxuICAgICAgaWYgKFxuICAgICAgICBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPT0gbnVsbCB8fFxuICAgICAgICBtZWFzdXJlbWVudC5lbmQgPiBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQuZW5kXG4gICAgICApIHtcbiAgICAgICAgZnVydGhlc3RNZWFzdXJlbWVudHMuc2V0KG1lYXN1cmVtZW50LmxhbmUsIG1lYXN1cmVtZW50KVxuICAgICAgfSBlbHNlIGlmIChtZWFzdXJlbWVudC5lbmQgPCBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQuZW5kKSB7XG4gICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuc2V0KG1lYXN1cmVtZW50LmxhbmUsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIGlmIChmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdXJ0aGVzdE1lYXN1cmVtZW50cy5zaXplID09PSB0aGlzLm9wdGlvbnMubGFuZXNcbiAgICAgID8gQXJyYXkuZnJvbShmdXJ0aGVzdE1lYXN1cmVtZW50cy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChhLmVuZCA9PT0gYi5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhLmVuZCAtIGIuZW5kXG4gICAgICAgIH0pWzBdXG4gICAgICA6IHVuZGVmaW5lZFxuICB9XG5cbiAgcHJpdmF0ZSBnZXRNZWFzdXJlbWVudE9wdGlvbnMgPSBtZW1vKFxuICAgICgpID0+IFtcbiAgICAgIHRoaXMub3B0aW9ucy5jb3VudCxcbiAgICAgIHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQsXG4gICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsTWFyZ2luLFxuICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXksXG4gICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCxcbiAgICBdLFxuICAgIChjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXksIGVuYWJsZWQpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW11cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvdW50LFxuICAgICAgICBwYWRkaW5nU3RhcnQsXG4gICAgICAgIHNjcm9sbE1hcmdpbixcbiAgICAgICAgZ2V0SXRlbUtleSxcbiAgICAgICAgZW5hYmxlZCxcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGtleTogZmFsc2UsXG4gICAgfSxcbiAgKVxuXG4gIHByaXZhdGUgZ2V0TWVhc3VyZW1lbnRzID0gbWVtbyhcbiAgICAoKSA9PiBbdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMoKSwgdGhpcy5pdGVtU2l6ZUNhY2hlXSxcbiAgICAoXG4gICAgICB7IGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSwgZW5hYmxlZCB9LFxuICAgICAgaXRlbVNpemVDYWNoZSxcbiAgICApID0+IHtcbiAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gW11cbiAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLmNsZWFyKClcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1lYXN1cmVtZW50c0NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gdGhpcy5vcHRpb25zLmluaXRpYWxNZWFzdXJlbWVudHNDYWNoZVxuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuc2V0KGl0ZW0ua2V5LCBpdGVtLnNpemUpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pbiA9XG4gICAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IE1hdGgubWluKC4uLnRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzKVxuICAgICAgICAgIDogMFxuICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXVxuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlLnNsaWNlKDAsIG1pbilcblxuICAgICAgZm9yIChsZXQgaSA9IG1pbjsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0SXRlbUtleShpKVxuXG4gICAgICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5sYW5lcyA9PT0gMVxuICAgICAgICAgICAgPyBtZWFzdXJlbWVudHNbaSAtIDFdXG4gICAgICAgICAgICA6IHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudChtZWFzdXJlbWVudHMsIGkpXG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBmdXJ0aGVzdE1lYXN1cmVtZW50XG4gICAgICAgICAgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCArIHRoaXMub3B0aW9ucy5nYXBcbiAgICAgICAgICA6IHBhZGRpbmdTdGFydCArIHNjcm9sbE1hcmdpblxuXG4gICAgICAgIGNvbnN0IG1lYXN1cmVkU2l6ZSA9IGl0ZW1TaXplQ2FjaGUuZ2V0KGtleSlcbiAgICAgICAgY29uc3Qgc2l6ZSA9XG4gICAgICAgICAgdHlwZW9mIG1lYXN1cmVkU2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gbWVhc3VyZWRTaXplXG4gICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5lc3RpbWF0ZVNpemUoaSlcblxuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHNpemVcblxuICAgICAgICBjb25zdCBsYW5lID0gZnVydGhlc3RNZWFzdXJlbWVudFxuICAgICAgICAgID8gZnVydGhlc3RNZWFzdXJlbWVudC5sYW5lXG4gICAgICAgICAgOiBpICUgdGhpcy5vcHRpb25zLmxhbmVzXG5cbiAgICAgICAgbWVhc3VyZW1lbnRzW2ldID0ge1xuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgZW5kLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBsYW5lLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBtZWFzdXJlbWVudHNcblxuICAgICAgcmV0dXJuIG1lYXN1cmVtZW50c1xuICAgIH0sXG4gICAge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICdnZXRNZWFzdXJlbWVudHMnLFxuICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1ZyxcbiAgICB9LFxuICApXG5cbiAgY2FsY3VsYXRlUmFuZ2UgPSBtZW1vKFxuICAgICgpID0+IFtcbiAgICAgIHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCksXG4gICAgICB0aGlzLmdldFNpemUoKSxcbiAgICAgIHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCksXG4gICAgICB0aGlzLm9wdGlvbnMubGFuZXMsXG4gICAgXSxcbiAgICAobWVhc3VyZW1lbnRzLCBvdXRlclNpemUsIHNjcm9sbE9mZnNldCwgbGFuZXMpID0+IHtcbiAgICAgIHJldHVybiAodGhpcy5yYW5nZSA9XG4gICAgICAgIG1lYXN1cmVtZW50cy5sZW5ndGggPiAwICYmIG91dGVyU2l6ZSA+IDBcbiAgICAgICAgICA/IGNhbGN1bGF0ZVJhbmdlKHtcbiAgICAgICAgICAgICAgbWVhc3VyZW1lbnRzLFxuICAgICAgICAgICAgICBvdXRlclNpemUsXG4gICAgICAgICAgICAgIHNjcm9sbE9mZnNldCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogbnVsbClcbiAgICB9LFxuICAgIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAnY2FsY3VsYXRlUmFuZ2UnLFxuICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1ZyxcbiAgICB9LFxuICApXG5cbiAgZ2V0VmlydHVhbEluZGV4ZXMgPSBtZW1vKFxuICAgICgpID0+IHtcbiAgICAgIGxldCBzdGFydEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IGVuZEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbFxuICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZVJhbmdlKClcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleFxuICAgICAgICBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4XG4gICAgICB9XG4gICAgICB0aGlzLm1heWJlTm90aWZ5LnVwZGF0ZURlcHMoW3RoaXMuaXNTY3JvbGxpbmcsIHN0YXJ0SW5kZXgsIGVuZEluZGV4XSlcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMub3B0aW9ucy5yYW5nZUV4dHJhY3RvcixcbiAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJzY2FuLFxuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnQsXG4gICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgIGVuZEluZGV4LFxuICAgICAgXVxuICAgIH0sXG4gICAgKHJhbmdlRXh0cmFjdG9yLCBvdmVyc2NhbiwgY291bnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gc3RhcnRJbmRleCA9PT0gbnVsbCB8fCBlbmRJbmRleCA9PT0gbnVsbFxuICAgICAgICA/IFtdXG4gICAgICAgIDogcmFuZ2VFeHRyYWN0b3Ioe1xuICAgICAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgICAgIGVuZEluZGV4LFxuICAgICAgICAgICAgb3ZlcnNjYW4sXG4gICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICB9KVxuICAgIH0sXG4gICAge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICdnZXRWaXJ0dWFsSW5kZXhlcycsXG4gICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnLFxuICAgIH0sXG4gIClcblxuICBpbmRleEZyb21FbGVtZW50ID0gKG5vZGU6IFRJdGVtRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLm9wdGlvbnMuaW5kZXhBdHRyaWJ1dGVcbiAgICBjb25zdCBpbmRleFN0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpXG5cbiAgICBpZiAoIWluZGV4U3RyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lICcke2F0dHJpYnV0ZU5hbWV9PXtpbmRleH0nIG9uIG1lYXN1cmVkIGVsZW1lbnQuYCxcbiAgICAgIClcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUludChpbmRleFN0ciwgMTApXG4gIH1cblxuICBwcml2YXRlIF9tZWFzdXJlRWxlbWVudCA9IChcbiAgICBub2RlOiBUSXRlbUVsZW1lbnQsXG4gICAgZW50cnk6IFJlc2l6ZU9ic2VydmVyRW50cnkgfCB1bmRlZmluZWQsXG4gICkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleEZyb21FbGVtZW50KG5vZGUpXG4gICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdXG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3Qga2V5ID0gaXRlbS5rZXlcbiAgICBjb25zdCBwcmV2Tm9kZSA9IHRoaXMuZWxlbWVudHNDYWNoZS5nZXQoa2V5KVxuXG4gICAgaWYgKHByZXZOb2RlICE9PSBub2RlKSB7XG4gICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUocHJldk5vZGUpXG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUobm9kZSlcbiAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5zZXQoa2V5LCBub2RlKVxuICAgIH1cblxuICAgIGlmIChub2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlc2l6ZUl0ZW0oaW5kZXgsIHRoaXMub3B0aW9ucy5tZWFzdXJlRWxlbWVudChub2RlLCBlbnRyeSwgdGhpcykpXG4gICAgfVxuICB9XG5cbiAgcmVzaXplSXRlbSA9IChpbmRleDogbnVtYmVyLCBzaXplOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZVtpbmRleF1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemVDYWNoZS5nZXQoaXRlbS5rZXkpID8/IGl0ZW0uc2l6ZVxuICAgIGNvbnN0IGRlbHRhID0gc2l6ZSAtIGl0ZW1TaXplXG5cbiAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5zaG91bGRBZGp1c3RTY3JvbGxQb3NpdGlvbk9uSXRlbVNpemVDaGFuZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5zaG91bGRBZGp1c3RTY3JvbGxQb3NpdGlvbk9uSXRlbVNpemVDaGFuZ2UoaXRlbSwgZGVsdGEsIHRoaXMpXG4gICAgICAgICAgOiBpdGVtLnN0YXJ0IDwgdGhpcy5nZXRTY3JvbGxPZmZzZXQoKSArIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHNcbiAgICAgICkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJ2NvcnJlY3Rpb24nLCBkZWx0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCksIHtcbiAgICAgICAgICBhZGp1c3RtZW50czogKHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgKz0gZGVsdGEpLFxuICAgICAgICAgIGJlaGF2aW9yOiB1bmRlZmluZWQsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLnB1c2goaXRlbS5pbmRleClcbiAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IG5ldyBNYXAodGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgc2l6ZSkpXG5cbiAgICAgIHRoaXMubm90aWZ5KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIG1lYXN1cmVFbGVtZW50ID0gKG5vZGU6IFRJdGVtRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5mb3JFYWNoKChjYWNoZWQsIGtleSkgPT4ge1xuICAgICAgICBpZiAoIWNhY2hlZC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKGNhY2hlZClcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZGVsZXRlKGtleSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX21lYXN1cmVFbGVtZW50KG5vZGUsIHVuZGVmaW5lZClcbiAgfVxuXG4gIGdldFZpcnR1YWxJdGVtcyA9IG1lbW8oXG4gICAgKCkgPT4gW3RoaXMuZ2V0VmlydHVhbEluZGV4ZXMoKSwgdGhpcy5nZXRNZWFzdXJlbWVudHMoKV0sXG4gICAgKGluZGV4ZXMsIG1lYXN1cmVtZW50cykgPT4ge1xuICAgICAgY29uc3QgdmlydHVhbEl0ZW1zOiBBcnJheTxWaXJ0dWFsSXRlbT4gPSBbXVxuXG4gICAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gaW5kZXhlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICBjb25zdCBpID0gaW5kZXhlc1trXSFcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV0hXG5cbiAgICAgICAgdmlydHVhbEl0ZW1zLnB1c2gobWVhc3VyZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aXJ0dWFsSXRlbXNcbiAgICB9LFxuICAgIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAnZ2V0VmlydHVhbEl0ZW1zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWcsXG4gICAgfSxcbiAgKVxuXG4gIGdldFZpcnR1YWxJdGVtRm9yT2Zmc2V0ID0gKG9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5nZXRNZWFzdXJlbWVudHMoKVxuICAgIGlmIChtZWFzdXJlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIHJldHVybiBub3RVbmRlZmluZWQoXG4gICAgICBtZWFzdXJlbWVudHNbXG4gICAgICAgIGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgKGluZGV4OiBudW1iZXIpID0+IG5vdFVuZGVmaW5lZChtZWFzdXJlbWVudHNbaW5kZXhdKS5zdGFydCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgKVxuICB9XG5cbiAgZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50ID0gKFxuICAgIHRvT2Zmc2V0OiBudW1iZXIsXG4gICAgYWxpZ246IFNjcm9sbEFsaWdubWVudCxcbiAgICBpdGVtU2l6ZSA9IDAsXG4gICkgPT4ge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKVxuICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KClcblxuICAgIGlmIChhbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICBhbGlnbiA9IHRvT2Zmc2V0ID49IHNjcm9sbE9mZnNldCArIHNpemUgPyAnZW5kJyA6ICdzdGFydCdcbiAgICB9XG5cbiAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAvLyBXaGVuIGFsaWduaW5nIHRvIGEgcGFydGljdWxhciBpdGVtIChlLmcuIHdpdGggc2Nyb2xsVG9JbmRleCksXG4gICAgICAvLyBhZGp1c3Qgb2Zmc2V0IGJ5IHRoZSBzaXplIG9mIHRoZSBpdGVtIHRvIGNlbnRlciBvbiB0aGUgaXRlbVxuICAgICAgdG9PZmZzZXQgKz0gKGl0ZW1TaXplIC0gc2l6ZSkgLyAyXG4gICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIHRvT2Zmc2V0IC09IHNpemVcbiAgICB9XG5cbiAgICBjb25zdCBtYXhPZmZzZXQgPSB0aGlzLmdldFRvdGFsU2l6ZSgpICsgdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbiAtIHNpemVcblxuICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihtYXhPZmZzZXQsIHRvT2Zmc2V0KSwgMClcbiAgfVxuXG4gIGdldE9mZnNldEZvckluZGV4ID0gKGluZGV4OiBudW1iZXIsIGFsaWduOiBTY3JvbGxBbGlnbm1lbnQgPSAnYXV0bycpID0+IHtcbiAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLm9wdGlvbnMuY291bnQgLSAxKSlcblxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW2luZGV4XVxuICAgIGlmICghaXRlbSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKVxuICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KClcblxuICAgIGlmIChhbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICBpZiAoaXRlbS5lbmQgPj0gc2Nyb2xsT2Zmc2V0ICsgc2l6ZSAtIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nRW5kKSB7XG4gICAgICAgIGFsaWduID0gJ2VuZCdcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5zdGFydCA8PSBzY3JvbGxPZmZzZXQgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0KSB7XG4gICAgICAgIGFsaWduID0gJ3N0YXJ0J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtzY3JvbGxPZmZzZXQsIGFsaWduXSBhcyBjb25zdFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRvT2Zmc2V0ID1cbiAgICAgIGFsaWduID09PSAnZW5kJ1xuICAgICAgICA/IGl0ZW0uZW5kICsgdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmRcbiAgICAgICAgOiBpdGVtLnN0YXJ0IC0gdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydFxuXG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiwgaXRlbS5zaXplKSxcbiAgICAgIGFsaWduLFxuICAgIF0gYXMgY29uc3RcbiAgfVxuXG4gIHByaXZhdGUgaXNEeW5hbWljTW9kZSA9ICgpID0+IHRoaXMuZWxlbWVudHNDYWNoZS5zaXplID4gMFxuXG4gIHNjcm9sbFRvT2Zmc2V0ID0gKFxuICAgIHRvT2Zmc2V0OiBudW1iZXIsXG4gICAgeyBhbGlnbiA9ICdzdGFydCcsIGJlaGF2aW9yIH06IFNjcm9sbFRvT2Zmc2V0T3B0aW9ucyA9IHt9LFxuICApID0+IHtcbiAgICBpZiAoYmVoYXZpb3IgPT09ICdzbW9vdGgnICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuJyxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24pLCB7XG4gICAgICBhZGp1c3RtZW50czogdW5kZWZpbmVkLFxuICAgICAgYmVoYXZpb3IsXG4gICAgfSlcbiAgfVxuXG4gIHNjcm9sbFRvSW5kZXggPSAoXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICB7IGFsaWduOiBpbml0aWFsQWxpZ24gPSAnYXV0bycsIGJlaGF2aW9yIH06IFNjcm9sbFRvSW5kZXhPcHRpb25zID0ge30sXG4gICkgPT4ge1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ3Ntb290aCcgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1RoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKVxuXG4gICAgbGV0IGF0dGVtcHRzID0gMFxuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gMTBcblxuICAgIGNvbnN0IHRyeVNjcm9sbCA9IChjdXJyZW50QWxpZ246IFNjcm9sbEFsaWdubWVudCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnRhcmdldFdpbmRvdykgcmV0dXJuXG5cbiAgICAgIGNvbnN0IG9mZnNldEluZm8gPSB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBjdXJyZW50QWxpZ24pXG4gICAgICBpZiAoIW9mZnNldEluZm8pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2V0IG9mZnNldCBmb3IgaW5kZXg6JywgaW5kZXgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgW29mZnNldCwgYWxpZ25dID0gb2Zmc2V0SW5mb1xuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQob2Zmc2V0LCB7IGFkanVzdG1lbnRzOiB1bmRlZmluZWQsIGJlaGF2aW9yIH0pXG5cbiAgICAgIHRoaXMudGFyZ2V0V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSB0aGlzLmdldFNjcm9sbE9mZnNldCgpXG4gICAgICAgIGNvbnN0IGFmdGVySW5mbyA9IHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXgoaW5kZXgsIGFsaWduKVxuICAgICAgICBpZiAoIWFmdGVySW5mbykge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCBvZmZzZXQgZm9yIGluZGV4OicsIGluZGV4KVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhcHByb3hFcXVhbChhZnRlckluZm9bMF0sIGN1cnJlbnRPZmZzZXQpKSB7XG4gICAgICAgICAgc2NoZWR1bGVSZXRyeShhbGlnbilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBzY2hlZHVsZVJldHJ5ID0gKGFsaWduOiBTY3JvbGxBbGlnbm1lbnQpID0+IHtcbiAgICAgIGlmICghdGhpcy50YXJnZXRXaW5kb3cpIHJldHVyblxuXG4gICAgICBhdHRlbXB0cysrXG4gICAgICBpZiAoYXR0ZW1wdHMgPCBtYXhBdHRlbXB0cykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJ1NjaGVkdWxlIHJldHJ5JywgYXR0ZW1wdHMsIG1heEF0dGVtcHRzKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFyZ2V0V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0cnlTY3JvbGwoYWxpZ24pKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gc2Nyb2xsIHRvIGluZGV4ICR7aW5kZXh9IGFmdGVyICR7bWF4QXR0ZW1wdHN9IGF0dGVtcHRzLmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnlTY3JvbGwoaW5pdGlhbEFsaWduKVxuICB9XG5cbiAgc2Nyb2xsQnkgPSAoZGVsdGE6IG51bWJlciwgeyBiZWhhdmlvciB9OiBTY3JvbGxUb09mZnNldE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ3Ntb290aCcgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1RoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgKyBkZWx0YSwge1xuICAgICAgYWRqdXN0bWVudHM6IHVuZGVmaW5lZCxcbiAgICAgIGJlaGF2aW9yLFxuICAgIH0pXG4gIH1cblxuICBnZXRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5nZXRNZWFzdXJlbWVudHMoKVxuXG4gICAgbGV0IGVuZDogbnVtYmVyXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIG1lYXN1cmVtZW50cywgc2V0IHRoZSBlbmQgdG8gcGFkZGluZ1N0YXJ0XG4gICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgbGFuZSwgdXNlIHRoZSBsYXN0IG1lYXN1cmVtZW50J3MgZW5kXG4gICAgLy8gT3RoZXJ3aXNlIGZpbmQgdGhlIG1heGltdW0gZW5kIHZhbHVlIGFtb25nIGFsbCBtZWFzdXJlbWVudHNcbiAgICBpZiAobWVhc3VyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZW5kID0gdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydFxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmxhbmVzID09PSAxKSB7XG4gICAgICBlbmQgPSBtZWFzdXJlbWVudHNbbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdPy5lbmQgPz8gMFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbmRCeUxhbmUgPSBBcnJheTxudW1iZXIgfCBudWxsPih0aGlzLm9wdGlvbnMubGFuZXMpLmZpbGwobnVsbClcbiAgICAgIGxldCBlbmRJbmRleCA9IG1lYXN1cmVtZW50cy5sZW5ndGggLSAxXG4gICAgICB3aGlsZSAoZW5kSW5kZXggPj0gMCAmJiBlbmRCeUxhbmUuc29tZSgodmFsKSA9PiB2YWwgPT09IG51bGwpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBtZWFzdXJlbWVudHNbZW5kSW5kZXhdIVxuICAgICAgICBpZiAoZW5kQnlMYW5lW2l0ZW0ubGFuZV0gPT09IG51bGwpIHtcbiAgICAgICAgICBlbmRCeUxhbmVbaXRlbS5sYW5lXSA9IGl0ZW0uZW5kXG4gICAgICAgIH1cblxuICAgICAgICBlbmRJbmRleC0tXG4gICAgICB9XG5cbiAgICAgIGVuZCA9IE1hdGgubWF4KC4uLmVuZEJ5TGFuZS5maWx0ZXIoKHZhbCk6IHZhbCBpcyBudW1iZXIgPT4gdmFsICE9PSBudWxsKSlcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICBlbmQgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsTWFyZ2luICsgdGhpcy5vcHRpb25zLnBhZGRpbmdFbmQsXG4gICAgICAwLFxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgX3Njcm9sbFRvT2Zmc2V0ID0gKFxuICAgIG9mZnNldDogbnVtYmVyLFxuICAgIHtcbiAgICAgIGFkanVzdG1lbnRzLFxuICAgICAgYmVoYXZpb3IsXG4gICAgfToge1xuICAgICAgYWRqdXN0bWVudHM6IG51bWJlciB8IHVuZGVmaW5lZFxuICAgICAgYmVoYXZpb3I6IFNjcm9sbEJlaGF2aW9yIHwgdW5kZWZpbmVkXG4gICAgfSxcbiAgKSA9PiB7XG4gICAgdGhpcy5vcHRpb25zLnNjcm9sbFRvRm4ob2Zmc2V0LCB7IGJlaGF2aW9yLCBhZGp1c3RtZW50cyB9LCB0aGlzKVxuICB9XG5cbiAgbWVhc3VyZSA9ICgpID0+IHtcbiAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSBuZXcgTWFwKClcbiAgICB0aGlzLm5vdGlmeShmYWxzZSlcbiAgfVxufVxuXG5jb25zdCBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCA9IChcbiAgbG93OiBudW1iZXIsXG4gIGhpZ2g6IG51bWJlcixcbiAgZ2V0Q3VycmVudFZhbHVlOiAoaTogbnVtYmVyKSA9PiBudW1iZXIsXG4gIHZhbHVlOiBudW1iZXIsXG4pID0+IHtcbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgY29uc3QgbWlkZGxlID0gKChsb3cgKyBoaWdoKSAvIDIpIHwgMFxuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGdldEN1cnJlbnRWYWx1ZShtaWRkbGUpXG5cbiAgICBpZiAoY3VycmVudFZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIGxvdyA9IG1pZGRsZSArIDFcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSA+IHZhbHVlKSB7XG4gICAgICBoaWdoID0gbWlkZGxlIC0gMVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkZGxlXG4gICAgfVxuICB9XG5cbiAgaWYgKGxvdyA+IDApIHtcbiAgICByZXR1cm4gbG93IC0gMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAwXG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2Uoe1xuICBtZWFzdXJlbWVudHMsXG4gIG91dGVyU2l6ZSxcbiAgc2Nyb2xsT2Zmc2V0LFxuICBsYW5lcyxcbn06IHtcbiAgbWVhc3VyZW1lbnRzOiBBcnJheTxWaXJ0dWFsSXRlbT5cbiAgb3V0ZXJTaXplOiBudW1iZXJcbiAgc2Nyb2xsT2Zmc2V0OiBudW1iZXJcbiAgbGFuZXM6IG51bWJlclxufSkge1xuICBjb25zdCBsYXN0SW5kZXggPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMVxuICBjb25zdCBnZXRPZmZzZXQgPSAoaW5kZXg6IG51bWJlcikgPT4gbWVhc3VyZW1lbnRzW2luZGV4XSEuc3RhcnRcblxuICAvLyBoYW5kbGUgY2FzZSB3aGVuIGl0ZW0gY291bnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGxhbmVzXG4gIGlmIChtZWFzdXJlbWVudHMubGVuZ3RoIDw9IGxhbmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0SW5kZXg6IDAsXG4gICAgICBlbmRJbmRleDogbGFzdEluZGV4LFxuICAgIH1cbiAgfVxuXG4gIGxldCBzdGFydEluZGV4ID0gZmluZE5lYXJlc3RCaW5hcnlTZWFyY2goXG4gICAgMCxcbiAgICBsYXN0SW5kZXgsXG4gICAgZ2V0T2Zmc2V0LFxuICAgIHNjcm9sbE9mZnNldCxcbiAgKVxuICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4XG5cbiAgaWYgKGxhbmVzID09PSAxKSB7XG4gICAgd2hpbGUgKFxuICAgICAgZW5kSW5kZXggPCBsYXN0SW5kZXggJiZcbiAgICAgIG1lYXN1cmVtZW50c1tlbmRJbmRleF0hLmVuZCA8IHNjcm9sbE9mZnNldCArIG91dGVyU2l6ZVxuICAgICkge1xuICAgICAgZW5kSW5kZXgrK1xuICAgIH1cbiAgfSBlbHNlIGlmIChsYW5lcyA+IDEpIHtcbiAgICAvLyBFeHBhbmQgZm9yd2FyZCB1bnRpbCB3ZSBpbmNsdWRlIHRoZSB2aXNpYmxlIGl0ZW1zIGZyb20gYWxsIGxhbmVzXG4gICAgLy8gd2hpY2ggYXJlIGNsb3NlciB0byB0aGUgZW5kIG9mIHRoZSB2aXJ0dWFsaXplciB3aW5kb3dcbiAgICBjb25zdCBlbmRQZXJMYW5lID0gQXJyYXkobGFuZXMpLmZpbGwoMClcbiAgICB3aGlsZSAoXG4gICAgICBlbmRJbmRleCA8IGxhc3RJbmRleCAmJlxuICAgICAgZW5kUGVyTGFuZS5zb21lKChwb3MpID0+IHBvcyA8IHNjcm9sbE9mZnNldCArIG91dGVyU2l6ZSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtZWFzdXJlbWVudHNbZW5kSW5kZXhdIVxuICAgICAgZW5kUGVyTGFuZVtpdGVtLmxhbmVdID0gaXRlbS5lbmRcbiAgICAgIGVuZEluZGV4KytcbiAgICB9XG5cbiAgICAvLyBFeHBhbmQgYmFja3dhcmQgdW50aWwgd2UgaW5jbHVkZSBhbGwgbGFuZXMnIHZpc2libGUgaXRlbXNcbiAgICAvLyBjbG9zZXIgdG8gdGhlIHRvcFxuICAgIGNvbnN0IHN0YXJ0UGVyTGFuZSA9IEFycmF5KGxhbmVzKS5maWxsKHNjcm9sbE9mZnNldCArIG91dGVyU2l6ZSlcbiAgICB3aGlsZSAoc3RhcnRJbmRleCA+PSAwICYmIHN0YXJ0UGVyTGFuZS5zb21lKChwb3MpID0+IHBvcyA+PSBzY3JvbGxPZmZzZXQpKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWVhc3VyZW1lbnRzW3N0YXJ0SW5kZXhdIVxuICAgICAgc3RhcnRQZXJMYW5lW2l0ZW0ubGFuZV0gPSBpdGVtLnN0YXJ0XG4gICAgICBzdGFydEluZGV4LS1cbiAgICB9XG5cbiAgICAvLyBBbGlnbiBzdGFydEluZGV4IHRvIHRoZSBiZWdpbm5pbmcgb2YgaXRzIGxhbmVcbiAgICBzdGFydEluZGV4ID0gTWF0aC5tYXgoMCwgc3RhcnRJbmRleCAtIChzdGFydEluZGV4ICUgbGFuZXMpKVxuICAgIC8vIEFsaWduIGVuZEluZGV4IHRvIHRoZSBlbmQgb2YgaXRzIGxhbmVcbiAgICBlbmRJbmRleCA9IE1hdGgubWluKGxhc3RJbmRleCwgZW5kSW5kZXggKyAobGFuZXMgLSAxIC0gKGVuZEluZGV4ICUgbGFuZXMpKSlcbiAgfVxuXG4gIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH1cbn1cbiJdLCJmaWxlIjoiRDovQmlsbDI0L2IyNG1hbmFnZW1lbnRwb3J0YWwvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvZGlzdC9lc20vaW5kZXguanMiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMF19