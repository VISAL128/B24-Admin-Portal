import { defineComponent, ref, computed, watchEffect, watch, onMounted, onUnmounted, createElementBlock, openBlock, Fragment, createBlock, createCommentVNode, withCtx, createTextVNode, toDisplayString, unref, Teleport, createVNode, mergeProps, withModifiers, renderSlot } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/vue/dist/vue.runtime.esm-bundler.js?v=1214a853";
import { useRafFn, onKeyStroke } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/node_modules/@vueuse/core/index.mjs?v=1214a853";
import { _ as _sfc_main$1 } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/dist/Toast/ToastAnnounce.js?v=1214a853";
import { g as getAnnounceTextContent, V as VIEWPORT_PAUSE, a as VIEWPORT_RESUME, i as isDeltaInDirection, h as handleAndDispatchCustomEvent, T as TOAST_SWIPE_END, b as TOAST_SWIPE_CANCEL, c as TOAST_SWIPE_MOVE, d as TOAST_SWIPE_START } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/dist/Toast/utils.js?v=1214a853";
import { isClient } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/node_modules/@vueuse/shared/index.mjs?v=1214a853";
import { u as useCollection } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/dist/Collection/Collection.js?v=1214a853";
import { c as createContext } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/dist/shared/createContext.js?v=1214a853";
import { u as useForwardExpose } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/dist/shared/useForwardExpose.js?v=1214a853";
import { P as Primitive } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/dist/Primitive/Primitive.js?v=1214a853";
import { g as getActiveElement } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/dist/shared/getActiveElement.js?v=1214a853";
import { i as injectToastProviderContext } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/dist/Toast/ToastProvider.js?v=1214a853";

const [injectToastRootContext, provideToastRootContext] = createContext("ToastRoot");
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "ToastRootImpl",
  props: {
    type: {},
    open: { type: Boolean, default: false },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const providerContext = injectToastProviderContext();
    const pointerStartRef = ref(null);
    const swipeDeltaRef = ref(null);
    const duration = computed(
      () => typeof props.duration === "number" ? props.duration : providerContext.duration.value
    );
    const closeTimerStartTimeRef = ref(0);
    const closeTimerRemainingTimeRef = ref(duration.value);
    const closeTimerRef = ref(0);
    const remainingTime = ref(duration.value);
    const remainingRaf = useRafFn(() => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.value;
      remainingTime.value = Math.max(closeTimerRemainingTimeRef.value - elapsedTime, 0);
    }, { fpsLimit: 60 });
    function startTimer(duration2) {
      if (duration2 <= 0 || duration2 === Number.POSITIVE_INFINITY)
        return;
      if (!isClient)
        return;
      window.clearTimeout(closeTimerRef.value);
      closeTimerStartTimeRef.value = (/* @__PURE__ */ new Date()).getTime();
      closeTimerRef.value = window.setTimeout(handleClose, duration2);
    }
    function handleClose(event) {
      const isNonPointerEvent = event?.pointerType === "";
      const isFocusInToast = currentElement.value?.contains(getActiveElement());
      if (isFocusInToast && isNonPointerEvent)
        providerContext.viewport.value?.focus();
      if (isNonPointerEvent) {
        providerContext.isClosePausedRef.value = false;
      }
      emits("close");
    }
    const announceTextContent = computed(() => currentElement.value ? getAnnounceTextContent(currentElement.value) : null);
    if (props.type && !["foreground", "background"].includes(props.type)) {
      const error = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(error);
    }
    watchEffect((cleanupFn) => {
      const viewport = providerContext.viewport.value;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.value);
          remainingRaf.resume();
          emits("resume");
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.value;
          closeTimerRemainingTimeRef.value = closeTimerRemainingTimeRef.value - elapsedTime;
          window.clearTimeout(closeTimerRef.value);
          remainingRaf.pause();
          emits("pause");
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    });
    watch(() => [props.open, duration.value], () => {
      closeTimerRemainingTimeRef.value = duration.value;
      if (props.open && !providerContext.isClosePausedRef.value)
        startTimer(duration.value);
    }, { immediate: true });
    onKeyStroke("Escape", (event) => {
      emits("escapeKeyDown", event);
      if (!event.defaultPrevented) {
        providerContext.isFocusedToastEscapeKeyDownRef.value = true;
        handleClose();
      }
    });
    onMounted(() => {
      providerContext.onToastAdd();
    });
    onUnmounted(() => {
      providerContext.onToastRemove();
    });
    provideToastRootContext({ onClose: handleClose });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        announceTextContent.value ? (openBlock(), createBlock(_sfc_main$1, {
          key: 0,
          role: "alert",
          "aria-live": _ctx.type === "foreground" ? "assertive" : "polite",
          "aria-atomic": "true"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(announceTextContent.value), 1)
          ]),
          _: 1
        }, 8, ["aria-live"])) : createCommentVNode("", true),
        unref(providerContext).viewport.value ? (openBlock(), createBlock(Teleport, {
          key: 1,
          to: unref(providerContext).viewport.value
        }, [
          createVNode(unref(CollectionItem), null, {
            default: withCtx(() => [
              createVNode(unref(Primitive), mergeProps({
                ref: unref(forwardRef),
                role: "alert",
                "aria-live": "off",
                "aria-atomic": "true",
                tabindex: "0"
              }, _ctx.$attrs, {
                as: _ctx.as,
                "as-child": _ctx.asChild,
                "data-state": _ctx.open ? "open" : "closed",
                "data-swipe-direction": unref(providerContext).swipeDirection.value,
                style: { userSelect: "none", touchAction: "none" },
                onPointerdown: _cache[0] || (_cache[0] = withModifiers((event) => {
                  pointerStartRef.value = { x: event.clientX, y: event.clientY };
                }, ["left"])),
                onPointermove: _cache[1] || (_cache[1] = (event) => {
                  if (!pointerStartRef.value) return;
                  const x = event.clientX - pointerStartRef.value.x;
                  const y = event.clientY - pointerStartRef.value.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.value);
                  const isHorizontalSwipe = ["left", "right"].includes(unref(providerContext).swipeDirection.value);
                  const clamp = ["left", "up"].includes(unref(providerContext).swipeDirection.value) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.value = delta;
                    unref(handleAndDispatchCustomEvent)(unref(TOAST_SWIPE_MOVE), (ev) => emits("swipeMove", ev), eventDetail);
                  } else if (unref(isDeltaInDirection)(delta, unref(providerContext).swipeDirection.value, moveStartBuffer)) {
                    swipeDeltaRef.value = delta;
                    unref(handleAndDispatchCustomEvent)(unref(TOAST_SWIPE_START), (ev) => emits("swipeStart", ev), eventDetail);
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.value = null;
                  }
                }),
                onPointerup: _cache[2] || (_cache[2] = (event) => {
                  const delta = swipeDeltaRef.value;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.value = null;
                  pointerStartRef.value = null;
                  if (delta) {
                    const toast = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (unref(isDeltaInDirection)(delta, unref(providerContext).swipeDirection.value, unref(providerContext).swipeThreshold.value)) {
                      unref(handleAndDispatchCustomEvent)(unref(TOAST_SWIPE_END), (ev) => emits("swipeEnd", ev), eventDetail);
                    } else {
                      unref(handleAndDispatchCustomEvent)(unref(TOAST_SWIPE_CANCEL), (ev) => emits("swipeCancel", ev), eventDetail);
                    }
                    toast?.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default", {
                    remaining: remainingTime.value,
                    duration: duration.value
                  })
                ]),
                _: 3
              }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
            ]),
            _: 3
          })
        ], 8, ["to"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});

export { _sfc_main as _, injectToastRootContext as i };
                                         

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9hc3RSb290SW1wbC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL1RvYXN0L1RvYXN0Um9vdEltcGwudnVlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5pbXBvcnQgdHlwZSB7IFN3aXBlRXZlbnQgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHR5cGUgeyBQcmltaXRpdmVQcm9wcyB9IGZyb20gJ0AvUHJpbWl0aXZlJ1xuaW1wb3J0IHsgaXNDbGllbnQgfSBmcm9tICdAdnVldXNlL3NoYXJlZCdcbmltcG9ydCB7IHVzZUNvbGxlY3Rpb24gfSBmcm9tICdAL0NvbGxlY3Rpb24nXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBnZXRBY3RpdmVFbGVtZW50LCB1c2VGb3J3YXJkRXhwb3NlIH0gZnJvbSAnQC9zaGFyZWQnXG5cbmV4cG9ydCB0eXBlIFRvYXN0Um9vdEltcGxFbWl0cyA9IHtcbiAgY2xvc2U6IFtdXG4gIC8qKiBFdmVudCBoYW5kbGVyIGNhbGxlZCB3aGVuIHRoZSBlc2NhcGUga2V5IGlzIGRvd24uIEl0IGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZyBgZXZlbnQucHJldmVudERlZmF1bHRgLiAqL1xuICBlc2NhcGVLZXlEb3duOiBbZXZlbnQ6IEtleWJvYXJkRXZlbnRdXG4gIC8qKiBFdmVudCBoYW5kbGVyIGNhbGxlZCB3aGVuIHRoZSBkaXNtaXNzIHRpbWVyIGlzIHBhdXNlZC4gVGhpcyBvY2N1cnMgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZlZCBvdmVyIHRoZSB2aWV3cG9ydCwgdGhlIHZpZXdwb3J0IGlzIGZvY3VzZWQgb3Igd2hlbiB0aGUgd2luZG93IGlzIGJsdXJyZWQuICovXG4gIHBhdXNlOiBbXVxuICAvKiogRXZlbnQgaGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgZGlzbWlzcyB0aW1lciBpcyByZXN1bWVkLiBUaGlzIG9jY3VycyB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmVkIGF3YXkgZnJvbSB0aGUgdmlld3BvcnQsIHRoZSB2aWV3cG9ydCBpcyBibHVycmVkIG9yIHdoZW4gdGhlIHdpbmRvdyBpcyBmb2N1c2VkLiAqL1xuICByZXN1bWU6IFtdXG4gIC8qKiBFdmVudCBoYW5kbGVyIGNhbGxlZCB3aGVuIHN0YXJ0aW5nIGEgc3dpcGUgaW50ZXJhY3Rpb24uIEl0IGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZyBgZXZlbnQucHJldmVudERlZmF1bHRgLiAqL1xuICBzd2lwZVN0YXJ0OiBbZXZlbnQ6IFN3aXBlRXZlbnRdXG4gIC8qKiBFdmVudCBoYW5kbGVyIGNhbGxlZCBkdXJpbmcgYSBzd2lwZSBpbnRlcmFjdGlvbi4gSXQgY2FuIGJlIHByZXZlbnRlZCBieSBjYWxsaW5nIGBldmVudC5wcmV2ZW50RGVmYXVsdGAuICovXG4gIHN3aXBlTW92ZTogW2V2ZW50OiBTd2lwZUV2ZW50XVxuICAvKiogRXZlbnQgaGFuZGxlciBjYWxsZWQgd2hlbiBzd2lwZSBpbnRlcmFjdGlvbiBpcyBjYW5jZWxsZWQuIEl0IGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZyBgZXZlbnQucHJldmVudERlZmF1bHRgLiAqL1xuICBzd2lwZUNhbmNlbDogW2V2ZW50OiBTd2lwZUV2ZW50XVxuICAvKiogRXZlbnQgaGFuZGxlciBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhIHN3aXBlIGludGVyYWN0aW9uLiBJdCBjYW4gYmUgcHJldmVudGVkIGJ5IGNhbGxpbmcgYGV2ZW50LnByZXZlbnREZWZhdWx0YC4gKi9cbiAgc3dpcGVFbmQ6IFtldmVudDogU3dpcGVFdmVudF1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb2FzdFJvb3RJbXBsUHJvcHMgZXh0ZW5kcyBQcmltaXRpdmVQcm9wcyB7XG4gIC8qKlxuICAgKiBDb250cm9sIHRoZSBzZW5zaXRpdml0eSBvZiB0aGUgdG9hc3QgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG4gICAqXG4gICAqIEZvciB0b2FzdHMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZiBhIHVzZXIgYWN0aW9uLCBjaG9vc2UgYGZvcmVncm91bmRgLiBUb2FzdHMgZ2VuZXJhdGVkIGZyb20gYmFja2dyb3VuZCB0YXNrcyBzaG91bGQgdXNlIGBiYWNrZ3JvdW5kYC5cbiAgICovXG4gIHR5cGU/OiAnZm9yZWdyb3VuZCcgfCAnYmFja2dyb3VuZCdcbiAgLyoqXG4gICAqIFRoZSBjb250cm9sbGVkIG9wZW4gc3RhdGUgb2YgdGhlIGRpYWxvZy4gQ2FuIGJlIGJpbmQgYXMgYHYtbW9kZWw6b3BlbmAuXG4gICAqL1xuICBvcGVuPzogYm9vbGVhblxuICAvKipcbiAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCB0b2FzdCBzaG91bGQgcmVtYWluIHZpc2libGUgZm9yLiBPdmVycmlkZXMgdmFsdWVcbiAgICogZ2l2ZW4gdG8gYFRvYXN0UHJvdmlkZXJgLlxuICAgKi9cbiAgZHVyYXRpb24/OiBudW1iZXJcbn1cblxuZXhwb3J0IGNvbnN0IFtpbmplY3RUb2FzdFJvb3RDb250ZXh0LCBwcm92aWRlVG9hc3RSb290Q29udGV4dF1cbiAgPSBjcmVhdGVDb250ZXh0PHsgb25DbG9zZTogKCkgPT4gdm9pZCB9PignVG9hc3RSb290Jylcbjwvc2NyaXB0PlxuXG48c2NyaXB0IHNldHVwIGxhbmc9XCJ0c1wiPlxuaW1wb3J0IHsgb25LZXlTdHJva2UsIHVzZVJhZkZuIH0gZnJvbSAnQHZ1ZXVzZS9jb3JlJ1xuaW1wb3J0IHsgY29tcHV0ZWQsIG9uTW91bnRlZCwgb25Vbm1vdW50ZWQsIHJlZiwgd2F0Y2gsIHdhdGNoRWZmZWN0IH0gZnJvbSAndnVlJ1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSAnQC9QcmltaXRpdmUnXG5pbXBvcnQgVG9hc3RBbm5vdW5jZSBmcm9tICcuL1RvYXN0QW5ub3VuY2UudnVlJ1xuaW1wb3J0IHsgaW5qZWN0VG9hc3RQcm92aWRlckNvbnRleHQgfSBmcm9tICcuL1RvYXN0UHJvdmlkZXIudnVlJ1xuaW1wb3J0IHsgZ2V0QW5ub3VuY2VUZXh0Q29udGVudCwgaGFuZGxlQW5kRGlzcGF0Y2hDdXN0b21FdmVudCwgaXNEZWx0YUluRGlyZWN0aW9uLCBUT0FTVF9TV0lQRV9DQU5DRUwsIFRPQVNUX1NXSVBFX0VORCwgVE9BU1RfU1dJUEVfTU9WRSwgVE9BU1RfU1dJUEVfU1RBUlQsIFZJRVdQT1JUX1BBVVNFLCBWSUVXUE9SVF9SRVNVTUUgfSBmcm9tICcuL3V0aWxzJ1xuXG5kZWZpbmVPcHRpb25zKHtcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbn0pXG5cbmNvbnN0IHByb3BzID0gd2l0aERlZmF1bHRzKGRlZmluZVByb3BzPFRvYXN0Um9vdEltcGxQcm9wcz4oKSwge1xuICBvcGVuOiBmYWxzZSxcbiAgYXM6ICdsaScsXG59KVxuXG5jb25zdCBlbWl0cyA9IGRlZmluZUVtaXRzPFRvYXN0Um9vdEltcGxFbWl0cz4oKVxuXG5jb25zdCB7IGZvcndhcmRSZWYsIGN1cnJlbnRFbGVtZW50IH0gPSB1c2VGb3J3YXJkRXhwb3NlKClcbmNvbnN0IHsgQ29sbGVjdGlvbkl0ZW0gfSA9IHVzZUNvbGxlY3Rpb24oKVxuXG5jb25zdCBwcm92aWRlckNvbnRleHQgPSBpbmplY3RUb2FzdFByb3ZpZGVyQ29udGV4dCgpXG5jb25zdCBwb2ludGVyU3RhcnRSZWYgPSByZWY8eyB4OiBudW1iZXIsIHk6IG51bWJlciB9IHwgbnVsbD4obnVsbClcbmNvbnN0IHN3aXBlRGVsdGFSZWYgPSByZWY8eyB4OiBudW1iZXIsIHk6IG51bWJlciB9IHwgbnVsbD4obnVsbClcbmNvbnN0IGR1cmF0aW9uID0gY29tcHV0ZWQoXG4gICgpID0+IHR5cGVvZiBwcm9wcy5kdXJhdGlvbiA9PT0gJ251bWJlcidcbiAgICA/IHByb3BzLmR1cmF0aW9uXG4gICAgOiBwcm92aWRlckNvbnRleHQuZHVyYXRpb24udmFsdWUsXG4pXG5cbmNvbnN0IGNsb3NlVGltZXJTdGFydFRpbWVSZWYgPSByZWYoMClcbmNvbnN0IGNsb3NlVGltZXJSZW1haW5pbmdUaW1lUmVmID0gcmVmKGR1cmF0aW9uLnZhbHVlKVxuY29uc3QgY2xvc2VUaW1lclJlZiA9IHJlZigwKVxuY29uc3QgcmVtYWluaW5nVGltZSA9IHJlZihkdXJhdGlvbi52YWx1ZSlcblxuY29uc3QgcmVtYWluaW5nUmFmID0gdXNlUmFmRm4oKCkgPT4ge1xuICBjb25zdCBlbGFwc2VkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gY2xvc2VUaW1lclN0YXJ0VGltZVJlZi52YWx1ZVxuICByZW1haW5pbmdUaW1lLnZhbHVlID0gTWF0aC5tYXgoY2xvc2VUaW1lclJlbWFpbmluZ1RpbWVSZWYudmFsdWUgLSBlbGFwc2VkVGltZSwgMClcbn0sIHsgZnBzTGltaXQ6IDYwIH0pXG5cbmZ1bmN0aW9uIHN0YXJ0VGltZXIoZHVyYXRpb246IG51bWJlcikge1xuICBpZiAoZHVyYXRpb24gPD0gMCB8fCBkdXJhdGlvbiA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgIHJldHVyblxuICAvLyBzdGFydFRpbWVyIGlzIHVzZWQgaW5zaWRlIGEgd2F0Y2ggd2l0aCBpbW1lZGlhdGUgc2V0IHRvIHRydWUuXG4gIC8vIFRoaXMgcmVzdWx0cyBpbiBjb2RlIGV4ZWN1dGlvbiBkdXJpbmcgU1NSLlxuICAvLyBFbnN1cmUgdGhpcyBjb2RlIG9ubHkgcnVucyBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgaWYgKCFpc0NsaWVudClcbiAgICByZXR1cm5cbiAgd2luZG93LmNsZWFyVGltZW91dChjbG9zZVRpbWVyUmVmLnZhbHVlKVxuICBjbG9zZVRpbWVyU3RhcnRUaW1lUmVmLnZhbHVlID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgY2xvc2VUaW1lclJlZi52YWx1ZSA9IHdpbmRvdy5zZXRUaW1lb3V0KGhhbmRsZUNsb3NlLCBkdXJhdGlvbilcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2xvc2UoZXZlbnQ/OiBQb2ludGVyRXZlbnQpIHtcbiAgY29uc3QgaXNOb25Qb2ludGVyRXZlbnQgPSBldmVudD8ucG9pbnRlclR5cGUgPT09ICcnXG5cbiAgLy8gcmVrYTogdXBkYXRlIHRvIG9ubHkgcGVyZm9ybSBmb2N1cyB3aGVuIHVzZXIgZm9jdXMgdmlhIGtleWJvYXJkXG4gIC8vIGZvY3VzIHZpZXdwb3J0IGlmIGZvY3VzIGlzIHdpdGhpbiB0b2FzdCB0byByZWFkIHRoZSByZW1haW5pbmcgdG9hc3RcbiAgLy8gY291bnQgdG8gU1IgdXNlcnMgYW5kIGVuc3VyZSBmb2N1cyBpc24ndCBsb3N0XG4gIGNvbnN0IGlzRm9jdXNJblRvYXN0ID0gY3VycmVudEVsZW1lbnQudmFsdWU/LmNvbnRhaW5zKGdldEFjdGl2ZUVsZW1lbnQoKSlcbiAgaWYgKGlzRm9jdXNJblRvYXN0ICYmIGlzTm9uUG9pbnRlckV2ZW50KVxuICAgIHByb3ZpZGVyQ29udGV4dC52aWV3cG9ydC52YWx1ZT8uZm9jdXMoKVxuXG4gIGlmIChpc05vblBvaW50ZXJFdmVudCkge1xuICAgIC8vIHdoZW4gbWFudWFsbHkgY2xvc2UgdGhlIHRvYXN0LCB3ZSByZXNldCBpc0Nsb3NlUGF1c2VkUmVmXG4gICAgcHJvdmlkZXJDb250ZXh0LmlzQ2xvc2VQYXVzZWRSZWYudmFsdWUgPSBmYWxzZVxuICB9XG5cbiAgZW1pdHMoJ2Nsb3NlJylcbn1cblxuY29uc3QgYW5ub3VuY2VUZXh0Q29udGVudCA9IGNvbXB1dGVkKCgpID0+IGN1cnJlbnRFbGVtZW50LnZhbHVlID8gZ2V0QW5ub3VuY2VUZXh0Q29udGVudChjdXJyZW50RWxlbWVudC52YWx1ZSkgOiBudWxsKVxuXG5pZiAocHJvcHMudHlwZSAmJiAhWydmb3JlZ3JvdW5kJywgJ2JhY2tncm91bmQnXS5pbmNsdWRlcyhwcm9wcy50eXBlKSkge1xuICBjb25zdCBlcnJvciA9ICdJbnZhbGlkIHByb3AgYHR5cGVgIHN1cHBsaWVkIHRvIGBUb2FzdGAuIEV4cGVjdGVkIGBmb3JlZ3JvdW5kIHwgYmFja2dyb3VuZGAuJ1xuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpXG59XG5cbndhdGNoRWZmZWN0KChjbGVhbnVwRm4pID0+IHtcbiAgY29uc3Qgdmlld3BvcnQgPSBwcm92aWRlckNvbnRleHQudmlld3BvcnQudmFsdWVcbiAgaWYgKHZpZXdwb3J0KSB7XG4gICAgY29uc3QgaGFuZGxlUmVzdW1lID0gKCkgPT4ge1xuICAgICAgc3RhcnRUaW1lcihjbG9zZVRpbWVyUmVtYWluaW5nVGltZVJlZi52YWx1ZSlcbiAgICAgIHJlbWFpbmluZ1JhZi5yZXN1bWUoKVxuICAgICAgZW1pdHMoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVBhdXNlID0gKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGNsb3NlVGltZXJTdGFydFRpbWVSZWYudmFsdWVcbiAgICAgIGNsb3NlVGltZXJSZW1haW5pbmdUaW1lUmVmLnZhbHVlID0gY2xvc2VUaW1lclJlbWFpbmluZ1RpbWVSZWYudmFsdWUgLSBlbGFwc2VkVGltZVxuICAgICAgd2luZG93LmNsZWFyVGltZW91dChjbG9zZVRpbWVyUmVmLnZhbHVlKVxuICAgICAgcmVtYWluaW5nUmFmLnBhdXNlKClcbiAgICAgIGVtaXRzKCdwYXVzZScpXG4gICAgfVxuICAgIHZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoVklFV1BPUlRfUEFVU0UsIGhhbmRsZVBhdXNlKVxuICAgIHZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoVklFV1BPUlRfUkVTVU1FLCBoYW5kbGVSZXN1bWUpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoVklFV1BPUlRfUEFVU0UsIGhhbmRsZVBhdXNlKVxuICAgICAgdmlld3BvcnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihWSUVXUE9SVF9SRVNVTUUsIGhhbmRsZVJlc3VtZSlcbiAgICB9XG4gIH1cbn0pXG5cbi8vIHN0YXJ0IHRpbWVyIHdoZW4gdG9hc3Qgb3BlbnMgb3IgZHVyYXRpb24gY2hhbmdlcy5cbi8vIHdlIGluY2x1ZGUgYG9wZW5gIGluIGRlcHMgYmVjYXVzZSBjbG9zZWQgIT09IHVubW91bnRlZCB3aGVuIGFuaW1hdGluZ1xuLy8gc28gaXQgY291bGQgcmVvcGVuIGJlZm9yZSBiZWluZyBjb21wbGV0ZWx5IHVubW91bnRlZFxud2F0Y2goKCkgPT4gW3Byb3BzLm9wZW4sIGR1cmF0aW9uLnZhbHVlXSwgKCkgPT4ge1xuICAvLyBSZXNldCB0aGUgdGltZXIgd2hlbiB0aGUgdG9hc3QgaXMgcmVyZW5kZXJlZCB3aXRoIHRoZSBuZXcgZHVyYXRpb25cbiAgY2xvc2VUaW1lclJlbWFpbmluZ1RpbWVSZWYudmFsdWUgPSBkdXJhdGlvbi52YWx1ZVxuXG4gIGlmIChwcm9wcy5vcGVuICYmICFwcm92aWRlckNvbnRleHQuaXNDbG9zZVBhdXNlZFJlZi52YWx1ZSlcbiAgICBzdGFydFRpbWVyKGR1cmF0aW9uLnZhbHVlKVxufSwgeyBpbW1lZGlhdGU6IHRydWUgfSlcblxub25LZXlTdHJva2UoJ0VzY2FwZScsIChldmVudCkgPT4ge1xuICBlbWl0cygnZXNjYXBlS2V5RG93bicsIGV2ZW50KVxuICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICBwcm92aWRlckNvbnRleHQuaXNGb2N1c2VkVG9hc3RFc2NhcGVLZXlEb3duUmVmLnZhbHVlID0gdHJ1ZVxuICAgIGhhbmRsZUNsb3NlKClcbiAgfVxufSlcblxub25Nb3VudGVkKCgpID0+IHtcbiAgcHJvdmlkZXJDb250ZXh0Lm9uVG9hc3RBZGQoKVxufSlcbm9uVW5tb3VudGVkKCgpID0+IHtcbiAgcHJvdmlkZXJDb250ZXh0Lm9uVG9hc3RSZW1vdmUoKVxufSlcblxucHJvdmlkZVRvYXN0Um9vdENvbnRleHQoeyBvbkNsb3NlOiBoYW5kbGVDbG9zZSB9KVxuPC9zY3JpcHQ+XG5cbjx0ZW1wbGF0ZT5cbiAgPFRvYXN0QW5ub3VuY2VcbiAgICB2LWlmPVwiYW5ub3VuY2VUZXh0Q29udGVudFwiXG4gICAgcm9sZT1cImFsZXJ0XCJcbiAgICA6YXJpYS1saXZlPVwidHlwZSA9PT0gJ2ZvcmVncm91bmQnID8gJ2Fzc2VydGl2ZScgOiAncG9saXRlJ1wiXG4gICAgYXJpYS1hdG9taWM9XCJ0cnVlXCJcbiAgPlxuICAgIHt7IGFubm91bmNlVGV4dENvbnRlbnQgfX1cbiAgPC9Ub2FzdEFubm91bmNlPlxuXG4gIDxUZWxlcG9ydFxuICAgIHYtaWY9XCJwcm92aWRlckNvbnRleHQudmlld3BvcnQudmFsdWVcIlxuICAgIDp0bz1cInByb3ZpZGVyQ29udGV4dC52aWV3cG9ydC52YWx1ZVwiXG4gID5cbiAgICA8Q29sbGVjdGlvbkl0ZW0+XG4gICAgICA8UHJpbWl0aXZlXG4gICAgICAgIDpyZWY9XCJmb3J3YXJkUmVmXCJcbiAgICAgICAgcm9sZT1cImFsZXJ0XCJcbiAgICAgICAgYXJpYS1saXZlPVwib2ZmXCJcbiAgICAgICAgYXJpYS1hdG9taWM9XCJ0cnVlXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgdi1iaW5kPVwiJGF0dHJzXCJcbiAgICAgICAgOmFzPVwiYXNcIlxuICAgICAgICA6YXMtY2hpbGQ9XCJhc0NoaWxkXCJcbiAgICAgICAgOmRhdGEtc3RhdGU9XCJvcGVuID8gJ29wZW4nIDogJ2Nsb3NlZCdcIlxuICAgICAgICA6ZGF0YS1zd2lwZS1kaXJlY3Rpb249XCJwcm92aWRlckNvbnRleHQuc3dpcGVEaXJlY3Rpb24udmFsdWVcIlxuICAgICAgICA6c3R5bGU9XCJ7IHVzZXJTZWxlY3Q6ICdub25lJywgdG91Y2hBY3Rpb246ICdub25lJyB9XCJcbiAgICAgICAgQHBvaW50ZXJkb3duLmxlZnQ9XCIoZXZlbnQ6IFBvaW50ZXJFdmVudCkgPT4ge1xuICAgICAgICAgIHBvaW50ZXJTdGFydFJlZiA9IHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9O1xuICAgICAgICB9XCJcbiAgICAgICAgQHBvaW50ZXJtb3ZlPVwiKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoIXBvaW50ZXJTdGFydFJlZikgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYIC0gcG9pbnRlclN0YXJ0UmVmLng7XG4gICAgICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFkgLSBwb2ludGVyU3RhcnRSZWYueTtcbiAgICAgICAgICBjb25zdCBoYXNTd2lwZU1vdmVTdGFydGVkID0gQm9vbGVhbihzd2lwZURlbHRhUmVmKTtcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWxTd2lwZSA9IFsnbGVmdCcsICdyaWdodCddLmluY2x1ZGVzKHByb3ZpZGVyQ29udGV4dC5zd2lwZURpcmVjdGlvbi52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgY2xhbXAgPSBbJ2xlZnQnLCAndXAnXS5pbmNsdWRlcyhwcm92aWRlckNvbnRleHQuc3dpcGVEaXJlY3Rpb24udmFsdWUpXG4gICAgICAgICAgICA/IE1hdGgubWluXG4gICAgICAgICAgICA6IE1hdGgubWF4O1xuICAgICAgICAgIGNvbnN0IGNsYW1wZWRYID0gaXNIb3Jpem9udGFsU3dpcGUgPyBjbGFtcCgwLCB4KSA6IDA7XG4gICAgICAgICAgY29uc3QgY2xhbXBlZFkgPSAhaXNIb3Jpem9udGFsU3dpcGUgPyBjbGFtcCgwLCB5KSA6IDA7XG4gICAgICAgICAgY29uc3QgbW92ZVN0YXJ0QnVmZmVyID0gZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgPyAxMCA6IDI7XG4gICAgICAgICAgY29uc3QgZGVsdGEgPSB7IHg6IGNsYW1wZWRYLCB5OiBjbGFtcGVkWSB9O1xuICAgICAgICAgIGNvbnN0IGV2ZW50RGV0YWlsID0geyBvcmlnaW5hbEV2ZW50OiBldmVudCwgZGVsdGEgfTtcbiAgICAgICAgICBpZiAoaGFzU3dpcGVNb3ZlU3RhcnRlZCkge1xuICAgICAgICAgICAgc3dpcGVEZWx0YVJlZiA9IGRlbHRhO1xuICAgICAgICAgICAgaGFuZGxlQW5kRGlzcGF0Y2hDdXN0b21FdmVudChUT0FTVF9TV0lQRV9NT1ZFLCAoZXY6IFN3aXBlRXZlbnQpID0+IGVtaXRzKCdzd2lwZU1vdmUnLCBldiksIGV2ZW50RGV0YWlsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNEZWx0YUluRGlyZWN0aW9uKGRlbHRhLCBwcm92aWRlckNvbnRleHQuc3dpcGVEaXJlY3Rpb24udmFsdWUsIG1vdmVTdGFydEJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHN3aXBlRGVsdGFSZWYgPSBkZWx0YTtcbiAgICAgICAgICAgIGhhbmRsZUFuZERpc3BhdGNoQ3VzdG9tRXZlbnQoVE9BU1RfU1dJUEVfU1RBUlQsIChldjogU3dpcGVFdmVudCkgPT4gZW1pdHMoJ3N3aXBlU3RhcnQnLCBldiksIGV2ZW50RGV0YWlsKTtcbiAgICAgICAgICAgIChldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKHgpID4gbW92ZVN0YXJ0QnVmZmVyIHx8IE1hdGguYWJzKHkpID4gbW92ZVN0YXJ0QnVmZmVyKSB7XG4gICAgICAgICAgICAvLyBVc2VyIGlzIHN3aXBpbmcgaW4gd3JvbmcgZGlyZWN0aW9uIHNvIHdlIGRpc2FibGUgc3dpcGUgZ2VzdHVyZVxuICAgICAgICAgICAgLy8gZm9yIHRoZSBjdXJyZW50IHBvaW50ZXIgZG93biBpbnRlcmFjdGlvblxuICAgICAgICAgICAgcG9pbnRlclN0YXJ0UmVmID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cIlxuICAgICAgICBAcG9pbnRlcnVwPVwiKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBkZWx0YSA9IHN3aXBlRGVsdGFSZWY7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgIGlmICh0YXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2lwZURlbHRhUmVmID0gbnVsbDtcbiAgICAgICAgICBwb2ludGVyU3RhcnRSZWYgPSBudWxsO1xuICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgY29uc3QgdG9hc3QgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgZXZlbnREZXRhaWwgPSB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50LCBkZWx0YSB9O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpc0RlbHRhSW5EaXJlY3Rpb24oZGVsdGEsIHByb3ZpZGVyQ29udGV4dC5zd2lwZURpcmVjdGlvbi52YWx1ZSwgcHJvdmlkZXJDb250ZXh0LnN3aXBlVGhyZXNob2xkLnZhbHVlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUFuZERpc3BhdGNoQ3VzdG9tRXZlbnQoVE9BU1RfU1dJUEVfRU5ELCAoZXY6IFN3aXBlRXZlbnQpID0+IGVtaXRzKCdzd2lwZUVuZCcsIGV2KSwgZXZlbnREZXRhaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGhhbmRsZUFuZERpc3BhdGNoQ3VzdG9tRXZlbnQoVE9BU1RfU1dJUEVfQ0FOQ0VMLCAoZXY6IFN3aXBlRXZlbnQpID0+IGVtaXRzKCdzd2lwZUNhbmNlbCcsIGV2KSwgZXZlbnREZXRhaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJldmVudCBjbGljayBldmVudCBmcm9tIHRyaWdnZXJpbmcgb24gaXRlbXMgd2l0aGluIHRoZSB0b2FzdCB3aGVuXG4gICAgICAgICAgICAvLyBwb2ludGVyIHVwIGlzIHBhcnQgb2YgYSBzd2lwZSBnZXN0dXJlXG4gICAgICAgICAgICB0b2FzdD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCksIHtcbiAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVwiXG4gICAgICA+XG4gICAgICAgIDxzbG90XG4gICAgICAgICAgOnJlbWFpbmluZz1cInJlbWFpbmluZ1RpbWVcIlxuICAgICAgICAgIDpkdXJhdGlvbj1cImR1cmF0aW9uXCJcbiAgICAgICAgLz5cbiAgICAgIDwvUHJpbWl0aXZlPlxuICAgIDwvQ29sbGVjdGlvbkl0ZW0+XG4gIDwvVGVsZXBvcnQ+XG48L3RlbXBsYXRlPlxuIl0sIm5hbWVzIjpbImR1cmF0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUEyQ08sTUFBTSxDQUFDLHNCQUFBLEVBQXdCLHVCQUF1QixDQUFBLEdBQ3pELGNBQXVDLFdBQVc7Ozs7Ozs7Ozs7Ozs7OztBQWV0RCxJQUFBLE1BQU0sS0FBUSxHQUFBLE9BQUE7QUFLZCxJQUFBLE1BQU0sS0FBUSxHQUFBLE1BQUE7QUFFZCxJQUFBLE1BQU0sRUFBRSxVQUFBLEVBQVksY0FBZSxFQUFBLEdBQUksZ0JBQWlCLEVBQUE7QUFDeEQsSUFBTSxNQUFBLEVBQUUsY0FBZSxFQUFBLEdBQUksYUFBYyxFQUFBO0FBRXpDLElBQUEsTUFBTSxrQkFBa0IsMEJBQTJCLEVBQUE7QUFDbkQsSUFBTSxNQUFBLGVBQUEsR0FBa0IsSUFBcUMsSUFBSSxDQUFBO0FBQ2pFLElBQU0sTUFBQSxhQUFBLEdBQWdCLElBQXFDLElBQUksQ0FBQTtBQUMvRCxJQUFBLE1BQU0sUUFBVyxHQUFBLFFBQUE7QUFBQSxNQUNmLE1BQU0sT0FBTyxLQUFNLENBQUEsUUFBQSxLQUFhLFdBQzVCLEtBQU0sQ0FBQSxRQUFBLEdBQ04sZ0JBQWdCLFFBQVMsQ0FBQTtBQUFBLEtBQy9CO0FBRUEsSUFBTSxNQUFBLHNCQUFBLEdBQXlCLElBQUksQ0FBQyxDQUFBO0FBQ3BDLElBQU0sTUFBQSwwQkFBQSxHQUE2QixHQUFJLENBQUEsUUFBQSxDQUFTLEtBQUssQ0FBQTtBQUNyRCxJQUFNLE1BQUEsYUFBQSxHQUFnQixJQUFJLENBQUMs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