import { noop, makeDestructurable, camelize, isClient, toArray, watchImmediate, isObject, tryOnScopeDispose, isIOS, notNullish, tryOnMounted, objectOmit, promiseTimeout, until, injectLocal, provideLocal, pxValue, increaseWithUnit, objectEntries, createRef, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, useIntervalFn, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, bypassFilter, createFilterWrapper, toRefs, watchOnce, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, tryOnUnmounted, clamp, syncRef, objectPick, watchWithFilter, identity, isDef, whenever, isWorker } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/@vueuse/shared/index.mjs?v=1214a853";
export * from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/@vueuse/shared/index.mjs?v=1214a853";
import { isRef, shallowRef, ref, watchEffect, computed, inject, defineComponent, h, TransitionGroup, Fragment, shallowReactive, toValue, unref, getCurrentInstance, onMounted, watch, customRef, onUpdated, readonly, reactive, hasInjectionContext, toRaw, nextTick, markRaw, getCurrentScope, isReadonly, onBeforeUpdate } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/vue/dist/vue.runtime.esm-bundler.js?v=1214a853";
function computedAsync(evaluationCallback, initialState, optionsOrRef) {
  let options;
  if (isRef(optionsOrRef)) {
    options = {
      evaluating: optionsOrRef
    };
  } else {
    options = optionsOrRef || {};
  }
  const {
    lazy = false,
    flush = "pre",
    evaluating = void 0,
    shallow = true,
    onError = noop
  } = options;
  const started = shallowRef(!lazy);
  const current = shallow ? shallowRef(initialState) : ref(initialState);
  let counter = 0;
  watchEffect(async (onInvalidate) => {
    if (!started.value)
      return;
    counter++;
    const counterAtBeginning = counter;
    let hasFinished = false;
    if (evaluating) {
      Promise.resolve().then(() => {
        evaluating.value = true;
      });
    }
    try {
      const result = await evaluationCallback((cancelCallback) => {
        onInvalidate(() => {
          if (evaluating)
            evaluating.value = false;
          if (!hasFinished)
            cancelCallback();
        });
      });
      if (counterAtBeginning === counter)
        current.value = result;
    } catch (e) {
      onError(e);
    } finally {
      if (evaluating && counterAtBeginning === counter)
        evaluating.value = false;
      hasFinished = true;
    }
  }, { flush });
  if (lazy) {
    return computed(() => {
      started.value = true;
      return current.value;
    });
  } else {
    return current;
  }
}
function computedInject(key, options, defaultSource, treatDefaultAsFactory) {
  let source = inject(key);
  if (defaultSource)
    source = inject(key, defaultSource);
  if (treatDefaultAsFactory)
    source = inject(key, defaultSource, treatDefaultAsFactory);
  if (typeof options === "function") {
    return computed((ctx) => options(source, ctx));
  } else {
    return computed({
      get: (ctx) => options.get(source, ctx),
      set: options.set
    });
  }
}
function createReusableTemplate(options = {}) {
  const {
    inheritAttrs = true
  } = options;
  const render = shallowRef();
  const define = /* @__PURE__ */ defineComponent({
    setup(_, { slots }) {
      return () => {
        render.value = slots.default;
      };
    }
  });
  const reuse = /* @__PURE__ */ defineComponent({
    inheritAttrs,
    props: options.props,
    setup(props, { attrs, slots }) {
      return () => {
        var _a;
        if (!render.value && true)
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, {
          ...options.props == null ? keysToCamelKebabCase(attrs) : props,
          $slots: slots
        });
        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;
      };
    }
  });
  return makeDestructurable(
    { define, reuse },
    [define, reuse]
  );
}
function keysToCamelKebabCase(obj) {
  const newObj = {};
  for (const key in obj)
    newObj[camelize(key)] = obj[key];
  return newObj;
}
function createTemplatePromise(options = {}) {
  let index = 0;
  const instances = ref([]);
  function create(...args) {
    const props = shallowReactive({
      key: index++,
      args,
      promise: void 0,
      resolve: () => {
      },
      reject: () => {
      },
      isResolving: false,
      options
    });
    instances.value.push(props);
    props.promise = new Promise((_resolve, _reject) => {
      props.resolve = (v) => {
        props.isResolving = true;
        return _resolve(v);
      };
      props.reject = _reject;
    }).finally(() => {
      props.promise = void 0;
      const index2 = instances.value.indexOf(props);
      if (index2 !== -1)
        instances.value.splice(index2, 1);
    });
    return props.promise;
  }
  function start(...args) {
    if (options.singleton && instances.value.length > 0)
      return instances.value[0].promise;
    return create(...args);
  }
  const component = /* @__PURE__ */ defineComponent((_, { slots }) => {
    const renderList = () => instances.value.map((props) => {
      var _a;
      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));
    });
    if (options.transition)
      return () => h(TransitionGroup, options.transition, renderList);
    return renderList;
  });
  component.start = start;
  return component;
}
function createUnrefFn(fn) {
  return function(...args) {
    return fn.apply(this, args.map((i) => toValue(i)));
  };
}
const defaultWindow = isClient ? window : void 0;
const defaultDocument = isClient ? window.document : void 0;
const defaultNavigator = isClient ? window.navigator : void 0;
const defaultLocation = isClient ? window.location : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test = toArray(toValue(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(cleanup);
  return stop;
}
let _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;
  if (!window2) {
    return controls ? { stop: noop, cancel: noop, trigger: noop } : noop;
  }
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    const listenerOptions = { passive: true };
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop, listenerOptions));
    window2.document.documentElement.addEventListener("click", noop, listenerOptions);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return toValue(ignore).some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  function hasMultipleRoots(target2) {
    const vm = toValue(target2);
    return vm && vm.$.subTree.shapeFlag === 16;
  }
  function checkMultipleRoots(target2, event) {
    const vm = toValue(target2);
    const children = vm.$.subTree && vm.$.subTree.children;
    if (children == null || !Array.isArray(children))
      return false;
    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
  }
  const listener = (event) => {
    const el = unrefElement(target);
    if (event.target == null)
      return;
    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))
      return;
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if ("detail" in event && event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  let isProcessingClick = false;
  const cleanup = [
    useEventListener(window2, "click", (event) => {
      if (!isProcessingClick) {
        isProcessingClick = true;
        setTimeout(() => {
          isProcessingClick = false;
        }, 0);
        listener(event);
      }
    }, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
          handler(event);
        }
      }, 0);
    }, { passive: true })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  if (controls) {
    return {
      stop,
      cancel: () => {
        shouldListen = false;
      },
      trigger: (event) => {
        shouldListen = true;
        listener(event);
        shouldListen = false;
      }
    };
  }
  return stop;
}
function useMounted() {
  const isMounted = shallowRef(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const value = toValue(target);
    const items = toArray(value).map(unrefElement).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function onElementRemoval(target, callback, options = {}) {
  const {
    window: window2 = defaultWindow,
    document: document2 = window2 == null ? void 0 : window2.document,
    flush = "sync"
  } = options;
  if (!window2 || !document2)
    return noop;
  let stopFn;
  const cleanupAndUpdate = (fn) => {
    stopFn == null ? void 0 : stopFn();
    stopFn = fn;
  };
  const stopWatch = watchEffect(() => {
    const el = unrefElement(target);
    if (el) {
      const { stop } = useMutationObserver(
        document2,
        (mutationsList) => {
          const targetRemoved = mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el));
          if (targetRemoved) {
            callback(mutationsList);
          }
        },
        {
          window: window2,
          childList: true,
          subtree: true
        }
      );
      cleanupAndUpdate(stop);
    }
  }, { flush });
  const stopHandle = () => {
    stopWatch();
    cleanupAndUpdate();
  };
  tryOnScopeDispose(stopHandle);
  return stopHandle;
}
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (e.repeat && toValue(dedupe))
      return;
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive);
}
function onKeyDown(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keydown" });
}
function onKeyPressed(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keypress" });
}
function onKeyUp(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keyup" });
}
const DEFAULT_DELAY = 500;
const DEFAULT_THRESHOLD = 10;
function onLongPress(target, handler, options) {
  var _a, _b;
  const elementRef = computed(() => unrefElement(target));
  let timeout;
  let posStart;
  let startTimestamp;
  let hasLongPressed = false;
  function clear() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    posStart = void 0;
    startTimestamp = void 0;
    hasLongPressed = false;
  }
  function onRelease(ev) {
    var _a2, _b2, _c;
    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];
    clear();
    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)
      return;
    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)
      return;
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    const dx = ev.x - _posStart.x;
    const dy = ev.y - _posStart.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);
  }
  function onDown(ev) {
    var _a2, _b2, _c, _d;
    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)
      return;
    clear();
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    posStart = {
      x: ev.x,
      y: ev.y
    };
    startTimestamp = ev.timeStamp;
    timeout = setTimeout(
      () => {
        hasLongPressed = true;
        handler(ev);
      },
      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY
    );
  }
  function onMove(ev) {
    var _a2, _b2, _c, _d;
    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)
      return;
    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)
      return;
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    const dx = ev.x - posStart.x;
    const dy = ev.y - posStart.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))
      clear();
  }
  const listenerOptions = {
    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,
    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once
  };
  const cleanup = [
    useEventListener(elementRef, "pointerdown", onDown, listenerOptions),
    useEventListener(elementRef, "pointermove", onMove, listenerOptions),
    useEventListener(elementRef, ["pointerup", "pointerleave"], onRelease, listenerOptions)
  ];
  const stop = () => cleanup.forEach((fn) => fn());
  return stop;
}
function isFocusedElementEditable() {
  const { activeElement, body } = document;
  if (!activeElement)
    return false;
  if (activeElement === body)
    return false;
  switch (activeElement.tagName) {
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return activeElement.hasAttribute("contenteditable");
}
function isTypedCharValid({
  keyCode,
  metaKey,
  ctrlKey,
  altKey
}) {
  if (metaKey || ctrlKey || altKey)
    return false;
  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)
    return true;
  if (keyCode >= 65 && keyCode <= 90)
    return true;
  return false;
}
function onStartTyping(callback, options = {}) {
  const { document: document2 = defaultDocument } = options;
  const keydown = (event) => {
    if (!isFocusedElementEditable() && isTypedCharValid(event)) {
      callback(event);
    }
  };
  if (document2)
    useEventListener(document2, "keydown", keydown, { passive: true });
}
function templateRef(key, initialValue = null) {
  const instance = getCurrentInstance();
  let _trigger = () => {
  };
  const element = customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        var _a, _b;
        track();
        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;
      },
      set() {
      }
    };
  });
  tryOnMounted(_trigger);
  onUpdated(_trigger);
  return element;
}
function useActiveElement(options = {}) {
  var _a;
  const {
    window: window2 = defaultWindow,
    deep = true,
    triggerOnRemoval = false
  } = options;
  const document2 = (_a = options.document) != null ? _a : window2 == null ? void 0 : window2.document;
  const getDeepActiveElement = () => {
    var _a2;
    let element = document2 == null ? void 0 : document2.activeElement;
    if (deep) {
      while (element == null ? void 0 : element.shadowRoot)
        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
    }
    return element;
  };
  const activeElement = shallowRef();
  const trigger = () => {
    activeElement.value = getDeepActiveElement();
  };
  if (window2) {
    const listenerOptions = {
      capture: true,
      passive: true
    };
    useEventListener(
      window2,
      "blur",
      (event) => {
        if (event.relatedTarget !== null)
          return;
        trigger();
      },
      listenerOptions
    );
    useEventListener(
      window2,
      "focus",
      trigger,
      listenerOptions
    );
  }
  if (triggerOnRemoval) {
    onElementRemoval(activeElement, trigger, { document: document2 });
  }
  trigger();
  return activeElement;
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow,
    once = false
  } = options;
  const isActive = shallowRef(false);
  const intervalLimit = computed(() => {
    return fpsLimit ? 1e3 / toValue(fpsLimit) : null;
  });
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit.value && delta < intervalLimit.value) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    if (once) {
      isActive.value = false;
      rafId = null;
      return;
    }
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
function useAnimate(target, keyframes, options) {
  let config;
  let animateOptions;
  if (isObject(options)) {
    config = options;
    animateOptions = objectOmit(options, ["window", "immediate", "commitStyles", "persist", "onReady", "onError"]);
  } else {
    config = { duration: options };
    animateOptions = options;
  }
  const {
    window: window2 = defaultWindow,
    immediate = true,
    commitStyles,
    persist,
    playbackRate: _playbackRate = 1,
    onReady,
    onError = (e) => {
      console.error(e);
    }
  } = config;
  const isSupported = useSupported(() => window2 && HTMLElement && "animate" in HTMLElement.prototype);
  const animate = shallowRef(void 0);
  const store = shallowReactive({
    startTime: null,
    currentTime: null,
    timeline: null,
    playbackRate: _playbackRate,
    pending: false,
    playState: immediate ? "idle" : "paused",
    replaceState: "active"
  });
  const pending = computed(() => store.pending);
  const playState = computed(() => store.playState);
  const replaceState = computed(() => store.replaceState);
  const startTime = computed({
    get() {
      return store.startTime;
    },
    set(value) {
      store.startTime = value;
      if (animate.value)
        animate.value.startTime = value;
    }
  });
  const currentTime = computed({
    get() {
      return store.currentTime;
    },
    set(value) {
      store.currentTime = value;
      if (animate.value) {
        animate.value.currentTime = value;
        syncResume();
      }
    }
  });
  const timeline = computed({
    get() {
      return store.timeline;
    },
    set(value) {
      store.timeline = value;
      if (animate.value)
        animate.value.timeline = value;
    }
  });
  const playbackRate = computed({
    get() {
      return store.playbackRate;
    },
    set(value) {
      store.playbackRate = value;
      if (animate.value)
        animate.value.playbackRate = value;
    }
  });
  const play = () => {
    if (animate.value) {
      try {
        animate.value.play();
        syncResume();
      } catch (e) {
        syncPause();
        onError(e);
      }
    } else {
      update();
    }
  };
  const pause = () => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.pause();
      syncPause();
    } catch (e) {
      onError(e);
    }
  };
  const reverse = () => {
    var _a;
    if (!animate.value)
      update();
    try {
      (_a = animate.value) == null ? void 0 : _a.reverse();
      syncResume();
    } catch (e) {
      syncPause();
      onError(e);
    }
  };
  const finish = () => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.finish();
      syncPause();
    } catch (e) {
      onError(e);
    }
  };
  const cancel = () => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.cancel();
      syncPause();
    } catch (e) {
      onError(e);
    }
  };
  watch(() => unrefElement(target), (el) => {
    if (el) {
      update();
    } else {
      animate.value = void 0;
    }
  });
  watch(() => keyframes, (value) => {
    if (animate.value) {
      update();
      const targetEl = unrefElement(target);
      if (targetEl) {
        animate.value.effect = new KeyframeEffect(
          targetEl,
          toValue(value),
          animateOptions
        );
      }
    }
  }, { deep: true });
  tryOnMounted(() => update(true), false);
  tryOnScopeDispose(cancel);
  function update(init) {
    const el = unrefElement(target);
    if (!isSupported.value || !el)
      return;
    if (!animate.value)
      animate.value = el.animate(toValue(keyframes), animateOptions);
    if (persist)
      animate.value.persist();
    if (_playbackRate !== 1)
      animate.value.playbackRate = _playbackRate;
    if (init && !immediate)
      animate.value.pause();
    else
      syncResume();
    onReady == null ? void 0 : onReady(animate.value);
  }
  const listenerOptions = { passive: true };
  useEventListener(animate, ["cancel", "finish", "remove"], syncPause, listenerOptions);
  useEventListener(animate, "finish", () => {
    var _a;
    if (commitStyles)
      (_a = animate.value) == null ? void 0 : _a.commitStyles();
  }, listenerOptions);
  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {
    if (!animate.value)
      return;
    store.pending = animate.value.pending;
    store.playState = animate.value.playState;
    store.replaceState = animate.value.replaceState;
    store.startTime = animate.value.startTime;
    store.currentTime = animate.value.currentTime;
    store.timeline = animate.value.timeline;
    store.playbackRate = animate.value.playbackRate;
  }, { immediate: false });
  function syncResume() {
    if (isSupported.value)
      resumeRef();
  }
  function syncPause() {
    if (isSupported.value && window2)
      window2.requestAnimationFrame(pauseRef);
  }
  return {
    isSupported,
    animate,
    // actions
    play,
    pause,
    reverse,
    finish,
    cancel,
    // state
    pending,
    playState,
    replaceState,
    startTime,
    currentTime,
    timeline,
    playbackRate
  };
}
function useAsyncQueue(tasks, options) {
  const {
    interrupt = true,
    onError = noop,
    onFinished = noop,
    signal
  } = options || {};
  const promiseState = {
    aborted: "aborted",
    fulfilled: "fulfilled",
    pending: "pending",
    rejected: "rejected"
  };
  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));
  const result = reactive(initialResult);
  const activeIndex = shallowRef(-1);
  if (!tasks || tasks.length === 0) {
    onFinished();
    return {
      activeIndex,
      result
    };
  }
  function updateResult(state, res) {
    activeIndex.value++;
    result[activeIndex.value].data = res;
    result[activeIndex.value].state = state;
  }
  tasks.reduce((prev, curr) => {
    return prev.then((prevRes) => {
      var _a;
      if (signal == null ? void 0 : signal.aborted) {
        updateResult(promiseState.aborted, new Error("aborted"));
        return;
      }
      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {
        onFinished();
        return;
      }
      const done = curr(prevRes).then((currentRes) => {
        updateResult(promiseState.fulfilled, currentRes);
        if (activeIndex.value === tasks.length - 1)
          onFinished();
        return currentRes;
      });
      if (!signal)
        return done;
      return Promise.race([done, whenAborted(signal)]);
    }).catch((e) => {
      if (signal == null ? void 0 : signal.aborted) {
        updateResult(promiseState.aborted, e);
        return e;
      }
      updateResult(promiseState.rejected, e);
      onError();
      return e;
    });
  }, Promise.resolve());
  return {
    activeIndex,
    result
  };
}
function whenAborted(signal) {
  return new Promise((resolve, reject) => {
    const error = new Error("aborted");
    if (signal.aborted)
      reject(error);
    else
      signal.addEventListener("abort", () => reject(error), { once: true });
  });
}
function useAsyncState(promise, initialState, options) {
  const {
    immediate = true,
    delay = 0,
    onError = noop,
    onSuccess = noop,
    resetOnExecute = true,
    shallow = true,
    throwError
  } = options != null ? options : {};
  const state = shallow ? shallowRef(initialState) : ref(initialState);
  const isReady = shallowRef(false);
  const isLoading = shallowRef(false);
  const error = shallowRef(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      state.value = initialState;
    error.value = void 0;
    isReady.value = false;
    isLoading.value = true;
    if (delay2 > 0)
      await promiseTimeout(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data = await _promise;
      state.value = data;
      isReady.value = true;
      onSuccess(data);
    } catch (e) {
      error.value = e;
      onError(e);
      if (throwError)
        throw e;
    } finally {
      isLoading.value = false;
    }
    return state.value;
  }
  if (immediate) {
    execute(delay);
  }
  const shell = {
    state,
    isReady,
    isLoading,
    error,
    execute,
    executeImmediate: (...args) => execute(0, ...args)
  };
  function waitUntilIsLoaded() {
    return new Promise((resolve, reject) => {
      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);
    });
  }
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilIsLoaded().then(onFulfilled, onRejected);
    }
  };
}
const defaults = {
  array: (v) => JSON.stringify(v),
  object: (v) => JSON.stringify(v),
  set: (v) => JSON.stringify(Array.from(v)),
  map: (v) => JSON.stringify(Object.fromEntries(v)),
  null: () => ""
};
function getDefaultSerialization(target) {
  if (!target)
    return defaults.null;
  if (target instanceof Map)
    return defaults.map;
  else if (target instanceof Set)
    return defaults.set;
  else if (Array.isArray(target))
    return defaults.array;
  else
    return defaults.object;
}
function useBase64(target, options) {
  const base64 = shallowRef("");
  const promise = shallowRef();
  function execute() {
    if (!isClient)
      return;
    promise.value = new Promise((resolve, reject) => {
      try {
        const _target = toValue(target);
        if (_target == null) {
          resolve("");
        } else if (typeof _target === "string") {
          resolve(blobToBase64(new Blob([_target], { type: "text/plain" })));
        } else if (_target instanceof Blob) {
          resolve(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
          }).catch(reject);
        } else if (typeof _target === "object") {
          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);
          const serialized = _serializeFn(_target);
          return resolve(blobToBase64(new Blob([serialized], { type: "application/json" })));
        } else {
          reject(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject(error);
      }
    });
    promise.value.then((res) => {
      base64.value = (options == null ? void 0 : options.dataUrl) === false ? res.replace(/^data:.*?;base64,/, "") : res;
    });
    return promise.value;
  }
  if (isRef(target) || typeof target === "function")
    watch(target, execute, { immediate: true });
  else
    execute();
  return {
    base64,
    promise,
    execute
  };
}
function imgLoaded(img) {
  return new Promise((resolve, reject) => {
    if (!img.complete) {
      img.onload = () => {
        resolve();
      };
      img.onerror = reject;
    } else {
      resolve();
    }
  });
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = (e) => {
      resolve(e.target.result);
    };
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
function useBattery(options = {}) {
  const { navigator: navigator2 = defaultNavigator } = options;
  const events2 = ["chargingchange", "chargingtimechange", "dischargingtimechange", "levelchange"];
  const isSupported = useSupported(() => navigator2 && "getBattery" in navigator2 && typeof navigator2.getBattery === "function");
  const charging = shallowRef(false);
  const chargingTime = shallowRef(0);
  const dischargingTime = shallowRef(0);
  const level = shallowRef(1);
  let battery;
  function updateBatteryInfo() {
    charging.value = this.charging;
    chargingTime.value = this.chargingTime || 0;
    dischargingTime.value = this.dischargingTime || 0;
    level.value = this.level;
  }
  if (isSupported.value) {
    navigator2.getBattery().then((_battery) => {
      battery = _battery;
      updateBatteryInfo.call(battery);
      useEventListener(battery, events2, updateBatteryInfo, { passive: true });
    });
  }
  return {
    isSupported,
    charging,
    chargingTime,
    dischargingTime,
    level
  };
}
function useBluetooth(options) {
  let {
    acceptAllDevices = false
  } = options || {};
  const {
    filters = void 0,
    optionalServices = void 0,
    navigator: navigator2 = defaultNavigator
  } = options || {};
  const isSupported = useSupported(() => navigator2 && "bluetooth" in navigator2);
  const device = shallowRef();
  const error = shallowRef(null);
  watch(device, () => {
    connectToBluetoothGATTServer();
  });
  async function requestDevice() {
    if (!isSupported.value)
      return;
    error.value = null;
    if (filters && filters.length > 0)
      acceptAllDevices = false;
    try {
      device.value = await (navigator2 == null ? void 0 : navigator2.bluetooth.requestDevice({
        acceptAllDevices,
        filters,
        optionalServices
      }));
    } catch (err) {
      error.value = err;
    }
  }
  const server = shallowRef();
  const isConnected = shallowRef(false);
  function reset() {
    isConnected.value = false;
    device.value = void 0;
    server.value = void 0;
  }
  async function connectToBluetoothGATTServer() {
    error.value = null;
    if (device.value && device.value.gatt) {
      useEventListener(device, "gattserverdisconnected", reset, { passive: true });
      try {
        server.value = await device.value.gatt.connect();
        isConnected.value = server.value.connected;
      } catch (err) {
        error.value = err;
      }
    }
  }
  tryOnMounted(() => {
    var _a;
    if (device.value)
      (_a = device.value.gatt) == null ? void 0 : _a.connect();
  });
  tryOnScopeDispose(() => {
    var _a;
    if (device.value)
      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();
  });
  return {
    isSupported,
    isConnected: readonly(isConnected),
    // Device:
    device,
    requestDevice,
    // Server:
    server,
    // Errors:
    error
  };
}
const ssrWidthSymbol = Symbol("vueuse-ssr-width");
function useSSRWidth() {
  const ssrWidth = hasInjectionContext() ? injectLocal(ssrWidthSymbol, null) : null;
  return typeof ssrWidth === "number" ? ssrWidth : void 0;
}
function provideSSRWidth(width, app) {
  if (app !== void 0) {
    app.provide(ssrWidthSymbol, width);
  } else {
    provideLocal(ssrWidthSymbol, width);
  }
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow, ssrWidth = useSSRWidth() } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  const ssrSupport = shallowRef(typeof ssrWidth === "number");
  const mediaQuery = shallowRef();
  const matches = shallowRef(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  watchEffect(() => {
    if (ssrSupport.value) {
      ssrSupport.value = !isSupported.value;
      const queryStrings = toValue(query).split(",");
      matches.value = queryStrings.some((queryString) => {
        const not = queryString.includes("not all");
        const minWidth = queryString.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        const maxWidth = queryString.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let res = Boolean(minWidth || maxWidth);
        if (minWidth && res) {
          res = ssrWidth >= pxValue(minWidth[1]);
        }
        if (maxWidth && res) {
          res = ssrWidth <= pxValue(maxWidth[1]);
        }
        return not ? !res : res;
      });
      return;
    }
    if (!isSupported.value)
      return;
    mediaQuery.value = window2.matchMedia(toValue(query));
    matches.value = mediaQuery.value.matches;
  });
  useEventListener(mediaQuery, "change", handler, { passive: true });
  return computed(() => matches.value);
}
const breakpointsTailwind = {
  "sm": 640,
  "md": 768,
  "lg": 1024,
  "xl": 1280,
  "2xl": 1536
};
const breakpointsBootstrapV5 = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
const breakpointsVuetifyV2 = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1264,
  xl: 1904
};
const breakpointsVuetifyV3 = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1280,
  xl: 1920,
  xxl: 2560
};
const breakpointsVuetify = breakpointsVuetifyV2;
const breakpointsAntDesign = {
  xs: 480,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1600
};
const breakpointsQuasar = {
  xs: 0,
  sm: 600,
  md: 1024,
  lg: 1440,
  xl: 1920
};
const breakpointsSematic = {
  mobileS: 320,
  mobileM: 375,
  mobileL: 425,
  tablet: 768,
  laptop: 1024,
  laptopL: 1440,
  desktop4K: 2560
};
const breakpointsMasterCss = {
  "3xs": 360,
  "2xs": 480,
  "xs": 600,
  "sm": 768,
  "md": 1024,
  "lg": 1280,
  "xl": 1440,
  "2xl": 1600,
  "3xl": 1920,
  "4xl": 2560
};
const breakpointsPrimeFlex = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
const breakpointsElement = {
  xs: 0,
  sm: 768,
  md: 992,
  lg: 1200,
  xl: 1920
};
function useBreakpoints(breakpoints, options = {}) {
  function getValue2(k, delta) {
    let v = toValue(breakpoints[toValue(k)]);
    if (delta != null)
      v = increaseWithUnit(v, delta);
    if (typeof v === "number")
      v = `${v}px`;
    return v;
  }
  const { window: window2 = defaultWindow, strategy = "min-width", ssrWidth = useSSRWidth() } = options;
  const ssrSupport = typeof ssrWidth === "number";
  const mounted = ssrSupport ? shallowRef(false) : { value: true };
  if (ssrSupport) {
    tryOnMounted(() => mounted.value = !!window2);
  }
  function match(query, size) {
    if (!mounted.value && ssrSupport) {
      return query === "min" ? ssrWidth >= pxValue(size) : ssrWidth <= pxValue(size);
    }
    if (!window2)
      return false;
    return window2.matchMedia(`(${query}-width: ${size})`).matches;
  }
  const greaterOrEqual = (k) => {
    return useMediaQuery(() => `(min-width: ${getValue2(k)})`, options);
  };
  const smallerOrEqual = (k) => {
    return useMediaQuery(() => `(max-width: ${getValue2(k)})`, options);
  };
  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      get: () => strategy === "min-width" ? greaterOrEqual(k) : smallerOrEqual(k),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  function current() {
    const points = Object.keys(breakpoints).map((k) => [k, shortcutMethods[k], pxValue(getValue2(k))]).sort((a, b) => a[2] - b[2]);
    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));
  }
  return Object.assign(shortcutMethods, {
    greaterOrEqual,
    smallerOrEqual,
    greater(k) {
      return useMediaQuery(() => `(min-width: ${getValue2(k, 0.1)})`, options);
    },
    smaller(k) {
      return useMediaQuery(() => `(max-width: ${getValue2(k, -0.1)})`, options);
    },
    between(a, b) {
      return useMediaQuery(() => `(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`, options);
    },
    isGreater(k) {
      return match("min", getValue2(k, 0.1));
    },
    isGreaterOrEqual(k) {
      return match("min", getValue2(k));
    },
    isSmaller(k) {
      return match("max", getValue2(k, -0.1));
    },
    isSmallerOrEqual(k) {
      return match("max", getValue2(k));
    },
    isInBetween(a, b) {
      return match("min", getValue2(a)) && match("max", getValue2(b, -0.1));
    },
    current,
    active() {
      const bps = current();
      return computed(() => bps.value.length === 0 ? "" : bps.value.at(strategy === "min-width" ? -1 : 0));
    }
  });
}
function useBroadcastChannel(options) {
  const {
    name,
    window: window2 = defaultWindow
  } = options;
  const isSupported = useSupported(() => window2 && "BroadcastChannel" in window2);
  const isClosed = shallowRef(false);
  const channel = ref();
  const data = ref();
  const error = shallowRef(null);
  const post = (data2) => {
    if (channel.value)
      channel.value.postMessage(data2);
  };
  const close = () => {
    if (channel.value)
      channel.value.close();
    isClosed.value = true;
  };
  if (isSupported.value) {
    tryOnMounted(() => {
      error.value = null;
      channel.value = new BroadcastChannel(name);
      const listenerOptions = {
        passive: true
      };
      useEventListener(channel, "message", (e) => {
        data.value = e.data;
      }, listenerOptions);
      useEventListener(channel, "messageerror", (e) => {
        error.value = e;
      }, listenerOptions);
      useEventListener(channel, "close", () => {
        isClosed.value = true;
      }, listenerOptions);
    });
  }
  tryOnScopeDispose(() => {
    close();
  });
  return {
    isSupported,
    channel,
    data,
    post,
    close,
    error,
    isClosed
  };
}
const WRITABLE_PROPERTIES = [
  "hash",
  "host",
  "hostname",
  "href",
  "pathname",
  "port",
  "protocol",
  "search"
];
function useBrowserLocation(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const refs = Object.fromEntries(
    WRITABLE_PROPERTIES.map((key) => [key, ref()])
  );
  for (const [key, ref2] of objectEntries(refs)) {
    watch(ref2, (value) => {
      if (!(window2 == null ? void 0 : window2.location) || window2.location[key] === value)
        return;
      window2.location[key] = value;
    });
  }
  const buildState = (trigger) => {
    var _a;
    const { state: state2, length } = (window2 == null ? void 0 : window2.history) || {};
    const { origin } = (window2 == null ? void 0 : window2.location) || {};
    for (const key of WRITABLE_PROPERTIES)
      refs[key].value = (_a = window2 == null ? void 0 : window2.location) == null ? void 0 : _a[key];
    return reactive({
      trigger,
      state: state2,
      length,
      origin,
      ...refs
    });
  };
  const state = ref(buildState("load"));
  if (window2) {
    const listenerOptions = { passive: true };
    useEventListener(window2, "popstate", () => state.value = buildState("popstate"), listenerOptions);
    useEventListener(window2, "hashchange", () => state.value = buildState("hashchange"), listenerOptions);
  }
  return state;
}
function useCached(refValue, comparator = (a, b) => a === b, options) {
  const { deepRefs = true, ...watchOptions } = options || {};
  const cachedValue = createRef(refValue.value, deepRefs);
  watch(() => refValue.value, (value) => {
    if (!comparator(value, cachedValue.value))
      cachedValue.value = value;
  }, watchOptions);
  return cachedValue;
}
function usePermission(permissionDesc, options = {}) {
  const {
    controls = false,
    navigator: navigator2 = defaultNavigator
  } = options;
  const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
  const permissionStatus = shallowRef();
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const state = shallowRef();
  const update = () => {
    var _a, _b;
    state.value = (_b = (_a = permissionStatus.value) == null ? void 0 : _a.state) != null ? _b : "prompt";
  };
  useEventListener(permissionStatus, "change", update, { passive: true });
  const query = createSingletonPromise(async () => {
    if (!isSupported.value)
      return;
    if (!permissionStatus.value) {
      try {
        permissionStatus.value = await navigator2.permissions.query(desc);
      } catch (e) {
        permissionStatus.value = void 0;
      } finally {
        update();
      }
    }
    if (controls)
      return toRaw(permissionStatus.value);
  });
  query();
  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  } else {
    return state;
  }
}
function useClipboard(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500,
    legacy = false
  } = options;
  const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
  const permissionRead = usePermission("clipboard-read");
  const permissionWrite = usePermission("clipboard-write");
  const isSupported = computed(() => isClipboardApiSupported.value || legacy);
  const text = shallowRef("");
  const copied = shallowRef(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });
  async function updateText() {
    let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionRead.value));
    if (!useLegacy) {
      try {
        text.value = await navigator2.clipboard.readText();
      } catch (e) {
        useLegacy = true;
      }
    }
    if (useLegacy) {
      text.value = legacyRead();
    }
  }
  if (isSupported.value && read)
    useEventListener(["copy", "cut"], updateText, { passive: true });
  async function copy(value = toValue(source)) {
    if (isSupported.value && value != null) {
      let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionWrite.value));
      if (!useLegacy) {
        try {
          await navigator2.clipboard.writeText(value);
        } catch (e) {
          useLegacy = true;
        }
      }
      if (useLegacy)
        legacyCopy(value);
      text.value = value;
      copied.value = true;
      timeout.start();
    }
  }
  function legacyCopy(value) {
    const ta = document.createElement("textarea");
    ta.value = value != null ? value : "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  function legacyRead() {
    var _a, _b, _c;
    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
  }
  function isAllowed(status) {
    return status === "granted" || status === "prompt";
  }
  return {
    isSupported,
    text,
    copied,
    copy
  };
}
function useClipboardItems(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500
  } = options;
  const isSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
  const content = ref([]);
  const copied = shallowRef(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });
  function updateContent() {
    if (isSupported.value) {
      navigator2.clipboard.read().then((items) => {
        content.value = items;
      });
    }
  }
  if (isSupported.value && read)
    useEventListener(["copy", "cut"], updateContent, { passive: true });
  async function copy(value = toValue(source)) {
    if (isSupported.value && value != null) {
      await navigator2.clipboard.write(value);
      content.value = value;
      copied.value = true;
      timeout.start();
    }
  }
  return {
    isSupported,
    content,
    copied,
    copy
  };
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
function useCloned(source, options = {}) {
  const cloned = ref({});
  const isModified = shallowRef(false);
  let _lastSync = false;
  const {
    manual,
    clone = cloneFnJSON,
    // watch options
    deep = true,
    immediate = true
  } = options;
  watch(cloned, () => {
    if (_lastSync) {
      _lastSync = false;
      return;
    }
    isModified.value = true;
  }, {
    deep: true,
    flush: "sync"
  });
  function sync() {
    _lastSync = true;
    isModified.value = false;
    cloned.value = clone(toValue(source));
  }
  if (!manual && (isRef(source) || typeof source === "function")) {
    watch(source, sync, {
      ...options,
      deep,
      immediate
    });
  } else {
    sync();
  }
  return { cloned, isModified, sync };
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function setSSRHandler(key, fn) {
  handlers[key] = fn;
}
function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => Number.parseFloat(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    },
    initOnMounted
  } = options;
  const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
  const keyComputed = computed(() => toValue(key));
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data;
  const rawInit = toValue(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(
    data,
    () => write(data.value),
    { flush, deep, eventFilter }
  );
  watch(keyComputed, () => update(), { flush });
  let firstMounted = false;
  const onStorageEvent = (ev) => {
    if (initOnMounted && !firstMounted) {
      return;
    }
    update(ev);
  };
  const onStorageCustomEvent = (ev) => {
    if (initOnMounted && !firstMounted) {
      return;
    }
    updateFromCustomEvent(ev);
  };
  if (window2 && listenToStorageChanges) {
    if (storage instanceof Storage)
      useEventListener(window2, "storage", onStorageEvent, { passive: true });
    else
      useEventListener(window2, customStorageEventName, onStorageCustomEvent);
  }
  if (initOnMounted) {
    tryOnMounted(() => {
      firstMounted = true;
      update();
    });
  } else {
    update();
  }
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2) {
      const payload = {
        key: keyComputed.value,
        oldValue,
        newValue,
        storageArea: storage
      };
      window2.dispatchEvent(storage instanceof Storage ? new StorageEvent("storage", payload) : new CustomEvent(customStorageEventName, {
        detail: payload
      }));
    }
  }
  function write(v) {
    try {
      const oldValue = storage.getItem(keyComputed.value);
      if (v == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(keyComputed.value);
      } else {
        const serialized = serializer.write(v);
        if (oldValue !== serialized) {
          storage.setItem(keyComputed.value, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(keyComputed.value);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage.setItem(keyComputed.value, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value, rawInit);
      else if (type === "object" && !Array.isArray(value))
        return { ...rawInit, ...value };
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== keyComputed.value)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
        data.value = read(event);
    } catch (e) {
      onError(e);
    } finally {
      if (event)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  return data;
}
const CSS_DISABLE_TRANS = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function useColorMode(options = {}) {
  const {
    selector = "html",
    attribute = "class",
    initialValue = "auto",
    window: window2 = defaultWindow,
    storage,
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef,
    emitAuto,
    disableTransition = true
  } = options;
  const modes = {
    auto: "",
    light: "light",
    dark: "dark",
    ...options.modes || {}
  };
  const preferredDark = usePreferredDark({ window: window2 });
  const system = computed(() => preferredDark.value ? "dark" : "light");
  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
  const state = computed(() => store.value === "auto" ? system.value : store.value);
  const updateHTMLAttrs = getSSRHandler(
    "updateHTMLAttrs",
    (selector2, attribute2, value) => {
      const el = typeof selector2 === "string" ? window2 == null ? void 0 : window2.document.querySelector(selector2) : unrefElement(selector2);
      if (!el)
        return;
      const classesToAdd = /* @__PURE__ */ new Set();
      const classesToRemove = /* @__PURE__ */ new Set();
      let attributeToChange = null;
      if (attribute2 === "class") {
        const current = value.split(/\s/g);
        Object.values(modes).flatMap((i) => (i || "").split(/\s/g)).filter(Boolean).forEach((v) => {
          if (current.includes(v))
            classesToAdd.add(v);
          else
            classesToRemove.add(v);
        });
      } else {
        attributeToChange = { key: attribute2, value };
      }
      if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)
        return;
      let style;
      if (disableTransition) {
        style = window2.document.createElement("style");
        style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));
        window2.document.head.appendChild(style);
      }
      for (const c of classesToAdd) {
        el.classList.add(c);
      }
      for (const c of classesToRemove) {
        el.classList.remove(c);
      }
      if (attributeToChange) {
        el.setAttribute(attributeToChange.key, attributeToChange.value);
      }
      if (disableTransition) {
        window2.getComputedStyle(style).opacity;
        document.head.removeChild(style);
      }
    }
  );
  function defaultOnChanged(mode) {
    var _a;
    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);
  }
  function onChanged(mode) {
    if (options.onChanged)
      options.onChanged(mode, defaultOnChanged);
    else
      defaultOnChanged(mode);
  }
  watch(state, onChanged, { flush: "post", immediate: true });
  tryOnMounted(() => onChanged(state.value));
  const auto = computed({
    get() {
      return emitAuto ? store.value : state.value;
    },
    set(v) {
      store.value = v;
    }
  });
  return Object.assign(auto, { store, system, state });
}
function useConfirmDialog(revealed = shallowRef(false)) {
  const confirmHook = createEventHook();
  const cancelHook = createEventHook();
  const revealHook = createEventHook();
  let _resolve = noop;
  const reveal = (data) => {
    revealHook.trigger(data);
    revealed.value = true;
    return new Promise((resolve) => {
      _resolve = resolve;
    });
  };
  const confirm = (data) => {
    revealed.value = false;
    confirmHook.trigger(data);
    _resolve({ data, isCanceled: false });
  };
  const cancel = (data) => {
    revealed.value = false;
    cancelHook.trigger(data);
    _resolve({ data, isCanceled: true });
  };
  return {
    isRevealed: computed(() => revealed.value),
    reveal,
    confirm,
    cancel,
    onReveal: revealHook.on,
    onConfirm: confirmHook.on,
    onCancel: cancelHook.on
  };
}
function useCountdown(initialCountdown, options) {
  var _a, _b;
  const remaining = shallowRef(toValue(initialCountdown));
  const intervalController = useIntervalFn(() => {
    var _a2, _b2;
    const value = remaining.value - 1;
    remaining.value = value < 0 ? 0 : value;
    (_a2 = options == null ? void 0 : options.onTick) == null ? void 0 : _a2.call(options);
    if (remaining.value <= 0) {
      intervalController.pause();
      (_b2 = options == null ? void 0 : options.onComplete) == null ? void 0 : _b2.call(options);
    }
  }, (_a = options == null ? void 0 : options.interval) != null ? _a : 1e3, { immediate: (_b = options == null ? void 0 : options.immediate) != null ? _b : false });
  const reset = (countdown) => {
    var _a2;
    remaining.value = (_a2 = toValue(countdown)) != null ? _a2 : toValue(initialCountdown);
  };
  const stop = () => {
    intervalController.pause();
    reset();
  };
  const resume = () => {
    if (!intervalController.isActive.value) {
      if (remaining.value > 0) {
        intervalController.resume();
      }
    }
  };
  const start = (countdown) => {
    reset(countdown);
    intervalController.resume();
  };
  return {
    remaining,
    reset,
    stop,
    start,
    pause: intervalController.pause,
    resume,
    isActive: intervalController.isActive
  };
}
function useCssVar(prop, target, options = {}) {
  const { window: window2 = defaultWindow, initialValue, observe = false } = options;
  const variable = shallowRef(initialValue);
  const elRef = computed(() => {
    var _a;
    return unrefElement(target) || ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
  });
  function updateCssVar() {
    var _a;
    const key = toValue(prop);
    const el = toValue(elRef);
    if (el && window2 && key) {
      const value = (_a = window2.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();
      variable.value = value || variable.value || initialValue;
    }
  }
  if (observe) {
    useMutationObserver(elRef, updateCssVar, {
      attributeFilter: ["style", "class"],
      window: window2
    });
  }
  watch(
    [elRef, () => toValue(prop)],
    (_, old) => {
      if (old[0] && old[1])
        old[0].style.removeProperty(old[1]);
      updateCssVar();
    },
    { immediate: true }
  );
  watch(
    [variable, elRef],
    ([val, el]) => {
      const raw_prop = toValue(prop);
      if ((el == null ? void 0 : el.style) && raw_prop) {
        if (val == null)
          el.style.removeProperty(raw_prop);
        else
          el.style.setProperty(raw_prop, val);
      }
    },
    { immediate: true }
  );
  return variable;
}
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance();
  const currentElement = computedWithControl(
    () => null,
    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el
  );
  onUpdated(currentElement.trigger);
  onMounted(currentElement.trigger);
  return currentElement;
}
function useCycleList(list, options) {
  const state = shallowRef(getInitialValue());
  const listRef = toRef(list);
  const index = computed({
    get() {
      var _a;
      const targetList = listRef.value;
      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);
      if (index2 < 0)
        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;
      return index2;
    },
    set(v) {
      set(v);
    }
  });
  function set(i) {
    const targetList = listRef.value;
    const length = targetList.length;
    const index2 = (i % length + length) % length;
    const value = targetList[index2];
    state.value = value;
    return value;
  }
  function shift(delta = 1) {
    return set(index.value + delta);
  }
  function next(n = 1) {
    return shift(n);
  }
  function prev(n = 1) {
    return shift(-n);
  }
  function getInitialValue() {
    var _a, _b;
    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;
  }
  watch(listRef, () => set(index.value));
  return {
    state,
    index,
    next,
    prev,
    go: set
  };
}
function useDark(options = {}) {
  const {
    valueDark = "dark",
    valueLight = ""
  } = options;
  const mode = useColorMode({
    ...options,
    onChanged: (mode2, defaultHandler) => {
      var _a;
      if (options.onChanged)
        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === "dark", defaultHandler, mode2);
      else
        defaultHandler(mode2);
    },
    modes: {
      dark: valueDark,
      light: valueLight
    }
  });
  const system = computed(() => mode.system.value);
  const isDark = computed({
    get() {
      return mode.value === "dark";
    },
    set(v) {
      const modeVal = v ? "dark" : "light";
      if (system.value === modeVal)
        mode.value = "auto";
      else
        mode.value = modeVal;
    }
  });
  return isDark;
}
function fnBypass(v) {
  return v;
}
function fnSetSource(source, value) {
  return source.value = value;
}
function defaultDump(clone) {
  return clone ? typeof clone === "function" ? clone : cloneFnJSON : fnBypass;
}
function defaultParse(clone) {
  return clone ? typeof clone === "function" ? clone : cloneFnJSON : fnBypass;
}
function useManualRefHistory(source, options = {}) {
  const {
    clone = false,
    dump = defaultDump(clone),
    parse = defaultParse(clone),
    setSource = fnSetSource
  } = options;
  function _createHistoryRecord() {
    return markRaw({
      snapshot: dump(source.value),
      timestamp: timestamp()
    });
  }
  const last = ref(_createHistoryRecord());
  const undoStack = ref([]);
  const redoStack = ref([]);
  const _setSource = (record) => {
    setSource(source, parse(record.snapshot));
    last.value = record;
  };
  const commit = () => {
    undoStack.value.unshift(last.value);
    last.value = _createHistoryRecord();
    if (options.capacity && undoStack.value.length > options.capacity)
      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);
    if (redoStack.value.length)
      redoStack.value.splice(0, redoStack.value.length);
  };
  const clear = () => {
    undoStack.value.splice(0, undoStack.value.length);
    redoStack.value.splice(0, redoStack.value.length);
  };
  const undo = () => {
    const state = undoStack.value.shift();
    if (state) {
      redoStack.value.unshift(last.value);
      _setSource(state);
    }
  };
  const redo = () => {
    const state = redoStack.value.shift();
    if (state) {
      undoStack.value.unshift(last.value);
      _setSource(state);
    }
  };
  const reset = () => {
    _setSource(last.value);
  };
  const history = computed(() => [last.value, ...undoStack.value]);
  const canUndo = computed(() => undoStack.value.length > 0);
  const canRedo = computed(() => redoStack.value.length > 0);
  return {
    source,
    undoStack,
    redoStack,
    last,
    history,
    canUndo,
    canRedo,
    clear,
    commit,
    reset,
    undo,
    redo
  };
}
function useRefHistory(source, options = {}) {
  const {
    deep = false,
    flush = "pre",
    eventFilter,
    shouldCommit = () => true
  } = options;
  const {
    eventFilter: composedFilter,
    pause,
    resume: resumeTracking,
    isActive: isTracking
  } = pausableFilter(eventFilter);
  let lastRawValue = source.value;
  const {
    ignoreUpdates,
    ignorePrevAsyncUpdates,
    stop
  } = watchIgnorable(
    source,
    commit,
    { deep, flush, eventFilter: composedFilter }
  );
  function setSource(source2, value) {
    ignorePrevAsyncUpdates();
    ignoreUpdates(() => {
      source2.value = value;
      lastRawValue = value;
    });
  }
  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });
  const { clear, commit: manualCommit } = manualHistory;
  function commit() {
    ignorePrevAsyncUpdates();
    if (!shouldCommit(lastRawValue, source.value))
      return;
    lastRawValue = source.value;
    manualCommit();
  }
  function resume(commitNow) {
    resumeTracking();
    if (commitNow)
      commit();
  }
  function batch(fn) {
    let canceled = false;
    const cancel = () => canceled = true;
    ignoreUpdates(() => {
      fn(cancel);
    });
    if (!canceled)
      commit();
  }
  function dispose() {
    stop();
    clear();
  }
  return {
    ...manualHistory,
    isTracking,
    pause,
    resume,
    commit,
    batch,
    dispose
  };
}
function useDebouncedRefHistory(source, options = {}) {
  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;
  const history = useRefHistory(source, { ...options, eventFilter: filter });
  return {
    ...history
  };
}
function useDeviceMotion(options = {}) {
  const {
    window: window2 = defaultWindow,
    requestPermissions = false,
    eventFilter = bypassFilter
  } = options;
  const isSupported = useSupported(() => typeof DeviceMotionEvent !== "undefined");
  const requirePermissions = useSupported(() => isSupported.value && "requestPermission" in DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === "function");
  const permissionGranted = shallowRef(false);
  const acceleration = ref({ x: null, y: null, z: null });
  const rotationRate = ref({ alpha: null, beta: null, gamma: null });
  const interval = shallowRef(0);
  const accelerationIncludingGravity = ref({
    x: null,
    y: null,
    z: null
  });
  function init() {
    if (window2) {
      const onDeviceMotion = createFilterWrapper(
        eventFilter,
        (event) => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i;
          acceleration.value = {
            x: ((_a = event.acceleration) == null ? void 0 : _a.x) || null,
            y: ((_b = event.acceleration) == null ? void 0 : _b.y) || null,
            z: ((_c = event.acceleration) == null ? void 0 : _c.z) || null
          };
          accelerationIncludingGravity.value = {
            x: ((_d = event.accelerationIncludingGravity) == null ? void 0 : _d.x) || null,
            y: ((_e = event.accelerationIncludingGravity) == null ? void 0 : _e.y) || null,
            z: ((_f = event.accelerationIncludingGravity) == null ? void 0 : _f.z) || null
          };
          rotationRate.value = {
            alpha: ((_g = event.rotationRate) == null ? void 0 : _g.alpha) || null,
            beta: ((_h = event.rotationRate) == null ? void 0 : _h.beta) || null,
            gamma: ((_i = event.rotationRate) == null ? void 0 : _i.gamma) || null
          };
          interval.value = event.interval;
        }
      );
      useEventListener(window2, "devicemotion", onDeviceMotion, { passive: true });
    }
  }
  const ensurePermissions = async () => {
    if (!requirePermissions.value)
      permissionGranted.value = true;
    if (permissionGranted.value)
      return;
    if (requirePermissions.value) {
      const requestPermission = DeviceMotionEvent.requestPermission;
      try {
        const response = await requestPermission();
        if (response === "granted") {
          permissionGranted.value = true;
          init();
        }
      } catch (error) {
        console.error(error);
      }
    }
  };
  if (isSupported.value) {
    if (requestPermissions && requirePermissions.value) {
      ensurePermissions().then(() => init());
    } else {
      init();
    }
  }
  return {
    acceleration,
    accelerationIncludingGravity,
    rotationRate,
    interval,
    isSupported,
    requirePermissions,
    ensurePermissions,
    permissionGranted
  };
}
function useDeviceOrientation(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "DeviceOrientationEvent" in window2);
  const isAbsolute = shallowRef(false);
  const alpha = shallowRef(null);
  const beta = shallowRef(null);
  const gamma = shallowRef(null);
  if (window2 && isSupported.value) {
    useEventListener(window2, "deviceorientation", (event) => {
      isAbsolute.value = event.absolute;
      alpha.value = event.alpha;
      beta.value = event.beta;
      gamma.value = event.gamma;
    }, { passive: true });
  }
  return {
    isSupported,
    isAbsolute,
    alpha,
    beta,
    gamma
  };
}
function useDevicePixelRatio(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const pixelRatio = shallowRef(1);
  const query = useMediaQuery(() => `(resolution: ${pixelRatio.value}dppx)`, options);
  let stop = noop;
  if (window2) {
    stop = watchImmediate(query, () => pixelRatio.value = window2.devicePixelRatio);
  }
  return {
    pixelRatio: readonly(pixelRatio),
    stop
  };
}
function useDevicesList(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    requestPermissions = false,
    constraints = { audio: true, video: true },
    onUpdated: onUpdated2
  } = options;
  const devices = ref([]);
  const videoInputs = computed(() => devices.value.filter((i) => i.kind === "videoinput"));
  const audioInputs = computed(() => devices.value.filter((i) => i.kind === "audioinput"));
  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === "audiooutput"));
  const isSupported = useSupported(() => navigator2 && navigator2.mediaDevices && navigator2.mediaDevices.enumerateDevices);
  const permissionGranted = shallowRef(false);
  let stream;
  async function update() {
    if (!isSupported.value)
      return;
    devices.value = await navigator2.mediaDevices.enumerateDevices();
    onUpdated2 == null ? void 0 : onUpdated2(devices.value);
    if (stream) {
      stream.getTracks().forEach((t) => t.stop());
      stream = null;
    }
  }
  async function ensurePermissions() {
    const deviceName = constraints.video ? "camera" : "microphone";
    if (!isSupported.value)
      return false;
    if (permissionGranted.value)
      return true;
    const { state, query } = usePermission(deviceName, { controls: true });
    await query();
    if (state.value !== "granted") {
      let granted = true;
      try {
        const allDevices = await navigator2.mediaDevices.enumerateDevices();
        const hasCamera = allDevices.some((device) => device.kind === "videoinput");
        const hasMicrophone = allDevices.some((device) => device.kind === "audioinput" || device.kind === "audiooutput");
        constraints.video = hasCamera ? constraints.video : false;
        constraints.audio = hasMicrophone ? constraints.audio : false;
        stream = await navigator2.mediaDevices.getUserMedia(constraints);
      } catch (e) {
        stream = null;
        granted = false;
      }
      update();
      permissionGranted.value = granted;
    } else {
      permissionGranted.value = true;
    }
    return permissionGranted.value;
  }
  if (isSupported.value) {
    if (requestPermissions)
      ensurePermissions();
    useEventListener(navigator2.mediaDevices, "devicechange", update, { passive: true });
    update();
  }
  return {
    devices,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported
  };
}
function useDisplayMedia(options = {}) {
  var _a;
  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);
  const video = options.video;
  const audio = options.audio;
  const { navigator: navigator2 = defaultNavigator } = options;
  const isSupported = useSupported(() => {
    var _a2;
    return (_a2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;
  });
  const constraint = { audio, video };
  const stream = shallowRef();
  async function _start() {
    var _a2;
    if (!isSupported.value || stream.value)
      return;
    stream.value = await navigator2.mediaDevices.getDisplayMedia(constraint);
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => useEventListener(t, "ended", stop, { passive: true }));
    return stream.value;
  }
  async function _stop() {
    var _a2;
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());
    stream.value = void 0;
  }
  function stop() {
    _stop();
    enabled.value = false;
  }
  async function start() {
    await _start();
    if (stream.value)
      enabled.value = true;
    return stream.value;
  }
  watch(
    enabled,
    (v) => {
      if (v)
        _start();
      else
        _stop();
    },
    { immediate: true }
  );
  return {
    isSupported,
    stream,
    start,
    stop,
    enabled
  };
}
function useDocumentVisibility(options = {}) {
  const { document: document2 = defaultDocument } = options;
  if (!document2)
    return shallowRef("visible");
  const visibility = shallowRef(document2.visibilityState);
  useEventListener(document2, "visibilitychange", () => {
    visibility.value = document2.visibilityState;
  }, { passive: true });
  return visibility;
}
function useDraggable(target, options = {}) {
  var _a;
  const {
    pointerTypes,
    preventDefault: preventDefault2,
    stopPropagation,
    exact,
    onMove,
    onEnd,
    onStart,
    initialValue,
    axis = "both",
    draggingElement = defaultWindow,
    containerElement,
    handle: draggingHandle = target,
    buttons = [0]
  } = options;
  const position = ref(
    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }
  );
  const pressedDelta = ref();
  const filterEvent = (e) => {
    if (pointerTypes)
      return pointerTypes.includes(e.pointerType);
    return true;
  };
  const handleEvent = (e) => {
    if (toValue(preventDefault2))
      e.preventDefault();
    if (toValue(stopPropagation))
      e.stopPropagation();
  };
  const start = (e) => {
    var _a2;
    if (!toValue(buttons).includes(e.button))
      return;
    if (toValue(options.disabled) || !filterEvent(e))
      return;
    if (toValue(exact) && e.target !== toValue(target))
      return;
    const container = toValue(containerElement);
    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);
    const targetRect = toValue(target).getBoundingClientRect();
    const pos = {
      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),
      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)
    };
    if ((onStart == null ? void 0 : onStart(pos, e)) === false)
      return;
    pressedDelta.value = pos;
    handleEvent(e);
  };
  const move = (e) => {
    if (toValue(options.disabled) || !filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    const container = toValue(containerElement);
    const targetRect = toValue(target).getBoundingClientRect();
    let { x, y } = position.value;
    if (axis === "x" || axis === "both") {
      x = e.clientX - pressedDelta.value.x;
      if (container)
        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);
    }
    if (axis === "y" || axis === "both") {
      y = e.clientY - pressedDelta.value.y;
      if (container)
        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);
    }
    position.value = {
      x,
      y
    };
    onMove == null ? void 0 : onMove(position.value, e);
    handleEvent(e);
  };
  const end = (e) => {
    if (toValue(options.disabled) || !filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    pressedDelta.value = void 0;
    onEnd == null ? void 0 : onEnd(position.value, e);
    handleEvent(e);
  };
  if (isClient) {
    const config = () => {
      var _a2;
      return {
        capture: (_a2 = options.capture) != null ? _a2 : true,
        passive: !toValue(preventDefault2)
      };
    };
    useEventListener(draggingHandle, "pointerdown", start, config);
    useEventListener(draggingElement, "pointermove", move, config);
    useEventListener(draggingElement, "pointerup", end, config);
  }
  return {
    ...toRefs(position),
    position,
    isDragging: computed(() => !!pressedDelta.value),
    style: computed(
      () => `left:${position.value.x}px;top:${position.value.y}px;`
    )
  };
}
function useDropZone(target, options = {}) {
  var _a, _b;
  const isOverDropZone = shallowRef(false);
  const files = shallowRef(null);
  let counter = 0;
  let isValid = true;
  if (isClient) {
    const _options = typeof options === "function" ? { onDrop: options } : options;
    const multiple = (_a = _options.multiple) != null ? _a : true;
    const preventDefaultForUnhandled = (_b = _options.preventDefaultForUnhandled) != null ? _b : false;
    const getFiles = (event) => {
      var _a2, _b2;
      const list = Array.from((_b2 = (_a2 = event.dataTransfer) == null ? void 0 : _a2.files) != null ? _b2 : []);
      return list.length === 0 ? null : multiple ? list : [list[0]];
    };
    const checkDataTypes = (types) => {
      const dataTypes = unref(_options.dataTypes);
      if (typeof dataTypes === "function")
        return dataTypes(types);
      if (!(dataTypes == null ? void 0 : dataTypes.length))
        return true;
      if (types.length === 0)
        return false;
      return types.every(
        (type) => dataTypes.some((allowedType) => type.includes(allowedType))
      );
    };
    const checkValidity = (items) => {
      const types = Array.from(items != null ? items : []).map((item) => item.type);
      const dataTypesValid = checkDataTypes(types);
      const multipleFilesValid = multiple || items.length <= 1;
      return dataTypesValid && multipleFilesValid;
    };
    const isSafari = () => /^(?:(?!chrome|android).)*safari/i.test(navigator.userAgent) && !("chrome" in window);
    const handleDragEvent = (event, eventType) => {
      var _a2, _b2, _c, _d, _e, _f;
      const dataTransferItemList = (_a2 = event.dataTransfer) == null ? void 0 : _a2.items;
      isValid = (_b2 = dataTransferItemList && checkValidity(dataTransferItemList)) != null ? _b2 : false;
      if (preventDefaultForUnhandled) {
        event.preventDefault();
      }
      if (!isSafari() && !isValid) {
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = "none";
        }
        return;
      }
      event.preventDefault();
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = "copy";
      }
      const currentFiles = getFiles(event);
      switch (eventType) {
        case "enter":
          counter += 1;
          isOverDropZone.value = true;
          (_c = _options.onEnter) == null ? void 0 : _c.call(_options, null, event);
          break;
        case "over":
          (_d = _options.onOver) == null ? void 0 : _d.call(_options, null, event);
          break;
        case "leave":
          counter -= 1;
          if (counter === 0)
            isOverDropZone.value = false;
          (_e = _options.onLeave) == null ? void 0 : _e.call(_options, null, event);
          break;
        case "drop":
          counter = 0;
          isOverDropZone.value = false;
          if (isValid) {
            files.value = currentFiles;
            (_f = _options.onDrop) == null ? void 0 : _f.call(_options, currentFiles, event);
          }
          break;
      }
    };
    useEventListener(target, "dragenter", (event) => handleDragEvent(event, "enter"));
    useEventListener(target, "dragover", (event) => handleDragEvent(event, "over"));
    useEventListener(target, "dragleave", (event) => handleDragEvent(event, "leave"));
    useEventListener(target, "drop", (event) => handleDragEvent(event, "drop"));
  }
  return {
    files,
    isOverDropZone
  };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const _targets = toValue(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true,
    updateTiming = "sync"
  } = options;
  const height = shallowRef(0);
  const bottom = shallowRef(0);
  const left = shallowRef(0);
  const right = shallowRef(0);
  const top = shallowRef(0);
  const width = shallowRef(0);
  const x = shallowRef(0);
  const y = shallowRef(0);
  function recalculate() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }
  function update() {
    if (updateTiming === "sync")
      recalculate();
    else if (updateTiming === "next-frame")
      requestAnimationFrame(() => recalculate());
  }
  useResizeObserver(target, update);
  watch(() => unrefElement(target), (ele) => !ele && update());
  useMutationObserver(target, update, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementByPoint(options) {
  const {
    x,
    y,
    document: document2 = defaultDocument,
    multiple,
    interval = "requestAnimationFrame",
    immediate = true
  } = options;
  const isSupported = useSupported(() => {
    if (toValue(multiple))
      return document2 && "elementsFromPoint" in document2;
    return document2 && "elementFromPoint" in document2;
  });
  const element = shallowRef(null);
  const cb = () => {
    var _a, _b;
    element.value = toValue(multiple) ? (_a = document2 == null ? void 0 : document2.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document2 == null ? void 0 : document2.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;
  };
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  return {
    isSupported,
    element,
    ...controls
  };
}
function useElementHover(el, options = {}) {
  const {
    delayEnter = 0,
    delayLeave = 0,
    triggerOnRemoval = false,
    window: window2 = defaultWindow
  } = options;
  const isHovered = shallowRef(false);
  let timer;
  const toggle = (entering) => {
    const delay = entering ? delayEnter : delayLeave;
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
    if (delay)
      timer = setTimeout(() => isHovered.value = entering, delay);
    else
      isHovered.value = entering;
  };
  if (!window2)
    return isHovered;
  useEventListener(el, "mouseenter", () => toggle(true), { passive: true });
  useEventListener(el, "mouseleave", () => toggle(false), { passive: true });
  if (triggerOnRemoval) {
    onElementRemoval(
      computed(() => unrefElement(el)),
      () => toggle(false)
    );
  }
  return isHovered;
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = shallowRef(initialSize.width);
  const height = shallowRef(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = toArray(boxSize);
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement(target);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch(
    () => unrefElement(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useIntersectionObserver(target, callback, options = {}) {
  const {
    root,
    rootMargin = "0px",
    threshold = 0,
    window: window2 = defaultWindow,
    immediate = true
  } = options;
  const isSupported = useSupported(() => window2 && "IntersectionObserver" in window2);
  const targets = computed(() => {
    const _target = toValue(target);
    return toArray(_target).map(unrefElement).filter(notNullish);
  });
  let cleanup = noop;
  const isActive = shallowRef(immediate);
  const stopWatch = isSupported.value ? watch(
    () => [targets.value, unrefElement(root), isActive.value],
    ([targets2, root2]) => {
      cleanup();
      if (!isActive.value)
        return;
      if (!targets2.length)
        return;
      const observer = new IntersectionObserver(
        callback,
        {
          root: unrefElement(root2),
          rootMargin,
          threshold
        }
      );
      targets2.forEach((el) => el && observer.observe(el));
      cleanup = () => {
        observer.disconnect();
        cleanup = noop;
      };
    },
    { immediate, flush: "post" }
  ) : noop;
  const stop = () => {
    cleanup();
    stopWatch();
    isActive.value = false;
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    isActive,
    pause() {
      cleanup();
      isActive.value = false;
    },
    resume() {
      isActive.value = true;
    },
    stop
  };
}
function useElementVisibility(element, options = {}) {
  const {
    window: window2 = defaultWindow,
    scrollTarget,
    threshold = 0,
    rootMargin,
    once = false
  } = options;
  const elementIsVisible = shallowRef(false);
  const { stop } = useIntersectionObserver(
    element,
    (intersectionObserverEntries) => {
      let isIntersecting = elementIsVisible.value;
      let latestTime = 0;
      for (const entry of intersectionObserverEntries) {
        if (entry.time >= latestTime) {
          latestTime = entry.time;
          isIntersecting = entry.isIntersecting;
        }
      }
      elementIsVisible.value = isIntersecting;
      if (once) {
        watchOnce(elementIsVisible, () => {
          stop();
        });
      }
    },
    {
      root: scrollTarget,
      window: window2,
      threshold,
      rootMargin: toValue(rootMargin)
    }
  );
  return elementIsVisible;
}
const events = /* @__PURE__ */ new Map();
function useEventBus(key) {
  const scope = getCurrentScope();
  function on(listener) {
    var _a;
    const listeners = events.get(key) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    events.set(key, listeners);
    const _off = () => off(listener);
    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);
    return _off;
  }
  function once(listener) {
    function _listener(...args) {
      off(_listener);
      listener(...args);
    }
    return on(_listener);
  }
  function off(listener) {
    const listeners = events.get(key);
    if (!listeners)
      return;
    listeners.delete(listener);
    if (!listeners.size)
      reset();
  }
  function reset() {
    events.delete(key);
  }
  function emit(event, payload) {
    var _a;
    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));
  }
  return { on, once, off, emit, reset };
}
function resolveNestedOptions$1(options) {
  if (options === true)
    return {};
  return options;
}
function useEventSource(url, events2 = [], options = {}) {
  const event = shallowRef(null);
  const data = shallowRef(null);
  const status = shallowRef("CONNECTING");
  const eventSource = ref(null);
  const error = shallowRef(null);
  const urlRef = toRef(url);
  const lastEventId = shallowRef(null);
  let explicitlyClosed = false;
  let retried = 0;
  const {
    withCredentials = false,
    immediate = true,
    autoConnect = true,
    autoReconnect
  } = options;
  const close = () => {
    if (isClient && eventSource.value) {
      eventSource.value.close();
      eventSource.value = null;
      status.value = "CLOSED";
      explicitlyClosed = true;
    }
  };
  const _init = () => {
    if (explicitlyClosed || typeof urlRef.value === "undefined")
      return;
    const es = new EventSource(urlRef.value, { withCredentials });
    status.value = "CONNECTING";
    eventSource.value = es;
    es.onopen = () => {
      status.value = "OPEN";
      error.value = null;
    };
    es.onerror = (e) => {
      status.value = "CLOSED";
      error.value = e;
      if (es.readyState === 2 && !explicitlyClosed && autoReconnect) {
        es.close();
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions$1(autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    es.onmessage = (e) => {
      event.value = null;
      data.value = e.data;
      lastEventId.value = e.lastEventId;
    };
    for (const event_name of events2) {
      useEventListener(es, event_name, (e) => {
        event.value = event_name;
        data.value = e.data || null;
        lastEventId.value = e.lastEventId || null;
      }, { passive: true });
    }
  };
  const open = () => {
    if (!isClient)
      return;
    close();
    explicitlyClosed = false;
    retried = 0;
    _init();
  };
  if (immediate)
    open();
  if (autoConnect)
    watch(urlRef, open);
  tryOnScopeDispose(close);
  return {
    eventSource,
    event,
    data,
    status,
    error,
    open,
    close,
    lastEventId
  };
}
function useEyeDropper(options = {}) {
  const { initialValue = "" } = options;
  const isSupported = useSupported(() => typeof window !== "undefined" && "EyeDropper" in window);
  const sRGBHex = shallowRef(initialValue);
  async function open(openOptions) {
    if (!isSupported.value)
      return;
    const eyeDropper = new window.EyeDropper();
    const result = await eyeDropper.open(openOptions);
    sRGBHex.value = result.sRGBHex;
    return result;
  }
  return { isSupported, sRGBHex, open };
}
function useFavicon(newIcon = null, options = {}) {
  const {
    baseUrl = "",
    rel = "icon",
    document: document2 = defaultDocument
  } = options;
  const favicon = toRef(newIcon);
  const applyIcon = (icon) => {
    const elements = document2 == null ? void 0 : document2.head.querySelectorAll(`link[rel*="${rel}"]`);
    if (!elements || elements.length === 0) {
      const link = document2 == null ? void 0 : document2.createElement("link");
      if (link) {
        link.rel = rel;
        link.href = `${baseUrl}${icon}`;
        link.type = `image/${icon.split(".").pop()}`;
        document2 == null ? void 0 : document2.head.append(link);
      }
      return;
    }
    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);
  };
  watch(
    favicon,
    (i, o) => {
      if (typeof i === "string" && i !== o)
        applyIcon(i);
    },
    { immediate: true }
  );
  return favicon;
}
const payloadMapping = {
  json: "application/json",
  text: "text/plain"
};
function isFetchOptions(obj) {
  return obj && containsProp(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch", "updateDataOnError");
}
const reAbsolute = /^(?:[a-z][a-z\d+\-.]*:)?\/\//i;
function isAbsoluteURL(url) {
  return reAbsolute.test(url);
}
function headersToObject(headers) {
  if (typeof Headers !== "undefined" && headers instanceof Headers)
    return Object.fromEntries(headers.entries());
  return headers;
}
function combineCallbacks(combination, ...callbacks) {
  if (combination === "overwrite") {
    return async (ctx) => {
      let callback;
      for (let i = callbacks.length - 1; i >= 0; i--) {
        if (callbacks[i] != null) {
          callback = callbacks[i];
          break;
        }
      }
      if (callback)
        return { ...ctx, ...await callback(ctx) };
      return ctx;
    };
  } else {
    return async (ctx) => {
      for (const callback of callbacks) {
        if (callback)
          ctx = { ...ctx, ...await callback(ctx) };
      }
      return ctx;
    };
  }
}
function createFetch(config = {}) {
  const _combination = config.combination || "chain";
  const _options = config.options || {};
  const _fetchOptions = config.fetchOptions || {};
  function useFactoryFetch(url, ...args) {
    const computedUrl = computed(() => {
      const baseUrl = toValue(config.baseUrl);
      const targetUrl = toValue(url);
      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;
    });
    let options = _options;
    let fetchOptions = _fetchOptions;
    if (args.length > 0) {
      if (isFetchOptions(args[0])) {
        options = {
          ...options,
          ...args[0],
          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),
          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),
          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)
        };
      } else {
        fetchOptions = {
          ...fetchOptions,
          ...args[0],
          headers: {
            ...headersToObject(fetchOptions.headers) || {},
            ...headersToObject(args[0].headers) || {}
          }
        };
      }
    }
    if (args.length > 1 && isFetchOptions(args[1])) {
      options = {
        ...options,
        ...args[1],
        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),
        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),
        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)
      };
    }
    return useFetch(computedUrl, fetchOptions, options);
  }
  return useFactoryFetch;
}
function useFetch(url, ...args) {
  var _a, _b;
  const supportsAbort = typeof AbortController === "function";
  let fetchOptions = {};
  let options = {
    immediate: true,
    refetch: false,
    timeout: 0,
    updateDataOnError: false
  };
  const config = {
    method: "GET",
    type: "text",
    payload: void 0
  };
  if (args.length > 0) {
    if (isFetchOptions(args[0]))
      options = { ...options, ...args[0] };
    else
      fetchOptions = args[0];
  }
  if (args.length > 1) {
    if (isFetchOptions(args[1]))
      options = { ...options, ...args[1] };
  }
  const {
    fetch = (_b = (_a = defaultWindow) == null ? void 0 : _a.fetch) != null ? _b : globalThis == null ? void 0 : globalThis.fetch,
    initialData,
    timeout
  } = options;
  const responseEvent = createEventHook();
  const errorEvent = createEventHook();
  const finallyEvent = createEventHook();
  const isFinished = shallowRef(false);
  const isFetching = shallowRef(false);
  const aborted = shallowRef(false);
  const statusCode = shallowRef(null);
  const response = shallowRef(null);
  const error = shallowRef(null);
  const data = shallowRef(initialData || null);
  const canAbort = computed(() => supportsAbort && isFetching.value);
  let controller;
  let timer;
  const abort = (reason) => {
    if (supportsAbort) {
      controller == null ? void 0 : controller.abort(reason);
      controller = new AbortController();
      controller.signal.onabort = () => aborted.value = true;
      fetchOptions = {
        ...fetchOptions,
        signal: controller.signal
      };
    }
  };
  const loading = (isLoading) => {
    isFetching.value = isLoading;
    isFinished.value = !isLoading;
  };
  if (timeout)
    timer = useTimeoutFn(abort, timeout, { immediate: false });
  let executeCounter = 0;
  const execute = async (throwOnFailed = false) => {
    var _a2, _b2;
    abort();
    loading(true);
    error.value = null;
    statusCode.value = null;
    aborted.value = false;
    executeCounter += 1;
    const currentExecuteCounter = executeCounter;
    const defaultFetchOptions = {
      method: config.method,
      headers: {}
    };
    const payload = toValue(config.payload);
    if (payload) {
      const headers = headersToObject(defaultFetchOptions.headers);
      const proto = Object.getPrototypeOf(payload);
      if (!config.payloadType && payload && (proto === Object.prototype || Array.isArray(proto)) && !(payload instanceof FormData))
        config.payloadType = "json";
      if (config.payloadType)
        headers["Content-Type"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;
      defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(payload) : payload;
    }
    let isCanceled = false;
    const context = {
      url: toValue(url),
      options: {
        ...defaultFetchOptions,
        ...fetchOptions
      },
      cancel: () => {
        isCanceled = true;
      }
    };
    if (options.beforeFetch)
      Object.assign(context, await options.beforeFetch(context));
    if (isCanceled || !fetch) {
      loading(false);
      return Promise.resolve(null);
    }
    let responseData = null;
    if (timer)
      timer.start();
    return fetch(
      context.url,
      {
        ...defaultFetchOptions,
        ...context.options,
        headers: {
          ...headersToObject(defaultFetchOptions.headers),
          ...headersToObject((_b2 = context.options) == null ? void 0 : _b2.headers)
        }
      }
    ).then(async (fetchResponse) => {
      response.value = fetchResponse;
      statusCode.value = fetchResponse.status;
      responseData = await fetchResponse.clone()[config.type]();
      if (!fetchResponse.ok) {
        data.value = initialData || null;
        throw new Error(fetchResponse.statusText);
      }
      if (options.afterFetch) {
        ({ data: responseData } = await options.afterFetch({
          data: responseData,
          response: fetchResponse,
          context,
          execute
        }));
      }
      data.value = responseData;
      responseEvent.trigger(fetchResponse);
      return fetchResponse;
    }).catch(async (fetchError) => {
      let errorData = fetchError.message || fetchError.name;
      if (options.onFetchError) {
        ({ error: errorData, data: responseData } = await options.onFetchError({
          data: responseData,
          error: fetchError,
          response: response.value,
          context,
          execute
        }));
      }
      error.value = errorData;
      if (options.updateDataOnError)
        data.value = responseData;
      errorEvent.trigger(fetchError);
      if (throwOnFailed)
        throw fetchError;
      return null;
    }).finally(() => {
      if (currentExecuteCounter === executeCounter)
        loading(false);
      if (timer)
        timer.stop();
      finallyEvent.trigger(null);
    });
  };
  const refetch = toRef(options.refetch);
  watch(
    [
      refetch,
      toRef(url)
    ],
    ([refetch2]) => refetch2 && execute(),
    { deep: true }
  );
  const shell = {
    isFinished: readonly(isFinished),
    isFetching: readonly(isFetching),
    statusCode,
    response,
    error,
    data,
    canAbort,
    aborted,
    abort,
    execute,
    onFetchResponse: responseEvent.on,
    onFetchError: errorEvent.on,
    onFetchFinally: finallyEvent.on,
    // method
    get: setMethod("GET"),
    put: setMethod("PUT"),
    post: setMethod("POST"),
    delete: setMethod("DELETE"),
    patch: setMethod("PATCH"),
    head: setMethod("HEAD"),
    options: setMethod("OPTIONS"),
    // type
    json: setType("json"),
    text: setType("text"),
    blob: setType("blob"),
    arrayBuffer: setType("arrayBuffer"),
    formData: setType("formData")
  };
  function setMethod(method) {
    return (payload, payloadType) => {
      if (!isFetching.value) {
        config.method = method;
        config.payload = payload;
        config.payloadType = payloadType;
        if (isRef(config.payload)) {
          watch(
            [
              refetch,
              toRef(config.payload)
            ],
            ([refetch2]) => refetch2 && execute(),
            { deep: true }
          );
        }
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  function waitUntilFinished() {
    return new Promise((resolve, reject) => {
      until(isFinished).toBe(true).then(() => resolve(shell)).catch(reject);
    });
  }
  function setType(type) {
    return () => {
      if (!isFetching.value) {
        config.type = type;
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  if (options.immediate)
    Promise.resolve().then(() => execute());
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilFinished().then(onFulfilled, onRejected);
    }
  };
}
function joinPaths(start, end) {
  if (!start.endsWith("/") && !end.startsWith("/")) {
    return `${start}/${end}`;
  }
  if (start.endsWith("/") && end.startsWith("/")) {
    return `${start.slice(0, -1)}${end}`;
  }
  return `${start}${end}`;
}
const DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*",
  reset: false,
  directory: false
};
function prepareInitialFiles(files) {
  if (!files)
    return null;
  if (files instanceof FileList)
    return files;
  const dt = new DataTransfer();
  for (const file of files) {
    dt.items.add(file);
  }
  return dt.files;
}
function useFileDialog(options = {}) {
  const {
    document: document2 = defaultDocument
  } = options;
  const files = ref(prepareInitialFiles(options.initialFiles));
  const { on: onChange, trigger: changeTrigger } = createEventHook();
  const { on: onCancel, trigger: cancelTrigger } = createEventHook();
  let input;
  if (document2) {
    input = unrefElement(options.input) || document2.createElement("input");
    input.type = "file";
    input.onchange = (event) => {
      const result = event.target;
      files.value = result.files;
      changeTrigger(files.value);
    };
    input.oncancel = () => {
      cancelTrigger();
    };
  }
  const reset = () => {
    files.value = null;
    if (input && input.value) {
      input.value = "";
      changeTrigger(null);
    }
  };
  const open = (localOptions) => {
    if (!input)
      return;
    const _options = {
      ...DEFAULT_OPTIONS,
      ...options,
      ...localOptions
    };
    input.multiple = _options.multiple;
    input.accept = _options.accept;
    input.webkitdirectory = _options.directory;
    if (hasOwn(_options, "capture"))
      input.capture = _options.capture;
    if (_options.reset)
      reset();
    input.click();
  };
  return {
    files: readonly(files),
    open,
    reset,
    onCancel,
    onChange
  };
}
function useFileSystemAccess(options = {}) {
  const {
    window: _window = defaultWindow,
    dataType = "Text"
  } = options;
  const window2 = _window;
  const isSupported = useSupported(() => window2 && "showSaveFilePicker" in window2 && "showOpenFilePicker" in window2);
  const fileHandle = shallowRef();
  const data = shallowRef();
  const file = shallowRef();
  const fileName = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : "";
  });
  const fileMIME = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : "";
  });
  const fileSize = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;
  });
  const fileLastModified = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;
  });
  async function open(_options = {}) {
    if (!isSupported.value)
      return;
    const [handle] = await window2.showOpenFilePicker({ ...toValue(options), ..._options });
    fileHandle.value = handle;
    await updateData();
  }
  async function create(_options = {}) {
    if (!isSupported.value)
      return;
    fileHandle.value = await window2.showSaveFilePicker({ ...options, ..._options });
    data.value = void 0;
    await updateData();
  }
  async function save(_options = {}) {
    if (!isSupported.value)
      return;
    if (!fileHandle.value)
      return saveAs(_options);
    if (data.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data.value);
      await writableStream.close();
    }
    await updateFile();
  }
  async function saveAs(_options = {}) {
    if (!isSupported.value)
      return;
    fileHandle.value = await window2.showSaveFilePicker({ ...options, ..._options });
    if (data.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data.value);
      await writableStream.close();
    }
    await updateFile();
  }
  async function updateFile() {
    var _a;
    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());
  }
  async function updateData() {
    var _a, _b;
    await updateFile();
    const type = toValue(dataType);
    if (type === "Text")
      data.value = await ((_a = file.value) == null ? void 0 : _a.text());
    else if (type === "ArrayBuffer")
      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());
    else if (type === "Blob")
      data.value = file.value;
  }
  watch(() => toValue(dataType), updateData);
  return {
    isSupported,
    data,
    file,
    fileName,
    fileMIME,
    fileSize,
    fileLastModified,
    open,
    create,
    save,
    saveAs,
    updateData
  };
}
function useFocus(target, options = {}) {
  const { initialValue = false, focusVisible = false, preventScroll = false } = options;
  const innerFocused = shallowRef(false);
  const targetElement = computed(() => unrefElement(target));
  const listenerOptions = { passive: true };
  useEventListener(targetElement, "focus", (event) => {
    var _a, _b;
    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, ":focus-visible")))
      innerFocused.value = true;
  }, listenerOptions);
  useEventListener(targetElement, "blur", () => innerFocused.value = false, listenerOptions);
  const focused = computed({
    get: () => innerFocused.value,
    set(value) {
      var _a, _b;
      if (!value && innerFocused.value)
        (_a = targetElement.value) == null ? void 0 : _a.blur();
      else if (value && !innerFocused.value)
        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });
    }
  });
  watch(
    targetElement,
    () => {
      focused.value = initialValue;
    },
    { immediate: true, flush: "post" }
  );
  return { focused };
}
const EVENT_FOCUS_IN = "focusin";
const EVENT_FOCUS_OUT = "focusout";
const PSEUDO_CLASS_FOCUS_WITHIN = ":focus-within";
function useFocusWithin(target, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const targetElement = computed(() => unrefElement(target));
  const _focused = shallowRef(false);
  const focused = computed(() => _focused.value);
  const activeElement = useActiveElement(options);
  if (!window2 || !activeElement.value) {
    return { focused };
  }
  const listenerOptions = { passive: true };
  useEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);
  useEventListener(targetElement, EVENT_FOCUS_OUT, () => {
    var _a, _b, _c;
    return _focused.value = (_c = (_b = (_a = targetElement.value) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, PSEUDO_CLASS_FOCUS_WITHIN)) != null ? _c : false;
  }, listenerOptions);
  return { focused };
}
function useFps(options) {
  var _a;
  const fps = shallowRef(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
const eventHandlers = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function useFullscreen(target, options = {}) {
  const {
    document: document2 = defaultDocument,
    autoExit = false
  } = options;
  const targetRef = computed(() => {
    var _a;
    return (_a = unrefElement(target)) != null ? _a : document2 == null ? void 0 : document2.documentElement;
  });
  const isFullscreen = shallowRef(false);
  const requestMethod = computed(() => {
    return [
      "requestFullscreen",
      "webkitRequestFullscreen",
      "webkitEnterFullscreen",
      "webkitEnterFullScreen",
      "webkitRequestFullScreen",
      "mozRequestFullScreen",
      "msRequestFullscreen"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const exitMethod = computed(() => {
    return [
      "exitFullscreen",
      "webkitExitFullscreen",
      "webkitExitFullScreen",
      "webkitCancelFullScreen",
      "mozCancelFullScreen",
      "msExitFullscreen"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const fullscreenEnabled = computed(() => {
    return [
      "fullScreen",
      "webkitIsFullScreen",
      "webkitDisplayingFullscreen",
      "mozFullScreen",
      "msFullscreenElement"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const fullscreenElementMethod = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((m) => document2 && m in document2);
  const isSupported = useSupported(() => targetRef.value && document2 && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);
  const isCurrentElementFullScreen = () => {
    if (fullscreenElementMethod)
      return (document2 == null ? void 0 : document2[fullscreenElementMethod]) === targetRef.value;
    return false;
  };
  const isElementFullScreen = () => {
    if (fullscreenEnabled.value) {
      if (document2 && document2[fullscreenEnabled.value] != null) {
        return document2[fullscreenEnabled.value];
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {
          return Boolean(target2[fullscreenEnabled.value]);
        }
      }
    }
    return false;
  };
  async function exit() {
    if (!isSupported.value || !isFullscreen.value)
      return;
    if (exitMethod.value) {
      if ((document2 == null ? void 0 : document2[exitMethod.value]) != null) {
        await document2[exitMethod.value]();
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)
          await target2[exitMethod.value]();
      }
    }
    isFullscreen.value = false;
  }
  async function enter() {
    if (!isSupported.value || isFullscreen.value)
      return;
    if (isElementFullScreen())
      await exit();
    const target2 = targetRef.value;
    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {
      await target2[requestMethod.value]();
      isFullscreen.value = true;
    }
  }
  async function toggle() {
    await (isFullscreen.value ? exit() : enter());
  }
  const handlerCallback = () => {
    const isElementFullScreenValue = isElementFullScreen();
    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())
      isFullscreen.value = isElementFullScreenValue;
  };
  const listenerOptions = { capture: false, passive: true };
  useEventListener(document2, eventHandlers, handlerCallback, listenerOptions);
  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, listenerOptions);
  tryOnMounted(handlerCallback, false);
  if (autoExit)
    tryOnScopeDispose(exit);
  return {
    isSupported,
    isFullscreen,
    enter,
    exit,
    toggle
  };
}
function mapGamepadToXbox360Controller(gamepad) {
  return computed(() => {
    if (gamepad.value) {
      return {
        buttons: {
          a: gamepad.value.buttons[0],
          b: gamepad.value.buttons[1],
          x: gamepad.value.buttons[2],
          y: gamepad.value.buttons[3]
        },
        bumper: {
          left: gamepad.value.buttons[4],
          right: gamepad.value.buttons[5]
        },
        triggers: {
          left: gamepad.value.buttons[6],
          right: gamepad.value.buttons[7]
        },
        stick: {
          left: {
            horizontal: gamepad.value.axes[0],
            vertical: gamepad.value.axes[1],
            button: gamepad.value.buttons[10]
          },
          right: {
            horizontal: gamepad.value.axes[2],
            vertical: gamepad.value.axes[3],
            button: gamepad.value.buttons[11]
          }
        },
        dpad: {
          up: gamepad.value.buttons[12],
          down: gamepad.value.buttons[13],
          left: gamepad.value.buttons[14],
          right: gamepad.value.buttons[15]
        },
        back: gamepad.value.buttons[8],
        start: gamepad.value.buttons[9]
      };
    }
    return null;
  });
}
function useGamepad(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator
  } = options;
  const isSupported = useSupported(() => navigator2 && "getGamepads" in navigator2);
  const gamepads = ref([]);
  const onConnectedHook = createEventHook();
  const onDisconnectedHook = createEventHook();
  const stateFromGamepad = (gamepad) => {
    const hapticActuators = [];
    const vibrationActuator = "vibrationActuator" in gamepad ? gamepad.vibrationActuator : null;
    if (vibrationActuator)
      hapticActuators.push(vibrationActuator);
    if (gamepad.hapticActuators)
      hapticActuators.push(...gamepad.hapticActuators);
    return {
      id: gamepad.id,
      index: gamepad.index,
      connected: gamepad.connected,
      mapping: gamepad.mapping,
      timestamp: gamepad.timestamp,
      vibrationActuator: gamepad.vibrationActuator,
      hapticActuators,
      axes: gamepad.axes.map((axes) => axes),
      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))
    };
  };
  const updateGamepadState = () => {
    const _gamepads = (navigator2 == null ? void 0 : navigator2.getGamepads()) || [];
    for (const gamepad of _gamepads) {
      if (gamepad && gamepads.value[gamepad.index])
        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);
    }
  };
  const { isActive, pause, resume } = useRafFn(updateGamepadState);
  const onGamepadConnected = (gamepad) => {
    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {
      gamepads.value.push(stateFromGamepad(gamepad));
      onConnectedHook.trigger(gamepad.index);
    }
    resume();
  };
  const onGamepadDisconnected = (gamepad) => {
    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);
    onDisconnectedHook.trigger(gamepad.index);
  };
  const listenerOptions = { passive: true };
  useEventListener("gamepadconnected", (e) => onGamepadConnected(e.gamepad), listenerOptions);
  useEventListener("gamepaddisconnected", (e) => onGamepadDisconnected(e.gamepad), listenerOptions);
  tryOnMounted(() => {
    const _gamepads = (navigator2 == null ? void 0 : navigator2.getGamepads()) || [];
    for (const gamepad of _gamepads) {
      if (gamepad && gamepads.value[gamepad.index])
        onGamepadConnected(gamepad);
    }
  });
  pause();
  return {
    isSupported,
    onConnected: onConnectedHook.on,
    onDisconnected: onDisconnectedHook.on,
    gamepads,
    pause,
    resume,
    isActive
  };
}
function useGeolocation(options = {}) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3,
    navigator: navigator2 = defaultNavigator,
    immediate = true
  } = options;
  const isSupported = useSupported(() => navigator2 && "geolocation" in navigator2);
  const locatedAt = shallowRef(null);
  const error = shallowRef(null);
  const coords = ref({
    accuracy: 0,
    latitude: Number.POSITIVE_INFINITY,
    longitude: Number.POSITIVE_INFINITY,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    speed: null
  });
  function updatePosition(position) {
    locatedAt.value = position.timestamp;
    coords.value = position.coords;
    error.value = null;
  }
  let watcher;
  function resume() {
    if (isSupported.value) {
      watcher = navigator2.geolocation.watchPosition(
        updatePosition,
        (err) => error.value = err,
        {
          enableHighAccuracy,
          maximumAge,
          timeout
        }
      );
    }
  }
  if (immediate)
    resume();
  function pause() {
    if (watcher && navigator2)
      navigator2.geolocation.clearWatch(watcher);
  }
  tryOnScopeDispose(() => {
    pause();
  });
  return {
    isSupported,
    coords,
    locatedAt,
    error,
    resume,
    pause
  };
}
const defaultEvents$1 = ["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"];
const oneMinute = 6e4;
function useIdle(timeout = oneMinute, options = {}) {
  const {
    initialState = false,
    listenForVisibilityChange = true,
    events: events2 = defaultEvents$1,
    window: window2 = defaultWindow,
    eventFilter = throttleFilter(50)
  } = options;
  const idle = shallowRef(initialState);
  const lastActive = shallowRef(timestamp());
  let timer;
  const reset = () => {
    idle.value = false;
    clearTimeout(timer);
    timer = setTimeout(() => idle.value = true, timeout);
  };
  const onEvent = createFilterWrapper(
    eventFilter,
    () => {
      lastActive.value = timestamp();
      reset();
    }
  );
  if (window2) {
    const document2 = window2.document;
    const listenerOptions = { passive: true };
    for (const event of events2)
      useEventListener(window2, event, onEvent, listenerOptions);
    if (listenForVisibilityChange) {
      useEventListener(document2, "visibilitychange", () => {
        if (!document2.hidden)
          onEvent();
      }, listenerOptions);
    }
    if (!initialState)
      reset();
  }
  return {
    idle,
    lastActive,
    reset
  };
}
async function loadImage(options) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy, width, height, decoding, fetchPriority, ismap, usemap } = options;
    img.src = src;
    if (srcset != null)
      img.srcset = srcset;
    if (sizes != null)
      img.sizes = sizes;
    if (clazz != null)
      img.className = clazz;
    if (loading != null)
      img.loading = loading;
    if (crossorigin != null)
      img.crossOrigin = crossorigin;
    if (referrerPolicy != null)
      img.referrerPolicy = referrerPolicy;
    if (width != null)
      img.width = width;
    if (height != null)
      img.height = height;
    if (decoding != null)
      img.decoding = decoding;
    if (fetchPriority != null)
      img.fetchPriority = fetchPriority;
    if (ismap != null)
      img.isMap = ismap;
    if (usemap != null)
      img.useMap = usemap;
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}
function useImage(options, asyncStateOptions = {}) {
  const state = useAsyncState(
    () => loadImage(toValue(options)),
    void 0,
    {
      resetOnExecute: true,
      ...asyncStateOptions
    }
  );
  watch(
    () => toValue(options),
    () => state.execute(asyncStateOptions.delay),
    { deep: true }
  );
  return state;
}
function resolveElement(el) {
  if (typeof Window !== "undefined" && el instanceof Window)
    return el.document.documentElement;
  if (typeof Document !== "undefined" && el instanceof Document)
    return el.documentElement;
  return el;
}
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(element, options = {}) {
  const {
    throttle = 0,
    idle = 200,
    onStop = noop,
    onScroll = noop,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    observe: _observe = {
      mutation: false
    },
    eventListenerOptions = {
      capture: false,
      passive: true
    },
    behavior = "auto",
    window: window2 = defaultWindow,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const observe = typeof _observe === "boolean" ? {
    mutation: _observe
  } : _observe;
  const internalX = shallowRef(0);
  const internalY = shallowRef(0);
  const x = computed({
    get() {
      return internalX.value;
    },
    set(x2) {
      scrollTo(x2, void 0);
    }
  });
  const y = computed({
    get() {
      return internalY.value;
    },
    set(y2) {
      scrollTo(void 0, y2);
    }
  });
  function scrollTo(_x, _y) {
    var _a, _b, _c, _d;
    if (!window2)
      return;
    const _element = toValue(element);
    if (!_element)
      return;
    (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
      top: (_a = toValue(_y)) != null ? _a : y.value,
      left: (_b = toValue(_x)) != null ? _b : x.value,
      behavior: toValue(behavior)
    });
    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
    if (x != null)
      internalX.value = scrollContainer.scrollLeft;
    if (y != null)
      internalY.value = scrollContainer.scrollTop;
  }
  const isScrolling = shallowRef(false);
  const arrivedState = reactive({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const directions = reactive({
    left: false,
    right: false,
    top: false,
    bottom: false
  });
  const onScrollEnd = (e) => {
    if (!isScrolling.value)
      return;
    isScrolling.value = false;
    directions.left = false;
    directions.right = false;
    directions.top = false;
    directions.bottom = false;
    onStop(e);
  };
  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);
  const setArrivedState = (target) => {
    var _a;
    if (!window2)
      return;
    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);
    const { display, flexDirection, direction } = getComputedStyle(el);
    const directionMultipler = direction === "rtl" ? -1 : 1;
    const scrollLeft = el.scrollLeft;
    directions.left = scrollLeft < internalX.value;
    directions.right = scrollLeft > internalX.value;
    const left = Math.abs(scrollLeft * directionMultipler) <= (offset.left || 0);
    const right = Math.abs(scrollLeft * directionMultipler) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "row-reverse") {
      arrivedState.left = right;
      arrivedState.right = left;
    } else {
      arrivedState.left = left;
      arrivedState.right = right;
    }
    internalX.value = scrollLeft;
    let scrollTop = el.scrollTop;
    if (target === window2.document && !scrollTop)
      scrollTop = window2.document.body.scrollTop;
    directions.top = scrollTop < internalY.value;
    directions.bottom = scrollTop > internalY.value;
    const top = Math.abs(scrollTop) <= (offset.top || 0);
    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "column-reverse") {
      arrivedState.top = bottom;
      arrivedState.bottom = top;
    } else {
      arrivedState.top = top;
      arrivedState.bottom = bottom;
    }
    internalY.value = scrollTop;
  };
  const onScrollHandler = (e) => {
    var _a;
    if (!window2)
      return;
    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;
    setArrivedState(eventTarget);
    isScrolling.value = true;
    onScrollEndDebounced(e);
    onScroll(e);
  };
  useEventListener(
    element,
    "scroll",
    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,
    eventListenerOptions
  );
  tryOnMounted(() => {
    try {
      const _element = toValue(element);
      if (!_element)
        return;
      setArrivedState(_element);
    } catch (e) {
      onError(e);
    }
  });
  if ((observe == null ? void 0 : observe.mutation) && element != null && element !== window2 && element !== document) {
    useMutationObserver(
      element,
      () => {
        const _element = toValue(element);
        if (!_element)
          return;
        setArrivedState(_element);
      },
      {
        attributes: true,
        childList: true,
        subtree: true
      }
    );
  }
  useEventListener(
    element,
    "scrollend",
    onScrollEnd,
    eventListenerOptions
  );
  return {
    x,
    y,
    isScrolling,
    arrivedState,
    directions,
    measure() {
      const _element = toValue(element);
      if (window2 && _element)
        setArrivedState(_element);
    }
  };
}
function useInfiniteScroll(element, onLoadMore, options = {}) {
  var _a;
  const {
    direction = "bottom",
    interval = 100,
    canLoadMore = () => true
  } = options;
  const state = reactive(useScroll(
    element,
    {
      ...options,
      offset: {
        [direction]: (_a = options.distance) != null ? _a : 0,
        ...options.offset
      }
    }
  ));
  const promise = ref();
  const isLoading = computed(() => !!promise.value);
  const observedElement = computed(() => {
    return resolveElement(toValue(element));
  });
  const isElementVisible = useElementVisibility(observedElement);
  function checkAndLoad() {
    state.measure();
    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))
      return;
    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;
    const isNarrower = direction === "bottom" || direction === "top" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;
    if (state.arrivedState[direction] || isNarrower) {
      if (!promise.value) {
        promise.value = Promise.all([
          onLoadMore(state),
          new Promise((resolve) => setTimeout(resolve, interval))
        ]).finally(() => {
          promise.value = null;
          nextTick(() => checkAndLoad());
        });
      }
    }
  }
  const stop = watch(
    () => [state.arrivedState[direction], isElementVisible.value],
    checkAndLoad,
    { immediate: true }
  );
  tryOnUnmounted(stop);
  return {
    isLoading,
    reset() {
      nextTick(() => checkAndLoad());
    }
  };
}
const defaultEvents = ["mousedown", "mouseup", "keydown", "keyup"];
function useKeyModifier(modifier, options = {}) {
  const {
    events: events2 = defaultEvents,
    document: document2 = defaultDocument,
    initial = null
  } = options;
  const state = shallowRef(initial);
  if (document2) {
    events2.forEach((listenerEvent) => {
      useEventListener(document2, listenerEvent, (evt) => {
        if (typeof evt.getModifierState === "function")
          state.value = evt.getModifierState(modifier);
      }, { passive: true });
    });
  }
  return state;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
const DefaultMagicKeysAliasMap = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
function useMagicKeys(options = {}) {
  const {
    reactive: useReactive = false,
    target = defaultWindow,
    aliasMap = DefaultMagicKeysAliasMap,
    passive = true,
    onEventFired = noop
  } = options;
  const current = reactive(/* @__PURE__ */ new Set());
  const obj = {
    toJSON() {
      return {};
    },
    current
  };
  const refs = useReactive ? reactive(obj) : obj;
  const metaDeps = /* @__PURE__ */ new Set();
  const shiftDeps = /* @__PURE__ */ new Set();
  const usedKeys = /* @__PURE__ */ new Set();
  function setRefs(key, value) {
    if (key in refs) {
      if (useReactive)
        refs[key] = value;
      else
        refs[key].value = value;
    }
  }
  function reset() {
    current.clear();
    for (const key of usedKeys)
      setRefs(key, false);
  }
  function updateRefs(e, value) {
    var _a, _b;
    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();
    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();
    const values = [code, key].filter(Boolean);
    if (key) {
      if (value)
        current.add(key);
      else
        current.delete(key);
    }
    for (const key2 of values) {
      usedKeys.add(key2);
      setRefs(key2, value);
    }
    if (key === "shift" && !value) {
      shiftDeps.forEach((key2) => {
        current.delete(key2);
        setRefs(key2, false);
      });
      shiftDeps.clear();
    } else if (typeof e.getModifierState === "function" && e.getModifierState("Shift") && value) {
      [...current, ...values].forEach((key2) => shiftDeps.add(key2));
    }
    if (key === "meta" && !value) {
      metaDeps.forEach((key2) => {
        current.delete(key2);
        setRefs(key2, false);
      });
      metaDeps.clear();
    } else if (typeof e.getModifierState === "function" && e.getModifierState("Meta") && value) {
      [...current, ...values].forEach((key2) => metaDeps.add(key2));
    }
  }
  useEventListener(target, "keydown", (e) => {
    updateRefs(e, true);
    return onEventFired(e);
  }, { passive });
  useEventListener(target, "keyup", (e) => {
    updateRefs(e, false);
    return onEventFired(e);
  }, { passive });
  useEventListener("blur", reset, { passive });
  useEventListener("focus", reset, { passive });
  const proxy = new Proxy(
    refs,
    {
      get(target2, prop, rec) {
        if (typeof prop !== "string")
          return Reflect.get(target2, prop, rec);
        prop = prop.toLowerCase();
        if (prop in aliasMap)
          prop = aliasMap[prop];
        if (!(prop in refs)) {
          if (/[+_-]/.test(prop)) {
            const keys2 = prop.split(/[+_-]/g).map((i) => i.trim());
            refs[prop] = computed(() => keys2.map((key) => toValue(proxy[key])).every(Boolean));
          } else {
            refs[prop] = shallowRef(false);
          }
        }
        const r = Reflect.get(target2, prop, rec);
        return useReactive ? toValue(r) : r;
      }
    }
  );
  return proxy;
}
function usingElRef(source, cb) {
  if (toValue(source))
    cb(toValue(source));
}
function timeRangeToArray(timeRanges) {
  let ranges = [];
  for (let i = 0; i < timeRanges.length; ++i)
    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];
  return ranges;
}
function tracksToArray(tracks) {
  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));
}
const defaultOptions = {
  src: "",
  tracks: []
};
function useMediaControls(target, options = {}) {
  target = toRef(target);
  options = {
    ...defaultOptions,
    ...options
  };
  const {
    document: document2 = defaultDocument
  } = options;
  const listenerOptions = { passive: true };
  const currentTime = shallowRef(0);
  const duration = shallowRef(0);
  const seeking = shallowRef(false);
  const volume = shallowRef(1);
  const waiting = shallowRef(false);
  const ended = shallowRef(false);
  const playing = shallowRef(false);
  const rate = shallowRef(1);
  const stalled = shallowRef(false);
  const buffered = ref([]);
  const tracks = ref([]);
  const selectedTrack = shallowRef(-1);
  const isPictureInPicture = shallowRef(false);
  const muted = shallowRef(false);
  const supportsPictureInPicture = document2 && "pictureInPictureEnabled" in document2;
  const sourceErrorEvent = createEventHook();
  const playbackErrorEvent = createEventHook();
  const disableTrack = (track) => {
    usingElRef(target, (el) => {
      if (track) {
        const id = typeof track === "number" ? track : track.id;
        el.textTracks[id].mode = "disabled";
      } else {
        for (let i = 0; i < el.textTracks.length; ++i)
          el.textTracks[i].mode = "disabled";
      }
      selectedTrack.value = -1;
    });
  };
  const enableTrack = (track, disableTracks = true) => {
    usingElRef(target, (el) => {
      const id = typeof track === "number" ? track : track.id;
      if (disableTracks)
        disableTrack();
      el.textTracks[id].mode = "showing";
      selectedTrack.value = id;
    });
  };
  const togglePictureInPicture = () => {
    return new Promise((resolve, reject) => {
      usingElRef(target, async (el) => {
        if (supportsPictureInPicture) {
          if (!isPictureInPicture.value) {
            el.requestPictureInPicture().then(resolve).catch(reject);
          } else {
            document2.exitPictureInPicture().then(resolve).catch(reject);
          }
        }
      });
    });
  };
  watchEffect(() => {
    if (!document2)
      return;
    const el = toValue(target);
    if (!el)
      return;
    const src = toValue(options.src);
    let sources = [];
    if (!src)
      return;
    if (typeof src === "string")
      sources = [{ src }];
    else if (Array.isArray(src))
      sources = src;
    else if (isObject(src))
      sources = [src];
    el.querySelectorAll("source").forEach((e) => {
      e.remove();
    });
    sources.forEach(({ src: src2, type, media }) => {
      const source = document2.createElement("source");
      source.setAttribute("src", src2);
      source.setAttribute("type", type || "");
      source.setAttribute("media", media || "");
      useEventListener(source, "error", sourceErrorEvent.trigger, listenerOptions);
      el.appendChild(source);
    });
    el.load();
  });
  watch([target, volume], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.volume = volume.value;
  });
  watch([target, muted], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.muted = muted.value;
  });
  watch([target, rate], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.playbackRate = rate.value;
  });
  watchEffect(() => {
    if (!document2)
      return;
    const textTracks = toValue(options.tracks);
    const el = toValue(target);
    if (!textTracks || !textTracks.length || !el)
      return;
    el.querySelectorAll("track").forEach((e) => e.remove());
    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {
      const track = document2.createElement("track");
      track.default = isDefault || false;
      track.kind = kind;
      track.label = label;
      track.src = src;
      track.srclang = srcLang;
      if (track.default)
        selectedTrack.value = i;
      el.appendChild(track);
    });
  });
  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {
    const el = toValue(target);
    if (!el)
      return;
    el.currentTime = time;
  });
  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {
    const el = toValue(target);
    if (!el)
      return;
    if (isPlaying) {
      el.play().catch((e) => {
        playbackErrorEvent.trigger(e);
        throw e;
      });
    } else {
      el.pause();
    }
  });
  useEventListener(
    target,
    "timeupdate",
    () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime),
    listenerOptions
  );
  useEventListener(
    target,
    "durationchange",
    () => duration.value = toValue(target).duration,
    listenerOptions
  );
  useEventListener(
    target,
    "progress",
    () => buffered.value = timeRangeToArray(toValue(target).buffered),
    listenerOptions
  );
  useEventListener(
    target,
    "seeking",
    () => seeking.value = true,
    listenerOptions
  );
  useEventListener(
    target,
    "seeked",
    () => seeking.value = false,
    listenerOptions
  );
  useEventListener(
    target,
    ["waiting", "loadstart"],
    () => {
      waiting.value = true;
      ignorePlayingUpdates(() => playing.value = false);
    },
    listenerOptions
  );
  useEventListener(
    target,
    "loadeddata",
    () => waiting.value = false,
    listenerOptions
  );
  useEventListener(
    target,
    "playing",
    () => {
      waiting.value = false;
      ended.value = false;
      ignorePlayingUpdates(() => playing.value = true);
    },
    listenerOptions
  );
  useEventListener(
    target,
    "ratechange",
    () => rate.value = toValue(target).playbackRate,
    listenerOptions
  );
  useEventListener(
    target,
    "stalled",
    () => stalled.value = true,
    listenerOptions
  );
  useEventListener(
    target,
    "ended",
    () => ended.value = true,
    listenerOptions
  );
  useEventListener(
    target,
    "pause",
    () => ignorePlayingUpdates(() => playing.value = false),
    listenerOptions
  );
  useEventListener(
    target,
    "play",
    () => ignorePlayingUpdates(() => playing.value = true),
    listenerOptions
  );
  useEventListener(
    target,
    "enterpictureinpicture",
    () => isPictureInPicture.value = true,
    listenerOptions
  );
  useEventListener(
    target,
    "leavepictureinpicture",
    () => isPictureInPicture.value = false,
    listenerOptions
  );
  useEventListener(
    target,
    "volumechange",
    () => {
      const el = toValue(target);
      if (!el)
        return;
      volume.value = el.volume;
      muted.value = el.muted;
    },
    listenerOptions
  );
  const listeners = [];
  const stop = watch([target], () => {
    const el = toValue(target);
    if (!el)
      return;
    stop();
    listeners[0] = useEventListener(el.textTracks, "addtrack", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);
    listeners[1] = useEventListener(el.textTracks, "removetrack", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);
    listeners[2] = useEventListener(el.textTracks, "change", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);
  });
  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));
  return {
    currentTime,
    duration,
    waiting,
    seeking,
    ended,
    stalled,
    buffered,
    playing,
    rate,
    // Volume
    volume,
    muted,
    // Tracks
    tracks,
    selectedTrack,
    enableTrack,
    disableTrack,
    // Picture in Picture
    supportsPictureInPicture,
    togglePictureInPicture,
    isPictureInPicture,
    // Events
    onSourceError: sourceErrorEvent.on,
    onPlaybackError: playbackErrorEvent.on
  };
}
function useMemoize(resolver, options) {
  const initCache = () => {
    if (options == null ? void 0 : options.cache)
      return shallowReactive(options.cache);
    return shallowReactive(/* @__PURE__ */ new Map());
  };
  const cache = initCache();
  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);
  const _loadData = (key, ...args) => {
    cache.set(key, resolver(...args));
    return cache.get(key);
  };
  const loadData = (...args) => _loadData(generateKey(...args), ...args);
  const deleteData = (...args) => {
    cache.delete(generateKey(...args));
  };
  const clearData = () => {
    cache.clear();
  };
  const memoized = (...args) => {
    const key = generateKey(...args);
    if (cache.has(key))
      return cache.get(key);
    return _loadData(key, ...args);
  };
  memoized.load = loadData;
  memoized.delete = deleteData;
  memoized.clear = clearData;
  memoized.generateKey = generateKey;
  memoized.cache = cache;
  return memoized;
}
function useMemory(options = {}) {
  const memory = ref();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported.value) {
    const { interval = 1e3 } = options;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });
  }
  return { isSupported, memory };
}
const UseMouseBuiltinExtractors = {
  page: (event) => [event.pageX, event.pageY],
  client: (event) => [event.clientX, event.clientY],
  screen: (event) => [event.screenX, event.screenY],
  movement: (event) => event instanceof MouseEvent ? [event.movementX, event.movementY] : null
};
function useMouse(options = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow,
    target = window2,
    scroll = true,
    eventFilter
  } = options;
  let _prevMouseEvent = null;
  let _prevScrollX = 0;
  let _prevScrollY = 0;
  const x = shallowRef(initialValue.x);
  const y = shallowRef(initialValue.y);
  const sourceType = shallowRef(null);
  const extractor = typeof type === "function" ? type : UseMouseBuiltinExtractors[type];
  const mouseHandler = (event) => {
    const result = extractor(event);
    _prevMouseEvent = event;
    if (result) {
      [x.value, y.value] = result;
      sourceType.value = "mouse";
    }
    if (window2) {
      _prevScrollX = window2.scrollX;
      _prevScrollY = window2.scrollY;
    }
  };
  const touchHandler = (event) => {
    if (event.touches.length > 0) {
      const result = extractor(event.touches[0]);
      if (result) {
        [x.value, y.value] = result;
        sourceType.value = "touch";
      }
    }
  };
  const scrollHandler = () => {
    if (!_prevMouseEvent || !window2)
      return;
    const pos = extractor(_prevMouseEvent);
    if (_prevMouseEvent instanceof MouseEvent && pos) {
      x.value = pos[0] + window2.scrollX - _prevScrollX;
      y.value = pos[1] + window2.scrollY - _prevScrollY;
    }
  };
  const reset = () => {
    x.value = initialValue.x;
    y.value = initialValue.y;
  };
  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);
  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);
  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["mousemove", "dragover"], mouseHandlerWrapper, listenerOptions);
    if (touch && type !== "movement") {
      useEventListener(target, ["touchstart", "touchmove"], touchHandlerWrapper, listenerOptions);
      if (resetOnTouchEnds)
        useEventListener(target, "touchend", reset, listenerOptions);
    }
    if (scroll && type === "page")
      useEventListener(window2, "scroll", scrollHandlerWrapper, listenerOptions);
  }
  return {
    x,
    y,
    sourceType
  };
}
function useMouseInElement(target, options = {}) {
  const {
    windowResize = true,
    windowScroll = true,
    handleOutside = true,
    window: window2 = defaultWindow
  } = options;
  const type = options.type || "page";
  const { x, y, sourceType } = useMouse(options);
  const targetRef = shallowRef(target != null ? target : window2 == null ? void 0 : window2.document.body);
  const elementX = shallowRef(0);
  const elementY = shallowRef(0);
  const elementPositionX = shallowRef(0);
  const elementPositionY = shallowRef(0);
  const elementHeight = shallowRef(0);
  const elementWidth = shallowRef(0);
  const isOutside = shallowRef(true);
  function update() {
    if (!window2)
      return;
    const el = unrefElement(targetRef);
    if (!el || !(el instanceof Element))
      return;
    const {
      left,
      top,
      width,
      height
    } = el.getBoundingClientRect();
    elementPositionX.value = left + (type === "page" ? window2.pageXOffset : 0);
    elementPositionY.value = top + (type === "page" ? window2.pageYOffset : 0);
    elementHeight.value = height;
    elementWidth.value = width;
    const elX = x.value - elementPositionX.value;
    const elY = y.value - elementPositionY.value;
    isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
    if (handleOutside) {
      elementX.value = elX;
      elementY.value = elY;
    }
  }
  const stopFnList = [];
  function stop() {
    stopFnList.forEach((fn) => fn());
    stopFnList.length = 0;
  }
  tryOnMounted(() => {
    update();
  });
  if (window2) {
    const {
      stop: stopResizeObserver
    } = useResizeObserver(targetRef, update);
    const {
      stop: stopMutationObserver
    } = useMutationObserver(targetRef, update, {
      attributeFilter: ["style", "class"]
    });
    const stopWatch = watch(
      [targetRef, x, y],
      update
    );
    stopFnList.push(
      stopResizeObserver,
      stopMutationObserver,
      stopWatch
    );
    useEventListener(
      document,
      "mouseleave",
      () => isOutside.value = true,
      { passive: true }
    );
    if (windowScroll) {
      stopFnList.push(
        useEventListener("scroll", update, { capture: true, passive: true })
      );
    }
    if (windowResize) {
      stopFnList.push(
        useEventListener("resize", update, { passive: true })
      );
    }
  }
  return {
    x,
    y,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop
  };
}
function useMousePressed(options = {}) {
  const {
    touch = true,
    drag = true,
    capture = false,
    initialValue = false,
    window: window2 = defaultWindow
  } = options;
  const pressed = shallowRef(initialValue);
  const sourceType = shallowRef(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = (srcType) => (event) => {
    var _a;
    pressed.value = true;
    sourceType.value = srcType;
    (_a = options.onPressed) == null ? void 0 : _a.call(options, event);
  };
  const onReleased = (event) => {
    var _a;
    pressed.value = false;
    sourceType.value = null;
    (_a = options.onReleased) == null ? void 0 : _a.call(options, event);
  };
  const target = computed(() => unrefElement(options.target) || window2);
  const listenerOptions = { passive: true, capture };
  useEventListener(target, "mousedown", onPressed("mouse"), listenerOptions);
  useEventListener(window2, "mouseleave", onReleased, listenerOptions);
  useEventListener(window2, "mouseup", onReleased, listenerOptions);
  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), listenerOptions);
    useEventListener(window2, "drop", onReleased, listenerOptions);
    useEventListener(window2, "dragend", onReleased, listenerOptions);
  }
  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), listenerOptions);
    useEventListener(window2, "touchend", onReleased, listenerOptions);
    useEventListener(window2, "touchcancel", onReleased, listenerOptions);
  }
  return {
    pressed,
    sourceType
  };
}
function useNavigatorLanguage(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator2 && "language" in navigator2);
  const language = shallowRef(navigator2 == null ? void 0 : navigator2.language);
  useEventListener(window2, "languagechange", () => {
    if (navigator2)
      language.value = navigator2.language;
  }, { passive: true });
  return {
    isSupported,
    language
  };
}
function useNetwork(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator2 && "connection" in navigator2);
  const isOnline = shallowRef(true);
  const saveData = shallowRef(false);
  const offlineAt = shallowRef(void 0);
  const onlineAt = shallowRef(void 0);
  const downlink = shallowRef(void 0);
  const downlinkMax = shallowRef(void 0);
  const rtt = shallowRef(void 0);
  const effectiveType = shallowRef(void 0);
  const type = shallowRef("unknown");
  const connection = isSupported.value && navigator2.connection;
  function updateNetworkInformation() {
    if (!navigator2)
      return;
    isOnline.value = navigator2.onLine;
    offlineAt.value = isOnline.value ? void 0 : Date.now();
    onlineAt.value = isOnline.value ? Date.now() : void 0;
    if (connection) {
      downlink.value = connection.downlink;
      downlinkMax.value = connection.downlinkMax;
      effectiveType.value = connection.effectiveType;
      rtt.value = connection.rtt;
      saveData.value = connection.saveData;
      type.value = connection.type;
    }
  }
  const listenerOptions = { passive: true };
  if (window2) {
    useEventListener(window2, "offline", () => {
      isOnline.value = false;
      offlineAt.value = Date.now();
    }, listenerOptions);
    useEventListener(window2, "online", () => {
      isOnline.value = true;
      onlineAt.value = Date.now();
    }, listenerOptions);
  }
  if (connection)
    useEventListener(connection, "change", updateNetworkInformation, listenerOptions);
  updateNetworkInformation();
  return {
    isSupported,
    isOnline: readonly(isOnline),
    saveData: readonly(saveData),
    offlineAt: readonly(offlineAt),
    onlineAt: readonly(onlineAt),
    downlink: readonly(downlink),
    downlinkMax: readonly(downlinkMax),
    effectiveType: readonly(effectiveType),
    rtt: readonly(rtt),
    type: readonly(type)
  };
}
function useNow(options = {}) {
  const {
    controls: exposeControls = false,
    interval = "requestAnimationFrame",
    immediate = true
  } = options;
  const now = ref(/* @__PURE__ */ new Date());
  const update = () => now.value = /* @__PURE__ */ new Date();
  const controls = interval === "requestAnimationFrame" ? useRafFn(update, { immediate }) : useIntervalFn(update, interval, { immediate });
  if (exposeControls) {
    return {
      now,
      ...controls
    };
  } else {
    return now;
  }
}
function useObjectUrl(object) {
  const url = shallowRef();
  const release = () => {
    if (url.value)
      URL.revokeObjectURL(url.value);
    url.value = void 0;
  };
  watch(
    () => toValue(object),
    (newObject) => {
      release();
      if (newObject)
        url.value = URL.createObjectURL(newObject);
    },
    { immediate: true }
  );
  tryOnScopeDispose(release);
  return readonly(url);
}
function useClamp(value, min, max) {
  if (typeof value === "function" || isReadonly(value))
    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));
  const _value = ref(value);
  return computed({
    get() {
      return _value.value = clamp(_value.value, toValue(min), toValue(max));
    },
    set(value2) {
      _value.value = clamp(value2, toValue(min), toValue(max));
    }
  });
}
function useOffsetPagination(options) {
  const {
    total = Number.POSITIVE_INFINITY,
    pageSize = 10,
    page = 1,
    onPageChange = noop,
    onPageSizeChange = noop,
    onPageCountChange = noop
  } = options;
  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);
  const pageCount = computed(() => Math.max(
    1,
    Math.ceil(toValue(total) / toValue(currentPageSize))
  ));
  const currentPage = useClamp(page, 1, pageCount);
  const isFirstPage = computed(() => currentPage.value === 1);
  const isLastPage = computed(() => currentPage.value === pageCount.value);
  if (isRef(page)) {
    syncRef(page, currentPage, {
      direction: isReadonly(page) ? "ltr" : "both"
    });
  }
  if (isRef(pageSize)) {
    syncRef(pageSize, currentPageSize, {
      direction: isReadonly(pageSize) ? "ltr" : "both"
    });
  }
  function prev() {
    currentPage.value--;
  }
  function next() {
    currentPage.value++;
  }
  const returnValue = {
    currentPage,
    currentPageSize,
    pageCount,
    isFirstPage,
    isLastPage,
    prev,
    next
  };
  watch(currentPage, () => {
    onPageChange(reactive(returnValue));
  });
  watch(currentPageSize, () => {
    onPageSizeChange(reactive(returnValue));
  });
  watch(pageCount, () => {
    onPageCountChange(reactive(returnValue));
  });
  return returnValue;
}
function useOnline(options = {}) {
  const { isOnline } = useNetwork(options);
  return isOnline;
}
function usePageLeave(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isLeft = shallowRef(false);
  const handler = (event) => {
    if (!window2)
      return;
    event = event || window2.event;
    const from = event.relatedTarget || event.toElement;
    isLeft.value = !from;
  };
  if (window2) {
    const listenerOptions = { passive: true };
    useEventListener(window2, "mouseout", handler, listenerOptions);
    useEventListener(window2.document, "mouseleave", handler, listenerOptions);
    useEventListener(window2.document, "mouseenter", handler, listenerOptions);
  }
  return isLeft;
}
function useScreenOrientation(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const isSupported = useSupported(() => window2 && "screen" in window2 && "orientation" in window2.screen);
  const screenOrientation = isSupported.value ? window2.screen.orientation : {};
  const orientation = ref(screenOrientation.type);
  const angle = shallowRef(screenOrientation.angle || 0);
  if (isSupported.value) {
    useEventListener(window2, "orientationchange", () => {
      orientation.value = screenOrientation.type;
      angle.value = screenOrientation.angle;
    }, { passive: true });
  }
  const lockOrientation = (type) => {
    if (isSupported.value && typeof screenOrientation.lock === "function")
      return screenOrientation.lock(type);
    return Promise.reject(new Error("Not supported"));
  };
  const unlockOrientation = () => {
    if (isSupported.value && typeof screenOrientation.unlock === "function")
      screenOrientation.unlock();
  };
  return {
    isSupported,
    orientation,
    angle,
    lockOrientation,
    unlockOrientation
  };
}
function useParallax(target, options = {}) {
  const {
    deviceOrientationTiltAdjust = (i) => i,
    deviceOrientationRollAdjust = (i) => i,
    mouseTiltAdjust = (i) => i,
    mouseRollAdjust = (i) => i,
    window: window2 = defaultWindow
  } = options;
  const orientation = reactive(useDeviceOrientation({ window: window2 }));
  const screenOrientation = reactive(useScreenOrientation({ window: window2 }));
  const {
    elementX: x,
    elementY: y,
    elementWidth: width,
    elementHeight: height
  } = useMouseInElement(target, { handleOutside: false, window: window2 });
  const source = computed(() => {
    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {
      return "deviceOrientation";
    }
    return "mouse";
  });
  const roll = computed(() => {
    if (source.value === "deviceOrientation") {
      let value;
      switch (screenOrientation.orientation) {
        case "landscape-primary":
          value = orientation.gamma / 90;
          break;
        case "landscape-secondary":
          value = -orientation.gamma / 90;
          break;
        case "portrait-primary":
          value = -orientation.beta / 90;
          break;
        case "portrait-secondary":
          value = orientation.beta / 90;
          break;
        default:
          value = -orientation.beta / 90;
      }
      return deviceOrientationRollAdjust(value);
    } else {
      const value = -(y.value - height.value / 2) / height.value;
      return mouseRollAdjust(value);
    }
  });
  const tilt = computed(() => {
    if (source.value === "deviceOrientation") {
      let value;
      switch (screenOrientation.orientation) {
        case "landscape-primary":
          value = orientation.beta / 90;
          break;
        case "landscape-secondary":
          value = -orientation.beta / 90;
          break;
        case "portrait-primary":
          value = orientation.gamma / 90;
          break;
        case "portrait-secondary":
          value = -orientation.gamma / 90;
          break;
        default:
          value = orientation.gamma / 90;
      }
      return deviceOrientationTiltAdjust(value);
    } else {
      const value = (x.value - width.value / 2) / width.value;
      return mouseTiltAdjust(value);
    }
  });
  return { roll, tilt, source };
}
function useParentElement(element = useCurrentElement()) {
  const parentElement = shallowRef();
  const update = () => {
    const el = unrefElement(element);
    if (el)
      parentElement.value = el.parentElement;
  };
  tryOnMounted(update);
  watch(() => toValue(element), update);
  return parentElement;
}
function usePerformanceObserver(options, callback) {
  const {
    window: window2 = defaultWindow,
    immediate = true,
    ...performanceOptions
  } = options;
  const isSupported = useSupported(() => window2 && "PerformanceObserver" in window2);
  let observer;
  const stop = () => {
    observer == null ? void 0 : observer.disconnect();
  };
  const start = () => {
    if (isSupported.value) {
      stop();
      observer = new PerformanceObserver(callback);
      observer.observe(performanceOptions);
    }
  };
  tryOnScopeDispose(stop);
  if (immediate)
    start();
  return {
    isSupported,
    start,
    stop
  };
}
const defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
const keys = /* @__PURE__ */ Object.keys(defaultState);
function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = shallowRef(false);
  const state = ref(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler = (event) => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    state.value = objectPick(event, keys, false);
  };
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs(state),
    isInside
  };
}
function usePointerLock(target, options = {}) {
  const { document: document2 = defaultDocument } = options;
  const isSupported = useSupported(() => document2 && "pointerLockElement" in document2);
  const element = shallowRef();
  const triggerElement = shallowRef();
  let targetElement;
  if (isSupported.value) {
    const listenerOptions = { passive: true };
    useEventListener(document2, "pointerlockchange", () => {
      var _a;
      const currentElement = (_a = document2.pointerLockElement) != null ? _a : element.value;
      if (targetElement && currentElement === targetElement) {
        element.value = document2.pointerLockElement;
        if (!element.value)
          targetElement = triggerElement.value = null;
      }
    }, listenerOptions);
    useEventListener(document2, "pointerlockerror", () => {
      var _a;
      const currentElement = (_a = document2.pointerLockElement) != null ? _a : element.value;
      if (targetElement && currentElement === targetElement) {
        const action = document2.pointerLockElement ? "release" : "acquire";
        throw new Error(`Failed to ${action} pointer lock.`);
      }
    }, listenerOptions);
  }
  async function lock(e) {
    var _a;
    if (!isSupported.value)
      throw new Error("Pointer Lock API is not supported by your browser.");
    triggerElement.value = e instanceof Event ? e.currentTarget : null;
    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);
    if (!targetElement)
      throw new Error("Target element undefined.");
    targetElement.requestPointerLock();
    return await until(element).toBe(targetElement);
  }
  async function unlock() {
    if (!element.value)
      return false;
    document2.exitPointerLock();
    await until(element).toBeNull();
    return true;
  }
  return {
    isSupported,
    element,
    triggerElement,
    lock,
    unlock
  };
}
function usePointerSwipe(target, options = {}) {
  const targetRef = toRef(target);
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    disableTextSelect = false
  } = options;
  const posStart = reactive({ x: 0, y: 0 });
  const updatePosStart = (x, y) => {
    posStart.x = x;
    posStart.y = y;
  };
  const posEnd = reactive({ x: 0, y: 0 });
  const updatePosEnd = (x, y) => {
    posEnd.x = x;
    posEnd.y = y;
  };
  const distanceX = computed(() => posStart.x - posEnd.x);
  const distanceY = computed(() => posStart.y - posEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);
  const isSwiping = shallowRef(false);
  const isPointerDown = shallowRef(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(distanceX.value) > abs(distanceY.value)) {
      return distanceX.value > 0 ? "left" : "right";
    } else {
      return distanceY.value > 0 ? "up" : "down";
    }
  });
  const eventIsAllowed = (e) => {
    var _a, _b, _c;
    const isReleasingButton = e.buttons === 0;
    const isPrimaryButton = e.buttons === 1;
    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;
  };
  const listenerOptions = { passive: true };
  const stops = [
    useEventListener(target, "pointerdown", (e) => {
      if (!eventIsAllowed(e))
        return;
      isPointerDown.value = true;
      const eventTarget = e.target;
      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);
      const { clientX: x, clientY: y } = e;
      updatePosStart(x, y);
      updatePosEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions),
    useEventListener(target, "pointermove", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (!isPointerDown.value)
        return;
      const { clientX: x, clientY: y } = e;
      updatePosEnd(x, y);
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions),
    useEventListener(target, "pointerup", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (isSwiping.value)
        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
      isPointerDown.value = false;
      isSwiping.value = false;
    }, listenerOptions)
  ];
  tryOnMounted(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "pan-y");
    if (disableTextSelect) {
      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty("-webkit-user-select", "none");
      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty("-ms-user-select", "none");
      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty("user-select", "none");
    }
  });
  const stop = () => stops.forEach((s) => s());
  return {
    isSwiping: readonly(isSwiping),
    direction: readonly(direction),
    posStart: readonly(posStart),
    posEnd: readonly(posEnd),
    distanceX,
    distanceY,
    stop
  };
}
function usePreferredColorScheme(options) {
  const isLight = useMediaQuery("(prefers-color-scheme: light)", options);
  const isDark = useMediaQuery("(prefers-color-scheme: dark)", options);
  return computed(() => {
    if (isDark.value)
      return "dark";
    if (isLight.value)
      return "light";
    return "no-preference";
  });
}
function usePreferredContrast(options) {
  const isMore = useMediaQuery("(prefers-contrast: more)", options);
  const isLess = useMediaQuery("(prefers-contrast: less)", options);
  const isCustom = useMediaQuery("(prefers-contrast: custom)", options);
  return computed(() => {
    if (isMore.value)
      return "more";
    if (isLess.value)
      return "less";
    if (isCustom.value)
      return "custom";
    return "no-preference";
  });
}
function usePreferredLanguages(options = {}) {
  const { window: window2 = defaultWindow } = options;
  if (!window2)
    return ref(["en"]);
  const navigator2 = window2.navigator;
  const value = ref(navigator2.languages);
  useEventListener(window2, "languagechange", () => {
    value.value = navigator2.languages;
  }, { passive: true });
  return value;
}
function usePreferredReducedMotion(options) {
  const isReduced = useMediaQuery("(prefers-reduced-motion: reduce)", options);
  return computed(() => {
    if (isReduced.value)
      return "reduce";
    return "no-preference";
  });
}
function usePreferredReducedTransparency(options) {
  const isReduced = useMediaQuery("(prefers-reduced-transparency: reduce)", options);
  return computed(() => {
    if (isReduced.value)
      return "reduce";
    return "no-preference";
  });
}
function usePrevious(value, initialValue) {
  const previous = shallowRef(initialValue);
  watch(
    toRef(value),
    (_, oldValue) => {
      previous.value = oldValue;
    },
    { flush: "sync" }
  );
  return readonly(previous);
}
const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";
function useScreenSafeArea() {
  const top = shallowRef("");
  const right = shallowRef("");
  const bottom = shallowRef("");
  const left = shallowRef("");
  if (isClient) {
    const topCssVar = useCssVar(topVarName);
    const rightCssVar = useCssVar(rightVarName);
    const bottomCssVar = useCssVar(bottomVarName);
    const leftCssVar = useCssVar(leftVarName);
    topCssVar.value = "env(safe-area-inset-top, 0px)";
    rightCssVar.value = "env(safe-area-inset-right, 0px)";
    bottomCssVar.value = "env(safe-area-inset-bottom, 0px)";
    leftCssVar.value = "env(safe-area-inset-left, 0px)";
    tryOnMounted(update);
    useEventListener("resize", useDebounceFn(update), { passive: true });
  }
  function update() {
    top.value = getValue(topVarName);
    right.value = getValue(rightVarName);
    bottom.value = getValue(bottomVarName);
    left.value = getValue(leftVarName);
  }
  return {
    top,
    right,
    bottom,
    left,
    update
  };
}
function getValue(position) {
  return getComputedStyle(document.documentElement).getPropertyValue(position);
}
function useScriptTag(src, onLoaded = noop, options = {}) {
  const {
    immediate = true,
    manual = false,
    type = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document: document2 = defaultDocument,
    attrs = {},
    nonce = void 0
  } = options;
  const scriptTag = shallowRef(null);
  let _promise = null;
  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      scriptTag.value = el2;
      resolve(el2);
      return el2;
    };
    if (!document2) {
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (!el) {
      el = document2.createElement("script");
      el.type = type;
      el.async = async;
      el.src = toValue(src);
      if (defer)
        el.defer = defer;
      if (crossOrigin)
        el.crossOrigin = crossOrigin;
      if (noModule)
        el.noModule = noModule;
      if (referrerPolicy)
        el.referrerPolicy = referrerPolicy;
      if (nonce) {
        el.nonce = nonce;
      }
      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    const listenerOptions = {
      passive: true
    };
    useEventListener(el, "error", (event) => reject(event), listenerOptions);
    useEventListener(el, "abort", (event) => reject(event), listenerOptions);
    useEventListener(el, "load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    }, listenerOptions);
    if (shouldAppend)
      el = document2.head.appendChild(el);
    if (!waitForScriptLoad)
      resolveWithElement(el);
  });
  const load = (waitForScriptLoad = true) => {
    if (!_promise)
      _promise = loadScript(waitForScriptLoad);
    return _promise;
  };
  const unload = () => {
    if (!document2)
      return;
    _promise = null;
    if (scriptTag.value)
      scriptTag.value = null;
    const el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (el)
      document2.head.removeChild(el);
  };
  if (immediate && !manual)
    tryOnMounted(load);
  if (!manual)
    tryOnUnmounted(unload);
  return { scriptTag, load, unload };
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault)
    e.preventDefault();
  return false;
}
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element, initialState = false) {
  const isLocked = shallowRef(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow = "";
  watch(toRef(element), (el) => {
    const target = resolveElement(toValue(el));
    if (target) {
      const ele = target;
      if (!elInitialOverflow.get(ele))
        elInitialOverflow.set(ele, ele.style.overflow);
      if (ele.style.overflow !== "hidden")
        initialOverflow = ele.style.overflow;
      if (ele.style.overflow === "hidden")
        return isLocked.value = true;
      if (isLocked.value)
        return ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const lock = () => {
    const el = resolveElement(toValue(element));
    if (!el || isLocked.value)
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        el,
        "touchmove",
        (e) => {
          preventDefault(e);
        },
        { passive: false }
      );
    }
    el.style.overflow = "hidden";
    isLocked.value = true;
  };
  const unlock = () => {
    const el = resolveElement(toValue(element));
    if (!el || !isLocked.value)
      return;
    if (isIOS)
      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
    el.style.overflow = initialOverflow;
    elInitialOverflow.delete(el);
    isLocked.value = false;
  };
  tryOnScopeDispose(unlock);
  return computed({
    get() {
      return isLocked.value;
    },
    set(v) {
      if (v)
        lock();
      else unlock();
    }
  });
}
function useSessionStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.sessionStorage, options);
}
function useShare(shareOptions = {}, options = {}) {
  const { navigator: navigator2 = defaultNavigator } = options;
  const _navigator = navigator2;
  const isSupported = useSupported(() => _navigator && "canShare" in _navigator);
  const share = async (overrideOptions = {}) => {
    if (isSupported.value) {
      const data = {
        ...toValue(shareOptions),
        ...toValue(overrideOptions)
      };
      let granted = true;
      if (data.files && _navigator.canShare)
        granted = _navigator.canShare({ files: data.files });
      if (granted)
        return _navigator.share(data);
    }
  };
  return {
    isSupported,
    share
  };
}
const defaultSortFn = (source, compareFn) => source.sort(compareFn);
const defaultCompare = (a, b) => a - b;
function useSorted(...args) {
  var _a, _b, _c, _d;
  const [source] = args;
  let compareFn = defaultCompare;
  let options = {};
  if (args.length === 2) {
    if (typeof args[1] === "object") {
      options = args[1];
      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;
    } else {
      compareFn = (_b = args[1]) != null ? _b : defaultCompare;
    }
  } else if (args.length > 2) {
    compareFn = (_c = args[1]) != null ? _c : defaultCompare;
    options = (_d = args[2]) != null ? _d : {};
  }
  const {
    dirty = false,
    sortFn = defaultSortFn
  } = options;
  if (!dirty)
    return computed(() => sortFn([...toValue(source)], compareFn));
  watchEffect(() => {
    const result = sortFn(toValue(source), compareFn);
    if (isRef(source))
      source.value = result;
    else
      source.splice(0, source.length, ...result);
  });
  return source;
}
function useSpeechRecognition(options = {}) {
  const {
    interimResults = true,
    continuous = true,
    maxAlternatives = 1,
    window: window2 = defaultWindow
  } = options;
  const lang = toRef(options.lang || "en-US");
  const isListening = shallowRef(false);
  const isFinal = shallowRef(false);
  const result = shallowRef("");
  const error = shallowRef(void 0);
  let recognition;
  const start = () => {
    isListening.value = true;
  };
  const stop = () => {
    isListening.value = false;
  };
  const toggle = (value = !isListening.value) => {
    if (value) {
      start();
    } else {
      stop();
    }
  };
  const SpeechRecognition = window2 && (window2.SpeechRecognition || window2.webkitSpeechRecognition);
  const isSupported = useSupported(() => SpeechRecognition);
  if (isSupported.value) {
    recognition = new SpeechRecognition();
    recognition.continuous = continuous;
    recognition.interimResults = interimResults;
    recognition.lang = toValue(lang);
    recognition.maxAlternatives = maxAlternatives;
    recognition.onstart = () => {
      isListening.value = true;
      isFinal.value = false;
    };
    watch(lang, (lang2) => {
      if (recognition && !isListening.value)
        recognition.lang = lang2;
    });
    recognition.onresult = (event) => {
      const currentResult = event.results[event.resultIndex];
      const { transcript } = currentResult[0];
      isFinal.value = currentResult.isFinal;
      result.value = transcript;
      error.value = void 0;
    };
    recognition.onerror = (event) => {
      error.value = event;
    };
    recognition.onend = () => {
      isListening.value = false;
      recognition.lang = toValue(lang);
    };
    watch(isListening, (newValue, oldValue) => {
      if (newValue === oldValue)
        return;
      if (newValue)
        recognition.start();
      else
        recognition.stop();
    });
  }
  tryOnScopeDispose(() => {
    stop();
  });
  return {
    isSupported,
    isListening,
    isFinal,
    recognition,
    result,
    error,
    toggle,
    start,
    stop
  };
}
function useSpeechSynthesis(text, options = {}) {
  const {
    pitch = 1,
    rate = 1,
    volume = 1,
    window: window2 = defaultWindow
  } = options;
  const synth = window2 && window2.speechSynthesis;
  const isSupported = useSupported(() => synth);
  const isPlaying = shallowRef(false);
  const status = shallowRef("init");
  const spokenText = toRef(text || "");
  const lang = toRef(options.lang || "en-US");
  const error = shallowRef(void 0);
  const toggle = (value = !isPlaying.value) => {
    isPlaying.value = value;
  };
  const bindEventsForUtterance = (utterance2) => {
    utterance2.lang = toValue(lang);
    utterance2.voice = toValue(options.voice) || null;
    utterance2.pitch = toValue(pitch);
    utterance2.rate = toValue(rate);
    utterance2.volume = volume;
    utterance2.onstart = () => {
      isPlaying.value = true;
      status.value = "play";
    };
    utterance2.onpause = () => {
      isPlaying.value = false;
      status.value = "pause";
    };
    utterance2.onresume = () => {
      isPlaying.value = true;
      status.value = "play";
    };
    utterance2.onend = () => {
      isPlaying.value = false;
      status.value = "end";
    };
    utterance2.onerror = (event) => {
      error.value = event;
    };
  };
  const utterance = computed(() => {
    isPlaying.value = false;
    status.value = "init";
    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
    bindEventsForUtterance(newUtterance);
    return newUtterance;
  });
  const speak = () => {
    synth.cancel();
    if (utterance)
      synth.speak(utterance.value);
  };
  const stop = () => {
    synth.cancel();
    isPlaying.value = false;
  };
  if (isSupported.value) {
    bindEventsForUtterance(utterance.value);
    watch(lang, (lang2) => {
      if (utterance.value && !isPlaying.value)
        utterance.value.lang = lang2;
    });
    if (options.voice) {
      watch(options.voice, () => {
        synth.cancel();
      });
    }
    watch(isPlaying, () => {
      if (isPlaying.value)
        synth.resume();
      else
        synth.pause();
    });
  }
  tryOnScopeDispose(() => {
    isPlaying.value = false;
  });
  return {
    isSupported,
    isPlaying,
    status,
    utterance,
    error,
    stop,
    toggle,
    speak
  };
}
function useStepper(steps, initialStep) {
  const stepsRef = ref(steps);
  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));
  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));
  const current = computed(() => at(index.value));
  const isFirst = computed(() => index.value === 0);
  const isLast = computed(() => index.value === stepNames.value.length - 1);
  const next = computed(() => stepNames.value[index.value + 1]);
  const previous = computed(() => stepNames.value[index.value - 1]);
  function at(index2) {
    if (Array.isArray(stepsRef.value))
      return stepsRef.value[index2];
    return stepsRef.value[stepNames.value[index2]];
  }
  function get(step) {
    if (!stepNames.value.includes(step))
      return;
    return at(stepNames.value.indexOf(step));
  }
  function goTo(step) {
    if (stepNames.value.includes(step))
      index.value = stepNames.value.indexOf(step);
  }
  function goToNext() {
    if (isLast.value)
      return;
    index.value++;
  }
  function goToPrevious() {
    if (isFirst.value)
      return;
    index.value--;
  }
  function goBackTo(step) {
    if (isAfter(step))
      goTo(step);
  }
  function isNext(step) {
    return stepNames.value.indexOf(step) === index.value + 1;
  }
  function isPrevious(step) {
    return stepNames.value.indexOf(step) === index.value - 1;
  }
  function isCurrent(step) {
    return stepNames.value.indexOf(step) === index.value;
  }
  function isBefore(step) {
    return index.value < stepNames.value.indexOf(step);
  }
  function isAfter(step) {
    return index.value > stepNames.value.indexOf(step);
  }
  return {
    steps: stepsRef,
    stepNames,
    index,
    current,
    next,
    previous,
    isFirst,
    isLast,
    at,
    get,
    goTo,
    goToNext,
    goToPrevious,
    goBackTo,
    isNext,
    isPrevious,
    isCurrent,
    isBefore,
    isAfter
  };
}
function useStorageAsync(key, initialValue, storage, options = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const rawInit = toValue(initialValue);
  const type = guessSerializerType(rawInit);
  const data = (shallow ? shallowRef : ref)(toValue(initialValue));
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorageAsync", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  async function read(event) {
    if (!storage || event && event.key !== key)
      return;
    try {
      const rawValue = event ? event.newValue : await storage.getItem(key);
      if (rawValue == null) {
        data.value = rawInit;
        if (writeDefaults && rawInit !== null)
          await storage.setItem(key, await serializer.write(rawInit));
      } else if (mergeDefaults) {
        const value = await serializer.read(rawValue);
        if (typeof mergeDefaults === "function")
          data.value = mergeDefaults(value, rawInit);
        else if (type === "object" && !Array.isArray(value))
          data.value = { ...rawInit, ...value };
        else data.value = value;
      } else {
        data.value = await serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    }
  }
  read();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e) => Promise.resolve().then(() => read(e)), { passive: true });
  if (storage) {
    watchWithFilter(
      data,
      async () => {
        try {
          if (data.value == null)
            await storage.removeItem(key);
          else
            await storage.setItem(key, await serializer.write(data.value));
        } catch (e) {
          onError(e);
        }
      },
      {
        flush,
        deep,
        eventFilter
      }
    );
  }
  return data;
}
let _id = 0;
function useStyleTag(css, options = {}) {
  const isLoaded = shallowRef(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id = `vueuse_styletag_${++_id}`
  } = options;
  const cssRef = shallowRef(css);
  let stop = () => {
  };
  const load = () => {
    if (!document2)
      return;
    const el = document2.getElementById(id) || document2.createElement("style");
    if (!el.isConnected) {
      el.id = id;
      if (options.nonce)
        el.nonce = options.nonce;
      if (options.media)
        el.media = options.media;
      document2.head.appendChild(el);
    }
    if (isLoaded.value)
      return;
    stop = watch(
      cssRef,
      (value) => {
        el.textContent = value;
      },
      { immediate: true }
    );
    isLoaded.value = true;
  };
  const unload = () => {
    if (!document2 || !isLoaded.value)
      return;
    stop();
    document2.head.removeChild(document2.getElementById(id));
    isLoaded.value = false;
  };
  if (immediate && !manual)
    tryOnMounted(load);
  if (!manual)
    tryOnScopeDispose(unload);
  return {
    id,
    css: cssRef,
    unload,
    load,
    isLoaded: readonly(isLoaded)
  };
}
function useSwipe(target, options = {}) {
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    passive = true
  } = options;
  const coordsStart = reactive({ x: 0, y: 0 });
  const coordsEnd = reactive({ x: 0, y: 0 });
  const diffX = computed(() => coordsStart.x - coordsEnd.x);
  const diffY = computed(() => coordsStart.y - coordsEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);
  const isSwiping = shallowRef(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(diffX.value) > abs(diffY.value)) {
      return diffX.value > 0 ? "left" : "right";
    } else {
      return diffY.value > 0 ? "up" : "down";
    }
  });
  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];
  const updateCoordsStart = (x, y) => {
    coordsStart.x = x;
    coordsStart.y = y;
  };
  const updateCoordsEnd = (x, y) => {
    coordsEnd.x = x;
    coordsEnd.y = y;
  };
  const listenerOptions = { passive, capture: !passive };
  const onTouchEnd = (e) => {
    if (isSwiping.value)
      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
    isSwiping.value = false;
  };
  const stops = [
    useEventListener(target, "touchstart", (e) => {
      if (e.touches.length !== 1)
        return;
      const [x, y] = getTouchEventCoords(e);
      updateCoordsStart(x, y);
      updateCoordsEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions),
    useEventListener(target, "touchmove", (e) => {
      if (e.touches.length !== 1)
        return;
      const [x, y] = getTouchEventCoords(e);
      updateCoordsEnd(x, y);
      if (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value))
        e.preventDefault();
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions),
    useEventListener(target, ["touchend", "touchcancel"], onTouchEnd, listenerOptions)
  ];
  const stop = () => stops.forEach((s) => s());
  return {
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop,
    // TODO: Remove in the next major version
    isPassiveEventSupported: true
  };
}
function useTemplateRefsList() {
  const refs = ref([]);
  refs.value.set = (el) => {
    if (el)
      refs.value.push(el);
  };
  onBeforeUpdate(() => {
    refs.value.length = 0;
  });
  return refs;
}
function useTextDirection(options = {}) {
  const {
    document: document2 = defaultDocument,
    selector = "html",
    observe = false,
    initialValue = "ltr"
  } = options;
  function getValue2() {
    var _a, _b;
    return (_b = (_a = document2 == null ? void 0 : document2.querySelector(selector)) == null ? void 0 : _a.getAttribute("dir")) != null ? _b : initialValue;
  }
  const dir = ref(getValue2());
  tryOnMounted(() => dir.value = getValue2());
  if (observe && document2) {
    useMutationObserver(
      document2.querySelector(selector),
      () => dir.value = getValue2(),
      { attributes: true }
    );
  }
  return computed({
    get() {
      return dir.value;
    },
    set(v) {
      var _a, _b;
      dir.value = v;
      if (!document2)
        return;
      if (dir.value)
        (_a = document2.querySelector(selector)) == null ? void 0 : _a.setAttribute("dir", dir.value);
      else
        (_b = document2.querySelector(selector)) == null ? void 0 : _b.removeAttribute("dir");
    }
  });
}
function getRangesFromSelection(selection) {
  var _a;
  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;
  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));
}
function useTextSelection(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const selection = ref(null);
  const text = computed(() => {
    var _a, _b;
    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : "";
  });
  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);
  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));
  function onSelectionChange() {
    selection.value = null;
    if (window2)
      selection.value = window2.getSelection();
  }
  if (window2)
    useEventListener(window2.document, "selectionchange", onSelectionChange, { passive: true });
  return {
    text,
    rects,
    ranges,
    selection
  };
}
function tryRequestAnimationFrame(window2 = defaultWindow, fn) {
  if (window2 && typeof window2.requestAnimationFrame === "function") {
    window2.requestAnimationFrame(fn);
  } else {
    fn();
  }
}
function useTextareaAutosize(options = {}) {
  var _a, _b;
  const { window: window2 = defaultWindow } = options;
  const textarea = toRef(options == null ? void 0 : options.element);
  const input = toRef((_a = options == null ? void 0 : options.input) != null ? _a : "");
  const styleProp = (_b = options == null ? void 0 : options.styleProp) != null ? _b : "height";
  const textareaScrollHeight = shallowRef(1);
  const textareaOldWidth = shallowRef(0);
  function triggerResize() {
    var _a2;
    if (!textarea.value)
      return;
    let height = "";
    textarea.value.style[styleProp] = "1px";
    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;
    const _styleTarget = toValue(options == null ? void 0 : options.styleTarget);
    if (_styleTarget)
      _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;
    else
      height = `${textareaScrollHeight.value}px`;
    textarea.value.style[styleProp] = height;
  }
  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });
  watch(textareaScrollHeight, () => {
    var _a2;
    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);
  });
  useResizeObserver(textarea, ([{ contentRect }]) => {
    if (textareaOldWidth.value === contentRect.width)
      return;
    tryRequestAnimationFrame(window2, () => {
      textareaOldWidth.value = contentRect.width;
      triggerResize();
    });
  });
  if (options == null ? void 0 : options.watch)
    watch(options.watch, triggerResize, { immediate: true, deep: true });
  return {
    textarea,
    input,
    triggerResize
  };
}
function useThrottledRefHistory(source, options = {}) {
  const { throttle = 200, trailing = true } = options;
  const filter = throttleFilter(throttle, trailing);
  const history = useRefHistory(source, { ...options, eventFilter: filter });
  return {
    ...history
  };
}
const DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: (n) => n.match(/\d/) ? `${n} ago` : n,
  future: (n) => n.match(/\d/) ? `in ${n}` : n,
  month: (n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`,
  year: (n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`,
  day: (n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`,
  week: (n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`,
  hour: (n) => `${n} hour${n > 1 ? "s" : ""}`,
  minute: (n) => `${n} minute${n > 1 ? "s" : ""}`,
  second: (n) => `${n} second${n > 1 ? "s" : ""}`,
  invalid: ""
};
function DEFAULT_FORMATTER(date) {
  return date.toISOString().slice(0, 10);
}
function useTimeAgo(time, options = {}) {
  const {
    controls: exposeControls = false,
    updateInterval = 3e4
  } = options;
  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });
  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));
  if (exposeControls) {
    return {
      timeAgo,
      ...controls
    };
  } else {
    return timeAgo;
  }
}
function formatTimeAgo(from, options = {}, now = Date.now()) {
  var _a;
  const {
    max,
    messages = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER,
    units = DEFAULT_UNITS,
    showSecond = false,
    rounding = "round"
  } = options;
  const roundFn = typeof rounding === "number" ? (n) => +n.toFixed(rounding) : Math[rounding];
  const diff = +now - +from;
  const absDiff = Math.abs(diff);
  function getValue2(diff2, unit) {
    return roundFn(Math.abs(diff2) / unit.value);
  }
  function format(diff2, unit) {
    const val = getValue2(diff2, unit);
    const past = diff2 > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }
  function applyFormat(name, val, isPast) {
    const formatter = messages[name];
    if (typeof formatter === "function")
      return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }
  if (absDiff < 6e4 && !showSecond)
    return messages.justNow;
  if (typeof max === "number" && absDiff > max)
    return fullDateFormatter(new Date(from));
  if (typeof max === "string") {
    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;
    if (unitMax && absDiff > unitMax)
      return fullDateFormatter(new Date(from));
  }
  for (const [idx, unit] of units.entries()) {
    const val = getValue2(diff, unit);
    if (val <= 0 && units[idx - 1])
      return format(diff, units[idx - 1]);
    if (absDiff < unit.max)
      return format(diff, unit);
  }
  return messages.invalid;
}
function useTimeoutPoll(fn, interval, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  const { start } = useTimeoutFn(loop, interval, { immediate });
  const isActive = shallowRef(false);
  async function loop() {
    if (!isActive.value)
      return;
    await fn();
    start();
  }
  function resume() {
    if (!isActive.value) {
      isActive.value = true;
      if (immediateCallback)
        fn();
      start();
    }
  }
  function pause() {
    isActive.value = false;
  }
  if (immediate && isClient)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useTimestamp(options = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval = "requestAnimationFrame",
    callback
  } = options;
  const ts = shallowRef(timestamp() + offset);
  const update = () => ts.value = timestamp() + offset;
  const cb = callback ? () => {
    update();
    callback(ts.value);
  } : update;
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  if (exposeControls) {
    return {
      timestamp: ts,
      ...controls
    };
  } else {
    return ts;
  }
}
function useTitle(newTitle = null, options = {}) {
  var _a, _b, _c;
  const {
    document: document2 = defaultDocument,
    restoreOnUnmount = (t) => t
  } = options;
  const originalTitle = (_a = document2 == null ? void 0 : document2.title) != null ? _a : "";
  const title = toRef((_b = newTitle != null ? newTitle : document2 == null ? void 0 : document2.title) != null ? _b : null);
  const isReadonly2 = !!(newTitle && typeof newTitle === "function");
  function format(t) {
    if (!("titleTemplate" in options))
      return t;
    const template = options.titleTemplate || "%s";
    return typeof template === "function" ? template(t) : toValue(template).replace(/%s/g, t);
  }
  watch(
    title,
    (newValue, oldValue) => {
      if (newValue !== oldValue && document2)
        document2.title = format(newValue != null ? newValue : "");
    },
    { immediate: true }
  );
  if (options.observe && !options.titleTemplate && document2 && !isReadonly2) {
    useMutationObserver(
      (_c = document2.head) == null ? void 0 : _c.querySelector("title"),
      () => {
        if (document2 && document2.title !== title.value)
          title.value = format(document2.title);
      },
      { childList: true }
    );
  }
  tryOnScopeDispose(() => {
    if (restoreOnUnmount) {
      const restoredTitle = restoreOnUnmount(originalTitle, title.value || "");
      if (restoredTitle != null && document2)
        document2.title = restoredTitle;
    }
  });
  return title;
}
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
const TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);
function createEasingFunction([p0, p1, p2, p3]) {
  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;
  const b = (a1, a2) => 3 * a2 - 6 * a1;
  const c = (a1) => 3 * a1;
  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
  const getTforX = (x) => {
    let aGuessT = x;
    for (let i = 0; i < 4; ++i) {
      const currentSlope = getSlope(aGuessT, p0, p2);
      if (currentSlope === 0)
        return aGuessT;
      const currentX = calcBezier(aGuessT, p0, p2) - x;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);
}
function lerp(a, b, alpha) {
  return a + alpha * (b - a);
}
function toVec(t) {
  return (typeof t === "number" ? [t] : t) || [];
}
function executeTransition(source, from, to, options = {}) {
  var _a, _b;
  const fromVal = toValue(from);
  const toVal = toValue(to);
  const v1 = toVec(fromVal);
  const v2 = toVec(toVal);
  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;
  const startedAt = Date.now();
  const endAt = Date.now() + duration;
  const trans = typeof options.transition === "function" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;
  const ease = typeof trans === "function" ? trans : createEasingFunction(trans);
  return new Promise((resolve) => {
    source.value = fromVal;
    const tick = () => {
      var _a2;
      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {
        resolve();
        return;
      }
      const now = Date.now();
      const alpha = ease((now - startedAt) / duration);
      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));
      if (Array.isArray(source.value))
        source.value = arr.map((n, i) => {
          var _a3, _b2;
          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);
        });
      else if (typeof source.value === "number")
        source.value = arr[0];
      if (now < endAt) {
        requestAnimationFrame(tick);
      } else {
        source.value = toVal;
        resolve();
      }
    };
    tick();
  });
}
function useTransition(source, options = {}) {
  let currentId = 0;
  const sourceVal = () => {
    const v = toValue(source);
    return typeof v === "number" ? v : v.map(toValue);
  };
  const outputRef = ref(sourceVal());
  watch(sourceVal, async (to) => {
    var _a, _b;
    if (toValue(options.disabled))
      return;
    const id = ++currentId;
    if (options.delay)
      await promiseTimeout(toValue(options.delay));
    if (id !== currentId)
      return;
    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);
    (_a = options.onStarted) == null ? void 0 : _a.call(options);
    await executeTransition(outputRef, outputRef.value, toVal, {
      ...options,
      abort: () => {
        var _a2;
        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));
      }
    });
    (_b = options.onFinished) == null ? void 0 : _b.call(options);
  }, { deep: true });
  watch(() => toValue(options.disabled), (disabled) => {
    if (disabled) {
      currentId++;
      outputRef.value = sourceVal();
    }
  });
  tryOnScopeDispose(() => {
    currentId++;
  });
  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);
}
function useUrlSearchParams(mode = "history", options = {}) {
  const {
    initialValue = {},
    removeNullishValues = true,
    removeFalsyValues = false,
    write: enableWrite = true,
    writeMode = "replace",
    window: window2 = defaultWindow,
    stringify = (params) => params.toString()
  } = options;
  if (!window2)
    return reactive(initialValue);
  const state = reactive({});
  function getRawParams() {
    if (mode === "history") {
      return window2.location.search || "";
    } else if (mode === "hash") {
      const hash = window2.location.hash || "";
      const index = hash.indexOf("?");
      return index > 0 ? hash.slice(index) : "";
    } else {
      return (window2.location.hash || "").replace(/^#/, "");
    }
  }
  function constructQuery(params) {
    const stringified = stringify(params);
    if (mode === "history")
      return `${stringified ? `?${stringified}` : ""}${window2.location.hash || ""}`;
    if (mode === "hash-params")
      return `${window2.location.search || ""}${stringified ? `#${stringified}` : ""}`;
    const hash = window2.location.hash || "#";
    const index = hash.indexOf("?");
    if (index > 0)
      return `${window2.location.search || ""}${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
    return `${window2.location.search || ""}${hash}${stringified ? `?${stringified}` : ""}`;
  }
  function read() {
    return new URLSearchParams(getRawParams());
  }
  function updateState(params) {
    const unusedKeys = new Set(Object.keys(state));
    for (const key of params.keys()) {
      const paramsForKey = params.getAll(key);
      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || "";
      unusedKeys.delete(key);
    }
    Array.from(unusedKeys).forEach((key) => delete state[key]);
  }
  const { pause, resume } = pausableWatch(
    state,
    () => {
      const params = new URLSearchParams("");
      Object.keys(state).forEach((key) => {
        const mapEntry = state[key];
        if (Array.isArray(mapEntry))
          mapEntry.forEach((value) => params.append(key, value));
        else if (removeNullishValues && mapEntry == null)
          params.delete(key);
        else if (removeFalsyValues && !mapEntry)
          params.delete(key);
        else
          params.set(key, mapEntry);
      });
      write(params, false);
    },
    { deep: true }
  );
  function write(params, shouldUpdate) {
    pause();
    if (shouldUpdate)
      updateState(params);
    if (writeMode === "replace") {
      window2.history.replaceState(
        window2.history.state,
        window2.document.title,
        window2.location.pathname + constructQuery(params)
      );
    } else {
      window2.history.pushState(
        window2.history.state,
        window2.document.title,
        window2.location.pathname + constructQuery(params)
      );
    }
    resume();
  }
  function onChanged() {
    if (!enableWrite)
      return;
    write(read(), true);
  }
  const listenerOptions = { passive: true };
  useEventListener(window2, "popstate", onChanged, listenerOptions);
  if (mode !== "history")
    useEventListener(window2, "hashchange", onChanged, listenerOptions);
  const initial = read();
  if (initial.keys().next().value)
    updateState(initial);
  else
    Object.assign(state, initialValue);
  return state;
}
function useUserMedia(options = {}) {
  var _a, _b;
  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);
  const autoSwitch = shallowRef((_b = options.autoSwitch) != null ? _b : true);
  const constraints = ref(options.constraints);
  const { navigator: navigator2 = defaultNavigator } = options;
  const isSupported = useSupported(() => {
    var _a2;
    return (_a2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _a2.getUserMedia;
  });
  const stream = shallowRef();
  function getDeviceOptions(type) {
    switch (type) {
      case "video": {
        if (constraints.value)
          return constraints.value.video || false;
        break;
      }
      case "audio": {
        if (constraints.value)
          return constraints.value.audio || false;
        break;
      }
    }
  }
  async function _start() {
    if (!isSupported.value || stream.value)
      return;
    stream.value = await navigator2.mediaDevices.getUserMedia({
      video: getDeviceOptions("video"),
      audio: getDeviceOptions("audio")
    });
    return stream.value;
  }
  function _stop() {
    var _a2;
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());
    stream.value = void 0;
  }
  function stop() {
    _stop();
    enabled.value = false;
  }
  async function start() {
    await _start();
    if (stream.value)
      enabled.value = true;
    return stream.value;
  }
  async function restart() {
    _stop();
    return await start();
  }
  watch(
    enabled,
    (v) => {
      if (v)
        _start();
      else _stop();
    },
    { immediate: true }
  );
  watch(
    constraints,
    () => {
      if (autoSwitch.value && stream.value)
        restart();
    },
    { immediate: true }
  );
  tryOnScopeDispose(() => {
    stop();
  });
  return {
    isSupported,
    stream,
    start,
    stop,
    restart,
    constraints,
    enabled,
    autoSwitch
  };
}
function useVModel(props, key, emit, options = {}) {
  var _a, _b, _c;
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  if (!key) {
    key = "modelValue";
  }
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
  const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v) => {
        if (!isUpdating && (v !== props[key] || deep))
          triggerEmit(v);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}
function useVModels(props, emit, options = {}) {
  const ret = {};
  for (const key in props) {
    ret[key] = useVModel(
      props,
      key,
      emit,
      options
    );
  }
  return ret;
}
function useVibrate(options) {
  const {
    pattern = [],
    interval = 0,
    navigator: navigator2 = defaultNavigator
  } = options || {};
  const isSupported = useSupported(() => typeof navigator2 !== "undefined" && "vibrate" in navigator2);
  const patternRef = toRef(pattern);
  let intervalControls;
  const vibrate = (pattern2 = patternRef.value) => {
    if (isSupported.value)
      navigator2.vibrate(pattern2);
  };
  const stop = () => {
    if (isSupported.value)
      navigator2.vibrate(0);
    intervalControls == null ? void 0 : intervalControls.pause();
  };
  if (interval > 0) {
    intervalControls = useIntervalFn(
      vibrate,
      interval,
      {
        immediate: false,
        immediateCallback: false
      }
    );
  }
  return {
    isSupported,
    pattern,
    intervalControls,
    vibrate,
    stop
  };
}
function useVirtualList(list, options) {
  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = "itemHeight" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);
  return {
    list: currentList,
    scrollTo,
    containerProps: {
      ref: containerRef,
      onScroll: () => {
        calculateRange();
      },
      style: containerStyle
    },
    wrapperProps
  };
}
function useVirtualListResources(list) {
  const containerRef = shallowRef(null);
  const size = useElementSize(containerRef);
  const currentList = ref([]);
  const source = shallowRef(list);
  const state = ref({ start: 0, end: 10 });
  return { state, source, currentList, size, containerRef };
}
function createGetViewCapacity(state, source, itemSize) {
  return (containerSize) => {
    if (typeof itemSize === "number")
      return Math.ceil(containerSize / itemSize);
    const { start = 0 } = state.value;
    let sum = 0;
    let capacity = 0;
    for (let i = start; i < source.value.length; i++) {
      const size = itemSize(i);
      sum += size;
      capacity = i;
      if (sum > containerSize)
        break;
    }
    return capacity - start;
  };
}
function createGetOffset(source, itemSize) {
  return (scrollDirection) => {
    if (typeof itemSize === "number")
      return Math.floor(scrollDirection / itemSize) + 1;
    let sum = 0;
    let offset = 0;
    for (let i = 0; i < source.value.length; i++) {
      const size = itemSize(i);
      sum += size;
      if (sum >= scrollDirection) {
        offset = i;
        break;
      }
    }
    return offset + 1;
  };
}
function createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {
  return () => {
    const element = containerRef.value;
    if (element) {
      const offset = getOffset(type === "vertical" ? element.scrollTop : element.scrollLeft);
      const viewCapacity = getViewCapacity(type === "vertical" ? element.clientHeight : element.clientWidth);
      const from = offset - overscan;
      const to = offset + viewCapacity + overscan;
      state.value = {
        start: from < 0 ? 0 : from,
        end: to > source.value.length ? source.value.length : to
      };
      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({
        data: ele,
        index: index + state.value.start
      }));
    }
  };
}
function createGetDistance(itemSize, source) {
  return (index) => {
    if (typeof itemSize === "number") {
      const size2 = index * itemSize;
      return size2;
    }
    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);
    return size;
  };
}
function useWatchForSizes(size, list, containerRef, calculateRange) {
  watch([size.width, size.height, list, containerRef], () => {
    calculateRange();
  });
}
function createComputedTotalSize(itemSize, source) {
  return computed(() => {
    if (typeof itemSize === "number")
      return source.value.length * itemSize;
    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);
  });
}
const scrollToDictionaryForElementScrollKey = {
  horizontal: "scrollLeft",
  vertical: "scrollTop"
};
function createScrollTo(type, calculateRange, getDistance, containerRef) {
  return (index) => {
    if (containerRef.value) {
      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);
      calculateRange();
    }
  };
}
function useHorizontalVirtualList(options, list) {
  const resources = useVirtualListResources(list);
  const { state, source, currentList, size, containerRef } = resources;
  const containerStyle = { overflowX: "auto" };
  const { itemWidth, overscan = 5 } = options;
  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);
  const getOffset = createGetOffset(source, itemWidth);
  const calculateRange = createCalculateRange("horizontal", overscan, getOffset, getViewCapacity, resources);
  const getDistanceLeft = createGetDistance(itemWidth, source);
  const offsetLeft = computed(() => getDistanceLeft(state.value.start));
  const totalWidth = createComputedTotalSize(itemWidth, source);
  useWatchForSizes(size, list, containerRef, calculateRange);
  const scrollTo = createScrollTo("horizontal", calculateRange, getDistanceLeft, containerRef);
  const wrapperProps = computed(() => {
    return {
      style: {
        height: "100%",
        width: `${totalWidth.value - offsetLeft.value}px`,
        marginLeft: `${offsetLeft.value}px`,
        display: "flex"
      }
    };
  });
  return {
    scrollTo,
    calculateRange,
    wrapperProps,
    containerStyle,
    currentList,
    containerRef
  };
}
function useVerticalVirtualList(options, list) {
  const resources = useVirtualListResources(list);
  const { state, source, currentList, size, containerRef } = resources;
  const containerStyle = { overflowY: "auto" };
  const { itemHeight, overscan = 5 } = options;
  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);
  const getOffset = createGetOffset(source, itemHeight);
  const calculateRange = createCalculateRange("vertical", overscan, getOffset, getViewCapacity, resources);
  const getDistanceTop = createGetDistance(itemHeight, source);
  const offsetTop = computed(() => getDistanceTop(state.value.start));
  const totalHeight = createComputedTotalSize(itemHeight, source);
  useWatchForSizes(size, list, containerRef, calculateRange);
  const scrollTo = createScrollTo("vertical", calculateRange, getDistanceTop, containerRef);
  const wrapperProps = computed(() => {
    return {
      style: {
        width: "100%",
        height: `${totalHeight.value - offsetTop.value}px`,
        marginTop: `${offsetTop.value}px`
      }
    };
  });
  return {
    calculateRange,
    scrollTo,
    containerStyle,
    wrapperProps,
    currentList,
    containerRef
  };
}
function useWakeLock(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    document: document2 = defaultDocument
  } = options;
  const requestedType = shallowRef(false);
  const sentinel = shallowRef(null);
  const documentVisibility = useDocumentVisibility({ document: document2 });
  const isSupported = useSupported(() => navigator2 && "wakeLock" in navigator2);
  const isActive = computed(() => !!sentinel.value && documentVisibility.value === "visible");
  if (isSupported.value) {
    useEventListener(sentinel, "release", () => {
      var _a, _b;
      requestedType.value = (_b = (_a = sentinel.value) == null ? void 0 : _a.type) != null ? _b : false;
    }, { passive: true });
    whenever(
      () => documentVisibility.value === "visible" && (document2 == null ? void 0 : document2.visibilityState) === "visible" && requestedType.value,
      (type) => {
        requestedType.value = false;
        forceRequest(type);
      }
    );
  }
  async function forceRequest(type) {
    var _a;
    await ((_a = sentinel.value) == null ? void 0 : _a.release());
    sentinel.value = isSupported.value ? await navigator2.wakeLock.request(type) : null;
  }
  async function request(type) {
    if (documentVisibility.value === "visible")
      await forceRequest(type);
    else
      requestedType.value = type;
  }
  async function release() {
    requestedType.value = false;
    const s = sentinel.value;
    sentinel.value = null;
    await (s == null ? void 0 : s.release());
  }
  return {
    sentinel,
    isSupported,
    isActive,
    request,
    forceRequest,
    release
  };
}
function useWebNotification(options = {}) {
  const {
    window: window2 = defaultWindow,
    requestPermissions: _requestForPermissions = true
  } = options;
  const defaultWebNotificationOptions = options;
  const isSupported = useSupported(() => {
    if (!window2 || !("Notification" in window2))
      return false;
    if (Notification.permission === "granted")
      return true;
    try {
      const notification2 = new Notification("");
      notification2.onshow = () => {
        notification2.close();
      };
    } catch (e) {
      if (e.name === "TypeError")
        return false;
    }
    return true;
  });
  const permissionGranted = shallowRef(isSupported.value && "permission" in Notification && Notification.permission === "granted");
  const notification = ref(null);
  const ensurePermissions = async () => {
    if (!isSupported.value)
      return;
    if (!permissionGranted.value && Notification.permission !== "denied") {
      const result = await Notification.requestPermission();
      if (result === "granted")
        permissionGranted.value = true;
    }
    return permissionGranted.value;
  };
  const { on: onClick, trigger: clickTrigger } = createEventHook();
  const { on: onShow, trigger: showTrigger } = createEventHook();
  const { on: onError, trigger: errorTrigger } = createEventHook();
  const { on: onClose, trigger: closeTrigger } = createEventHook();
  const show = async (overrides) => {
    if (!isSupported.value || !permissionGranted.value)
      return;
    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);
    notification.value = new Notification(options2.title || "", options2);
    notification.value.onclick = clickTrigger;
    notification.value.onshow = showTrigger;
    notification.value.onerror = errorTrigger;
    notification.value.onclose = closeTrigger;
    return notification.value;
  };
  const close = () => {
    if (notification.value)
      notification.value.close();
    notification.value = null;
  };
  if (_requestForPermissions)
    tryOnMounted(ensurePermissions);
  tryOnScopeDispose(close);
  if (isSupported.value && window2) {
    const document2 = window2.document;
    useEventListener(document2, "visibilitychange", (e) => {
      e.preventDefault();
      if (document2.visibilityState === "visible") {
        close();
      }
    });
  }
  return {
    isSupported,
    notification,
    ensurePermissions,
    permissionGranted,
    show,
    close,
    onClick,
    onShow,
    onError,
    onClose
  };
}
const DEFAULT_PING_MESSAGE = "ping";
function resolveNestedOptions(options) {
  if (options === true)
    return {};
  return options;
}
function useWebSocket(url, options = {}) {
  const {
    onConnected,
    onDisconnected,
    onError,
    onMessage,
    immediate = true,
    autoConnect = true,
    autoClose = true,
    protocols = []
  } = options;
  const data = ref(null);
  const status = shallowRef("CLOSED");
  const wsRef = ref();
  const urlRef = toRef(url);
  let heartbeatPause;
  let heartbeatResume;
  let explicitlyClosed = false;
  let retried = 0;
  let bufferedData = [];
  let retryTimeout;
  let pongTimeoutWait;
  const _sendBuffer = () => {
    if (bufferedData.length && wsRef.value && status.value === "OPEN") {
      for (const buffer of bufferedData)
        wsRef.value.send(buffer);
      bufferedData = [];
    }
  };
  const resetRetry = () => {
    if (retryTimeout != null) {
      clearTimeout(retryTimeout);
      retryTimeout = void 0;
    }
  };
  const resetHeartbeat = () => {
    clearTimeout(pongTimeoutWait);
    pongTimeoutWait = void 0;
  };
  const close = (code = 1e3, reason) => {
    resetRetry();
    if (!isClient && !isWorker || !wsRef.value)
      return;
    explicitlyClosed = true;
    resetHeartbeat();
    heartbeatPause == null ? void 0 : heartbeatPause();
    wsRef.value.close(code, reason);
    wsRef.value = void 0;
  };
  const send = (data2, useBuffer = true) => {
    if (!wsRef.value || status.value !== "OPEN") {
      if (useBuffer)
        bufferedData.push(data2);
      return false;
    }
    _sendBuffer();
    wsRef.value.send(data2);
    return true;
  };
  const _init = () => {
    if (explicitlyClosed || typeof urlRef.value === "undefined")
      return;
    const ws = new WebSocket(urlRef.value, protocols);
    wsRef.value = ws;
    status.value = "CONNECTING";
    ws.onopen = () => {
      status.value = "OPEN";
      retried = 0;
      onConnected == null ? void 0 : onConnected(ws);
      heartbeatResume == null ? void 0 : heartbeatResume();
      _sendBuffer();
    };
    ws.onclose = (ev) => {
      status.value = "CLOSED";
      resetHeartbeat();
      heartbeatPause == null ? void 0 : heartbeatPause();
      onDisconnected == null ? void 0 : onDisconnected(ws, ev);
      if (!explicitlyClosed && options.autoReconnect && (wsRef.value == null || ws === wsRef.value)) {
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions(options.autoReconnect);
        const checkRetires = typeof retries === "function" ? retries : () => typeof retries === "number" && (retries < 0 || retried < retries);
        if (checkRetires(retried)) {
          retried += 1;
          retryTimeout = setTimeout(_init, delay);
        } else {
          onFailed == null ? void 0 : onFailed();
        }
      }
    };
    ws.onerror = (e) => {
      onError == null ? void 0 : onError(ws, e);
    };
    ws.onmessage = (e) => {
      if (options.heartbeat) {
        resetHeartbeat();
        const {
          message = DEFAULT_PING_MESSAGE,
          responseMessage = message
        } = resolveNestedOptions(options.heartbeat);
        if (e.data === toValue(responseMessage))
          return;
      }
      data.value = e.data;
      onMessage == null ? void 0 : onMessage(ws, e);
    };
  };
  if (options.heartbeat) {
    const {
      message = DEFAULT_PING_MESSAGE,
      interval = 1e3,
      pongTimeout = 1e3
    } = resolveNestedOptions(options.heartbeat);
    const { pause, resume } = useIntervalFn(
      () => {
        send(toValue(message), false);
        if (pongTimeoutWait != null)
          return;
        pongTimeoutWait = setTimeout(() => {
          close();
          explicitlyClosed = false;
        }, pongTimeout);
      },
      interval,
      { immediate: false }
    );
    heartbeatPause = pause;
    heartbeatResume = resume;
  }
  if (autoClose) {
    if (isClient)
      useEventListener("beforeunload", () => close(), { passive: true });
    tryOnScopeDispose(close);
  }
  const open = () => {
    if (!isClient && !isWorker)
      return;
    close();
    explicitlyClosed = false;
    retried = 0;
    _init();
  };
  if (immediate)
    open();
  if (autoConnect)
    watch(urlRef, open);
  return {
    data,
    status,
    close,
    send,
    open,
    ws: wsRef
  };
}
function useWebWorker(arg0, workerOptions, options) {
  const {
    window: window2 = defaultWindow
  } = options != null ? options : {};
  const data = ref(null);
  const worker = shallowRef();
  const post = (...args) => {
    if (!worker.value)
      return;
    worker.value.postMessage(...args);
  };
  const terminate = function terminate2() {
    if (!worker.value)
      return;
    worker.value.terminate();
  };
  if (window2) {
    if (typeof arg0 === "string")
      worker.value = new Worker(arg0, workerOptions);
    else if (typeof arg0 === "function")
      worker.value = arg0();
    else
      worker.value = arg0;
    worker.value.onmessage = (e) => {
      data.value = e.data;
    };
    tryOnScopeDispose(() => {
      if (worker.value)
        worker.value.terminate();
    });
  }
  return {
    data,
    post,
    terminate,
    worker
  };
}
function depsParser(deps, localDeps) {
  if (deps.length === 0 && localDeps.length === 0)
    return "";
  const depsString = deps.map((dep) => `'${dep}'`).toString();
  const depsFunctionString = localDeps.filter((dep) => typeof dep === "function").map((fn) => {
    const str = fn.toString();
    if (str.trim().startsWith("function")) {
      return str;
    } else {
      const name = fn.name;
      return `const ${name} = ${str}`;
    }
  }).join(";");
  const importString = `importScripts(${depsString});`;
  return `${depsString.trim() === "" ? "" : importString} ${depsFunctionString}`;
}
function jobRunner(userFunc) {
  return (e) => {
    const userFuncArgs = e.data[0];
    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {
      postMessage(["SUCCESS", result]);
    }).catch((error) => {
      postMessage(["ERROR", error]);
    });
  };
}
function createWorkerBlobUrl(fn, deps, localDeps) {
  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;
  const blob = new Blob([blobCode], { type: "text/javascript" });
  const url = URL.createObjectURL(blob);
  return url;
}
function useWebWorkerFn(fn, options = {}) {
  const {
    dependencies = [],
    localDependencies = [],
    timeout,
    window: window2 = defaultWindow
  } = options;
  const worker = ref();
  const workerStatus = shallowRef("PENDING");
  const promise = ref({});
  const timeoutId = shallowRef();
  const workerTerminate = (status = "PENDING") => {
    if (worker.value && worker.value._url && window2) {
      worker.value.terminate();
      URL.revokeObjectURL(worker.value._url);
      promise.value = {};
      worker.value = void 0;
      window2.clearTimeout(timeoutId.value);
      workerStatus.value = status;
    }
  };
  workerTerminate();
  tryOnScopeDispose(workerTerminate);
  const generateWorker = () => {
    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;
    newWorker.onmessage = (e) => {
      const { resolve = () => {
      }, reject = () => {
      } } = promise.value;
      const [status, result] = e.data;
      switch (status) {
        case "SUCCESS":
          resolve(result);
          workerTerminate(status);
          break;
        default:
          reject(result);
          workerTerminate("ERROR");
          break;
      }
    };
    newWorker.onerror = (e) => {
      const { reject = () => {
      } } = promise.value;
      e.preventDefault();
      reject(e);
      workerTerminate("ERROR");
    };
    if (timeout) {
      timeoutId.value = setTimeout(
        () => workerTerminate("TIMEOUT_EXPIRED"),
        timeout
      );
    }
    return newWorker;
  };
  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {
    var _a;
    promise.value = {
      resolve,
      reject
    };
    (_a = worker.value) == null ? void 0 : _a.postMessage([[...fnArgs]]);
    workerStatus.value = "RUNNING";
  });
  const workerFn = (...fnArgs) => {
    if (workerStatus.value === "RUNNING") {
      console.error(
        "[useWebWorkerFn] You can only run one instance of the worker at a time."
      );
      return Promise.reject();
    }
    worker.value = generateWorker();
    return callWorker(...fnArgs);
  };
  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
}
function useWindowFocus(options = {}) {
  const { window: window2 = defaultWindow } = options;
  if (!window2)
    return shallowRef(false);
  const focused = shallowRef(window2.document.hasFocus());
  const listenerOptions = { passive: true };
  useEventListener(window2, "blur", () => {
    focused.value = false;
  }, listenerOptions);
  useEventListener(window2, "focus", () => {
    focused.value = true;
  }, listenerOptions);
  return focused;
}
function useWindowScroll(options = {}) {
  const { window: window2 = defaultWindow, ...rest } = options;
  return useScroll(window2, rest);
}
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true,
    type = "inner"
  } = options;
  const width = shallowRef(initialWidth);
  const height = shallowRef(initialHeight);
  const update = () => {
    if (window2) {
      if (type === "outer") {
        width.value = window2.outerWidth;
        height.value = window2.outerHeight;
      } else if (type === "visual" && window2.visualViewport) {
        const { width: visualViewportWidth, height: visualViewportHeight, scale } = window2.visualViewport;
        width.value = Math.round(visualViewportWidth * scale);
        height.value = Math.round(visualViewportHeight * scale);
      } else if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  const listenerOptions = { passive: true };
  useEventListener("resize", update, listenerOptions);
  if (window2 && type === "visual" && window2.visualViewport) {
    useEventListener(window2.visualViewport, "resize", update, listenerOptions);
  }
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch(matches, () => update());
  }
  return { width, height };
}
export { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsElement, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onElementRemoval, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, provideSSRWidth, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCountdown, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePreferredReducedTransparency, usePrevious, useRafFn, useRefHistory, useResizeObserver, useSSRWidth, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4Lm1qcz92PTEyMTRhODUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5vb3AsIG1ha2VEZXN0cnVjdHVyYWJsZSwgY2FtZWxpemUsIGlzQ2xpZW50LCB0b0FycmF5LCB3YXRjaEltbWVkaWF0ZSwgaXNPYmplY3QsIHRyeU9uU2NvcGVEaXNwb3NlLCBpc0lPUywgbm90TnVsbGlzaCwgdHJ5T25Nb3VudGVkLCBvYmplY3RPbWl0LCBwcm9taXNlVGltZW91dCwgdW50aWwsIGluamVjdExvY2FsLCBwcm92aWRlTG9jYWwsIHB4VmFsdWUsIGluY3JlYXNlV2l0aFVuaXQsIG9iamVjdEVudHJpZXMsIGNyZWF0ZVJlZiwgY3JlYXRlU2luZ2xldG9uUHJvbWlzZSwgdXNlVGltZW91dEZuLCBwYXVzYWJsZVdhdGNoLCB0b1JlZiwgY3JlYXRlRXZlbnRIb29rLCB1c2VJbnRlcnZhbEZuLCBjb21wdXRlZFdpdGhDb250cm9sLCB0aW1lc3RhbXAsIHBhdXNhYmxlRmlsdGVyLCB3YXRjaElnbm9yYWJsZSwgZGVib3VuY2VGaWx0ZXIsIGJ5cGFzc0ZpbHRlciwgY3JlYXRlRmlsdGVyV3JhcHBlciwgdG9SZWZzLCB3YXRjaE9uY2UsIGNvbnRhaW5zUHJvcCwgaGFzT3duLCB0aHJvdHRsZUZpbHRlciwgdXNlRGVib3VuY2VGbiwgdXNlVGhyb3R0bGVGbiwgdHJ5T25Vbm1vdW50ZWQsIGNsYW1wLCBzeW5jUmVmLCBvYmplY3RQaWNrLCB3YXRjaFdpdGhGaWx0ZXIsIGlkZW50aXR5LCBpc0RlZiwgd2hlbmV2ZXIsIGlzV29ya2VyIH0gZnJvbSAnQHZ1ZXVzZS9zaGFyZWQnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZXVzZS9zaGFyZWQnO1xuaW1wb3J0IHsgaXNSZWYsIHNoYWxsb3dSZWYsIHJlZiwgd2F0Y2hFZmZlY3QsIGNvbXB1dGVkLCBpbmplY3QsIGRlZmluZUNvbXBvbmVudCwgaCwgVHJhbnNpdGlvbkdyb3VwLCBGcmFnbWVudCwgc2hhbGxvd1JlYWN0aXZlLCB0b1ZhbHVlLCB1bnJlZiwgZ2V0Q3VycmVudEluc3RhbmNlLCBvbk1vdW50ZWQsIHdhdGNoLCBjdXN0b21SZWYsIG9uVXBkYXRlZCwgcmVhZG9ubHksIHJlYWN0aXZlLCBoYXNJbmplY3Rpb25Db250ZXh0LCB0b1JhdywgbmV4dFRpY2ssIG1hcmtSYXcsIGdldEN1cnJlbnRTY29wZSwgaXNSZWFkb25seSwgb25CZWZvcmVVcGRhdGUgfSBmcm9tICd2dWUnO1xuXG5mdW5jdGlvbiBjb21wdXRlZEFzeW5jKGV2YWx1YXRpb25DYWxsYmFjaywgaW5pdGlhbFN0YXRlLCBvcHRpb25zT3JSZWYpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChpc1JlZihvcHRpb25zT3JSZWYpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGV2YWx1YXRpbmc6IG9wdGlvbnNPclJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNPclJlZiB8fCB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgbGF6eSA9IGZhbHNlLFxuICAgIGZsdXNoID0gXCJwcmVcIixcbiAgICBldmFsdWF0aW5nID0gdm9pZCAwLFxuICAgIHNoYWxsb3cgPSB0cnVlLFxuICAgIG9uRXJyb3IgPSBub29wXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzdGFydGVkID0gc2hhbGxvd1JlZighbGF6eSk7XG4gIGNvbnN0IGN1cnJlbnQgPSBzaGFsbG93ID8gc2hhbGxvd1JlZihpbml0aWFsU3RhdGUpIDogcmVmKGluaXRpYWxTdGF0ZSk7XG4gIGxldCBjb3VudGVyID0gMDtcbiAgd2F0Y2hFZmZlY3QoYXN5bmMgKG9uSW52YWxpZGF0ZSkgPT4ge1xuICAgIGlmICghc3RhcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb3VudGVyKys7XG4gICAgY29uc3QgY291bnRlckF0QmVnaW5uaW5nID0gY291bnRlcjtcbiAgICBsZXQgaGFzRmluaXNoZWQgPSBmYWxzZTtcbiAgICBpZiAoZXZhbHVhdGluZykge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGV2YWx1YXRpbmcudmFsdWUgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmFsdWF0aW9uQ2FsbGJhY2soKGNhbmNlbENhbGxiYWNrKSA9PiB7XG4gICAgICAgIG9uSW52YWxpZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKGV2YWx1YXRpbmcpXG4gICAgICAgICAgICBldmFsdWF0aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFoYXNGaW5pc2hlZClcbiAgICAgICAgICAgIGNhbmNlbENhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoY291bnRlckF0QmVnaW5uaW5nID09PSBjb3VudGVyKVxuICAgICAgICBjdXJyZW50LnZhbHVlID0gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChldmFsdWF0aW5nICYmIGNvdW50ZXJBdEJlZ2lubmluZyA9PT0gY291bnRlcilcbiAgICAgICAgZXZhbHVhdGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgaGFzRmluaXNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwgeyBmbHVzaCB9KTtcbiAgaWYgKGxhenkpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgc3RhcnRlZC52YWx1ZSA9IHRydWU7XG4gICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlZEluamVjdChrZXksIG9wdGlvbnMsIGRlZmF1bHRTb3VyY2UsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSkge1xuICBsZXQgc291cmNlID0gaW5qZWN0KGtleSk7XG4gIGlmIChkZWZhdWx0U291cmNlKVxuICAgIHNvdXJjZSA9IGluamVjdChrZXksIGRlZmF1bHRTb3VyY2UpO1xuICBpZiAodHJlYXREZWZhdWx0QXNGYWN0b3J5KVxuICAgIHNvdXJjZSA9IGluamVjdChrZXksIGRlZmF1bHRTb3VyY2UsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkKChjdHgpID0+IG9wdGlvbnMoc291cmNlLCBjdHgpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoe1xuICAgICAgZ2V0OiAoY3R4KSA9PiBvcHRpb25zLmdldChzb3VyY2UsIGN0eCksXG4gICAgICBzZXQ6IG9wdGlvbnMuc2V0XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmV1c2FibGVUZW1wbGF0ZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGluaGVyaXRBdHRycyA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlbmRlciA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgZGVmaW5lID0gLypAX19QVVJFX18qLyBkZWZpbmVDb21wb25lbnQoe1xuICAgIHNldHVwKF8sIHsgc2xvdHMgfSkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVuZGVyLnZhbHVlID0gc2xvdHMuZGVmYXVsdDtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcmV1c2UgPSAvKkBfX1BVUkVfXyovIGRlZmluZUNvbXBvbmVudCh7XG4gICAgaW5oZXJpdEF0dHJzLFxuICAgIHByb3BzOiBvcHRpb25zLnByb3BzLFxuICAgIHNldHVwKHByb3BzLCB7IGF0dHJzLCBzbG90cyB9KSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcmVuZGVyLnZhbHVlICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbVnVlVXNlXSBGYWlsZWQgdG8gZmluZCB0aGUgZGVmaW5pdGlvbiBvZiByZXVzYWJsZSB0ZW1wbGF0ZVwiKTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSAoX2EgPSByZW5kZXIudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHJlbmRlciwge1xuICAgICAgICAgIC4uLm9wdGlvbnMucHJvcHMgPT0gbnVsbCA/IGtleXNUb0NhbWVsS2ViYWJDYXNlKGF0dHJzKSA6IHByb3BzLFxuICAgICAgICAgICRzbG90czogc2xvdHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbmhlcml0QXR0cnMgJiYgKHZub2RlID09IG51bGwgPyB2b2lkIDAgOiB2bm9kZS5sZW5ndGgpID09PSAxID8gdm5vZGVbMF0gOiB2bm9kZTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1ha2VEZXN0cnVjdHVyYWJsZShcbiAgICB7IGRlZmluZSwgcmV1c2UgfSxcbiAgICBbZGVmaW5lLCByZXVzZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGtleXNUb0NhbWVsS2ViYWJDYXNlKG9iaikge1xuICBjb25zdCBuZXdPYmogPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKVxuICAgIG5ld09ialtjYW1lbGl6ZShrZXkpXSA9IG9ialtrZXldO1xuICByZXR1cm4gbmV3T2JqO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZVByb21pc2Uob3B0aW9ucyA9IHt9KSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IGluc3RhbmNlcyA9IHJlZihbXSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBzaGFsbG93UmVhY3RpdmUoe1xuICAgICAga2V5OiBpbmRleCsrLFxuICAgICAgYXJncyxcbiAgICAgIHByb21pc2U6IHZvaWQgMCxcbiAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICByZWplY3Q6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBpc1Jlc29sdmluZzogZmFsc2UsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgaW5zdGFuY2VzLnZhbHVlLnB1c2gocHJvcHMpO1xuICAgIHByb3BzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgIHByb3BzLnJlc29sdmUgPSAodikgPT4ge1xuICAgICAgICBwcm9wcy5pc1Jlc29sdmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBfcmVzb2x2ZSh2KTtcbiAgICAgIH07XG4gICAgICBwcm9wcy5yZWplY3QgPSBfcmVqZWN0O1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgcHJvcHMucHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGluZGV4MiA9IGluc3RhbmNlcy52YWx1ZS5pbmRleE9mKHByb3BzKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKVxuICAgICAgICBpbnN0YW5jZXMudmFsdWUuc3BsaWNlKGluZGV4MiwgMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3BzLnByb21pc2U7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoLi4uYXJncykge1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbiAmJiBpbnN0YW5jZXMudmFsdWUubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBpbnN0YW5jZXMudmFsdWVbMF0ucHJvbWlzZTtcbiAgICByZXR1cm4gY3JlYXRlKC4uLmFyZ3MpO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudCA9IC8qQF9fUFVSRV9fKi8gZGVmaW5lQ29tcG9uZW50KChfLCB7IHNsb3RzIH0pID0+IHtcbiAgICBjb25zdCByZW5kZXJMaXN0ID0gKCkgPT4gaW5zdGFuY2VzLnZhbHVlLm1hcCgocHJvcHMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBoKEZyYWdtZW50LCB7IGtleTogcHJvcHMua2V5IH0sIChfYSA9IHNsb3RzLmRlZmF1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHNsb3RzLCBwcm9wcykpO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pXG4gICAgICByZXR1cm4gKCkgPT4gaChUcmFuc2l0aW9uR3JvdXAsIG9wdGlvbnMudHJhbnNpdGlvbiwgcmVuZGVyTGlzdCk7XG4gICAgcmV0dXJuIHJlbmRlckxpc3Q7XG4gIH0pO1xuICBjb21wb25lbnQuc3RhcnQgPSBzdGFydDtcbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5yZWZGbihmbikge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzLm1hcCgoaSkgPT4gdG9WYWx1ZShpKSkpO1xuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0V2luZG93ID0gaXNDbGllbnQgPyB3aW5kb3cgOiB2b2lkIDA7XG5jb25zdCBkZWZhdWx0RG9jdW1lbnQgPSBpc0NsaWVudCA/IHdpbmRvdy5kb2N1bWVudCA6IHZvaWQgMDtcbmNvbnN0IGRlZmF1bHROYXZpZ2F0b3IgPSBpc0NsaWVudCA/IHdpbmRvdy5uYXZpZ2F0b3IgOiB2b2lkIDA7XG5jb25zdCBkZWZhdWx0TG9jYXRpb24gPSBpc0NsaWVudCA/IHdpbmRvdy5sb2NhdGlvbiA6IHZvaWQgMDtcblxuZnVuY3Rpb24gdW5yZWZFbGVtZW50KGVsUmVmKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcGxhaW4gPSB0b1ZhbHVlKGVsUmVmKTtcbiAgcmV0dXJuIChfYSA9IHBsYWluID09IG51bGwgPyB2b2lkIDAgOiBwbGFpbi4kZWwpICE9IG51bGwgPyBfYSA6IHBsYWluO1xufVxuXG5mdW5jdGlvbiB1c2VFdmVudExpc3RlbmVyKC4uLmFyZ3MpIHtcbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBjbGVhbnVwcy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgY2xlYW51cHMubGVuZ3RoID0gMDtcbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXIgPSAoZWwsIGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9ucykgPT4ge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBmaXJzdFBhcmFtVGFyZ2V0cyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCB0ZXN0ID0gdG9BcnJheSh0b1ZhbHVlKGFyZ3NbMF0pKS5maWx0ZXIoKGUpID0+IGUgIT0gbnVsbCk7XG4gICAgcmV0dXJuIHRlc3QuZXZlcnkoKGUpID0+IHR5cGVvZiBlICE9PSBcInN0cmluZ1wiKSA/IHRlc3QgOiB2b2lkIDA7XG4gIH0pO1xuICBjb25zdCBzdG9wV2F0Y2ggPSB3YXRjaEltbWVkaWF0ZShcbiAgICAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgKF9iID0gKF9hID0gZmlyc3RQYXJhbVRhcmdldHMudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IHVucmVmRWxlbWVudChlKSkpICE9IG51bGwgPyBfYiA6IFtkZWZhdWx0V2luZG93XS5maWx0ZXIoKGUpID0+IGUgIT0gbnVsbCksXG4gICAgICAgIHRvQXJyYXkodG9WYWx1ZShmaXJzdFBhcmFtVGFyZ2V0cy52YWx1ZSA/IGFyZ3NbMV0gOiBhcmdzWzBdKSksXG4gICAgICAgIHRvQXJyYXkodW5yZWYoZmlyc3RQYXJhbVRhcmdldHMudmFsdWUgPyBhcmdzWzJdIDogYXJnc1sxXSkpLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVHlwZVNjcmlwdCBnZXRzIHRoZSBjb3JyZWN0IHR5cGVzLCBidXQgc29tZWhvdyBzdGlsbCBjb21wbGFpbnNcbiAgICAgICAgdG9WYWx1ZShmaXJzdFBhcmFtVGFyZ2V0cy52YWx1ZSA/IGFyZ3NbM10gOiBhcmdzWzJdKVxuICAgICAgXTtcbiAgICB9LFxuICAgIChbcmF3X3RhcmdldHMsIHJhd19ldmVudHMsIHJhd19saXN0ZW5lcnMsIHJhd19vcHRpb25zXSkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgaWYgKCEocmF3X3RhcmdldHMgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd190YXJnZXRzLmxlbmd0aCkgfHwgIShyYXdfZXZlbnRzID09IG51bGwgPyB2b2lkIDAgOiByYXdfZXZlbnRzLmxlbmd0aCkgfHwgIShyYXdfbGlzdGVuZXJzID09IG51bGwgPyB2b2lkIDAgOiByYXdfbGlzdGVuZXJzLmxlbmd0aCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG9wdGlvbnNDbG9uZSA9IGlzT2JqZWN0KHJhd19vcHRpb25zKSA/IHsgLi4ucmF3X29wdGlvbnMgfSA6IHJhd19vcHRpb25zO1xuICAgICAgY2xlYW51cHMucHVzaChcbiAgICAgICAgLi4ucmF3X3RhcmdldHMuZmxhdE1hcChcbiAgICAgICAgICAoZWwpID0+IHJhd19ldmVudHMuZmxhdE1hcChcbiAgICAgICAgICAgIChldmVudCkgPT4gcmF3X2xpc3RlbmVycy5tYXAoKGxpc3RlbmVyKSA9PiByZWdpc3RlcihlbCwgZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zQ2xvbmUpKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHsgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBzdG9wV2F0Y2goKTtcbiAgICBjbGVhbnVwKCk7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKGNsZWFudXApO1xuICByZXR1cm4gc3RvcDtcbn1cblxubGV0IF9pT1NXb3JrYXJvdW5kID0gZmFsc2U7XG5mdW5jdGlvbiBvbkNsaWNrT3V0c2lkZSh0YXJnZXQsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIGlnbm9yZSA9IFtdLCBjYXB0dXJlID0gdHJ1ZSwgZGV0ZWN0SWZyYW1lID0gZmFsc2UsIGNvbnRyb2xzID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuIGNvbnRyb2xzID8geyBzdG9wOiBub29wLCBjYW5jZWw6IG5vb3AsIHRyaWdnZXI6IG5vb3AgfSA6IG5vb3A7XG4gIH1cbiAgaWYgKGlzSU9TICYmICFfaU9TV29ya2Fyb3VuZCkge1xuICAgIF9pT1NXb3JrYXJvdW5kID0gdHJ1ZTtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICBBcnJheS5mcm9tKHdpbmRvdy5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChlbCkgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG5vb3AsIGxpc3RlbmVyT3B0aW9ucykpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG5vb3AsIGxpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgbGV0IHNob3VsZExpc3RlbiA9IHRydWU7XG4gIGNvbnN0IHNob3VsZElnbm9yZSA9IChldmVudCkgPT4ge1xuICAgIHJldHVybiB0b1ZhbHVlKGlnbm9yZSkuc29tZSgodGFyZ2V0MikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldDIpKS5zb21lKChlbCkgPT4gZWwgPT09IGV2ZW50LnRhcmdldCB8fCBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0Mik7XG4gICAgICAgIHJldHVybiBlbCAmJiAoZXZlbnQudGFyZ2V0ID09PSBlbCB8fCBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlbCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBoYXNNdWx0aXBsZVJvb3RzKHRhcmdldDIpIHtcbiAgICBjb25zdCB2bSA9IHRvVmFsdWUodGFyZ2V0Mik7XG4gICAgcmV0dXJuIHZtICYmIHZtLiQuc3ViVHJlZS5zaGFwZUZsYWcgPT09IDE2O1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVSb290cyh0YXJnZXQyLCBldmVudCkge1xuICAgIGNvbnN0IHZtID0gdG9WYWx1ZSh0YXJnZXQyKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHZtLiQuc3ViVHJlZSAmJiB2bS4kLnN1YlRyZWUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuZWwgPT09IGV2ZW50LnRhcmdldCB8fCBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhjaGlsZC5lbCkpO1xuICB9XG4gIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSAmJiBoYXNNdWx0aXBsZVJvb3RzKHRhcmdldCkgJiYgY2hlY2tNdWx0aXBsZVJvb3RzKHRhcmdldCwgZXZlbnQpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghZWwgfHwgZWwgPT09IGV2ZW50LnRhcmdldCB8fCBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlbCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKFwiZGV0YWlsXCIgaW4gZXZlbnQgJiYgZXZlbnQuZGV0YWlsID09PSAwKVxuICAgICAgc2hvdWxkTGlzdGVuID0gIXNob3VsZElnbm9yZShldmVudCk7XG4gICAgaWYgKCFzaG91bGRMaXN0ZW4pIHtcbiAgICAgIHNob3VsZExpc3RlbiA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZXIoZXZlbnQpO1xuICB9O1xuICBsZXQgaXNQcm9jZXNzaW5nQ2xpY2sgPSBmYWxzZTtcbiAgY29uc3QgY2xlYW51cCA9IFtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghaXNQcm9jZXNzaW5nQ2xpY2spIHtcbiAgICAgICAgaXNQcm9jZXNzaW5nQ2xpY2sgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpc1Byb2Nlc3NpbmdDbGljayA9IGZhbHNlO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9KSxcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVyZG93blwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICAgIHNob3VsZExpc3RlbiA9ICFzaG91bGRJZ25vcmUoZSkgJiYgISEoZWwgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoZWwpKTtcbiAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSksXG4gICAgZGV0ZWN0SWZyYW1lICYmIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImJsdXJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgICAgICBpZiAoKChfYSA9IHdpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EudGFnTmFtZSkgPT09IFwiSUZSQU1FXCIgJiYgIShlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuY29udGFpbnMod2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSkge1xuICAgICAgICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSlcbiAgXS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiBjbGVhbnVwLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgaWYgKGNvbnRyb2xzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3AsXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgc2hvdWxkTGlzdGVuID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlcjogKGV2ZW50KSA9PiB7XG4gICAgICAgIHNob3VsZExpc3RlbiA9IHRydWU7XG4gICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgc2hvdWxkTGlzdGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RvcDtcbn1cblxuZnVuY3Rpb24gdXNlTW91bnRlZCgpIHtcbiAgY29uc3QgaXNNb3VudGVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICBpc01vdW50ZWQudmFsdWUgPSB0cnVlO1xuICAgIH0sIGluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaXNNb3VudGVkO1xufVxuXG5mdW5jdGlvbiB1c2VTdXBwb3J0ZWQoY2FsbGJhY2spIHtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlTW91bnRlZCgpO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlzTW91bnRlZC52YWx1ZTtcbiAgICByZXR1cm4gQm9vbGVhbihjYWxsYmFjaygpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIodGFyZ2V0LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgLi4ubXV0YXRpb25PcHRpb25zIH0gPSBvcHRpb25zO1xuICBsZXQgb2JzZXJ2ZXI7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIk11dGF0aW9uT2JzZXJ2ZXJcIiBpbiB3aW5kb3cpO1xuICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgb2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xuICBjb25zdCB0YXJnZXRzID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGNvbnN0IGl0ZW1zID0gdG9BcnJheSh2YWx1ZSkubWFwKHVucmVmRWxlbWVudCkuZmlsdGVyKG5vdE51bGxpc2gpO1xuICAgIHJldHVybiBuZXcgU2V0KGl0ZW1zKTtcbiAgfSk7XG4gIGNvbnN0IHN0b3BXYXRjaCA9IHdhdGNoKFxuICAgICgpID0+IHRhcmdldHMudmFsdWUsXG4gICAgKHRhcmdldHMyKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgdGFyZ2V0czIuc2l6ZSkge1xuICAgICAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICAgICAgdGFyZ2V0czIuZm9yRWFjaCgoZWwpID0+IG9ic2VydmVyLm9ic2VydmUoZWwsIG11dGF0aW9uT3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUsIGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG4gIGNvbnN0IHRha2VSZWNvcmRzID0gKCkgPT4ge1xuICAgIHJldHVybiBvYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBzdG9wV2F0Y2goKTtcbiAgICBjbGVhbnVwKCk7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHN0b3ApO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHN0b3AsXG4gICAgdGFrZVJlY29yZHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25FbGVtZW50UmVtb3ZhbCh0YXJnZXQsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgZG9jdW1lbnQgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudCxcbiAgICBmbHVzaCA9IFwic3luY1wiXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIXdpbmRvdyB8fCAhZG9jdW1lbnQpXG4gICAgcmV0dXJuIG5vb3A7XG4gIGxldCBzdG9wRm47XG4gIGNvbnN0IGNsZWFudXBBbmRVcGRhdGUgPSAoZm4pID0+IHtcbiAgICBzdG9wRm4gPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3BGbigpO1xuICAgIHN0b3BGbiA9IGZuO1xuICB9O1xuICBjb25zdCBzdG9wV2F0Y2ggPSB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGNvbnN0IHsgc3RvcCB9ID0gdXNlTXV0YXRpb25PYnNlcnZlcihcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIChtdXRhdGlvbnNMaXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0UmVtb3ZlZCA9IG11dGF0aW9uc0xpc3QubWFwKChtdXRhdGlvbikgPT4gWy4uLm11dGF0aW9uLnJlbW92ZWROb2Rlc10pLmZsYXQoKS5zb21lKChub2RlKSA9PiBub2RlID09PSBlbCB8fCBub2RlLmNvbnRhaW5zKGVsKSk7XG4gICAgICAgICAgaWYgKHRhcmdldFJlbW92ZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG11dGF0aW9uc0xpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHdpbmRvdyxcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY2xlYW51cEFuZFVwZGF0ZShzdG9wKTtcbiAgICB9XG4gIH0sIHsgZmx1c2ggfSk7XG4gIGNvbnN0IHN0b3BIYW5kbGUgPSAoKSA9PiB7XG4gICAgc3RvcFdhdGNoKCk7XG4gICAgY2xlYW51cEFuZFVwZGF0ZSgpO1xuICB9O1xuICB0cnlPblNjb3BlRGlzcG9zZShzdG9wSGFuZGxlKTtcbiAgcmV0dXJuIHN0b3BIYW5kbGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVByZWRpY2F0ZShrZXlGaWx0ZXIpIHtcbiAgaWYgKHR5cGVvZiBrZXlGaWx0ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4ga2V5RmlsdGVyO1xuICBlbHNlIGlmICh0eXBlb2Yga2V5RmlsdGVyID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiAoZXZlbnQpID0+IGV2ZW50LmtleSA9PT0ga2V5RmlsdGVyO1xuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGtleUZpbHRlcikpXG4gICAgcmV0dXJuIChldmVudCkgPT4ga2V5RmlsdGVyLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gIHJldHVybiAoKSA9PiB0cnVlO1xufVxuZnVuY3Rpb24gb25LZXlTdHJva2UoLi4uYXJncykge1xuICBsZXQga2V5O1xuICBsZXQgaGFuZGxlcjtcbiAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAga2V5ID0gYXJnc1swXTtcbiAgICBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICBvcHRpb25zID0gYXJnc1syXTtcbiAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAga2V5ID0gdHJ1ZTtcbiAgICAgIGhhbmRsZXIgPSBhcmdzWzBdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGFyZ3NbMF07XG4gICAgICBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gdHJ1ZTtcbiAgICBoYW5kbGVyID0gYXJnc1swXTtcbiAgfVxuICBjb25zdCB7XG4gICAgdGFyZ2V0ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBldmVudE5hbWUgPSBcImtleWRvd25cIixcbiAgICBwYXNzaXZlID0gZmFsc2UsXG4gICAgZGVkdXBlID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByZWRpY2F0ZSA9IGNyZWF0ZUtleVByZWRpY2F0ZShrZXkpO1xuICBjb25zdCBsaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgaWYgKGUucmVwZWF0ICYmIHRvVmFsdWUoZGVkdXBlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAocHJlZGljYXRlKGUpKVxuICAgICAgaGFuZGxlcihlKTtcbiAgfTtcbiAgcmV0dXJuIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWUsIGxpc3RlbmVyLCBwYXNzaXZlKTtcbn1cbmZ1bmN0aW9uIG9uS2V5RG93bihrZXksIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gb25LZXlTdHJva2Uoa2V5LCBoYW5kbGVyLCB7IC4uLm9wdGlvbnMsIGV2ZW50TmFtZTogXCJrZXlkb3duXCIgfSk7XG59XG5mdW5jdGlvbiBvbktleVByZXNzZWQoa2V5LCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG9uS2V5U3Ryb2tlKGtleSwgaGFuZGxlciwgeyAuLi5vcHRpb25zLCBldmVudE5hbWU6IFwia2V5cHJlc3NcIiB9KTtcbn1cbmZ1bmN0aW9uIG9uS2V5VXAoa2V5LCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG9uS2V5U3Ryb2tlKGtleSwgaGFuZGxlciwgeyAuLi5vcHRpb25zLCBldmVudE5hbWU6IFwia2V5dXBcIiB9KTtcbn1cblxuY29uc3QgREVGQVVMVF9ERUxBWSA9IDUwMDtcbmNvbnN0IERFRkFVTFRfVEhSRVNIT0xEID0gMTA7XG5mdW5jdGlvbiBvbkxvbmdQcmVzcyh0YXJnZXQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZWxlbWVudFJlZiA9IGNvbXB1dGVkKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpKTtcbiAgbGV0IHRpbWVvdXQ7XG4gIGxldCBwb3NTdGFydDtcbiAgbGV0IHN0YXJ0VGltZXN0YW1wO1xuICBsZXQgaGFzTG9uZ1ByZXNzZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHBvc1N0YXJ0ID0gdm9pZCAwO1xuICAgIHN0YXJ0VGltZXN0YW1wID0gdm9pZCAwO1xuICAgIGhhc0xvbmdQcmVzc2VkID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gb25SZWxlYXNlKGV2KSB7XG4gICAgdmFyIF9hMiwgX2IyLCBfYztcbiAgICBjb25zdCBbX3N0YXJ0VGltZXN0YW1wLCBfcG9zU3RhcnQsIF9oYXNMb25nUHJlc3NlZF0gPSBbc3RhcnRUaW1lc3RhbXAsIHBvc1N0YXJ0LCBoYXNMb25nUHJlc3NlZF07XG4gICAgY2xlYXIoKTtcbiAgICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uTW91c2VVcCkgfHwgIV9wb3NTdGFydCB8fCAhX3N0YXJ0VGltZXN0YW1wKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICgoKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNlbGYpICYmIGV2LnRhcmdldCAhPT0gZWxlbWVudFJlZi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoKF9iMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnByZXZlbnQpXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0b3ApXG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCBkeCA9IGV2LnggLSBfcG9zU3RhcnQueDtcbiAgICBjb25zdCBkeSA9IGV2LnkgLSBfcG9zU3RhcnQueTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgb3B0aW9ucy5vbk1vdXNlVXAoZXYudGltZVN0YW1wIC0gX3N0YXJ0VGltZXN0YW1wLCBkaXN0YW5jZSwgX2hhc0xvbmdQcmVzc2VkKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRvd24oZXYpIHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jLCBfZDtcbiAgICBpZiAoKChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZWxmKSAmJiBldi50YXJnZXQgIT09IGVsZW1lbnRSZWYudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY2xlYXIoKTtcbiAgICBpZiAoKF9iMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnByZXZlbnQpXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0b3ApXG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBwb3NTdGFydCA9IHtcbiAgICAgIHg6IGV2LngsXG4gICAgICB5OiBldi55XG4gICAgfTtcbiAgICBzdGFydFRpbWVzdGFtcCA9IGV2LnRpbWVTdGFtcDtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgaGFzTG9uZ1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVyKGV2KTtcbiAgICAgIH0sXG4gICAgICAoX2QgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRlbGF5KSAhPSBudWxsID8gX2QgOiBERUZBVUxUX0RFTEFZXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBvbk1vdmUoZXYpIHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jLCBfZDtcbiAgICBpZiAoKChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZWxmKSAmJiBldi50YXJnZXQgIT09IGVsZW1lbnRSZWYudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwb3NTdGFydCB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXN0YW5jZVRocmVzaG9sZCkgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICgoX2IyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYjIucHJldmVudClcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKChfYyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RvcClcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IGR4ID0gZXYueCAtIHBvc1N0YXJ0Lng7XG4gICAgY29uc3QgZHkgPSBldi55IC0gcG9zU3RhcnQueTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKGRpc3RhbmNlID49ICgoX2QgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc3RhbmNlVGhyZXNob2xkKSAhPSBudWxsID8gX2QgOiBERUZBVUxUX1RIUkVTSE9MRCkpXG4gICAgICBjbGVhcigpO1xuICB9XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICBjYXB0dXJlOiAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhcHR1cmUsXG4gICAgb25jZTogKF9iID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vbmNlXG4gIH07XG4gIGNvbnN0IGNsZWFudXAgPSBbXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihlbGVtZW50UmVmLCBcInBvaW50ZXJkb3duXCIsIG9uRG93biwgbGlzdGVuZXJPcHRpb25zKSxcbiAgICB1c2VFdmVudExpc3RlbmVyKGVsZW1lbnRSZWYsIFwicG9pbnRlcm1vdmVcIiwgb25Nb3ZlLCBsaXN0ZW5lck9wdGlvbnMpLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIoZWxlbWVudFJlZiwgW1wicG9pbnRlcnVwXCIsIFwicG9pbnRlcmxlYXZlXCJdLCBvblJlbGVhc2UsIGxpc3RlbmVyT3B0aW9ucylcbiAgXTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IGNsZWFudXAuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICByZXR1cm4gc3RvcDtcbn1cblxuZnVuY3Rpb24gaXNGb2N1c2VkRWxlbWVudEVkaXRhYmxlKCkge1xuICBjb25zdCB7IGFjdGl2ZUVsZW1lbnQsIGJvZHkgfSA9IGRvY3VtZW50O1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gYm9keSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoYWN0aXZlRWxlbWVudC50YWdOYW1lKSB7XG4gICAgY2FzZSBcIklOUFVUXCI6XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIik7XG59XG5mdW5jdGlvbiBpc1R5cGVkQ2hhclZhbGlkKHtcbiAga2V5Q29kZSxcbiAgbWV0YUtleSxcbiAgY3RybEtleSxcbiAgYWx0S2V5XG59KSB7XG4gIGlmIChtZXRhS2V5IHx8IGN0cmxLZXkgfHwgYWx0S2V5KVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1NyB8fCBrZXlDb2RlID49IDk2ICYmIGtleUNvZGUgPD0gMTA1KVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoa2V5Q29kZSA+PSA2NSAmJiBrZXlDb2RlIDw9IDkwKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvblN0YXJ0VHlwaW5nKGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBkb2N1bWVudDogZG9jdW1lbnQyID0gZGVmYXVsdERvY3VtZW50IH0gPSBvcHRpb25zO1xuICBjb25zdCBrZXlkb3duID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCFpc0ZvY3VzZWRFbGVtZW50RWRpdGFibGUoKSAmJiBpc1R5cGVkQ2hhclZhbGlkKGV2ZW50KSkge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGRvY3VtZW50MilcbiAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50MiwgXCJrZXlkb3duXCIsIGtleWRvd24sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVSZWYoa2V5LCBpbml0aWFsVmFsdWUgPSBudWxsKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGxldCBfdHJpZ2dlciA9ICgpID0+IHtcbiAgfTtcbiAgY29uc3QgZWxlbWVudCA9IGN1c3RvbVJlZigodHJhY2ssIHRyaWdnZXIpID0+IHtcbiAgICBfdHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJhY2soKTtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5wcm94eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLiRyZWZzW2tleV0pICE9IG51bGwgPyBfYiA6IGluaXRpYWxWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHRyeU9uTW91bnRlZChfdHJpZ2dlcik7XG4gIG9uVXBkYXRlZChfdHJpZ2dlcik7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1c2VBY3RpdmVFbGVtZW50KG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGRlZXAgPSB0cnVlLFxuICAgIHRyaWdnZXJPblJlbW92YWwgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZG9jdW1lbnQgPSAoX2EgPSBvcHRpb25zLmRvY3VtZW50KSAhPSBudWxsID8gX2EgOiB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudDtcbiAgY29uc3QgZ2V0RGVlcEFjdGl2ZUVsZW1lbnQgPSAoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChkZWVwKSB7XG4gICAgICB3aGlsZSAoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5zaGFkb3dSb290KVxuICAgICAgICBlbGVtZW50ID0gKF9hMiA9IGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnQuc2hhZG93Um9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgdHJpZ2dlciA9ICgpID0+IHtcbiAgICBhY3RpdmVFbGVtZW50LnZhbHVlID0gZ2V0RGVlcEFjdGl2ZUVsZW1lbnQoKTtcbiAgfTtcbiAgaWYgKHdpbmRvdykge1xuICAgIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFxuICAgICAgd2luZG93LFxuICAgICAgXCJibHVyXCIsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICB9LFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFxuICAgICAgd2luZG93LFxuICAgICAgXCJmb2N1c1wiLFxuICAgICAgdHJpZ2dlcixcbiAgICAgIGxpc3RlbmVyT3B0aW9uc1xuICAgICk7XG4gIH1cbiAgaWYgKHRyaWdnZXJPblJlbW92YWwpIHtcbiAgICBvbkVsZW1lbnRSZW1vdmFsKGFjdGl2ZUVsZW1lbnQsIHRyaWdnZXIsIHsgZG9jdW1lbnQgfSk7XG4gIH1cbiAgdHJpZ2dlcigpO1xuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gdXNlUmFmRm4oZm4sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBmcHNMaW1pdCA9IHZvaWQgMCxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIG9uY2UgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNBY3RpdmUgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgaW50ZXJ2YWxMaW1pdCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gZnBzTGltaXQgPyAxZTMgLyB0b1ZhbHVlKGZwc0xpbWl0KSA6IG51bGw7XG4gIH0pO1xuICBsZXQgcHJldmlvdXNGcmFtZVRpbWVzdGFtcCA9IDA7XG4gIGxldCByYWZJZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGxvb3AodGltZXN0YW1wKSB7XG4gICAgaWYgKCFpc0FjdGl2ZS52YWx1ZSB8fCAhd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcHJldmlvdXNGcmFtZVRpbWVzdGFtcClcbiAgICAgIHByZXZpb3VzRnJhbWVUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgY29uc3QgZGVsdGEgPSB0aW1lc3RhbXAgLSBwcmV2aW91c0ZyYW1lVGltZXN0YW1wO1xuICAgIGlmIChpbnRlcnZhbExpbWl0LnZhbHVlICYmIGRlbHRhIDwgaW50ZXJ2YWxMaW1pdC52YWx1ZSkge1xuICAgICAgcmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcmV2aW91c0ZyYW1lVGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIGZuKHsgZGVsdGEsIHRpbWVzdGFtcCB9KTtcbiAgICBpZiAob25jZSkge1xuICAgICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgICAgIHJhZklkID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBpZiAoIWlzQWN0aXZlLnZhbHVlICYmIHdpbmRvdykge1xuICAgICAgaXNBY3RpdmUudmFsdWUgPSB0cnVlO1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWVzdGFtcCA9IDA7XG4gICAgICByYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlzQWN0aXZlLnZhbHVlID0gZmFsc2U7XG4gICAgaWYgKHJhZklkICE9IG51bGwgJiYgd2luZG93KSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgcmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoaW1tZWRpYXRlKVxuICAgIHJlc3VtZSgpO1xuICB0cnlPblNjb3BlRGlzcG9zZShwYXVzZSk7XG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmU6IHJlYWRvbmx5KGlzQWN0aXZlKSxcbiAgICBwYXVzZSxcbiAgICByZXN1bWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQW5pbWF0ZSh0YXJnZXQsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICBsZXQgY29uZmlnO1xuICBsZXQgYW5pbWF0ZU9wdGlvbnM7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGNvbmZpZyA9IG9wdGlvbnM7XG4gICAgYW5pbWF0ZU9wdGlvbnMgPSBvYmplY3RPbWl0KG9wdGlvbnMsIFtcIndpbmRvd1wiLCBcImltbWVkaWF0ZVwiLCBcImNvbW1pdFN0eWxlc1wiLCBcInBlcnNpc3RcIiwgXCJvblJlYWR5XCIsIFwib25FcnJvclwiXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuICAgIGFuaW1hdGVPcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGNvbW1pdFN0eWxlcyxcbiAgICBwZXJzaXN0LFxuICAgIHBsYXliYWNrUmF0ZTogX3BsYXliYWNrUmF0ZSA9IDEsXG4gICAgb25SZWFkeSxcbiAgICBvbkVycm9yID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgSFRNTEVsZW1lbnQgJiYgXCJhbmltYXRlXCIgaW4gSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcbiAgY29uc3QgYW5pbWF0ZSA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3Qgc3RvcmUgPSBzaGFsbG93UmVhY3RpdmUoe1xuICAgIHN0YXJ0VGltZTogbnVsbCxcbiAgICBjdXJyZW50VGltZTogbnVsbCxcbiAgICB0aW1lbGluZTogbnVsbCxcbiAgICBwbGF5YmFja1JhdGU6IF9wbGF5YmFja1JhdGUsXG4gICAgcGVuZGluZzogZmFsc2UsXG4gICAgcGxheVN0YXRlOiBpbW1lZGlhdGUgPyBcImlkbGVcIiA6IFwicGF1c2VkXCIsXG4gICAgcmVwbGFjZVN0YXRlOiBcImFjdGl2ZVwiXG4gIH0pO1xuICBjb25zdCBwZW5kaW5nID0gY29tcHV0ZWQoKCkgPT4gc3RvcmUucGVuZGluZyk7XG4gIGNvbnN0IHBsYXlTdGF0ZSA9IGNvbXB1dGVkKCgpID0+IHN0b3JlLnBsYXlTdGF0ZSk7XG4gIGNvbnN0IHJlcGxhY2VTdGF0ZSA9IGNvbXB1dGVkKCgpID0+IHN0b3JlLnJlcGxhY2VTdGF0ZSk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IGNvbXB1dGVkKHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gc3RvcmUuc3RhcnRUaW1lO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBzdG9yZS5zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgIGlmIChhbmltYXRlLnZhbHVlKVxuICAgICAgICBhbmltYXRlLnZhbHVlLnN0YXJ0VGltZSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50VGltZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc3RvcmUuY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICAgIGlmIChhbmltYXRlLnZhbHVlKSB7XG4gICAgICAgIGFuaW1hdGUudmFsdWUuY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgc3luY1Jlc3VtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRpbWVsaW5lID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzdG9yZS50aW1lbGluZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc3RvcmUudGltZWxpbmUgPSB2YWx1ZTtcbiAgICAgIGlmIChhbmltYXRlLnZhbHVlKVxuICAgICAgICBhbmltYXRlLnZhbHVlLnRpbWVsaW5lID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcGxheWJhY2tSYXRlID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzdG9yZS5wbGF5YmFja1JhdGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHN0b3JlLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xuICAgICAgaWYgKGFuaW1hdGUudmFsdWUpXG4gICAgICAgIGFuaW1hdGUudmFsdWUucGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcGxheSA9ICgpID0+IHtcbiAgICBpZiAoYW5pbWF0ZS52YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYW5pbWF0ZS52YWx1ZS5wbGF5KCk7XG4gICAgICAgIHN5bmNSZXN1bWUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3luY1BhdXNlKCk7XG4gICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF1c2UgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EucGF1c2UoKTtcbiAgICAgIHN5bmNQYXVzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXZlcnNlID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWFuaW1hdGUudmFsdWUpXG4gICAgICB1cGRhdGUoKTtcbiAgICB0cnkge1xuICAgICAgKF9hID0gYW5pbWF0ZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJldmVyc2UoKTtcbiAgICAgIHN5bmNSZXN1bWUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzeW5jUGF1c2UoKTtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBmaW5pc2ggPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmluaXNoKCk7XG4gICAgICBzeW5jUGF1c2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICB0cnkge1xuICAgICAgKF9hID0gYW5pbWF0ZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbmNlbCgpO1xuICAgICAgc3luY1BhdXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH07XG4gIHdhdGNoKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpLCAoZWwpID0+IHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRlLnZhbHVlID0gdm9pZCAwO1xuICAgIH1cbiAgfSk7XG4gIHdhdGNoKCgpID0+IGtleWZyYW1lcywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKGFuaW1hdGUudmFsdWUpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgY29uc3QgdGFyZ2V0RWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICAgIGlmICh0YXJnZXRFbCkge1xuICAgICAgICBhbmltYXRlLnZhbHVlLmVmZmVjdCA9IG5ldyBLZXlmcmFtZUVmZmVjdChcbiAgICAgICAgICB0YXJnZXRFbCxcbiAgICAgICAgICB0b1ZhbHVlKHZhbHVlKSxcbiAgICAgICAgICBhbmltYXRlT3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSwgeyBkZWVwOiB0cnVlIH0pO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4gdXBkYXRlKHRydWUpLCBmYWxzZSk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKGNhbmNlbCk7XG4gIGZ1bmN0aW9uIHVwZGF0ZShpbml0KSB7XG4gICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8ICFlbClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIWFuaW1hdGUudmFsdWUpXG4gICAgICBhbmltYXRlLnZhbHVlID0gZWwuYW5pbWF0ZSh0b1ZhbHVlKGtleWZyYW1lcyksIGFuaW1hdGVPcHRpb25zKTtcbiAgICBpZiAocGVyc2lzdClcbiAgICAgIGFuaW1hdGUudmFsdWUucGVyc2lzdCgpO1xuICAgIGlmIChfcGxheWJhY2tSYXRlICE9PSAxKVxuICAgICAgYW5pbWF0ZS52YWx1ZS5wbGF5YmFja1JhdGUgPSBfcGxheWJhY2tSYXRlO1xuICAgIGlmIChpbml0ICYmICFpbW1lZGlhdGUpXG4gICAgICBhbmltYXRlLnZhbHVlLnBhdXNlKCk7XG4gICAgZWxzZVxuICAgICAgc3luY1Jlc3VtZSgpO1xuICAgIG9uUmVhZHkgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVhZHkoYW5pbWF0ZS52YWx1ZSk7XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIoYW5pbWF0ZSwgW1wiY2FuY2VsXCIsIFwiZmluaXNoXCIsIFwicmVtb3ZlXCJdLCBzeW5jUGF1c2UsIGxpc3RlbmVyT3B0aW9ucyk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoYW5pbWF0ZSwgXCJmaW5pc2hcIiwgKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoY29tbWl0U3R5bGVzKVxuICAgICAgKF9hID0gYW5pbWF0ZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbW1pdFN0eWxlcygpO1xuICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICBjb25zdCB7IHJlc3VtZTogcmVzdW1lUmVmLCBwYXVzZTogcGF1c2VSZWYgfSA9IHVzZVJhZkZuKCgpID0+IHtcbiAgICBpZiAoIWFuaW1hdGUudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RvcmUucGVuZGluZyA9IGFuaW1hdGUudmFsdWUucGVuZGluZztcbiAgICBzdG9yZS5wbGF5U3RhdGUgPSBhbmltYXRlLnZhbHVlLnBsYXlTdGF0ZTtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUgPSBhbmltYXRlLnZhbHVlLnJlcGxhY2VTdGF0ZTtcbiAgICBzdG9yZS5zdGFydFRpbWUgPSBhbmltYXRlLnZhbHVlLnN0YXJ0VGltZTtcbiAgICBzdG9yZS5jdXJyZW50VGltZSA9IGFuaW1hdGUudmFsdWUuY3VycmVudFRpbWU7XG4gICAgc3RvcmUudGltZWxpbmUgPSBhbmltYXRlLnZhbHVlLnRpbWVsaW5lO1xuICAgIHN0b3JlLnBsYXliYWNrUmF0ZSA9IGFuaW1hdGUudmFsdWUucGxheWJhY2tSYXRlO1xuICB9LCB7IGltbWVkaWF0ZTogZmFsc2UgfSk7XG4gIGZ1bmN0aW9uIHN5bmNSZXN1bWUoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmVzdW1lUmVmKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3luY1BhdXNlKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB3aW5kb3cpXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHBhdXNlUmVmKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGFuaW1hdGUsXG4gICAgLy8gYWN0aW9uc1xuICAgIHBsYXksXG4gICAgcGF1c2UsXG4gICAgcmV2ZXJzZSxcbiAgICBmaW5pc2gsXG4gICAgY2FuY2VsLFxuICAgIC8vIHN0YXRlXG4gICAgcGVuZGluZyxcbiAgICBwbGF5U3RhdGUsXG4gICAgcmVwbGFjZVN0YXRlLFxuICAgIHN0YXJ0VGltZSxcbiAgICBjdXJyZW50VGltZSxcbiAgICB0aW1lbGluZSxcbiAgICBwbGF5YmFja1JhdGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQXN5bmNRdWV1ZSh0YXNrcywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgaW50ZXJydXB0ID0gdHJ1ZSxcbiAgICBvbkVycm9yID0gbm9vcCxcbiAgICBvbkZpbmlzaGVkID0gbm9vcCxcbiAgICBzaWduYWxcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHByb21pc2VTdGF0ZSA9IHtcbiAgICBhYm9ydGVkOiBcImFib3J0ZWRcIixcbiAgICBmdWxmaWxsZWQ6IFwiZnVsZmlsbGVkXCIsXG4gICAgcGVuZGluZzogXCJwZW5kaW5nXCIsXG4gICAgcmVqZWN0ZWQ6IFwicmVqZWN0ZWRcIlxuICB9O1xuICBjb25zdCBpbml0aWFsUmVzdWx0ID0gQXJyYXkuZnJvbShBcnJheS5mcm9tKHsgbGVuZ3RoOiB0YXNrcy5sZW5ndGggfSksICgpID0+ICh7IHN0YXRlOiBwcm9taXNlU3RhdGUucGVuZGluZywgZGF0YTogbnVsbCB9KSk7XG4gIGNvbnN0IHJlc3VsdCA9IHJlYWN0aXZlKGluaXRpYWxSZXN1bHQpO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IHNoYWxsb3dSZWYoLTEpO1xuICBpZiAoIXRhc2tzIHx8IHRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIG9uRmluaXNoZWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aXZlSW5kZXgsXG4gICAgICByZXN1bHRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJlc3VsdChzdGF0ZSwgcmVzKSB7XG4gICAgYWN0aXZlSW5kZXgudmFsdWUrKztcbiAgICByZXN1bHRbYWN0aXZlSW5kZXgudmFsdWVdLmRhdGEgPSByZXM7XG4gICAgcmVzdWx0W2FjdGl2ZUluZGV4LnZhbHVlXS5zdGF0ZSA9IHN0YXRlO1xuICB9XG4gIHRhc2tzLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgIHJldHVybiBwcmV2LnRoZW4oKHByZXZSZXMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHVwZGF0ZVJlc3VsdChwcm9taXNlU3RhdGUuYWJvcnRlZCwgbmV3IEVycm9yKFwiYWJvcnRlZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9hID0gcmVzdWx0W2FjdGl2ZUluZGV4LnZhbHVlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0YXRlKSA9PT0gcHJvbWlzZVN0YXRlLnJlamVjdGVkICYmIGludGVycnVwdCkge1xuICAgICAgICBvbkZpbmlzaGVkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRvbmUgPSBjdXJyKHByZXZSZXMpLnRoZW4oKGN1cnJlbnRSZXMpID0+IHtcbiAgICAgICAgdXBkYXRlUmVzdWx0KHByb21pc2VTdGF0ZS5mdWxmaWxsZWQsIGN1cnJlbnRSZXMpO1xuICAgICAgICBpZiAoYWN0aXZlSW5kZXgudmFsdWUgPT09IHRhc2tzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgb25GaW5pc2hlZCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaWduYWwpXG4gICAgICAgIHJldHVybiBkb25lO1xuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbZG9uZSwgd2hlbkFib3J0ZWQoc2lnbmFsKV0pO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBpZiAoc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB1cGRhdGVSZXN1bHQocHJvbWlzZVN0YXRlLmFib3J0ZWQsIGUpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVJlc3VsdChwcm9taXNlU3RhdGUucmVqZWN0ZWQsIGUpO1xuICAgICAgb25FcnJvcigpO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0sIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICByZXN1bHRcbiAgfTtcbn1cbmZ1bmN0aW9uIHdoZW5BYm9ydGVkKHNpZ25hbCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiYWJvcnRlZFwiKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIGVsc2VcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4gcmVqZWN0KGVycm9yKSwgeyBvbmNlOiB0cnVlIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQXN5bmNTdGF0ZShwcm9taXNlLCBpbml0aWFsU3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgZGVsYXkgPSAwLFxuICAgIG9uRXJyb3IgPSBub29wLFxuICAgIG9uU3VjY2VzcyA9IG5vb3AsXG4gICAgcmVzZXRPbkV4ZWN1dGUgPSB0cnVlLFxuICAgIHNoYWxsb3cgPSB0cnVlLFxuICAgIHRocm93RXJyb3JcbiAgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgY29uc3Qgc3RhdGUgPSBzaGFsbG93ID8gc2hhbGxvd1JlZihpbml0aWFsU3RhdGUpIDogcmVmKGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IGlzUmVhZHkgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgaXNMb2FkaW5nID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBhc3luYyBmdW5jdGlvbiBleGVjdXRlKGRlbGF5MiA9IDAsIC4uLmFyZ3MpIHtcbiAgICBpZiAocmVzZXRPbkV4ZWN1dGUpXG4gICAgICBzdGF0ZS52YWx1ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICBlcnJvci52YWx1ZSA9IHZvaWQgMDtcbiAgICBpc1JlYWR5LnZhbHVlID0gZmFsc2U7XG4gICAgaXNMb2FkaW5nLnZhbHVlID0gdHJ1ZTtcbiAgICBpZiAoZGVsYXkyID4gMClcbiAgICAgIGF3YWl0IHByb21pc2VUaW1lb3V0KGRlbGF5Mik7XG4gICAgY29uc3QgX3Byb21pc2UgPSB0eXBlb2YgcHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiID8gcHJvbWlzZSguLi5hcmdzKSA6IHByb21pc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfcHJvbWlzZTtcbiAgICAgIHN0YXRlLnZhbHVlID0gZGF0YTtcbiAgICAgIGlzUmVhZHkudmFsdWUgPSB0cnVlO1xuICAgICAgb25TdWNjZXNzKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yLnZhbHVlID0gZTtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgICBpZiAodGhyb3dFcnJvcilcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNMb2FkaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS52YWx1ZTtcbiAgfVxuICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgZXhlY3V0ZShkZWxheSk7XG4gIH1cbiAgY29uc3Qgc2hlbGwgPSB7XG4gICAgc3RhdGUsXG4gICAgaXNSZWFkeSxcbiAgICBpc0xvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgZXhlY3V0ZSxcbiAgICBleGVjdXRlSW1tZWRpYXRlOiAoLi4uYXJncykgPT4gZXhlY3V0ZSgwLCAuLi5hcmdzKVxuICB9O1xuICBmdW5jdGlvbiB3YWl0VW50aWxJc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdW50aWwoaXNMb2FkaW5nKS50b0JlKGZhbHNlKS50aGVuKCgpID0+IHJlc29sdmUoc2hlbGwpKS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2hlbGwsXG4gICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHdhaXRVbnRpbElzTG9hZGVkKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJyYXk6ICh2KSA9PiBKU09OLnN0cmluZ2lmeSh2KSxcbiAgb2JqZWN0OiAodikgPT4gSlNPTi5zdHJpbmdpZnkodiksXG4gIHNldDogKHYpID0+IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20odikpLFxuICBtYXA6ICh2KSA9PiBKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXModikpLFxuICBudWxsOiAoKSA9PiBcIlwiXG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFNlcmlhbGl6YXRpb24odGFyZ2V0KSB7XG4gIGlmICghdGFyZ2V0KVxuICAgIHJldHVybiBkZWZhdWx0cy5udWxsO1xuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwKVxuICAgIHJldHVybiBkZWZhdWx0cy5tYXA7XG4gIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldClcbiAgICByZXR1cm4gZGVmYXVsdHMuc2V0O1xuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpXG4gICAgcmV0dXJuIGRlZmF1bHRzLmFycmF5O1xuICBlbHNlXG4gICAgcmV0dXJuIGRlZmF1bHRzLm9iamVjdDtcbn1cblxuZnVuY3Rpb24gdXNlQmFzZTY0KHRhcmdldCwgb3B0aW9ucykge1xuICBjb25zdCBiYXNlNjQgPSBzaGFsbG93UmVmKFwiXCIpO1xuICBjb25zdCBwcm9taXNlID0gc2hhbGxvd1JlZigpO1xuICBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgIGlmICghaXNDbGllbnQpXG4gICAgICByZXR1cm47XG4gICAgcHJvbWlzZS52YWx1ZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IF90YXJnZXQgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgICAgIGlmIChfdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICByZXNvbHZlKFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmVzb2x2ZShibG9iVG9CYXNlNjQobmV3IEJsb2IoW190YXJnZXRdLCB7IHR5cGU6IFwidGV4dC9wbGFpblwiIH0pKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RhcmdldCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICByZXNvbHZlKGJsb2JUb0Jhc2U2NChfdGFyZ2V0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RhcmdldCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmVzb2x2ZSh3aW5kb3cuYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KF90YXJnZXQpKSkpO1xuICAgICAgICB9IGVsc2UgaWYgKF90YXJnZXQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIHJlc29sdmUoX3RhcmdldC50b0RhdGFVUkwob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50eXBlLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1YWxpdHkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IGltZyA9IF90YXJnZXQuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiO1xuICAgICAgICAgIGltZ0xvYWRlZChpbWcpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgcmVzb2x2ZShjYW52YXMudG9EYXRhVVJMKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5xdWFsaXR5KSk7XG4gICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX3RhcmdldCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGNvbnN0IF9zZXJpYWxpemVGbiA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNlcmlhbGl6ZXIpIHx8IGdldERlZmF1bHRTZXJpYWxpemF0aW9uKF90YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBfc2VyaWFsaXplRm4oX3RhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoYmxvYlRvQmFzZTY0KG5ldyBCbG9iKFtzZXJpYWxpemVkXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0YXJnZXQgaXMgdW5zdXBwb3J0ZWQgdHlwZXNcIikpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHByb21pc2UudmFsdWUudGhlbigocmVzKSA9PiB7XG4gICAgICBiYXNlNjQudmFsdWUgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhVXJsKSA9PT0gZmFsc2UgPyByZXMucmVwbGFjZSgvXmRhdGE6Lio/O2Jhc2U2NCwvLCBcIlwiKSA6IHJlcztcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgfVxuICBpZiAoaXNSZWYodGFyZ2V0KSB8fCB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpXG4gICAgd2F0Y2godGFyZ2V0LCBleGVjdXRlLCB7IGltbWVkaWF0ZTogdHJ1ZSB9KTtcbiAgZWxzZVxuICAgIGV4ZWN1dGUoKTtcbiAgcmV0dXJuIHtcbiAgICBiYXNlNjQsXG4gICAgcHJvbWlzZSxcbiAgICBleGVjdXRlXG4gIH07XG59XG5mdW5jdGlvbiBpbWdMb2FkZWQoaW1nKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFpbWcuY29tcGxldGUpIHtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICBpbWcub25lcnJvciA9IHJlamVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBibG9iVG9CYXNlNjQoYmxvYikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgIH07XG4gICAgZnIub25lcnJvciA9IHJlamVjdDtcbiAgICBmci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQmF0dGVyeShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yIH0gPSBvcHRpb25zO1xuICBjb25zdCBldmVudHMgPSBbXCJjaGFyZ2luZ2NoYW5nZVwiLCBcImNoYXJnaW5ndGltZWNoYW5nZVwiLCBcImRpc2NoYXJnaW5ndGltZWNoYW5nZVwiLCBcImxldmVsY2hhbmdlXCJdO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJnZXRCYXR0ZXJ5XCIgaW4gbmF2aWdhdG9yICYmIHR5cGVvZiBuYXZpZ2F0b3IuZ2V0QmF0dGVyeSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgY29uc3QgY2hhcmdpbmcgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgY2hhcmdpbmdUaW1lID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgZGlzY2hhcmdpbmdUaW1lID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgbGV2ZWwgPSBzaGFsbG93UmVmKDEpO1xuICBsZXQgYmF0dGVyeTtcbiAgZnVuY3Rpb24gdXBkYXRlQmF0dGVyeUluZm8oKSB7XG4gICAgY2hhcmdpbmcudmFsdWUgPSB0aGlzLmNoYXJnaW5nO1xuICAgIGNoYXJnaW5nVGltZS52YWx1ZSA9IHRoaXMuY2hhcmdpbmdUaW1lIHx8IDA7XG4gICAgZGlzY2hhcmdpbmdUaW1lLnZhbHVlID0gdGhpcy5kaXNjaGFyZ2luZ1RpbWUgfHwgMDtcbiAgICBsZXZlbC52YWx1ZSA9IHRoaXMubGV2ZWw7XG4gIH1cbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgbmF2aWdhdG9yLmdldEJhdHRlcnkoKS50aGVuKChfYmF0dGVyeSkgPT4ge1xuICAgICAgYmF0dGVyeSA9IF9iYXR0ZXJ5O1xuICAgICAgdXBkYXRlQmF0dGVyeUluZm8uY2FsbChiYXR0ZXJ5KTtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoYmF0dGVyeSwgZXZlbnRzLCB1cGRhdGVCYXR0ZXJ5SW5mbywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgY2hhcmdpbmcsXG4gICAgY2hhcmdpbmdUaW1lLFxuICAgIGRpc2NoYXJnaW5nVGltZSxcbiAgICBsZXZlbFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VCbHVldG9vdGgob3B0aW9ucykge1xuICBsZXQge1xuICAgIGFjY2VwdEFsbERldmljZXMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qge1xuICAgIGZpbHRlcnMgPSB2b2lkIDAsXG4gICAgb3B0aW9uYWxTZXJ2aWNlcyA9IHZvaWQgMCxcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJibHVldG9vdGhcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBkZXZpY2UgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgd2F0Y2goZGV2aWNlLCAoKSA9PiB7XG4gICAgY29ubmVjdFRvQmx1ZXRvb3RoR0FUVFNlcnZlcigpO1xuICB9KTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdERldmljZSgpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgICBpZiAoZmlsdGVycyAmJiBmaWx0ZXJzLmxlbmd0aCA+IDApXG4gICAgICBhY2NlcHRBbGxEZXZpY2VzID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGRldmljZS52YWx1ZSA9IGF3YWl0IChuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5ibHVldG9vdGgucmVxdWVzdERldmljZSh7XG4gICAgICAgIGFjY2VwdEFsbERldmljZXMsXG4gICAgICAgIGZpbHRlcnMsXG4gICAgICAgIG9wdGlvbmFsU2VydmljZXNcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZXJ2ZXIgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IGlzQ29ubmVjdGVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlzQ29ubmVjdGVkLnZhbHVlID0gZmFsc2U7XG4gICAgZGV2aWNlLnZhbHVlID0gdm9pZCAwO1xuICAgIHNlcnZlci52YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjb25uZWN0VG9CbHVldG9vdGhHQVRUU2VydmVyKCkge1xuICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgICBpZiAoZGV2aWNlLnZhbHVlICYmIGRldmljZS52YWx1ZS5nYXR0KSB7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKGRldmljZSwgXCJnYXR0c2VydmVyZGlzY29ubmVjdGVkXCIsIHJlc2V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBzZXJ2ZXIudmFsdWUgPSBhd2FpdCBkZXZpY2UudmFsdWUuZ2F0dC5jb25uZWN0KCk7XG4gICAgICAgIGlzQ29ubmVjdGVkLnZhbHVlID0gc2VydmVyLnZhbHVlLmNvbm5lY3RlZDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJ5T25Nb3VudGVkKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGRldmljZS52YWx1ZSlcbiAgICAgIChfYSA9IGRldmljZS52YWx1ZS5nYXR0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29ubmVjdCgpO1xuICB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZGV2aWNlLnZhbHVlKVxuICAgICAgKF9hID0gZGV2aWNlLnZhbHVlLmdhdHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzQ29ubmVjdGVkOiByZWFkb25seShpc0Nvbm5lY3RlZCksXG4gICAgLy8gRGV2aWNlOlxuICAgIGRldmljZSxcbiAgICByZXF1ZXN0RGV2aWNlLFxuICAgIC8vIFNlcnZlcjpcbiAgICBzZXJ2ZXIsXG4gICAgLy8gRXJyb3JzOlxuICAgIGVycm9yXG4gIH07XG59XG5cbmNvbnN0IHNzcldpZHRoU3ltYm9sID0gU3ltYm9sKFwidnVldXNlLXNzci13aWR0aFwiKTtcbmZ1bmN0aW9uIHVzZVNTUldpZHRoKCkge1xuICBjb25zdCBzc3JXaWR0aCA9IGhhc0luamVjdGlvbkNvbnRleHQoKSA/IGluamVjdExvY2FsKHNzcldpZHRoU3ltYm9sLCBudWxsKSA6IG51bGw7XG4gIHJldHVybiB0eXBlb2Ygc3NyV2lkdGggPT09IFwibnVtYmVyXCIgPyBzc3JXaWR0aCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHByb3ZpZGVTU1JXaWR0aCh3aWR0aCwgYXBwKSB7XG4gIGlmIChhcHAgIT09IHZvaWQgMCkge1xuICAgIGFwcC5wcm92aWRlKHNzcldpZHRoU3ltYm9sLCB3aWR0aCk7XG4gIH0gZWxzZSB7XG4gICAgcHJvdmlkZUxvY2FsKHNzcldpZHRoU3ltYm9sLCB3aWR0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTWVkaWFRdWVyeShxdWVyeSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgc3NyV2lkdGggPSB1c2VTU1JXaWR0aCgpIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJtYXRjaE1lZGlhXCIgaW4gd2luZG93ICYmIHR5cGVvZiB3aW5kb3cubWF0Y2hNZWRpYSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgY29uc3Qgc3NyU3VwcG9ydCA9IHNoYWxsb3dSZWYodHlwZW9mIHNzcldpZHRoID09PSBcIm51bWJlclwiKTtcbiAgY29uc3QgbWVkaWFRdWVyeSA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgbWF0Y2hlcyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBoYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgbWF0Y2hlcy52YWx1ZSA9IGV2ZW50Lm1hdGNoZXM7XG4gIH07XG4gIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3NyU3VwcG9ydC52YWx1ZSkge1xuICAgICAgc3NyU3VwcG9ydC52YWx1ZSA9ICFpc1N1cHBvcnRlZC52YWx1ZTtcbiAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5ncyA9IHRvVmFsdWUocXVlcnkpLnNwbGl0KFwiLFwiKTtcbiAgICAgIG1hdGNoZXMudmFsdWUgPSBxdWVyeVN0cmluZ3Muc29tZSgocXVlcnlTdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3Qgbm90ID0gcXVlcnlTdHJpbmcuaW5jbHVkZXMoXCJub3QgYWxsXCIpO1xuICAgICAgICBjb25zdCBtaW5XaWR0aCA9IHF1ZXJ5U3RyaW5nLm1hdGNoKC9cXChcXHMqbWluLXdpZHRoOlxccyooLT9cXGQrKD86XFwuXFxkKik/W2Etel0rXFxzKilcXCkvKTtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBxdWVyeVN0cmluZy5tYXRjaCgvXFwoXFxzKm1heC13aWR0aDpcXHMqKC0/XFxkKyg/OlxcLlxcZCopP1thLXpdK1xccyopXFwpLyk7XG4gICAgICAgIGxldCByZXMgPSBCb29sZWFuKG1pbldpZHRoIHx8IG1heFdpZHRoKTtcbiAgICAgICAgaWYgKG1pbldpZHRoICYmIHJlcykge1xuICAgICAgICAgIHJlcyA9IHNzcldpZHRoID49IHB4VmFsdWUobWluV2lkdGhbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhXaWR0aCAmJiByZXMpIHtcbiAgICAgICAgICByZXMgPSBzc3JXaWR0aCA8PSBweFZhbHVlKG1heFdpZHRoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90ID8gIXJlcyA6IHJlcztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIG1lZGlhUXVlcnkudmFsdWUgPSB3aW5kb3cubWF0Y2hNZWRpYSh0b1ZhbHVlKHF1ZXJ5KSk7XG4gICAgbWF0Y2hlcy52YWx1ZSA9IG1lZGlhUXVlcnkudmFsdWUubWF0Y2hlcztcbiAgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIobWVkaWFRdWVyeSwgXCJjaGFuZ2VcIiwgaGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gbWF0Y2hlcy52YWx1ZSk7XG59XG5cbmNvbnN0IGJyZWFrcG9pbnRzVGFpbHdpbmQgPSB7XG4gIFwic21cIjogNjQwLFxuICBcIm1kXCI6IDc2OCxcbiAgXCJsZ1wiOiAxMDI0LFxuICBcInhsXCI6IDEyODAsXG4gIFwiMnhsXCI6IDE1MzZcbn07XG5jb25zdCBicmVha3BvaW50c0Jvb3RzdHJhcFY1ID0ge1xuICB4czogMCxcbiAgc206IDU3NixcbiAgbWQ6IDc2OCxcbiAgbGc6IDk5MixcbiAgeGw6IDEyMDAsXG4gIHh4bDogMTQwMFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzVnVldGlmeVYyID0ge1xuICB4czogMCxcbiAgc206IDYwMCxcbiAgbWQ6IDk2MCxcbiAgbGc6IDEyNjQsXG4gIHhsOiAxOTA0XG59O1xuY29uc3QgYnJlYWtwb2ludHNWdWV0aWZ5VjMgPSB7XG4gIHhzOiAwLFxuICBzbTogNjAwLFxuICBtZDogOTYwLFxuICBsZzogMTI4MCxcbiAgeGw6IDE5MjAsXG4gIHh4bDogMjU2MFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzVnVldGlmeSA9IGJyZWFrcG9pbnRzVnVldGlmeVYyO1xuY29uc3QgYnJlYWtwb2ludHNBbnREZXNpZ24gPSB7XG4gIHhzOiA0ODAsXG4gIHNtOiA1NzYsXG4gIG1kOiA3NjgsXG4gIGxnOiA5OTIsXG4gIHhsOiAxMjAwLFxuICB4eGw6IDE2MDBcbn07XG5jb25zdCBicmVha3BvaW50c1F1YXNhciA9IHtcbiAgeHM6IDAsXG4gIHNtOiA2MDAsXG4gIG1kOiAxMDI0LFxuICBsZzogMTQ0MCxcbiAgeGw6IDE5MjBcbn07XG5jb25zdCBicmVha3BvaW50c1NlbWF0aWMgPSB7XG4gIG1vYmlsZVM6IDMyMCxcbiAgbW9iaWxlTTogMzc1LFxuICBtb2JpbGVMOiA0MjUsXG4gIHRhYmxldDogNzY4LFxuICBsYXB0b3A6IDEwMjQsXG4gIGxhcHRvcEw6IDE0NDAsXG4gIGRlc2t0b3A0SzogMjU2MFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzTWFzdGVyQ3NzID0ge1xuICBcIjN4c1wiOiAzNjAsXG4gIFwiMnhzXCI6IDQ4MCxcbiAgXCJ4c1wiOiA2MDAsXG4gIFwic21cIjogNzY4LFxuICBcIm1kXCI6IDEwMjQsXG4gIFwibGdcIjogMTI4MCxcbiAgXCJ4bFwiOiAxNDQwLFxuICBcIjJ4bFwiOiAxNjAwLFxuICBcIjN4bFwiOiAxOTIwLFxuICBcIjR4bFwiOiAyNTYwXG59O1xuY29uc3QgYnJlYWtwb2ludHNQcmltZUZsZXggPSB7XG4gIHNtOiA1NzYsXG4gIG1kOiA3NjgsXG4gIGxnOiA5OTIsXG4gIHhsOiAxMjAwXG59O1xuY29uc3QgYnJlYWtwb2ludHNFbGVtZW50ID0ge1xuICB4czogMCxcbiAgc206IDc2OCxcbiAgbWQ6IDk5MixcbiAgbGc6IDEyMDAsXG4gIHhsOiAxOTIwXG59O1xuXG5mdW5jdGlvbiB1c2VCcmVha3BvaW50cyhicmVha3BvaW50cywgb3B0aW9ucyA9IHt9KSB7XG4gIGZ1bmN0aW9uIGdldFZhbHVlKGssIGRlbHRhKSB7XG4gICAgbGV0IHYgPSB0b1ZhbHVlKGJyZWFrcG9pbnRzW3RvVmFsdWUoayldKTtcbiAgICBpZiAoZGVsdGEgIT0gbnVsbClcbiAgICAgIHYgPSBpbmNyZWFzZVdpdGhVbml0KHYsIGRlbHRhKTtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpXG4gICAgICB2ID0gYCR7dn1weGA7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCBzdHJhdGVneSA9IFwibWluLXdpZHRoXCIsIHNzcldpZHRoID0gdXNlU1NSV2lkdGgoKSB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc3NyU3VwcG9ydCA9IHR5cGVvZiBzc3JXaWR0aCA9PT0gXCJudW1iZXJcIjtcbiAgY29uc3QgbW91bnRlZCA9IHNzclN1cHBvcnQgPyBzaGFsbG93UmVmKGZhbHNlKSA6IHsgdmFsdWU6IHRydWUgfTtcbiAgaWYgKHNzclN1cHBvcnQpIHtcbiAgICB0cnlPbk1vdW50ZWQoKCkgPT4gbW91bnRlZC52YWx1ZSA9ICEhd2luZG93KTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaChxdWVyeSwgc2l6ZSkge1xuICAgIGlmICghbW91bnRlZC52YWx1ZSAmJiBzc3JTdXBwb3J0KSB7XG4gICAgICByZXR1cm4gcXVlcnkgPT09IFwibWluXCIgPyBzc3JXaWR0aCA+PSBweFZhbHVlKHNpemUpIDogc3NyV2lkdGggPD0gcHhWYWx1ZShzaXplKTtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKGAoJHtxdWVyeX0td2lkdGg6ICR7c2l6ZX0pYCkubWF0Y2hlcztcbiAgfVxuICBjb25zdCBncmVhdGVyT3JFcXVhbCA9IChrKSA9PiB7XG4gICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoayl9KWAsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBzbWFsbGVyT3JFcXVhbCA9IChrKSA9PiB7XG4gICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtYXgtd2lkdGg6ICR7Z2V0VmFsdWUoayl9KWAsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBzaG9ydGN1dE1ldGhvZHMgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cykucmVkdWNlKChzaG9ydGN1dHMsIGspID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2hvcnRjdXRzLCBrLCB7XG4gICAgICBnZXQ6ICgpID0+IHN0cmF0ZWd5ID09PSBcIm1pbi13aWR0aFwiID8gZ3JlYXRlck9yRXF1YWwoaykgOiBzbWFsbGVyT3JFcXVhbChrKSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gc2hvcnRjdXRzO1xuICB9LCB7fSk7XG4gIGZ1bmN0aW9uIGN1cnJlbnQoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLm1hcCgoaykgPT4gW2ssIHNob3J0Y3V0TWV0aG9kc1trXSwgcHhWYWx1ZShnZXRWYWx1ZShrKSldKS5zb3J0KChhLCBiKSA9PiBhWzJdIC0gYlsyXSk7XG4gICAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHBvaW50cy5maWx0ZXIoKFssIHZdKSA9PiB2LnZhbHVlKS5tYXAoKFtrXSkgPT4gaykpO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHNob3J0Y3V0TWV0aG9kcywge1xuICAgIGdyZWF0ZXJPckVxdWFsLFxuICAgIHNtYWxsZXJPckVxdWFsLFxuICAgIGdyZWF0ZXIoaykge1xuICAgICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoaywgMC4xKX0pYCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBzbWFsbGVyKGspIHtcbiAgICAgIHJldHVybiB1c2VNZWRpYVF1ZXJ5KCgpID0+IGAobWF4LXdpZHRoOiAke2dldFZhbHVlKGssIC0wLjEpfSlgLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGJldHdlZW4oYSwgYikge1xuICAgICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoYSl9KSBhbmQgKG1heC13aWR0aDogJHtnZXRWYWx1ZShiLCAtMC4xKX0pYCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBpc0dyZWF0ZXIoaykge1xuICAgICAgcmV0dXJuIG1hdGNoKFwibWluXCIsIGdldFZhbHVlKGssIDAuMSkpO1xuICAgIH0sXG4gICAgaXNHcmVhdGVyT3JFcXVhbChrKSB7XG4gICAgICByZXR1cm4gbWF0Y2goXCJtaW5cIiwgZ2V0VmFsdWUoaykpO1xuICAgIH0sXG4gICAgaXNTbWFsbGVyKGspIHtcbiAgICAgIHJldHVybiBtYXRjaChcIm1heFwiLCBnZXRWYWx1ZShrLCAtMC4xKSk7XG4gICAgfSxcbiAgICBpc1NtYWxsZXJPckVxdWFsKGspIHtcbiAgICAgIHJldHVybiBtYXRjaChcIm1heFwiLCBnZXRWYWx1ZShrKSk7XG4gICAgfSxcbiAgICBpc0luQmV0d2VlbihhLCBiKSB7XG4gICAgICByZXR1cm4gbWF0Y2goXCJtaW5cIiwgZ2V0VmFsdWUoYSkpICYmIG1hdGNoKFwibWF4XCIsIGdldFZhbHVlKGIsIC0wLjEpKTtcbiAgICB9LFxuICAgIGN1cnJlbnQsXG4gICAgYWN0aXZlKCkge1xuICAgICAgY29uc3QgYnBzID0gY3VycmVudCgpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IGJwcy52YWx1ZS5sZW5ndGggPT09IDAgPyBcIlwiIDogYnBzLnZhbHVlLmF0KHN0cmF0ZWd5ID09PSBcIm1pbi13aWR0aFwiID8gLTEgOiAwKSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQnJvYWRjYXN0Q2hhbm5lbChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIkJyb2FkY2FzdENoYW5uZWxcIiBpbiB3aW5kb3cpO1xuICBjb25zdCBpc0Nsb3NlZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBjaGFubmVsID0gcmVmKCk7XG4gIGNvbnN0IGRhdGEgPSByZWYoKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBwb3N0ID0gKGRhdGEyKSA9PiB7XG4gICAgaWYgKGNoYW5uZWwudmFsdWUpXG4gICAgICBjaGFubmVsLnZhbHVlLnBvc3RNZXNzYWdlKGRhdGEyKTtcbiAgfTtcbiAgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgaWYgKGNoYW5uZWwudmFsdWUpXG4gICAgICBjaGFubmVsLnZhbHVlLmNsb3NlKCk7XG4gICAgaXNDbG9zZWQudmFsdWUgPSB0cnVlO1xuICB9O1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgICAgY2hhbm5lbC52YWx1ZSA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKG5hbWUpO1xuICAgICAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0ge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9O1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihjaGFubmVsLCBcIm1lc3NhZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgZGF0YS52YWx1ZSA9IGUuZGF0YTtcbiAgICAgIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKGNoYW5uZWwsIFwibWVzc2FnZWVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgIGVycm9yLnZhbHVlID0gZTtcbiAgICAgIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKGNoYW5uZWwsIFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICBpc0Nsb3NlZC52YWx1ZSA9IHRydWU7XG4gICAgICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBjbG9zZSgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBjaGFubmVsLFxuICAgIGRhdGEsXG4gICAgcG9zdCxcbiAgICBjbG9zZSxcbiAgICBlcnJvcixcbiAgICBpc0Nsb3NlZFxuICB9O1xufVxuXG5jb25zdCBXUklUQUJMRV9QUk9QRVJUSUVTID0gW1xuICBcImhhc2hcIixcbiAgXCJob3N0XCIsXG4gIFwiaG9zdG5hbWVcIixcbiAgXCJocmVmXCIsXG4gIFwicGF0aG5hbWVcIixcbiAgXCJwb3J0XCIsXG4gIFwicHJvdG9jb2xcIixcbiAgXCJzZWFyY2hcIlxuXTtcbmZ1bmN0aW9uIHVzZUJyb3dzZXJMb2NhdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCByZWZzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIFdSSVRBQkxFX1BST1BFUlRJRVMubWFwKChrZXkpID0+IFtrZXksIHJlZigpXSlcbiAgKTtcbiAgZm9yIChjb25zdCBba2V5LCByZWZdIG9mIG9iamVjdEVudHJpZXMocmVmcykpIHtcbiAgICB3YXRjaChyZWYsICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCEod2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pIHx8IHdpbmRvdy5sb2NhdGlvbltrZXldID09PSB2YWx1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgd2luZG93LmxvY2F0aW9uW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBidWlsZFN0YXRlID0gKHRyaWdnZXIpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzdGF0ZTogc3RhdGUyLCBsZW5ndGggfSA9ICh3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5oaXN0b3J5KSB8fCB7fTtcbiAgICBjb25zdCB7IG9yaWdpbiB9ID0gKHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBXUklUQUJMRV9QUk9QRVJUSUVTKVxuICAgICAgcmVmc1trZXldLnZhbHVlID0gKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYVtrZXldO1xuICAgIHJldHVybiByZWFjdGl2ZSh7XG4gICAgICB0cmlnZ2VyLFxuICAgICAgc3RhdGU6IHN0YXRlMixcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9yaWdpbixcbiAgICAgIC4uLnJlZnNcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc3RhdGUgPSByZWYoYnVpbGRTdGF0ZShcImxvYWRcIikpO1xuICBpZiAod2luZG93KSB7XG4gICAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwicG9wc3RhdGVcIiwgKCkgPT4gc3RhdGUudmFsdWUgPSBidWlsZFN0YXRlKFwicG9wc3RhdGVcIiksIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCAoKSA9PiBzdGF0ZS52YWx1ZSA9IGJ1aWxkU3RhdGUoXCJoYXNoY2hhbmdlXCIpLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gdXNlQ2FjaGVkKHJlZlZhbHVlLCBjb21wYXJhdG9yID0gKGEsIGIpID0+IGEgPT09IGIsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBkZWVwUmVmcyA9IHRydWUsIC4uLndhdGNoT3B0aW9ucyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgY2FjaGVkVmFsdWUgPSBjcmVhdGVSZWYocmVmVmFsdWUudmFsdWUsIGRlZXBSZWZzKTtcbiAgd2F0Y2goKCkgPT4gcmVmVmFsdWUudmFsdWUsICh2YWx1ZSkgPT4ge1xuICAgIGlmICghY29tcGFyYXRvcih2YWx1ZSwgY2FjaGVkVmFsdWUudmFsdWUpKVxuICAgICAgY2FjaGVkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgfSwgd2F0Y2hPcHRpb25zKTtcbiAgcmV0dXJuIGNhY2hlZFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VQZXJtaXNzaW9uKHBlcm1pc3Npb25EZXNjLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2xzID0gZmFsc2UsXG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwicGVybWlzc2lvbnNcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBwZXJtaXNzaW9uU3RhdHVzID0gc2hhbGxvd1JlZigpO1xuICBjb25zdCBkZXNjID0gdHlwZW9mIHBlcm1pc3Npb25EZXNjID09PSBcInN0cmluZ1wiID8geyBuYW1lOiBwZXJtaXNzaW9uRGVzYyB9IDogcGVybWlzc2lvbkRlc2M7XG4gIGNvbnN0IHN0YXRlID0gc2hhbGxvd1JlZigpO1xuICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBzdGF0ZS52YWx1ZSA9IChfYiA9IChfYSA9IHBlcm1pc3Npb25TdGF0dXMudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT0gbnVsbCA/IF9iIDogXCJwcm9tcHRcIjtcbiAgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihwZXJtaXNzaW9uU3RhdHVzLCBcImNoYW5nZVwiLCB1cGRhdGUsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgY29uc3QgcXVlcnkgPSBjcmVhdGVTaW5nbGV0b25Qcm9taXNlKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcGVybWlzc2lvblN0YXR1cy52YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGVybWlzc2lvblN0YXR1cy52YWx1ZSA9IGF3YWl0IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeShkZXNjKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcGVybWlzc2lvblN0YXR1cy52YWx1ZSA9IHZvaWQgMDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udHJvbHMpXG4gICAgICByZXR1cm4gdG9SYXcocGVybWlzc2lvblN0YXR1cy52YWx1ZSk7XG4gIH0pO1xuICBxdWVyeSgpO1xuICBpZiAoY29udHJvbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGUsXG4gICAgICBpc1N1cHBvcnRlZCxcbiAgICAgIHF1ZXJ5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2xpcGJvYXJkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICByZWFkID0gZmFsc2UsXG4gICAgc291cmNlLFxuICAgIGNvcGllZER1cmluZyA9IDE1MDAsXG4gICAgbGVnYWN5ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzQ2xpcGJvYXJkQXBpU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImNsaXBib2FyZFwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IHBlcm1pc3Npb25SZWFkID0gdXNlUGVybWlzc2lvbihcImNsaXBib2FyZC1yZWFkXCIpO1xuICBjb25zdCBwZXJtaXNzaW9uV3JpdGUgPSB1c2VQZXJtaXNzaW9uKFwiY2xpcGJvYXJkLXdyaXRlXCIpO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IGNvbXB1dGVkKCgpID0+IGlzQ2xpcGJvYXJkQXBpU3VwcG9ydGVkLnZhbHVlIHx8IGxlZ2FjeSk7XG4gIGNvbnN0IHRleHQgPSBzaGFsbG93UmVmKFwiXCIpO1xuICBjb25zdCBjb3BpZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgdGltZW91dCA9IHVzZVRpbWVvdXRGbigoKSA9PiBjb3BpZWQudmFsdWUgPSBmYWxzZSwgY29waWVkRHVyaW5nLCB7IGltbWVkaWF0ZTogZmFsc2UgfSk7XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVRleHQoKSB7XG4gICAgbGV0IHVzZUxlZ2FjeSA9ICEoaXNDbGlwYm9hcmRBcGlTdXBwb3J0ZWQudmFsdWUgJiYgaXNBbGxvd2VkKHBlcm1pc3Npb25SZWFkLnZhbHVlKSk7XG4gICAgaWYgKCF1c2VMZWdhY3kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQudmFsdWUgPSBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLnJlYWRUZXh0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHVzZUxlZ2FjeSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VMZWdhY3kpIHtcbiAgICAgIHRleHQudmFsdWUgPSBsZWdhY3lSZWFkKCk7XG4gICAgfVxuICB9XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiByZWFkKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoW1wiY29weVwiLCBcImN1dFwiXSwgdXBkYXRlVGV4dCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICBhc3luYyBmdW5jdGlvbiBjb3B5KHZhbHVlID0gdG9WYWx1ZShzb3VyY2UpKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGxldCB1c2VMZWdhY3kgPSAhKGlzQ2xpcGJvYXJkQXBpU3VwcG9ydGVkLnZhbHVlICYmIGlzQWxsb3dlZChwZXJtaXNzaW9uV3JpdGUudmFsdWUpKTtcbiAgICAgIGlmICghdXNlTGVnYWN5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdXNlTGVnYWN5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVzZUxlZ2FjeSlcbiAgICAgICAgbGVnYWN5Q29weSh2YWx1ZSk7XG4gICAgICB0ZXh0LnZhbHVlID0gdmFsdWU7XG4gICAgICBjb3BpZWQudmFsdWUgPSB0cnVlO1xuICAgICAgdGltZW91dC5zdGFydCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsZWdhY3lDb3B5KHZhbHVlKSB7XG4gICAgY29uc3QgdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgdGEudmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBcIlwiO1xuICAgIHRhLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHRhLnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRhKTtcbiAgICB0YS5zZWxlY3QoKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIik7XG4gICAgdGEucmVtb3ZlKCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVnYWN5UmVhZCgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmdldFNlbGVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZG9jdW1lbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF9jIDogXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBpc0FsbG93ZWQoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gXCJncmFudGVkXCIgfHwgc3RhdHVzID09PSBcInByb21wdFwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgdGV4dCxcbiAgICBjb3BpZWQsXG4gICAgY29weVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VDbGlwYm9hcmRJdGVtcyhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IsXG4gICAgcmVhZCA9IGZhbHNlLFxuICAgIHNvdXJjZSxcbiAgICBjb3BpZWREdXJpbmcgPSAxNTAwXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJjbGlwYm9hcmRcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBjb250ZW50ID0gcmVmKFtdKTtcbiAgY29uc3QgY29waWVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHRpbWVvdXQgPSB1c2VUaW1lb3V0Rm4oKCkgPT4gY29waWVkLnZhbHVlID0gZmFsc2UsIGNvcGllZER1cmluZywgeyBpbW1lZGlhdGU6IGZhbHNlIH0pO1xuICBmdW5jdGlvbiB1cGRhdGVDb250ZW50KCkge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkKCkudGhlbigoaXRlbXMpID0+IHtcbiAgICAgICAgY29udGVudC52YWx1ZSA9IGl0ZW1zO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiByZWFkKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoW1wiY29weVwiLCBcImN1dFwiXSwgdXBkYXRlQ29udGVudCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICBhc3luYyBmdW5jdGlvbiBjb3B5KHZhbHVlID0gdG9WYWx1ZShzb3VyY2UpKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGUodmFsdWUpO1xuICAgICAgY29udGVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgY29waWVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgIHRpbWVvdXQuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBjb250ZW50LFxuICAgIGNvcGllZCxcbiAgICBjb3B5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsb25lRm5KU09OKHNvdXJjZSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzb3VyY2UpKTtcbn1cbmZ1bmN0aW9uIHVzZUNsb25lZChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBjbG9uZWQgPSByZWYoe30pO1xuICBjb25zdCBpc01vZGlmaWVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGxldCBfbGFzdFN5bmMgPSBmYWxzZTtcbiAgY29uc3Qge1xuICAgIG1hbnVhbCxcbiAgICBjbG9uZSA9IGNsb25lRm5KU09OLFxuICAgIC8vIHdhdGNoIG9wdGlvbnNcbiAgICBkZWVwID0gdHJ1ZSxcbiAgICBpbW1lZGlhdGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICB3YXRjaChjbG9uZWQsICgpID0+IHtcbiAgICBpZiAoX2xhc3RTeW5jKSB7XG4gICAgICBfbGFzdFN5bmMgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNNb2RpZmllZC52YWx1ZSA9IHRydWU7XG4gIH0sIHtcbiAgICBkZWVwOiB0cnVlLFxuICAgIGZsdXNoOiBcInN5bmNcIlxuICB9KTtcbiAgZnVuY3Rpb24gc3luYygpIHtcbiAgICBfbGFzdFN5bmMgPSB0cnVlO1xuICAgIGlzTW9kaWZpZWQudmFsdWUgPSBmYWxzZTtcbiAgICBjbG9uZWQudmFsdWUgPSBjbG9uZSh0b1ZhbHVlKHNvdXJjZSkpO1xuICB9XG4gIGlmICghbWFudWFsICYmIChpc1JlZihzb3VyY2UpIHx8IHR5cGVvZiBzb3VyY2UgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB3YXRjaChzb3VyY2UsIHN5bmMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBkZWVwLFxuICAgICAgaW1tZWRpYXRlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3luYygpO1xuICB9XG4gIHJldHVybiB7IGNsb25lZCwgaXNNb2RpZmllZCwgc3luYyB9O1xufVxuXG5jb25zdCBfZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB7fTtcbmNvbnN0IGdsb2JhbEtleSA9IFwiX192dWV1c2Vfc3NyX2hhbmRsZXJzX19cIjtcbmNvbnN0IGhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGdldEhhbmRsZXJzKCk7XG5mdW5jdGlvbiBnZXRIYW5kbGVycygpIHtcbiAgaWYgKCEoZ2xvYmFsS2V5IGluIF9nbG9iYWwpKVxuICAgIF9nbG9iYWxbZ2xvYmFsS2V5XSA9IF9nbG9iYWxbZ2xvYmFsS2V5XSB8fCB7fTtcbiAgcmV0dXJuIF9nbG9iYWxbZ2xvYmFsS2V5XTtcbn1cbmZ1bmN0aW9uIGdldFNTUkhhbmRsZXIoa2V5LCBmYWxsYmFjaykge1xuICByZXR1cm4gaGFuZGxlcnNba2V5XSB8fCBmYWxsYmFjaztcbn1cbmZ1bmN0aW9uIHNldFNTUkhhbmRsZXIoa2V5LCBmbikge1xuICBoYW5kbGVyc1trZXldID0gZm47XG59XG5cbmZ1bmN0aW9uIHVzZVByZWZlcnJlZERhcmsob3B0aW9ucykge1xuICByZXR1cm4gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIiwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGd1ZXNzU2VyaWFsaXplclR5cGUocmF3SW5pdCkge1xuICByZXR1cm4gcmF3SW5pdCA9PSBudWxsID8gXCJhbnlcIiA6IHJhd0luaXQgaW5zdGFuY2VvZiBTZXQgPyBcInNldFwiIDogcmF3SW5pdCBpbnN0YW5jZW9mIE1hcCA/IFwibWFwXCIgOiByYXdJbml0IGluc3RhbmNlb2YgRGF0ZSA/IFwiZGF0ZVwiIDogdHlwZW9mIHJhd0luaXQgPT09IFwiYm9vbGVhblwiID8gXCJib29sZWFuXCIgOiB0eXBlb2YgcmF3SW5pdCA9PT0gXCJzdHJpbmdcIiA/IFwic3RyaW5nXCIgOiB0eXBlb2YgcmF3SW5pdCA9PT0gXCJvYmplY3RcIiA/IFwib2JqZWN0XCIgOiAhTnVtYmVyLmlzTmFOKHJhd0luaXQpID8gXCJudW1iZXJcIiA6IFwiYW55XCI7XG59XG5cbmNvbnN0IFN0b3JhZ2VTZXJpYWxpemVycyA9IHtcbiAgYm9vbGVhbjoge1xuICAgIHJlYWQ6ICh2KSA9PiB2ID09PSBcInRydWVcIixcbiAgICB3cml0ZTogKHYpID0+IFN0cmluZyh2KVxuICB9LFxuICBvYmplY3Q6IHtcbiAgICByZWFkOiAodikgPT4gSlNPTi5wYXJzZSh2KSxcbiAgICB3cml0ZTogKHYpID0+IEpTT04uc3RyaW5naWZ5KHYpXG4gIH0sXG4gIG51bWJlcjoge1xuICAgIHJlYWQ6ICh2KSA9PiBOdW1iZXIucGFyc2VGbG9hdCh2KSxcbiAgICB3cml0ZTogKHYpID0+IFN0cmluZyh2KVxuICB9LFxuICBhbnk6IHtcbiAgICByZWFkOiAodikgPT4gdixcbiAgICB3cml0ZTogKHYpID0+IFN0cmluZyh2KVxuICB9LFxuICBzdHJpbmc6IHtcbiAgICByZWFkOiAodikgPT4gdixcbiAgICB3cml0ZTogKHYpID0+IFN0cmluZyh2KVxuICB9LFxuICBtYXA6IHtcbiAgICByZWFkOiAodikgPT4gbmV3IE1hcChKU09OLnBhcnNlKHYpKSxcbiAgICB3cml0ZTogKHYpID0+IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20odi5lbnRyaWVzKCkpKVxuICB9LFxuICBzZXQ6IHtcbiAgICByZWFkOiAodikgPT4gbmV3IFNldChKU09OLnBhcnNlKHYpKSxcbiAgICB3cml0ZTogKHYpID0+IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20odikpXG4gIH0sXG4gIGRhdGU6IHtcbiAgICByZWFkOiAodikgPT4gbmV3IERhdGUodiksXG4gICAgd3JpdGU6ICh2KSA9PiB2LnRvSVNPU3RyaW5nKClcbiAgfVxufTtcbmNvbnN0IGN1c3RvbVN0b3JhZ2VFdmVudE5hbWUgPSBcInZ1ZXVzZS1zdG9yYWdlXCI7XG5mdW5jdGlvbiB1c2VTdG9yYWdlKGtleSwgZGVmYXVsdHMsIHN0b3JhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBmbHVzaCA9IFwicHJlXCIsXG4gICAgZGVlcCA9IHRydWUsXG4gICAgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcyA9IHRydWUsXG4gICAgd3JpdGVEZWZhdWx0cyA9IHRydWUsXG4gICAgbWVyZ2VEZWZhdWx0cyA9IGZhbHNlLFxuICAgIHNoYWxsb3csXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBldmVudEZpbHRlcixcbiAgICBvbkVycm9yID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfSxcbiAgICBpbml0T25Nb3VudGVkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhID0gKHNoYWxsb3cgPyBzaGFsbG93UmVmIDogcmVmKSh0eXBlb2YgZGVmYXVsdHMgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRzKCkgOiBkZWZhdWx0cyk7XG4gIGNvbnN0IGtleUNvbXB1dGVkID0gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShrZXkpKTtcbiAgaWYgKCFzdG9yYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0b3JhZ2UgPSBnZXRTU1JIYW5kbGVyKFwiZ2V0RGVmYXVsdFN0b3JhZ2VcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKF9hMiA9IGRlZmF1bHRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9jYWxTdG9yYWdlO1xuICAgICAgfSkoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAoIXN0b3JhZ2UpXG4gICAgcmV0dXJuIGRhdGE7XG4gIGNvbnN0IHJhd0luaXQgPSB0b1ZhbHVlKGRlZmF1bHRzKTtcbiAgY29uc3QgdHlwZSA9IGd1ZXNzU2VyaWFsaXplclR5cGUocmF3SW5pdCk7XG4gIGNvbnN0IHNlcmlhbGl6ZXIgPSAoX2EgPSBvcHRpb25zLnNlcmlhbGl6ZXIpICE9IG51bGwgPyBfYSA6IFN0b3JhZ2VTZXJpYWxpemVyc1t0eXBlXTtcbiAgY29uc3QgeyBwYXVzZTogcGF1c2VXYXRjaCwgcmVzdW1lOiByZXN1bWVXYXRjaCB9ID0gcGF1c2FibGVXYXRjaChcbiAgICBkYXRhLFxuICAgICgpID0+IHdyaXRlKGRhdGEudmFsdWUpLFxuICAgIHsgZmx1c2gsIGRlZXAsIGV2ZW50RmlsdGVyIH1cbiAgKTtcbiAgd2F0Y2goa2V5Q29tcHV0ZWQsICgpID0+IHVwZGF0ZSgpLCB7IGZsdXNoIH0pO1xuICBsZXQgZmlyc3RNb3VudGVkID0gZmFsc2U7XG4gIGNvbnN0IG9uU3RvcmFnZUV2ZW50ID0gKGV2KSA9PiB7XG4gICAgaWYgKGluaXRPbk1vdW50ZWQgJiYgIWZpcnN0TW91bnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGUoZXYpO1xuICB9O1xuICBjb25zdCBvblN0b3JhZ2VDdXN0b21FdmVudCA9IChldikgPT4ge1xuICAgIGlmIChpbml0T25Nb3VudGVkICYmICFmaXJzdE1vdW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRnJvbUN1c3RvbUV2ZW50KGV2KTtcbiAgfTtcbiAgaWYgKHdpbmRvdyAmJiBsaXN0ZW5Ub1N0b3JhZ2VDaGFuZ2VzKSB7XG4gICAgaWYgKHN0b3JhZ2UgaW5zdGFuY2VvZiBTdG9yYWdlKVxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwic3RvcmFnZVwiLCBvblN0b3JhZ2VFdmVudCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIGVsc2VcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBjdXN0b21TdG9yYWdlRXZlbnROYW1lLCBvblN0b3JhZ2VDdXN0b21FdmVudCk7XG4gIH1cbiAgaWYgKGluaXRPbk1vdW50ZWQpIHtcbiAgICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgZmlyc3RNb3VudGVkID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoV3JpdGVFdmVudChvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAod2luZG93KSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBrZXk6IGtleUNvbXB1dGVkLnZhbHVlLFxuICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgIHN0b3JhZ2VBcmVhOiBzdG9yYWdlXG4gICAgICB9O1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoc3RvcmFnZSBpbnN0YW5jZW9mIFN0b3JhZ2UgPyBuZXcgU3RvcmFnZUV2ZW50KFwic3RvcmFnZVwiLCBwYXlsb2FkKSA6IG5ldyBDdXN0b21FdmVudChjdXN0b21TdG9yYWdlRXZlbnROYW1lLCB7XG4gICAgICAgIGRldGFpbDogcGF5bG9hZFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3cml0ZSh2KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gc3RvcmFnZS5nZXRJdGVtKGtleUNvbXB1dGVkLnZhbHVlKTtcbiAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgZGlzcGF0Y2hXcml0ZUV2ZW50KG9sZFZhbHVlLCBudWxsKTtcbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleUNvbXB1dGVkLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVyLndyaXRlKHYpO1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5Q29tcHV0ZWQudmFsdWUsIHNlcmlhbGl6ZWQpO1xuICAgICAgICAgIGRpc3BhdGNoV3JpdGVFdmVudChvbGRWYWx1ZSwgc2VyaWFsaXplZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgY29uc3QgcmF3VmFsdWUgPSBldmVudCA/IGV2ZW50Lm5ld1ZhbHVlIDogc3RvcmFnZS5nZXRJdGVtKGtleUNvbXB1dGVkLnZhbHVlKTtcbiAgICBpZiAocmF3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgaWYgKHdyaXRlRGVmYXVsdHMgJiYgcmF3SW5pdCAhPSBudWxsKVxuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5Q29tcHV0ZWQudmFsdWUsIHNlcmlhbGl6ZXIud3JpdGUocmF3SW5pdCkpO1xuICAgICAgcmV0dXJuIHJhd0luaXQ7XG4gICAgfSBlbHNlIGlmICghZXZlbnQgJiYgbWVyZ2VEZWZhdWx0cykge1xuICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVyLnJlYWQocmF3VmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBtZXJnZURlZmF1bHRzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKHZhbHVlLCByYXdJbml0KTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4geyAuLi5yYXdJbml0LCAuLi52YWx1ZSB9O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhd1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gcmF3VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVyLnJlYWQocmF3VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuc3RvcmFnZUFyZWEgIT09IHN0b3JhZ2UpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LmtleSA9PSBudWxsKSB7XG4gICAgICBkYXRhLnZhbHVlID0gcmF3SW5pdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LmtleSAhPT0ga2V5Q29tcHV0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgcGF1c2VXYXRjaCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoKGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5uZXdWYWx1ZSkgIT09IHNlcmlhbGl6ZXIud3JpdGUoZGF0YS52YWx1ZSkpXG4gICAgICAgIGRhdGEudmFsdWUgPSByZWFkKGV2ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXZlbnQpXG4gICAgICAgIG5leHRUaWNrKHJlc3VtZVdhdGNoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdW1lV2F0Y2goKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbUN1c3RvbUV2ZW50KGV2ZW50KSB7XG4gICAgdXBkYXRlKGV2ZW50LmRldGFpbCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmNvbnN0IENTU19ESVNBQkxFX1RSQU5TID0gXCIqLCo6OmJlZm9yZSwqOjphZnRlcnstd2Via2l0LXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW1vei10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50Oy1vLXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW1zLXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7dHJhbnNpdGlvbjpub25lIWltcG9ydGFudH1cIjtcbmZ1bmN0aW9uIHVzZUNvbG9yTW9kZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdG9yID0gXCJodG1sXCIsXG4gICAgYXR0cmlidXRlID0gXCJjbGFzc1wiLFxuICAgIGluaXRpYWxWYWx1ZSA9IFwiYXV0b1wiLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgc3RvcmFnZSxcbiAgICBzdG9yYWdlS2V5ID0gXCJ2dWV1c2UtY29sb3Itc2NoZW1lXCIsXG4gICAgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcyA9IHRydWUsXG4gICAgc3RvcmFnZVJlZixcbiAgICBlbWl0QXV0byxcbiAgICBkaXNhYmxlVHJhbnNpdGlvbiA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1vZGVzID0ge1xuICAgIGF1dG86IFwiXCIsXG4gICAgbGlnaHQ6IFwibGlnaHRcIixcbiAgICBkYXJrOiBcImRhcmtcIixcbiAgICAuLi5vcHRpb25zLm1vZGVzIHx8IHt9XG4gIH07XG4gIGNvbnN0IHByZWZlcnJlZERhcmsgPSB1c2VQcmVmZXJyZWREYXJrKHsgd2luZG93IH0pO1xuICBjb25zdCBzeXN0ZW0gPSBjb21wdXRlZCgoKSA9PiBwcmVmZXJyZWREYXJrLnZhbHVlID8gXCJkYXJrXCIgOiBcImxpZ2h0XCIpO1xuICBjb25zdCBzdG9yZSA9IHN0b3JhZ2VSZWYgfHwgKHN0b3JhZ2VLZXkgPT0gbnVsbCA/IHRvUmVmKGluaXRpYWxWYWx1ZSkgOiB1c2VTdG9yYWdlKHN0b3JhZ2VLZXksIGluaXRpYWxWYWx1ZSwgc3RvcmFnZSwgeyB3aW5kb3csIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMgfSkpO1xuICBjb25zdCBzdGF0ZSA9IGNvbXB1dGVkKCgpID0+IHN0b3JlLnZhbHVlID09PSBcImF1dG9cIiA/IHN5c3RlbS52YWx1ZSA6IHN0b3JlLnZhbHVlKTtcbiAgY29uc3QgdXBkYXRlSFRNTEF0dHJzID0gZ2V0U1NSSGFuZGxlcihcbiAgICBcInVwZGF0ZUhUTUxBdHRyc1wiLFxuICAgIChzZWxlY3RvcjIsIGF0dHJpYnV0ZTIsIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IHR5cGVvZiBzZWxlY3RvcjIgPT09IFwic3RyaW5nXCIgPyB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yMikgOiB1bnJlZkVsZW1lbnQoc2VsZWN0b3IyKTtcbiAgICAgIGlmICghZWwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGNsYXNzZXNUb0FkZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgbGV0IGF0dHJpYnV0ZVRvQ2hhbmdlID0gbnVsbDtcbiAgICAgIGlmIChhdHRyaWJ1dGUyID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHZhbHVlLnNwbGl0KC9cXHMvZyk7XG4gICAgICAgIE9iamVjdC52YWx1ZXMobW9kZXMpLmZsYXRNYXAoKGkpID0+IChpIHx8IFwiXCIpLnNwbGl0KC9cXHMvZykpLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQuaW5jbHVkZXModikpXG4gICAgICAgICAgICBjbGFzc2VzVG9BZGQuYWRkKHYpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNsYXNzZXNUb1JlbW92ZS5hZGQodik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlVG9DaGFuZ2UgPSB7IGtleTogYXR0cmlidXRlMiwgdmFsdWUgfTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc2VzVG9BZGQuc2l6ZSA9PT0gMCAmJiBjbGFzc2VzVG9SZW1vdmUuc2l6ZSA9PT0gMCAmJiBhdHRyaWJ1dGVUb0NoYW5nZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHN0eWxlO1xuICAgICAgaWYgKGRpc2FibGVUcmFuc2l0aW9uKSB7XG4gICAgICAgIHN0eWxlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoQ1NTX0RJU0FCTEVfVFJBTlMpKTtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjIG9mIGNsYXNzZXNUb0FkZCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjIG9mIGNsYXNzZXNUb1JlbW92ZSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZVRvQ2hhbmdlKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0NoYW5nZS5rZXksIGF0dHJpYnV0ZVRvQ2hhbmdlLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlVHJhbnNpdGlvbikge1xuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSkub3BhY2l0eTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBmdW5jdGlvbiBkZWZhdWx0T25DaGFuZ2VkKG1vZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgdXBkYXRlSFRNTEF0dHJzKHNlbGVjdG9yLCBhdHRyaWJ1dGUsIChfYSA9IG1vZGVzW21vZGVdKSAhPSBudWxsID8gX2EgOiBtb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBvbkNoYW5nZWQobW9kZSkge1xuICAgIGlmIChvcHRpb25zLm9uQ2hhbmdlZClcbiAgICAgIG9wdGlvbnMub25DaGFuZ2VkKG1vZGUsIGRlZmF1bHRPbkNoYW5nZWQpO1xuICAgIGVsc2VcbiAgICAgIGRlZmF1bHRPbkNoYW5nZWQobW9kZSk7XG4gIH1cbiAgd2F0Y2goc3RhdGUsIG9uQ2hhbmdlZCwgeyBmbHVzaDogXCJwb3N0XCIsIGltbWVkaWF0ZTogdHJ1ZSB9KTtcbiAgdHJ5T25Nb3VudGVkKCgpID0+IG9uQ2hhbmdlZChzdGF0ZS52YWx1ZSkpO1xuICBjb25zdCBhdXRvID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBlbWl0QXV0byA/IHN0b3JlLnZhbHVlIDogc3RhdGUudmFsdWU7XG4gICAgfSxcbiAgICBzZXQodikge1xuICAgICAgc3RvcmUudmFsdWUgPSB2O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGF1dG8sIHsgc3RvcmUsIHN5c3RlbSwgc3RhdGUgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbmZpcm1EaWFsb2cocmV2ZWFsZWQgPSBzaGFsbG93UmVmKGZhbHNlKSkge1xuICBjb25zdCBjb25maXJtSG9vayA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBjYW5jZWxIb29rID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IHJldmVhbEhvb2sgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgbGV0IF9yZXNvbHZlID0gbm9vcDtcbiAgY29uc3QgcmV2ZWFsID0gKGRhdGEpID0+IHtcbiAgICByZXZlYWxIb29rLnRyaWdnZXIoZGF0YSk7XG4gICAgcmV2ZWFsZWQudmFsdWUgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBjb25maXJtID0gKGRhdGEpID0+IHtcbiAgICByZXZlYWxlZC52YWx1ZSA9IGZhbHNlO1xuICAgIGNvbmZpcm1Ib29rLnRyaWdnZXIoZGF0YSk7XG4gICAgX3Jlc29sdmUoeyBkYXRhLCBpc0NhbmNlbGVkOiBmYWxzZSB9KTtcbiAgfTtcbiAgY29uc3QgY2FuY2VsID0gKGRhdGEpID0+IHtcbiAgICByZXZlYWxlZC52YWx1ZSA9IGZhbHNlO1xuICAgIGNhbmNlbEhvb2sudHJpZ2dlcihkYXRhKTtcbiAgICBfcmVzb2x2ZSh7IGRhdGEsIGlzQ2FuY2VsZWQ6IHRydWUgfSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgaXNSZXZlYWxlZDogY29tcHV0ZWQoKCkgPT4gcmV2ZWFsZWQudmFsdWUpLFxuICAgIHJldmVhbCxcbiAgICBjb25maXJtLFxuICAgIGNhbmNlbCxcbiAgICBvblJldmVhbDogcmV2ZWFsSG9vay5vbixcbiAgICBvbkNvbmZpcm06IGNvbmZpcm1Ib29rLm9uLFxuICAgIG9uQ2FuY2VsOiBjYW5jZWxIb29rLm9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUNvdW50ZG93bihpbml0aWFsQ291bnRkb3duLCBvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJlbWFpbmluZyA9IHNoYWxsb3dSZWYodG9WYWx1ZShpbml0aWFsQ291bnRkb3duKSk7XG4gIGNvbnN0IGludGVydmFsQ29udHJvbGxlciA9IHVzZUludGVydmFsRm4oKCkgPT4ge1xuICAgIHZhciBfYTIsIF9iMjtcbiAgICBjb25zdCB2YWx1ZSA9IHJlbWFpbmluZy52YWx1ZSAtIDE7XG4gICAgcmVtYWluaW5nLnZhbHVlID0gdmFsdWUgPCAwID8gMCA6IHZhbHVlO1xuICAgIChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uVGljaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKG9wdGlvbnMpO1xuICAgIGlmIChyZW1haW5pbmcudmFsdWUgPD0gMCkge1xuICAgICAgaW50ZXJ2YWxDb250cm9sbGVyLnBhdXNlKCk7XG4gICAgICAoX2IyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vbkNvbXBsZXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmNhbGwob3B0aW9ucyk7XG4gICAgfVxuICB9LCAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmludGVydmFsKSAhPSBudWxsID8gX2EgOiAxZTMsIHsgaW1tZWRpYXRlOiAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmltbWVkaWF0ZSkgIT0gbnVsbCA/IF9iIDogZmFsc2UgfSk7XG4gIGNvbnN0IHJlc2V0ID0gKGNvdW50ZG93bikgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmVtYWluaW5nLnZhbHVlID0gKF9hMiA9IHRvVmFsdWUoY291bnRkb3duKSkgIT0gbnVsbCA/IF9hMiA6IHRvVmFsdWUoaW5pdGlhbENvdW50ZG93bik7XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaW50ZXJ2YWxDb250cm9sbGVyLnBhdXNlKCk7XG4gICAgcmVzZXQoKTtcbiAgfTtcbiAgY29uc3QgcmVzdW1lID0gKCkgPT4ge1xuICAgIGlmICghaW50ZXJ2YWxDb250cm9sbGVyLmlzQWN0aXZlLnZhbHVlKSB7XG4gICAgICBpZiAocmVtYWluaW5nLnZhbHVlID4gMCkge1xuICAgICAgICBpbnRlcnZhbENvbnRyb2xsZXIucmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzdGFydCA9IChjb3VudGRvd24pID0+IHtcbiAgICByZXNldChjb3VudGRvd24pO1xuICAgIGludGVydmFsQ29udHJvbGxlci5yZXN1bWUoKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByZW1haW5pbmcsXG4gICAgcmVzZXQsXG4gICAgc3RvcCxcbiAgICBzdGFydCxcbiAgICBwYXVzZTogaW50ZXJ2YWxDb250cm9sbGVyLnBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBpc0FjdGl2ZTogaW50ZXJ2YWxDb250cm9sbGVyLmlzQWN0aXZlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUNzc1Zhcihwcm9wLCB0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIGluaXRpYWxWYWx1ZSwgb2JzZXJ2ZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBjb25zdCB2YXJpYWJsZSA9IHNoYWxsb3dSZWYoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgZWxSZWYgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiB1bnJlZkVsZW1lbnQodGFyZ2V0KSB8fCAoKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kb2N1bWVudEVsZW1lbnQpO1xuICB9KTtcbiAgZnVuY3Rpb24gdXBkYXRlQ3NzVmFyKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBrZXkgPSB0b1ZhbHVlKHByb3ApO1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZShlbFJlZik7XG4gICAgaWYgKGVsICYmIHdpbmRvdyAmJiBrZXkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gKF9hID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRyaW0oKTtcbiAgICAgIHZhcmlhYmxlLnZhbHVlID0gdmFsdWUgfHwgdmFyaWFibGUudmFsdWUgfHwgaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAob2JzZXJ2ZSkge1xuICAgIHVzZU11dGF0aW9uT2JzZXJ2ZXIoZWxSZWYsIHVwZGF0ZUNzc1Zhciwge1xuICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJzdHlsZVwiLCBcImNsYXNzXCJdLFxuICAgICAgd2luZG93XG4gICAgfSk7XG4gIH1cbiAgd2F0Y2goXG4gICAgW2VsUmVmLCAoKSA9PiB0b1ZhbHVlKHByb3ApXSxcbiAgICAoXywgb2xkKSA9PiB7XG4gICAgICBpZiAob2xkWzBdICYmIG9sZFsxXSlcbiAgICAgICAgb2xkWzBdLnN0eWxlLnJlbW92ZVByb3BlcnR5KG9sZFsxXSk7XG4gICAgICB1cGRhdGVDc3NWYXIoKTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgd2F0Y2goXG4gICAgW3ZhcmlhYmxlLCBlbFJlZl0sXG4gICAgKFt2YWwsIGVsXSkgPT4ge1xuICAgICAgY29uc3QgcmF3X3Byb3AgPSB0b1ZhbHVlKHByb3ApO1xuICAgICAgaWYgKChlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuc3R5bGUpICYmIHJhd19wcm9wKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShyYXdfcHJvcCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShyYXdfcHJvcCwgdmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5mdW5jdGlvbiB1c2VDdXJyZW50RWxlbWVudChyb290Q29tcG9uZW50KSB7XG4gIGNvbnN0IHZtID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gY29tcHV0ZWRXaXRoQ29udHJvbChcbiAgICAoKSA9PiBudWxsLFxuICAgICgpID0+IHJvb3RDb21wb25lbnQgPyB1bnJlZkVsZW1lbnQocm9vdENvbXBvbmVudCkgOiB2bS5wcm94eS4kZWxcbiAgKTtcbiAgb25VcGRhdGVkKGN1cnJlbnRFbGVtZW50LnRyaWdnZXIpO1xuICBvbk1vdW50ZWQoY3VycmVudEVsZW1lbnQudHJpZ2dlcik7XG4gIHJldHVybiBjdXJyZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gdXNlQ3ljbGVMaXN0KGxpc3QsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhdGUgPSBzaGFsbG93UmVmKGdldEluaXRpYWxWYWx1ZSgpKTtcbiAgY29uc3QgbGlzdFJlZiA9IHRvUmVmKGxpc3QpO1xuICBjb25zdCBpbmRleCA9IGNvbXB1dGVkKHtcbiAgICBnZXQoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB0YXJnZXRMaXN0ID0gbGlzdFJlZi52YWx1ZTtcbiAgICAgIGxldCBpbmRleDIgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRJbmRleE9mKSA/IG9wdGlvbnMuZ2V0SW5kZXhPZihzdGF0ZS52YWx1ZSwgdGFyZ2V0TGlzdCkgOiB0YXJnZXRMaXN0LmluZGV4T2Yoc3RhdGUudmFsdWUpO1xuICAgICAgaWYgKGluZGV4MiA8IDApXG4gICAgICAgIGluZGV4MiA9IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2tJbmRleCkgIT0gbnVsbCA/IF9hIDogMDtcbiAgICAgIHJldHVybiBpbmRleDI7XG4gICAgfSxcbiAgICBzZXQodikge1xuICAgICAgc2V0KHYpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIHNldChpKSB7XG4gICAgY29uc3QgdGFyZ2V0TGlzdCA9IGxpc3RSZWYudmFsdWU7XG4gICAgY29uc3QgbGVuZ3RoID0gdGFyZ2V0TGlzdC5sZW5ndGg7XG4gICAgY29uc3QgaW5kZXgyID0gKGkgJSBsZW5ndGggKyBsZW5ndGgpICUgbGVuZ3RoO1xuICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0TGlzdFtpbmRleDJdO1xuICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHNoaWZ0KGRlbHRhID0gMSkge1xuICAgIHJldHVybiBzZXQoaW5kZXgudmFsdWUgKyBkZWx0YSk7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dChuID0gMSkge1xuICAgIHJldHVybiBzaGlmdChuKTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2KG4gPSAxKSB7XG4gICAgcmV0dXJuIHNoaWZ0KC1uKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gdG9WYWx1ZSgoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmluaXRpYWxWYWx1ZSkgIT0gbnVsbCA/IF9hIDogdG9WYWx1ZShsaXN0KVswXSkpICE9IG51bGwgPyBfYiA6IHZvaWQgMDtcbiAgfVxuICB3YXRjaChsaXN0UmVmLCAoKSA9PiBzZXQoaW5kZXgudmFsdWUpKTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0ZSxcbiAgICBpbmRleCxcbiAgICBuZXh0LFxuICAgIHByZXYsXG4gICAgZ286IHNldFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEYXJrKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdmFsdWVEYXJrID0gXCJkYXJrXCIsXG4gICAgdmFsdWVMaWdodCA9IFwiXCJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1vZGUgPSB1c2VDb2xvck1vZGUoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgb25DaGFuZ2VkOiAobW9kZTIsIGRlZmF1bHRIYW5kbGVyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAob3B0aW9ucy5vbkNoYW5nZWQpXG4gICAgICAgIChfYSA9IG9wdGlvbnMub25DaGFuZ2VkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBtb2RlMiA9PT0gXCJkYXJrXCIsIGRlZmF1bHRIYW5kbGVyLCBtb2RlMik7XG4gICAgICBlbHNlXG4gICAgICAgIGRlZmF1bHRIYW5kbGVyKG1vZGUyKTtcbiAgICB9LFxuICAgIG1vZGVzOiB7XG4gICAgICBkYXJrOiB2YWx1ZURhcmssXG4gICAgICBsaWdodDogdmFsdWVMaWdodFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN5c3RlbSA9IGNvbXB1dGVkKCgpID0+IG1vZGUuc3lzdGVtLnZhbHVlKTtcbiAgY29uc3QgaXNEYXJrID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBtb2RlLnZhbHVlID09PSBcImRhcmtcIjtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICBjb25zdCBtb2RlVmFsID0gdiA/IFwiZGFya1wiIDogXCJsaWdodFwiO1xuICAgICAgaWYgKHN5c3RlbS52YWx1ZSA9PT0gbW9kZVZhbClcbiAgICAgICAgbW9kZS52YWx1ZSA9IFwiYXV0b1wiO1xuICAgICAgZWxzZVxuICAgICAgICBtb2RlLnZhbHVlID0gbW9kZVZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaXNEYXJrO1xufVxuXG5mdW5jdGlvbiBmbkJ5cGFzcyh2KSB7XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZm5TZXRTb3VyY2Uoc291cmNlLCB2YWx1ZSkge1xuICByZXR1cm4gc291cmNlLnZhbHVlID0gdmFsdWU7XG59XG5mdW5jdGlvbiBkZWZhdWx0RHVtcChjbG9uZSkge1xuICByZXR1cm4gY2xvbmUgPyB0eXBlb2YgY2xvbmUgPT09IFwiZnVuY3Rpb25cIiA/IGNsb25lIDogY2xvbmVGbkpTT04gOiBmbkJ5cGFzcztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQYXJzZShjbG9uZSkge1xuICByZXR1cm4gY2xvbmUgPyB0eXBlb2YgY2xvbmUgPT09IFwiZnVuY3Rpb25cIiA/IGNsb25lIDogY2xvbmVGbkpTT04gOiBmbkJ5cGFzcztcbn1cbmZ1bmN0aW9uIHVzZU1hbnVhbFJlZkhpc3Rvcnkoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNsb25lID0gZmFsc2UsXG4gICAgZHVtcCA9IGRlZmF1bHREdW1wKGNsb25lKSxcbiAgICBwYXJzZSA9IGRlZmF1bHRQYXJzZShjbG9uZSksXG4gICAgc2V0U291cmNlID0gZm5TZXRTb3VyY2VcbiAgfSA9IG9wdGlvbnM7XG4gIGZ1bmN0aW9uIF9jcmVhdGVIaXN0b3J5UmVjb3JkKCkge1xuICAgIHJldHVybiBtYXJrUmF3KHtcbiAgICAgIHNuYXBzaG90OiBkdW1wKHNvdXJjZS52YWx1ZSksXG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCgpXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IHJlZihfY3JlYXRlSGlzdG9yeVJlY29yZCgpKTtcbiAgY29uc3QgdW5kb1N0YWNrID0gcmVmKFtdKTtcbiAgY29uc3QgcmVkb1N0YWNrID0gcmVmKFtdKTtcbiAgY29uc3QgX3NldFNvdXJjZSA9IChyZWNvcmQpID0+IHtcbiAgICBzZXRTb3VyY2Uoc291cmNlLCBwYXJzZShyZWNvcmQuc25hcHNob3QpKTtcbiAgICBsYXN0LnZhbHVlID0gcmVjb3JkO1xuICB9O1xuICBjb25zdCBjb21taXQgPSAoKSA9PiB7XG4gICAgdW5kb1N0YWNrLnZhbHVlLnVuc2hpZnQobGFzdC52YWx1ZSk7XG4gICAgbGFzdC52YWx1ZSA9IF9jcmVhdGVIaXN0b3J5UmVjb3JkKCk7XG4gICAgaWYgKG9wdGlvbnMuY2FwYWNpdHkgJiYgdW5kb1N0YWNrLnZhbHVlLmxlbmd0aCA+IG9wdGlvbnMuY2FwYWNpdHkpXG4gICAgICB1bmRvU3RhY2sudmFsdWUuc3BsaWNlKG9wdGlvbnMuY2FwYWNpdHksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgaWYgKHJlZG9TdGFjay52YWx1ZS5sZW5ndGgpXG4gICAgICByZWRvU3RhY2sudmFsdWUuc3BsaWNlKDAsIHJlZG9TdGFjay52YWx1ZS5sZW5ndGgpO1xuICB9O1xuICBjb25zdCBjbGVhciA9ICgpID0+IHtcbiAgICB1bmRvU3RhY2sudmFsdWUuc3BsaWNlKDAsIHVuZG9TdGFjay52YWx1ZS5sZW5ndGgpO1xuICAgIHJlZG9TdGFjay52YWx1ZS5zcGxpY2UoMCwgcmVkb1N0YWNrLnZhbHVlLmxlbmd0aCk7XG4gIH07XG4gIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB1bmRvU3RhY2sudmFsdWUuc2hpZnQoKTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHJlZG9TdGFjay52YWx1ZS51bnNoaWZ0KGxhc3QudmFsdWUpO1xuICAgICAgX3NldFNvdXJjZShzdGF0ZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWRvID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gcmVkb1N0YWNrLnZhbHVlLnNoaWZ0KCk7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB1bmRvU3RhY2sudmFsdWUudW5zaGlmdChsYXN0LnZhbHVlKTtcbiAgICAgIF9zZXRTb3VyY2Uoc3RhdGUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgX3NldFNvdXJjZShsYXN0LnZhbHVlKTtcbiAgfTtcbiAgY29uc3QgaGlzdG9yeSA9IGNvbXB1dGVkKCgpID0+IFtsYXN0LnZhbHVlLCAuLi51bmRvU3RhY2sudmFsdWVdKTtcbiAgY29uc3QgY2FuVW5kbyA9IGNvbXB1dGVkKCgpID0+IHVuZG9TdGFjay52YWx1ZS5sZW5ndGggPiAwKTtcbiAgY29uc3QgY2FuUmVkbyA9IGNvbXB1dGVkKCgpID0+IHJlZG9TdGFjay52YWx1ZS5sZW5ndGggPiAwKTtcbiAgcmV0dXJuIHtcbiAgICBzb3VyY2UsXG4gICAgdW5kb1N0YWNrLFxuICAgIHJlZG9TdGFjayxcbiAgICBsYXN0LFxuICAgIGhpc3RvcnksXG4gICAgY2FuVW5kbyxcbiAgICBjYW5SZWRvLFxuICAgIGNsZWFyLFxuICAgIGNvbW1pdCxcbiAgICByZXNldCxcbiAgICB1bmRvLFxuICAgIHJlZG9cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmSGlzdG9yeShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZGVlcCA9IGZhbHNlLFxuICAgIGZsdXNoID0gXCJwcmVcIixcbiAgICBldmVudEZpbHRlcixcbiAgICBzaG91bGRDb21taXQgPSAoKSA9PiB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB7XG4gICAgZXZlbnRGaWx0ZXI6IGNvbXBvc2VkRmlsdGVyLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZTogcmVzdW1lVHJhY2tpbmcsXG4gICAgaXNBY3RpdmU6IGlzVHJhY2tpbmdcbiAgfSA9IHBhdXNhYmxlRmlsdGVyKGV2ZW50RmlsdGVyKTtcbiAgbGV0IGxhc3RSYXdWYWx1ZSA9IHNvdXJjZS52YWx1ZTtcbiAgY29uc3Qge1xuICAgIGlnbm9yZVVwZGF0ZXMsXG4gICAgaWdub3JlUHJldkFzeW5jVXBkYXRlcyxcbiAgICBzdG9wXG4gIH0gPSB3YXRjaElnbm9yYWJsZShcbiAgICBzb3VyY2UsXG4gICAgY29tbWl0LFxuICAgIHsgZGVlcCwgZmx1c2gsIGV2ZW50RmlsdGVyOiBjb21wb3NlZEZpbHRlciB9XG4gICk7XG4gIGZ1bmN0aW9uIHNldFNvdXJjZShzb3VyY2UyLCB2YWx1ZSkge1xuICAgIGlnbm9yZVByZXZBc3luY1VwZGF0ZXMoKTtcbiAgICBpZ25vcmVVcGRhdGVzKCgpID0+IHtcbiAgICAgIHNvdXJjZTIudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGxhc3RSYXdWYWx1ZSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1hbnVhbEhpc3RvcnkgPSB1c2VNYW51YWxSZWZIaXN0b3J5KHNvdXJjZSwgeyAuLi5vcHRpb25zLCBjbG9uZTogb3B0aW9ucy5jbG9uZSB8fCBkZWVwLCBzZXRTb3VyY2UgfSk7XG4gIGNvbnN0IHsgY2xlYXIsIGNvbW1pdDogbWFudWFsQ29tbWl0IH0gPSBtYW51YWxIaXN0b3J5O1xuICBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgaWdub3JlUHJldkFzeW5jVXBkYXRlcygpO1xuICAgIGlmICghc2hvdWxkQ29tbWl0KGxhc3RSYXdWYWx1ZSwgc291cmNlLnZhbHVlKSlcbiAgICAgIHJldHVybjtcbiAgICBsYXN0UmF3VmFsdWUgPSBzb3VyY2UudmFsdWU7XG4gICAgbWFudWFsQ29tbWl0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lKGNvbW1pdE5vdykge1xuICAgIHJlc3VtZVRyYWNraW5nKCk7XG4gICAgaWYgKGNvbW1pdE5vdylcbiAgICAgIGNvbW1pdCgpO1xuICB9XG4gIGZ1bmN0aW9uIGJhdGNoKGZuKSB7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4gY2FuY2VsZWQgPSB0cnVlO1xuICAgIGlnbm9yZVVwZGF0ZXMoKCkgPT4ge1xuICAgICAgZm4oY2FuY2VsKTtcbiAgICB9KTtcbiAgICBpZiAoIWNhbmNlbGVkKVxuICAgICAgY29tbWl0KCk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBzdG9wKCk7XG4gICAgY2xlYXIoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm1hbnVhbEhpc3RvcnksXG4gICAgaXNUcmFja2luZyxcbiAgICBwYXVzZSxcbiAgICByZXN1bWUsXG4gICAgY29tbWl0LFxuICAgIGJhdGNoLFxuICAgIGRpc3Bvc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGVib3VuY2VkUmVmSGlzdG9yeShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBmaWx0ZXIgPSBvcHRpb25zLmRlYm91bmNlID8gZGVib3VuY2VGaWx0ZXIob3B0aW9ucy5kZWJvdW5jZSkgOiB2b2lkIDA7XG4gIGNvbnN0IGhpc3RvcnkgPSB1c2VSZWZIaXN0b3J5KHNvdXJjZSwgeyAuLi5vcHRpb25zLCBldmVudEZpbHRlcjogZmlsdGVyIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmhpc3RvcnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGV2aWNlTW90aW9uKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICByZXF1ZXN0UGVybWlzc2lvbnMgPSBmYWxzZSxcbiAgICBldmVudEZpbHRlciA9IGJ5cGFzc0ZpbHRlclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gdHlwZW9mIERldmljZU1vdGlvbkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgY29uc3QgcmVxdWlyZVBlcm1pc3Npb25zID0gdXNlU3VwcG9ydGVkKCgpID0+IGlzU3VwcG9ydGVkLnZhbHVlICYmIFwicmVxdWVzdFBlcm1pc3Npb25cIiBpbiBEZXZpY2VNb3Rpb25FdmVudCAmJiB0eXBlb2YgRGV2aWNlTW90aW9uRXZlbnQucmVxdWVzdFBlcm1pc3Npb24gPT09IFwiZnVuY3Rpb25cIik7XG4gIGNvbnN0IHBlcm1pc3Npb25HcmFudGVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGFjY2VsZXJhdGlvbiA9IHJlZih7IHg6IG51bGwsIHk6IG51bGwsIHo6IG51bGwgfSk7XG4gIGNvbnN0IHJvdGF0aW9uUmF0ZSA9IHJlZih7IGFscGhhOiBudWxsLCBiZXRhOiBudWxsLCBnYW1tYTogbnVsbCB9KTtcbiAgY29uc3QgaW50ZXJ2YWwgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5ID0gcmVmKHtcbiAgICB4OiBudWxsLFxuICAgIHk6IG51bGwsXG4gICAgejogbnVsbFxuICB9KTtcbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBpZiAod2luZG93KSB7XG4gICAgICBjb25zdCBvbkRldmljZU1vdGlvbiA9IGNyZWF0ZUZpbHRlcldyYXBwZXIoXG4gICAgICAgIGV2ZW50RmlsdGVyLFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaTtcbiAgICAgICAgICBhY2NlbGVyYXRpb24udmFsdWUgPSB7XG4gICAgICAgICAgICB4OiAoKF9hID0gZXZlbnQuYWNjZWxlcmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EueCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHk6ICgoX2IgPSBldmVudC5hY2NlbGVyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi55KSB8fCBudWxsLFxuICAgICAgICAgICAgejogKChfYyA9IGV2ZW50LmFjY2VsZXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnopIHx8IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkudmFsdWUgPSB7XG4gICAgICAgICAgICB4OiAoKF9kID0gZXZlbnQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLngpIHx8IG51bGwsXG4gICAgICAgICAgICB5OiAoKF9lID0gZXZlbnQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnkpIHx8IG51bGwsXG4gICAgICAgICAgICB6OiAoKF9mID0gZXZlbnQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnopIHx8IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJvdGF0aW9uUmF0ZS52YWx1ZSA9IHtcbiAgICAgICAgICAgIGFscGhhOiAoKF9nID0gZXZlbnQucm90YXRpb25SYXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2cuYWxwaGEpIHx8IG51bGwsXG4gICAgICAgICAgICBiZXRhOiAoKF9oID0gZXZlbnQucm90YXRpb25SYXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2guYmV0YSkgfHwgbnVsbCxcbiAgICAgICAgICAgIGdhbW1hOiAoKF9pID0gZXZlbnQucm90YXRpb25SYXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2kuZ2FtbWEpIHx8IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGludGVydmFsLnZhbHVlID0gZXZlbnQuaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJkZXZpY2Vtb3Rpb25cIiwgb25EZXZpY2VNb3Rpb24sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW5zdXJlUGVybWlzc2lvbnMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFyZXF1aXJlUGVybWlzc2lvbnMudmFsdWUpXG4gICAgICBwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSA9IHRydWU7XG4gICAgaWYgKHBlcm1pc3Npb25HcmFudGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyZXF1aXJlUGVybWlzc2lvbnMudmFsdWUpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RQZXJtaXNzaW9uID0gRGV2aWNlTW90aW9uRXZlbnQucmVxdWVzdFBlcm1pc3Npb247XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICAgIGlmIChyZXNwb25zZSA9PT0gXCJncmFudGVkXCIpIHtcbiAgICAgICAgICBwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgaW5pdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIGlmIChyZXF1ZXN0UGVybWlzc2lvbnMgJiYgcmVxdWlyZVBlcm1pc3Npb25zLnZhbHVlKSB7XG4gICAgICBlbnN1cmVQZXJtaXNzaW9ucygpLnRoZW4oKCkgPT4gaW5pdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGFjY2VsZXJhdGlvbixcbiAgICBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LFxuICAgIHJvdGF0aW9uUmF0ZSxcbiAgICBpbnRlcnZhbCxcbiAgICBpc1N1cHBvcnRlZCxcbiAgICByZXF1aXJlUGVybWlzc2lvbnMsXG4gICAgZW5zdXJlUGVybWlzc2lvbnMsXG4gICAgcGVybWlzc2lvbkdyYW50ZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGV2aWNlT3JpZW50YXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwiRGV2aWNlT3JpZW50YXRpb25FdmVudFwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IGlzQWJzb2x1dGUgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgYWxwaGEgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBiZXRhID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgZ2FtbWEgPSBzaGFsbG93UmVmKG51bGwpO1xuICBpZiAod2luZG93ICYmIGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiZGV2aWNlb3JpZW50YXRpb25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBpc0Fic29sdXRlLnZhbHVlID0gZXZlbnQuYWJzb2x1dGU7XG4gICAgICBhbHBoYS52YWx1ZSA9IGV2ZW50LmFscGhhO1xuICAgICAgYmV0YS52YWx1ZSA9IGV2ZW50LmJldGE7XG4gICAgICBnYW1tYS52YWx1ZSA9IGV2ZW50LmdhbW1hO1xuICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzQWJzb2x1dGUsXG4gICAgYWxwaGEsXG4gICAgYmV0YSxcbiAgICBnYW1tYVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZXZpY2VQaXhlbFJhdGlvKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHNoYWxsb3dSZWYoMSk7XG4gIGNvbnN0IHF1ZXJ5ID0gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKHJlc29sdXRpb246ICR7cGl4ZWxSYXRpby52YWx1ZX1kcHB4KWAsIG9wdGlvbnMpO1xuICBsZXQgc3RvcCA9IG5vb3A7XG4gIGlmICh3aW5kb3cpIHtcbiAgICBzdG9wID0gd2F0Y2hJbW1lZGlhdGUocXVlcnksICgpID0+IHBpeGVsUmF0aW8udmFsdWUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwaXhlbFJhdGlvOiByZWFkb25seShwaXhlbFJhdGlvKSxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURldmljZXNMaXN0KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICByZXF1ZXN0UGVybWlzc2lvbnMgPSBmYWxzZSxcbiAgICBjb25zdHJhaW50cyA9IHsgYXVkaW86IHRydWUsIHZpZGVvOiB0cnVlIH0sXG4gICAgb25VcGRhdGVkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBkZXZpY2VzID0gcmVmKFtdKTtcbiAgY29uc3QgdmlkZW9JbnB1dHMgPSBjb21wdXRlZCgoKSA9PiBkZXZpY2VzLnZhbHVlLmZpbHRlcigoaSkgPT4gaS5raW5kID09PSBcInZpZGVvaW5wdXRcIikpO1xuICBjb25zdCBhdWRpb0lucHV0cyA9IGNvbXB1dGVkKCgpID0+IGRldmljZXMudmFsdWUuZmlsdGVyKChpKSA9PiBpLmtpbmQgPT09IFwiYXVkaW9pbnB1dFwiKSk7XG4gIGNvbnN0IGF1ZGlvT3V0cHV0cyA9IGNvbXB1dGVkKCgpID0+IGRldmljZXMudmFsdWUuZmlsdGVyKChpKSA9PiBpLmtpbmQgPT09IFwiYXVkaW9vdXRwdXRcIikpO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMpO1xuICBjb25zdCBwZXJtaXNzaW9uR3JhbnRlZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBsZXQgc3RyZWFtO1xuICBhc3luYyBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBkZXZpY2VzLnZhbHVlID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgb25VcGRhdGVkID09IG51bGwgPyB2b2lkIDAgOiBvblVwZGF0ZWQoZGV2aWNlcy52YWx1ZSk7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHQuc3RvcCgpKTtcbiAgICAgIHN0cmVhbSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVuc3VyZVBlcm1pc3Npb25zKCkge1xuICAgIGNvbnN0IGRldmljZU5hbWUgPSBjb25zdHJhaW50cy52aWRlbyA/IFwiY2FtZXJhXCIgOiBcIm1pY3JvcGhvbmVcIjtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHsgc3RhdGUsIHF1ZXJ5IH0gPSB1c2VQZXJtaXNzaW9uKGRldmljZU5hbWUsIHsgY29udHJvbHM6IHRydWUgfSk7XG4gICAgYXdhaXQgcXVlcnkoKTtcbiAgICBpZiAoc3RhdGUudmFsdWUgIT09IFwiZ3JhbnRlZFwiKSB7XG4gICAgICBsZXQgZ3JhbnRlZCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGxEZXZpY2VzID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgIGNvbnN0IGhhc0NhbWVyYSA9IGFsbERldmljZXMuc29tZSgoZGV2aWNlKSA9PiBkZXZpY2Uua2luZCA9PT0gXCJ2aWRlb2lucHV0XCIpO1xuICAgICAgICBjb25zdCBoYXNNaWNyb3Bob25lID0gYWxsRGV2aWNlcy5zb21lKChkZXZpY2UpID0+IGRldmljZS5raW5kID09PSBcImF1ZGlvaW5wdXRcIiB8fCBkZXZpY2Uua2luZCA9PT0gXCJhdWRpb291dHB1dFwiKTtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSBoYXNDYW1lcmEgPyBjb25zdHJhaW50cy52aWRlbyA6IGZhbHNlO1xuICAgICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGhhc01pY3JvcGhvbmUgPyBjb25zdHJhaW50cy5hdWRpbyA6IGZhbHNlO1xuICAgICAgICBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0cmVhbSA9IG51bGw7XG4gICAgICAgIGdyYW50ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgcGVybWlzc2lvbkdyYW50ZWQudmFsdWUgPSBncmFudGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZTtcbiAgfVxuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICBpZiAocmVxdWVzdFBlcm1pc3Npb25zKVxuICAgICAgZW5zdXJlUGVybWlzc2lvbnMoKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKG5hdmlnYXRvci5tZWRpYURldmljZXMsIFwiZGV2aWNlY2hhbmdlXCIsIHVwZGF0ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHVwZGF0ZSgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGV2aWNlcyxcbiAgICBlbnN1cmVQZXJtaXNzaW9ucyxcbiAgICBwZXJtaXNzaW9uR3JhbnRlZCxcbiAgICB2aWRlb0lucHV0cyxcbiAgICBhdWRpb0lucHV0cyxcbiAgICBhdWRpb091dHB1dHMsXG4gICAgaXNTdXBwb3J0ZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGlzcGxheU1lZGlhKG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGVuYWJsZWQgPSBzaGFsbG93UmVmKChfYSA9IG9wdGlvbnMuZW5hYmxlZCkgIT0gbnVsbCA/IF9hIDogZmFsc2UpO1xuICBjb25zdCB2aWRlbyA9IG9wdGlvbnMudmlkZW87XG4gIGNvbnN0IGF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgY29uc3QgeyBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXREaXNwbGF5TWVkaWE7XG4gIH0pO1xuICBjb25zdCBjb25zdHJhaW50ID0geyBhdWRpbywgdmlkZW8gfTtcbiAgY29uc3Qgc3RyZWFtID0gc2hhbGxvd1JlZigpO1xuICBhc3luYyBmdW5jdGlvbiBfc3RhcnQoKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8IHN0cmVhbS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBzdHJlYW0udmFsdWUgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50KTtcbiAgICAoX2EyID0gc3RyZWFtLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHVzZUV2ZW50TGlzdGVuZXIodCwgXCJlbmRlZFwiLCBzdG9wLCB7IHBhc3NpdmU6IHRydWUgfSkpO1xuICAgIHJldHVybiBzdHJlYW0udmFsdWU7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gX3N0b3AoKSB7XG4gICAgdmFyIF9hMjtcbiAgICAoX2EyID0gc3RyZWFtLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHQuc3RvcCgpKTtcbiAgICBzdHJlYW0udmFsdWUgPSB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBfc3RvcCgpO1xuICAgIGVuYWJsZWQudmFsdWUgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICBhd2FpdCBfc3RhcnQoKTtcbiAgICBpZiAoc3RyZWFtLnZhbHVlKVxuICAgICAgZW5hYmxlZC52YWx1ZSA9IHRydWU7XG4gICAgcmV0dXJuIHN0cmVhbS52YWx1ZTtcbiAgfVxuICB3YXRjaChcbiAgICBlbmFibGVkLFxuICAgICh2KSA9PiB7XG4gICAgICBpZiAodilcbiAgICAgICAgX3N0YXJ0KCk7XG4gICAgICBlbHNlXG4gICAgICAgIF9zdG9wKCk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RyZWFtLFxuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgZW5hYmxlZFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEb2N1bWVudFZpc2liaWxpdHkob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQgfSA9IG9wdGlvbnM7XG4gIGlmICghZG9jdW1lbnQpXG4gICAgcmV0dXJuIHNoYWxsb3dSZWYoXCJ2aXNpYmxlXCIpO1xuICBjb25zdCB2aXNpYmlsaXR5ID0gc2hhbGxvd1JlZihkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpO1xuICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInZpc2liaWxpdHljaGFuZ2VcIiwgKCkgPT4ge1xuICAgIHZpc2liaWxpdHkudmFsdWUgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIHZpc2liaWxpdHk7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdnYWJsZSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBwb2ludGVyVHlwZXMsXG4gICAgcHJldmVudERlZmF1bHQsXG4gICAgc3RvcFByb3BhZ2F0aW9uLFxuICAgIGV4YWN0LFxuICAgIG9uTW92ZSxcbiAgICBvbkVuZCxcbiAgICBvblN0YXJ0LFxuICAgIGluaXRpYWxWYWx1ZSxcbiAgICBheGlzID0gXCJib3RoXCIsXG4gICAgZHJhZ2dpbmdFbGVtZW50ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBjb250YWluZXJFbGVtZW50LFxuICAgIGhhbmRsZTogZHJhZ2dpbmdIYW5kbGUgPSB0YXJnZXQsXG4gICAgYnV0dG9ucyA9IFswXVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcG9zaXRpb24gPSByZWYoXG4gICAgKF9hID0gdG9WYWx1ZShpbml0aWFsVmFsdWUpKSAhPSBudWxsID8gX2EgOiB7IHg6IDAsIHk6IDAgfVxuICApO1xuICBjb25zdCBwcmVzc2VkRGVsdGEgPSByZWYoKTtcbiAgY29uc3QgZmlsdGVyRXZlbnQgPSAoZSkgPT4ge1xuICAgIGlmIChwb2ludGVyVHlwZXMpXG4gICAgICByZXR1cm4gcG9pbnRlclR5cGVzLmluY2x1ZGVzKGUucG9pbnRlclR5cGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBjb25zdCBoYW5kbGVFdmVudCA9IChlKSA9PiB7XG4gICAgaWYgKHRvVmFsdWUocHJldmVudERlZmF1bHQpKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0b1ZhbHVlKHN0b3BQcm9wYWdhdGlvbikpXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuICBjb25zdCBzdGFydCA9IChlKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoIXRvVmFsdWUoYnV0dG9ucykuaW5jbHVkZXMoZS5idXR0b24pKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpIHx8ICFmaWx0ZXJFdmVudChlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodG9WYWx1ZShleGFjdCkgJiYgZS50YXJnZXQgIT09IHRvVmFsdWUodGFyZ2V0KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjb250YWluZXIgPSB0b1ZhbHVlKGNvbnRhaW5lckVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSAoX2EyID0gY29udGFpbmVyID09IG51bGwgPyB2b2lkIDAgOiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoY29udGFpbmVyKTtcbiAgICBjb25zdCB0YXJnZXRSZWN0ID0gdG9WYWx1ZSh0YXJnZXQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHBvcyA9IHtcbiAgICAgIHg6IGUuY2xpZW50WCAtIChjb250YWluZXIgPyB0YXJnZXRSZWN0LmxlZnQgLSBjb250YWluZXJSZWN0LmxlZnQgKyBjb250YWluZXIuc2Nyb2xsTGVmdCA6IHRhcmdldFJlY3QubGVmdCksXG4gICAgICB5OiBlLmNsaWVudFkgLSAoY29udGFpbmVyID8gdGFyZ2V0UmVjdC50b3AgLSBjb250YWluZXJSZWN0LnRvcCArIGNvbnRhaW5lci5zY3JvbGxUb3AgOiB0YXJnZXRSZWN0LnRvcClcbiAgICB9O1xuICAgIGlmICgob25TdGFydCA9PSBudWxsID8gdm9pZCAwIDogb25TdGFydChwb3MsIGUpKSA9PT0gZmFsc2UpXG4gICAgICByZXR1cm47XG4gICAgcHJlc3NlZERlbHRhLnZhbHVlID0gcG9zO1xuICAgIGhhbmRsZUV2ZW50KGUpO1xuICB9O1xuICBjb25zdCBtb3ZlID0gKGUpID0+IHtcbiAgICBpZiAodG9WYWx1ZShvcHRpb25zLmRpc2FibGVkKSB8fCAhZmlsdGVyRXZlbnQoZSkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwcmVzc2VkRGVsdGEudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29udGFpbmVyID0gdG9WYWx1ZShjb250YWluZXJFbGVtZW50KTtcbiAgICBjb25zdCB0YXJnZXRSZWN0ID0gdG9WYWx1ZSh0YXJnZXQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB7IHgsIHkgfSA9IHBvc2l0aW9uLnZhbHVlO1xuICAgIGlmIChheGlzID09PSBcInhcIiB8fCBheGlzID09PSBcImJvdGhcIikge1xuICAgICAgeCA9IGUuY2xpZW50WCAtIHByZXNzZWREZWx0YS52YWx1ZS54O1xuICAgICAgaWYgKGNvbnRhaW5lcilcbiAgICAgICAgeCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHgpLCBjb250YWluZXIuc2Nyb2xsV2lkdGggLSB0YXJnZXRSZWN0LndpZHRoKTtcbiAgICB9XG4gICAgaWYgKGF4aXMgPT09IFwieVwiIHx8IGF4aXMgPT09IFwiYm90aFwiKSB7XG4gICAgICB5ID0gZS5jbGllbnRZIC0gcHJlc3NlZERlbHRhLnZhbHVlLnk7XG4gICAgICBpZiAoY29udGFpbmVyKVxuICAgICAgICB5ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgeSksIGNvbnRhaW5lci5zY3JvbGxIZWlnaHQgLSB0YXJnZXRSZWN0LmhlaWdodCk7XG4gICAgfVxuICAgIHBvc2l0aW9uLnZhbHVlID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIG9uTW92ZSA9PSBudWxsID8gdm9pZCAwIDogb25Nb3ZlKHBvc2l0aW9uLnZhbHVlLCBlKTtcbiAgICBoYW5kbGVFdmVudChlKTtcbiAgfTtcbiAgY29uc3QgZW5kID0gKGUpID0+IHtcbiAgICBpZiAodG9WYWx1ZShvcHRpb25zLmRpc2FibGVkKSB8fCAhZmlsdGVyRXZlbnQoZSkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwcmVzc2VkRGVsdGEudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgcHJlc3NlZERlbHRhLnZhbHVlID0gdm9pZCAwO1xuICAgIG9uRW5kID09IG51bGwgPyB2b2lkIDAgOiBvbkVuZChwb3NpdGlvbi52YWx1ZSwgZSk7XG4gICAgaGFuZGxlRXZlbnQoZSk7XG4gIH07XG4gIGlmIChpc0NsaWVudCkge1xuICAgIGNvbnN0IGNvbmZpZyA9ICgpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXB0dXJlOiAoX2EyID0gb3B0aW9ucy5jYXB0dXJlKSAhPSBudWxsID8gX2EyIDogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogIXRvVmFsdWUocHJldmVudERlZmF1bHQpXG4gICAgICB9O1xuICAgIH07XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkcmFnZ2luZ0hhbmRsZSwgXCJwb2ludGVyZG93blwiLCBzdGFydCwgY29uZmlnKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRyYWdnaW5nRWxlbWVudCwgXCJwb2ludGVybW92ZVwiLCBtb3ZlLCBjb25maWcpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZHJhZ2dpbmdFbGVtZW50LCBcInBvaW50ZXJ1cFwiLCBlbmQsIGNvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50b1JlZnMocG9zaXRpb24pLFxuICAgIHBvc2l0aW9uLFxuICAgIGlzRHJhZ2dpbmc6IGNvbXB1dGVkKCgpID0+ICEhcHJlc3NlZERlbHRhLnZhbHVlKSxcbiAgICBzdHlsZTogY29tcHV0ZWQoXG4gICAgICAoKSA9PiBgbGVmdDoke3Bvc2l0aW9uLnZhbHVlLnh9cHg7dG9wOiR7cG9zaXRpb24udmFsdWUueX1weDtgXG4gICAgKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEcm9wWm9uZSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBpc092ZXJEcm9wWm9uZSA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBmaWxlcyA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGxldCBjb3VudGVyID0gMDtcbiAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICBpZiAoaXNDbGllbnQpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7IG9uRHJvcDogb3B0aW9ucyB9IDogb3B0aW9ucztcbiAgICBjb25zdCBtdWx0aXBsZSA9IChfYSA9IF9vcHRpb25zLm11bHRpcGxlKSAhPSBudWxsID8gX2EgOiB0cnVlO1xuICAgIGNvbnN0IHByZXZlbnREZWZhdWx0Rm9yVW5oYW5kbGVkID0gKF9iID0gX29wdGlvbnMucHJldmVudERlZmF1bHRGb3JVbmhhbmRsZWQpICE9IG51bGwgPyBfYiA6IGZhbHNlO1xuICAgIGNvbnN0IGdldEZpbGVzID0gKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjI7XG4gICAgICBjb25zdCBsaXN0ID0gQXJyYXkuZnJvbSgoX2IyID0gKF9hMiA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5maWxlcykgIT0gbnVsbCA/IF9iMiA6IFtdKTtcbiAgICAgIHJldHVybiBsaXN0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiBtdWx0aXBsZSA/IGxpc3QgOiBbbGlzdFswXV07XG4gICAgfTtcbiAgICBjb25zdCBjaGVja0RhdGFUeXBlcyA9ICh0eXBlcykgPT4ge1xuICAgICAgY29uc3QgZGF0YVR5cGVzID0gdW5yZWYoX29wdGlvbnMuZGF0YVR5cGVzKTtcbiAgICAgIGlmICh0eXBlb2YgZGF0YVR5cGVzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBkYXRhVHlwZXModHlwZXMpO1xuICAgICAgaWYgKCEoZGF0YVR5cGVzID09IG51bGwgPyB2b2lkIDAgOiBkYXRhVHlwZXMubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHlwZXMuZXZlcnkoXG4gICAgICAgICh0eXBlKSA9PiBkYXRhVHlwZXMuc29tZSgoYWxsb3dlZFR5cGUpID0+IHR5cGUuaW5jbHVkZXMoYWxsb3dlZFR5cGUpKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoZWNrVmFsaWRpdHkgPSAoaXRlbXMpID0+IHtcbiAgICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuZnJvbShpdGVtcyAhPSBudWxsID8gaXRlbXMgOiBbXSkubWFwKChpdGVtKSA9PiBpdGVtLnR5cGUpO1xuICAgICAgY29uc3QgZGF0YVR5cGVzVmFsaWQgPSBjaGVja0RhdGFUeXBlcyh0eXBlcyk7XG4gICAgICBjb25zdCBtdWx0aXBsZUZpbGVzVmFsaWQgPSBtdWx0aXBsZSB8fCBpdGVtcy5sZW5ndGggPD0gMTtcbiAgICAgIHJldHVybiBkYXRhVHlwZXNWYWxpZCAmJiBtdWx0aXBsZUZpbGVzVmFsaWQ7XG4gICAgfTtcbiAgICBjb25zdCBpc1NhZmFyaSA9ICgpID0+IC9eKD86KD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhKFwiY2hyb21lXCIgaW4gd2luZG93KTtcbiAgICBjb25zdCBoYW5kbGVEcmFnRXZlbnQgPSAoZXZlbnQsIGV2ZW50VHlwZSkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IyLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIGNvbnN0IGRhdGFUcmFuc2Zlckl0ZW1MaXN0ID0gKF9hMiA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pdGVtcztcbiAgICAgIGlzVmFsaWQgPSAoX2IyID0gZGF0YVRyYW5zZmVySXRlbUxpc3QgJiYgY2hlY2tWYWxpZGl0eShkYXRhVHJhbnNmZXJJdGVtTGlzdCkpICE9IG51bGwgPyBfYjIgOiBmYWxzZTtcbiAgICAgIGlmIChwcmV2ZW50RGVmYXVsdEZvclVuaGFuZGxlZCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1NhZmFyaSgpICYmICFpc1ZhbGlkKSB7XG4gICAgICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50RmlsZXMgPSBnZXRGaWxlcyhldmVudCk7XG4gICAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgICAgICBjYXNlIFwiZW50ZXJcIjpcbiAgICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgICAgICAgaXNPdmVyRHJvcFpvbmUudmFsdWUgPSB0cnVlO1xuICAgICAgICAgIChfYyA9IF9vcHRpb25zLm9uRW50ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKF9vcHRpb25zLCBudWxsLCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvdmVyXCI6XG4gICAgICAgICAgKF9kID0gX29wdGlvbnMub25PdmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChfb3B0aW9ucywgbnVsbCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVhdmVcIjpcbiAgICAgICAgICBjb3VudGVyIC09IDE7XG4gICAgICAgICAgaWYgKGNvdW50ZXIgPT09IDApXG4gICAgICAgICAgICBpc092ZXJEcm9wWm9uZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIChfZSA9IF9vcHRpb25zLm9uTGVhdmUpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWxsKF9vcHRpb25zLCBudWxsLCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkcm9wXCI6XG4gICAgICAgICAgY291bnRlciA9IDA7XG4gICAgICAgICAgaXNPdmVyRHJvcFpvbmUudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgZmlsZXMudmFsdWUgPSBjdXJyZW50RmlsZXM7XG4gICAgICAgICAgICAoX2YgPSBfb3B0aW9ucy5vbkRyb3ApID09IG51bGwgPyB2b2lkIDAgOiBfZi5jYWxsKF9vcHRpb25zLCBjdXJyZW50RmlsZXMsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJkcmFnZW50ZXJcIiwgKGV2ZW50KSA9PiBoYW5kbGVEcmFnRXZlbnQoZXZlbnQsIFwiZW50ZXJcIikpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyYWdvdmVyXCIsIChldmVudCkgPT4gaGFuZGxlRHJhZ0V2ZW50KGV2ZW50LCBcIm92ZXJcIikpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyYWdsZWF2ZVwiLCAoZXZlbnQpID0+IGhhbmRsZURyYWdFdmVudChldmVudCwgXCJsZWF2ZVwiKSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZHJvcFwiLCAoZXZlbnQpID0+IGhhbmRsZURyYWdFdmVudChldmVudCwgXCJkcm9wXCIpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbGVzLFxuICAgIGlzT3ZlckRyb3Bab25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKHRhcmdldCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIC4uLm9ic2VydmVyT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgbGV0IG9ic2VydmVyO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJSZXNpemVPYnNlcnZlclwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBvYnNlcnZlciA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRhcmdldHMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgY29uc3QgX3RhcmdldHMgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoX3RhcmdldHMpID8gX3RhcmdldHMubWFwKChlbCkgPT4gdW5yZWZFbGVtZW50KGVsKSkgOiBbdW5yZWZFbGVtZW50KF90YXJnZXRzKV07XG4gIH0pO1xuICBjb25zdCBzdG9wV2F0Y2ggPSB3YXRjaChcbiAgICB0YXJnZXRzLFxuICAgIChlbHMpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB3aW5kb3cpIHtcbiAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgICAgICBmb3IgKGNvbnN0IF9lbCBvZiBlbHMpIHtcbiAgICAgICAgICBpZiAoX2VsKVxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShfZWwsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlLCBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgICBzdG9wV2F0Y2goKTtcbiAgfTtcbiAgdHJ5T25TY29wZURpc3Bvc2Uoc3RvcCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50Qm91bmRpbmcodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHJlc2V0ID0gdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemUgPSB0cnVlLFxuICAgIHdpbmRvd1Njcm9sbCA9IHRydWUsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICB1cGRhdGVUaW1pbmcgPSBcInN5bmNcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaGVpZ2h0ID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgYm90dG9tID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgbGVmdCA9IHNoYWxsb3dSZWYoMCk7XG4gIGNvbnN0IHJpZ2h0ID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgdG9wID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3Qgd2lkdGggPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCB4ID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgeSA9IHNoYWxsb3dSZWYoMCk7XG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlKCkge1xuICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGhlaWdodC52YWx1ZSA9IDA7XG4gICAgICAgIGJvdHRvbS52YWx1ZSA9IDA7XG4gICAgICAgIGxlZnQudmFsdWUgPSAwO1xuICAgICAgICByaWdodC52YWx1ZSA9IDA7XG4gICAgICAgIHRvcC52YWx1ZSA9IDA7XG4gICAgICAgIHdpZHRoLnZhbHVlID0gMDtcbiAgICAgICAgeC52YWx1ZSA9IDA7XG4gICAgICAgIHkudmFsdWUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaGVpZ2h0LnZhbHVlID0gcmVjdC5oZWlnaHQ7XG4gICAgYm90dG9tLnZhbHVlID0gcmVjdC5ib3R0b207XG4gICAgbGVmdC52YWx1ZSA9IHJlY3QubGVmdDtcbiAgICByaWdodC52YWx1ZSA9IHJlY3QucmlnaHQ7XG4gICAgdG9wLnZhbHVlID0gcmVjdC50b3A7XG4gICAgd2lkdGgudmFsdWUgPSByZWN0LndpZHRoO1xuICAgIHgudmFsdWUgPSByZWN0Lng7XG4gICAgeS52YWx1ZSA9IHJlY3QueTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgaWYgKHVwZGF0ZVRpbWluZyA9PT0gXCJzeW5jXCIpXG4gICAgICByZWNhbGN1bGF0ZSgpO1xuICAgIGVsc2UgaWYgKHVwZGF0ZVRpbWluZyA9PT0gXCJuZXh0LWZyYW1lXCIpXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcmVjYWxjdWxhdGUoKSk7XG4gIH1cbiAgdXNlUmVzaXplT2JzZXJ2ZXIodGFyZ2V0LCB1cGRhdGUpO1xuICB3YXRjaCgoKSA9PiB1bnJlZkVsZW1lbnQodGFyZ2V0KSwgKGVsZSkgPT4gIWVsZSAmJiB1cGRhdGUoKSk7XG4gIHVzZU11dGF0aW9uT2JzZXJ2ZXIodGFyZ2V0LCB1cGRhdGUsIHtcbiAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcInN0eWxlXCIsIFwiY2xhc3NcIl1cbiAgfSk7XG4gIGlmICh3aW5kb3dTY3JvbGwpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1cGRhdGUsIHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgaWYgKHdpbmRvd1Jlc2l6ZSlcbiAgICB1c2VFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIGlmIChpbW1lZGlhdGUpXG4gICAgICB1cGRhdGUoKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIHRvcCxcbiAgICB3aWR0aCxcbiAgICB4LFxuICAgIHksXG4gICAgdXBkYXRlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUVsZW1lbnRCeVBvaW50KG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBtdWx0aXBsZSxcbiAgICBpbnRlcnZhbCA9IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4ge1xuICAgIGlmICh0b1ZhbHVlKG11bHRpcGxlKSlcbiAgICAgIHJldHVybiBkb2N1bWVudCAmJiBcImVsZW1lbnRzRnJvbVBvaW50XCIgaW4gZG9jdW1lbnQ7XG4gICAgcmV0dXJuIGRvY3VtZW50ICYmIFwiZWxlbWVudEZyb21Qb2ludFwiIGluIGRvY3VtZW50O1xuICB9KTtcbiAgY29uc3QgZWxlbWVudCA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGNiID0gKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgZWxlbWVudC52YWx1ZSA9IHRvVmFsdWUobXVsdGlwbGUpID8gKF9hID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KHRvVmFsdWUoeCksIHRvVmFsdWUoeSkpKSAhPSBudWxsID8gX2EgOiBbXSA6IChfYiA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvVmFsdWUoeCksIHRvVmFsdWUoeSkpKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICB9O1xuICBjb25zdCBjb250cm9scyA9IGludGVydmFsID09PSBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiID8gdXNlUmFmRm4oY2IsIHsgaW1tZWRpYXRlIH0pIDogdXNlSW50ZXJ2YWxGbihjYiwgaW50ZXJ2YWwsIHsgaW1tZWRpYXRlIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGVsZW1lbnQsXG4gICAgLi4uY29udHJvbHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRWxlbWVudEhvdmVyKGVsLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGRlbGF5RW50ZXIgPSAwLFxuICAgIGRlbGF5TGVhdmUgPSAwLFxuICAgIHRyaWdnZXJPblJlbW92YWwgPSBmYWxzZSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc0hvdmVyZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgbGV0IHRpbWVyO1xuICBjb25zdCB0b2dnbGUgPSAoZW50ZXJpbmcpID0+IHtcbiAgICBjb25zdCBkZWxheSA9IGVudGVyaW5nID8gZGVsYXlFbnRlciA6IGRlbGF5TGVhdmU7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChkZWxheSlcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBpc0hvdmVyZWQudmFsdWUgPSBlbnRlcmluZywgZGVsYXkpO1xuICAgIGVsc2VcbiAgICAgIGlzSG92ZXJlZC52YWx1ZSA9IGVudGVyaW5nO1xuICB9O1xuICBpZiAoIXdpbmRvdylcbiAgICByZXR1cm4gaXNIb3ZlcmVkO1xuICB1c2VFdmVudExpc3RlbmVyKGVsLCBcIm1vdXNlZW50ZXJcIiwgKCkgPT4gdG9nZ2xlKHRydWUpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoZWwsIFwibW91c2VsZWF2ZVwiLCAoKSA9PiB0b2dnbGUoZmFsc2UpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIGlmICh0cmlnZ2VyT25SZW1vdmFsKSB7XG4gICAgb25FbGVtZW50UmVtb3ZhbChcbiAgICAgIGNvbXB1dGVkKCgpID0+IHVucmVmRWxlbWVudChlbCkpLFxuICAgICAgKCkgPT4gdG9nZ2xlKGZhbHNlKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGlzSG92ZXJlZDtcbn1cblxuZnVuY3Rpb24gdXNlRWxlbWVudFNpemUodGFyZ2V0LCBpbml0aWFsU2l6ZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCBib3ggPSBcImNvbnRlbnQtYm94XCIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU1ZHID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHVucmVmRWxlbWVudCh0YXJnZXQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZXNwYWNlVVJJKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJzdmdcIik7XG4gIH0pO1xuICBjb25zdCB3aWR0aCA9IHNoYWxsb3dSZWYoaW5pdGlhbFNpemUud2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBzaGFsbG93UmVmKGluaXRpYWxTaXplLmhlaWdodCk7XG4gIGNvbnN0IHsgc3RvcDogc3RvcDEgfSA9IHVzZVJlc2l6ZU9ic2VydmVyKFxuICAgIHRhcmdldCxcbiAgICAoW2VudHJ5XSkgPT4ge1xuICAgICAgY29uc3QgYm94U2l6ZSA9IGJveCA9PT0gXCJib3JkZXItYm94XCIgPyBlbnRyeS5ib3JkZXJCb3hTaXplIDogYm94ID09PSBcImNvbnRlbnQtYm94XCIgPyBlbnRyeS5jb250ZW50Qm94U2l6ZSA6IGVudHJ5LmRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gICAgICBpZiAod2luZG93ICYmIGlzU1ZHLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0ICRlbGVtID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgICAgIGlmICgkZWxlbSkge1xuICAgICAgICAgIGNvbnN0IHJlY3QgPSAkZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB3aWR0aC52YWx1ZSA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0LnZhbHVlID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChib3hTaXplKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0Qm94U2l6ZSA9IHRvQXJyYXkoYm94U2l6ZSk7XG4gICAgICAgICAgd2lkdGgudmFsdWUgPSBmb3JtYXRCb3hTaXplLnJlZHVjZSgoYWNjLCB7IGlubGluZVNpemUgfSkgPT4gYWNjICsgaW5saW5lU2l6ZSwgMCk7XG4gICAgICAgICAgaGVpZ2h0LnZhbHVlID0gZm9ybWF0Qm94U2l6ZS5yZWR1Y2UoKGFjYywgeyBibG9ja1NpemUgfSkgPT4gYWNjICsgYmxvY2tTaXplLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aC52YWx1ZSA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgICAgIGhlaWdodC52YWx1ZSA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIGNvbnN0IGVsZSA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHdpZHRoLnZhbHVlID0gXCJvZmZzZXRXaWR0aFwiIGluIGVsZSA/IGVsZS5vZmZzZXRXaWR0aCA6IGluaXRpYWxTaXplLndpZHRoO1xuICAgICAgaGVpZ2h0LnZhbHVlID0gXCJvZmZzZXRIZWlnaHRcIiBpbiBlbGUgPyBlbGUub2Zmc2V0SGVpZ2h0IDogaW5pdGlhbFNpemUuaGVpZ2h0O1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN0b3AyID0gd2F0Y2goXG4gICAgKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCksXG4gICAgKGVsZSkgPT4ge1xuICAgICAgd2lkdGgudmFsdWUgPSBlbGUgPyBpbml0aWFsU2l6ZS53aWR0aCA6IDA7XG4gICAgICBoZWlnaHQudmFsdWUgPSBlbGUgPyBpbml0aWFsU2l6ZS5oZWlnaHQgOiAwO1xuICAgIH1cbiAgKTtcbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzdG9wMSgpO1xuICAgIHN0b3AyKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcih0YXJnZXQsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHJvb3QsXG4gICAgcm9vdE1hcmdpbiA9IFwiMHB4XCIsXG4gICAgdGhyZXNob2xkID0gMCxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIkludGVyc2VjdGlvbk9ic2VydmVyXCIgaW4gd2luZG93KTtcbiAgY29uc3QgdGFyZ2V0cyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCBfdGFyZ2V0ID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIHJldHVybiB0b0FycmF5KF90YXJnZXQpLm1hcCh1bnJlZkVsZW1lbnQpLmZpbHRlcihub3ROdWxsaXNoKTtcbiAgfSk7XG4gIGxldCBjbGVhbnVwID0gbm9vcDtcbiAgY29uc3QgaXNBY3RpdmUgPSBzaGFsbG93UmVmKGltbWVkaWF0ZSk7XG4gIGNvbnN0IHN0b3BXYXRjaCA9IGlzU3VwcG9ydGVkLnZhbHVlID8gd2F0Y2goXG4gICAgKCkgPT4gW3RhcmdldHMudmFsdWUsIHVucmVmRWxlbWVudChyb290KSwgaXNBY3RpdmUudmFsdWVdLFxuICAgIChbdGFyZ2V0czIsIHJvb3QyXSkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgaWYgKCFpc0FjdGl2ZS52YWx1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCF0YXJnZXRzMi5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAge1xuICAgICAgICAgIHJvb3Q6IHVucmVmRWxlbWVudChyb290MiksXG4gICAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgICB0aHJlc2hvbGRcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRhcmdldHMyLmZvckVhY2goKGVsKSA9PiBlbCAmJiBvYnNlcnZlci5vYnNlcnZlKGVsKSk7XG4gICAgICBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGNsZWFudXAgPSBub29wO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlLCBmbHVzaDogXCJwb3N0XCIgfVxuICApIDogbm9vcDtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBjbGVhbnVwKCk7XG4gICAgc3RvcFdhdGNoKCk7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgfTtcbiAgdHJ5T25TY29wZURpc3Bvc2Uoc3RvcCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNBY3RpdmUsXG4gICAgcGF1c2UoKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgcmVzdW1lKCkge1xuICAgICAgaXNBY3RpdmUudmFsdWUgPSB0cnVlO1xuICAgIH0sXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50VmlzaWJpbGl0eShlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgc2Nyb2xsVGFyZ2V0LFxuICAgIHRocmVzaG9sZCA9IDAsXG4gICAgcm9vdE1hcmdpbixcbiAgICBvbmNlID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGVsZW1lbnRJc1Zpc2libGUgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgeyBzdG9wIH0gPSB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICBlbGVtZW50LFxuICAgIChpbnRlcnNlY3Rpb25PYnNlcnZlckVudHJpZXMpID0+IHtcbiAgICAgIGxldCBpc0ludGVyc2VjdGluZyA9IGVsZW1lbnRJc1Zpc2libGUudmFsdWU7XG4gICAgICBsZXQgbGF0ZXN0VGltZSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGludGVyc2VjdGlvbk9ic2VydmVyRW50cmllcykge1xuICAgICAgICBpZiAoZW50cnkudGltZSA+PSBsYXRlc3RUaW1lKSB7XG4gICAgICAgICAgbGF0ZXN0VGltZSA9IGVudHJ5LnRpbWU7XG4gICAgICAgICAgaXNJbnRlcnNlY3RpbmcgPSBlbnRyeS5pc0ludGVyc2VjdGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxlbWVudElzVmlzaWJsZS52YWx1ZSA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgd2F0Y2hPbmNlKGVsZW1lbnRJc1Zpc2libGUsICgpID0+IHtcbiAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgcm9vdDogc2Nyb2xsVGFyZ2V0LFxuICAgICAgd2luZG93LFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgcm9vdE1hcmdpbjogdG9WYWx1ZShyb290TWFyZ2luKVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGU7XG59XG5cbmNvbnN0IGV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIHVzZUV2ZW50QnVzKGtleSkge1xuICBjb25zdCBzY29wZSA9IGdldEN1cnJlbnRTY29wZSgpO1xuICBmdW5jdGlvbiBvbihsaXN0ZW5lcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBldmVudHMuZ2V0KGtleSkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICBldmVudHMuc2V0KGtleSwgbGlzdGVuZXJzKTtcbiAgICBjb25zdCBfb2ZmID0gKCkgPT4gb2ZmKGxpc3RlbmVyKTtcbiAgICAoX2EgPSBzY29wZSA9PSBudWxsID8gdm9pZCAwIDogc2NvcGUuY2xlYW51cHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wdXNoKF9vZmYpO1xuICAgIHJldHVybiBfb2ZmO1xuICB9XG4gIGZ1bmN0aW9uIG9uY2UobGlzdGVuZXIpIHtcbiAgICBmdW5jdGlvbiBfbGlzdGVuZXIoLi4uYXJncykge1xuICAgICAgb2ZmKF9saXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lciguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9uKF9saXN0ZW5lcik7XG4gIH1cbiAgZnVuY3Rpb24gb2ZmKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gZXZlbnRzLmdldChrZXkpO1xuICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIGlmICghbGlzdGVuZXJzLnNpemUpXG4gICAgICByZXNldCgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGV2ZW50cy5kZWxldGUoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IGV2ZW50cy5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHYpID0+IHYoZXZlbnQsIHBheWxvYWQpKTtcbiAgfVxuICByZXR1cm4geyBvbiwgb25jZSwgb2ZmLCBlbWl0LCByZXNldCB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTmVzdGVkT3B0aW9ucyQxKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpXG4gICAgcmV0dXJuIHt9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIHVzZUV2ZW50U291cmNlKHVybCwgZXZlbnRzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBldmVudCA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGEgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBzdGF0dXMgPSBzaGFsbG93UmVmKFwiQ09OTkVDVElOR1wiKTtcbiAgY29uc3QgZXZlbnRTb3VyY2UgPSByZWYobnVsbCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgdXJsUmVmID0gdG9SZWYodXJsKTtcbiAgY29uc3QgbGFzdEV2ZW50SWQgPSBzaGFsbG93UmVmKG51bGwpO1xuICBsZXQgZXhwbGljaXRseUNsb3NlZCA9IGZhbHNlO1xuICBsZXQgcmV0cmllZCA9IDA7XG4gIGNvbnN0IHtcbiAgICB3aXRoQ3JlZGVudGlhbHMgPSBmYWxzZSxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGF1dG9Db25uZWN0ID0gdHJ1ZSxcbiAgICBhdXRvUmVjb25uZWN0XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICBpZiAoaXNDbGllbnQgJiYgZXZlbnRTb3VyY2UudmFsdWUpIHtcbiAgICAgIGV2ZW50U291cmNlLnZhbHVlLmNsb3NlKCk7XG4gICAgICBldmVudFNvdXJjZS52YWx1ZSA9IG51bGw7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcIkNMT1NFRFwiO1xuICAgICAgZXhwbGljaXRseUNsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBjb25zdCBfaW5pdCA9ICgpID0+IHtcbiAgICBpZiAoZXhwbGljaXRseUNsb3NlZCB8fCB0eXBlb2YgdXJsUmVmLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVzID0gbmV3IEV2ZW50U291cmNlKHVybFJlZi52YWx1ZSwgeyB3aXRoQ3JlZGVudGlhbHMgfSk7XG4gICAgc3RhdHVzLnZhbHVlID0gXCJDT05ORUNUSU5HXCI7XG4gICAgZXZlbnRTb3VyY2UudmFsdWUgPSBlcztcbiAgICBlcy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcIk9QRU5cIjtcbiAgICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgICB9O1xuICAgIGVzLm9uZXJyb3IgPSAoZSkgPT4ge1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJDTE9TRURcIjtcbiAgICAgIGVycm9yLnZhbHVlID0gZTtcbiAgICAgIGlmIChlcy5yZWFkeVN0YXRlID09PSAyICYmICFleHBsaWNpdGx5Q2xvc2VkICYmIGF1dG9SZWNvbm5lY3QpIHtcbiAgICAgICAgZXMuY2xvc2UoKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJldHJpZXMgPSAtMSxcbiAgICAgICAgICBkZWxheSA9IDFlMyxcbiAgICAgICAgICBvbkZhaWxlZFxuICAgICAgICB9ID0gcmVzb2x2ZU5lc3RlZE9wdGlvbnMkMShhdXRvUmVjb25uZWN0KTtcbiAgICAgICAgcmV0cmllZCArPSAxO1xuICAgICAgICBpZiAodHlwZW9mIHJldHJpZXMgPT09IFwibnVtYmVyXCIgJiYgKHJldHJpZXMgPCAwIHx8IHJldHJpZWQgPCByZXRyaWVzKSlcbiAgICAgICAgICBzZXRUaW1lb3V0KF9pbml0LCBkZWxheSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXRyaWVzID09PSBcImZ1bmN0aW9uXCIgJiYgcmV0cmllcygpKVxuICAgICAgICAgIHNldFRpbWVvdXQoX2luaXQsIGRlbGF5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9uRmFpbGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkZhaWxlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXMub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgIGV2ZW50LnZhbHVlID0gbnVsbDtcbiAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGE7XG4gICAgICBsYXN0RXZlbnRJZC52YWx1ZSA9IGUubGFzdEV2ZW50SWQ7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50X25hbWUgb2YgZXZlbnRzKSB7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKGVzLCBldmVudF9uYW1lLCAoZSkgPT4ge1xuICAgICAgICBldmVudC52YWx1ZSA9IGV2ZW50X25hbWU7XG4gICAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGEgfHwgbnVsbDtcbiAgICAgICAgbGFzdEV2ZW50SWQudmFsdWUgPSBlLmxhc3RFdmVudElkIHx8IG51bGw7XG4gICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBvcGVuID0gKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQpXG4gICAgICByZXR1cm47XG4gICAgY2xvc2UoKTtcbiAgICBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgcmV0cmllZCA9IDA7XG4gICAgX2luaXQoKTtcbiAgfTtcbiAgaWYgKGltbWVkaWF0ZSlcbiAgICBvcGVuKCk7XG4gIGlmIChhdXRvQ29ubmVjdClcbiAgICB3YXRjaCh1cmxSZWYsIG9wZW4pO1xuICB0cnlPblNjb3BlRGlzcG9zZShjbG9zZSk7XG4gIHJldHVybiB7XG4gICAgZXZlbnRTb3VyY2UsXG4gICAgZXZlbnQsXG4gICAgZGF0YSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3IsXG4gICAgb3BlbixcbiAgICBjbG9zZSxcbiAgICBsYXN0RXZlbnRJZFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VFeWVEcm9wcGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGluaXRpYWxWYWx1ZSA9IFwiXCIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJFeWVEcm9wcGVyXCIgaW4gd2luZG93KTtcbiAgY29uc3Qgc1JHQkhleCA9IHNoYWxsb3dSZWYoaW5pdGlhbFZhbHVlKTtcbiAgYXN5bmMgZnVuY3Rpb24gb3BlbihvcGVuT3B0aW9ucykge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXllRHJvcHBlciA9IG5ldyB3aW5kb3cuRXllRHJvcHBlcigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV5ZURyb3BwZXIub3BlbihvcGVuT3B0aW9ucyk7XG4gICAgc1JHQkhleC52YWx1ZSA9IHJlc3VsdC5zUkdCSGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHsgaXNTdXBwb3J0ZWQsIHNSR0JIZXgsIG9wZW4gfTtcbn1cblxuZnVuY3Rpb24gdXNlRmF2aWNvbihuZXdJY29uID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBiYXNlVXJsID0gXCJcIixcbiAgICByZWwgPSBcImljb25cIixcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmF2aWNvbiA9IHRvUmVmKG5ld0ljb24pO1xuICBjb25zdCBhcHBseUljb24gPSAoaWNvbikgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvckFsbChgbGlua1tyZWwqPVwiJHtyZWx9XCJdYCk7XG4gICAgaWYgKCFlbGVtZW50cyB8fCBlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICBpZiAobGluaykge1xuICAgICAgICBsaW5rLnJlbCA9IHJlbDtcbiAgICAgICAgbGluay5ocmVmID0gYCR7YmFzZVVybH0ke2ljb259YDtcbiAgICAgICAgbGluay50eXBlID0gYGltYWdlLyR7aWNvbi5zcGxpdChcIi5cIikucG9wKCl9YDtcbiAgICAgICAgZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmhlYWQuYXBwZW5kKGxpbmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50cyA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IGVsLmhyZWYgPSBgJHtiYXNlVXJsfSR7aWNvbn1gKTtcbiAgfTtcbiAgd2F0Y2goXG4gICAgZmF2aWNvbixcbiAgICAoaSwgbykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpID09PSBcInN0cmluZ1wiICYmIGkgIT09IG8pXG4gICAgICAgIGFwcGx5SWNvbihpKTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgcmV0dXJuIGZhdmljb247XG59XG5cbmNvbnN0IHBheWxvYWRNYXBwaW5nID0ge1xuICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgdGV4dDogXCJ0ZXh0L3BsYWluXCJcbn07XG5mdW5jdGlvbiBpc0ZldGNoT3B0aW9ucyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBjb250YWluc1Byb3Aob2JqLCBcImltbWVkaWF0ZVwiLCBcInJlZmV0Y2hcIiwgXCJpbml0aWFsRGF0YVwiLCBcInRpbWVvdXRcIiwgXCJiZWZvcmVGZXRjaFwiLCBcImFmdGVyRmV0Y2hcIiwgXCJvbkZldGNoRXJyb3JcIiwgXCJmZXRjaFwiLCBcInVwZGF0ZURhdGFPbkVycm9yXCIpO1xufVxuY29uc3QgcmVBYnNvbHV0ZSA9IC9eKD86W2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pO1xuZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgcmV0dXJuIHJlQWJzb2x1dGUudGVzdCh1cmwpO1xufVxuZnVuY3Rpb24gaGVhZGVyc1RvT2JqZWN0KGhlYWRlcnMpIHtcbiAgaWYgKHR5cGVvZiBIZWFkZXJzICE9PSBcInVuZGVmaW5lZFwiICYmIGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKVxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpO1xuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGNvbWJpbmVDYWxsYmFja3MoY29tYmluYXRpb24sIC4uLmNhbGxiYWNrcykge1xuICBpZiAoY29tYmluYXRpb24gPT09IFwib3ZlcndyaXRlXCIpIHtcbiAgICByZXR1cm4gYXN5bmMgKGN0eCkgPT4ge1xuICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgZm9yIChsZXQgaSA9IGNhbGxiYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzW2ldICE9IG51bGwpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICByZXR1cm4geyAuLi5jdHgsIC4uLmF3YWl0IGNhbGxiYWNrKGN0eCkgfTtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXN5bmMgKGN0eCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgIGN0eCA9IHsgLi4uY3R4LCAuLi5hd2FpdCBjYWxsYmFjayhjdHgpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoKGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IF9jb21iaW5hdGlvbiA9IGNvbmZpZy5jb21iaW5hdGlvbiB8fCBcImNoYWluXCI7XG4gIGNvbnN0IF9vcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IF9mZXRjaE9wdGlvbnMgPSBjb25maWcuZmV0Y2hPcHRpb25zIHx8IHt9O1xuICBmdW5jdGlvbiB1c2VGYWN0b3J5RmV0Y2godXJsLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY29tcHV0ZWRVcmwgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgICBjb25zdCBiYXNlVXJsID0gdG9WYWx1ZShjb25maWcuYmFzZVVybCk7XG4gICAgICBjb25zdCB0YXJnZXRVcmwgPSB0b1ZhbHVlKHVybCk7XG4gICAgICByZXR1cm4gYmFzZVVybCAmJiAhaXNBYnNvbHV0ZVVSTCh0YXJnZXRVcmwpID8gam9pblBhdGhzKGJhc2VVcmwsIHRhcmdldFVybCkgOiB0YXJnZXRVcmw7XG4gICAgfSk7XG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcbiAgICBsZXQgZmV0Y2hPcHRpb25zID0gX2ZldGNoT3B0aW9ucztcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaXNGZXRjaE9wdGlvbnMoYXJnc1swXSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIC4uLmFyZ3NbMF0sXG4gICAgICAgICAgYmVmb3JlRmV0Y2g6IGNvbWJpbmVDYWxsYmFja3MoX2NvbWJpbmF0aW9uLCBfb3B0aW9ucy5iZWZvcmVGZXRjaCwgYXJnc1swXS5iZWZvcmVGZXRjaCksXG4gICAgICAgICAgYWZ0ZXJGZXRjaDogY29tYmluZUNhbGxiYWNrcyhfY29tYmluYXRpb24sIF9vcHRpb25zLmFmdGVyRmV0Y2gsIGFyZ3NbMF0uYWZ0ZXJGZXRjaCksXG4gICAgICAgICAgb25GZXRjaEVycm9yOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMub25GZXRjaEVycm9yLCBhcmdzWzBdLm9uRmV0Y2hFcnJvcilcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgLi4uYXJnc1swXSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzVG9PYmplY3QoZmV0Y2hPcHRpb25zLmhlYWRlcnMpIHx8IHt9LFxuICAgICAgICAgICAgLi4uaGVhZGVyc1RvT2JqZWN0KGFyZ3NbMF0uaGVhZGVycykgfHwge31cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEgJiYgaXNGZXRjaE9wdGlvbnMoYXJnc1sxXSkpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLmFyZ3NbMV0sXG4gICAgICAgIGJlZm9yZUZldGNoOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMuYmVmb3JlRmV0Y2gsIGFyZ3NbMV0uYmVmb3JlRmV0Y2gpLFxuICAgICAgICBhZnRlckZldGNoOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMuYWZ0ZXJGZXRjaCwgYXJnc1sxXS5hZnRlckZldGNoKSxcbiAgICAgICAgb25GZXRjaEVycm9yOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMub25GZXRjaEVycm9yLCBhcmdzWzFdLm9uRmV0Y2hFcnJvcilcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1c2VGZXRjaChjb21wdXRlZFVybCwgZmV0Y2hPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gdXNlRmFjdG9yeUZldGNoO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2godXJsLCAuLi5hcmdzKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHN1cHBvcnRzQWJvcnQgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSBcImZ1bmN0aW9uXCI7XG4gIGxldCBmZXRjaE9wdGlvbnMgPSB7fTtcbiAgbGV0IG9wdGlvbnMgPSB7XG4gICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgIHJlZmV0Y2g6IGZhbHNlLFxuICAgIHRpbWVvdXQ6IDAsXG4gICAgdXBkYXRlRGF0YU9uRXJyb3I6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgcGF5bG9hZDogdm9pZCAwXG4gIH07XG4gIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoaXNGZXRjaE9wdGlvbnMoYXJnc1swXSkpXG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCAuLi5hcmdzWzBdIH07XG4gICAgZWxzZVxuICAgICAgZmV0Y2hPcHRpb25zID0gYXJnc1swXTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGlzRmV0Y2hPcHRpb25zKGFyZ3NbMV0pKVxuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgLi4uYXJnc1sxXSB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBmZXRjaCA9IChfYiA9IChfYSA9IGRlZmF1bHRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mZXRjaCkgIT0gbnVsbCA/IF9iIDogZ2xvYmFsVGhpcyA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICBpbml0aWFsRGF0YSxcbiAgICB0aW1lb3V0XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXNwb25zZUV2ZW50ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IGVycm9yRXZlbnQgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgZmluYWxseUV2ZW50ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IGlzRmluaXNoZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgaXNGZXRjaGluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBhYm9ydGVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHN0YXR1c0NvZGUgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCByZXNwb25zZSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgZGF0YSA9IHNoYWxsb3dSZWYoaW5pdGlhbERhdGEgfHwgbnVsbCk7XG4gIGNvbnN0IGNhbkFib3J0ID0gY29tcHV0ZWQoKCkgPT4gc3VwcG9ydHNBYm9ydCAmJiBpc0ZldGNoaW5nLnZhbHVlKTtcbiAgbGV0IGNvbnRyb2xsZXI7XG4gIGxldCB0aW1lcjtcbiAgY29uc3QgYWJvcnQgPSAocmVhc29uKSA9PiB7XG4gICAgaWYgKHN1cHBvcnRzQWJvcnQpIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbiAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb250cm9sbGVyLnNpZ25hbC5vbmFib3J0ID0gKCkgPT4gYWJvcnRlZC52YWx1ZSA9IHRydWU7XG4gICAgICBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxvYWRpbmcgPSAoaXNMb2FkaW5nKSA9PiB7XG4gICAgaXNGZXRjaGluZy52YWx1ZSA9IGlzTG9hZGluZztcbiAgICBpc0ZpbmlzaGVkLnZhbHVlID0gIWlzTG9hZGluZztcbiAgfTtcbiAgaWYgKHRpbWVvdXQpXG4gICAgdGltZXIgPSB1c2VUaW1lb3V0Rm4oYWJvcnQsIHRpbWVvdXQsIHsgaW1tZWRpYXRlOiBmYWxzZSB9KTtcbiAgbGV0IGV4ZWN1dGVDb3VudGVyID0gMDtcbiAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jICh0aHJvd09uRmFpbGVkID0gZmFsc2UpID0+IHtcbiAgICB2YXIgX2EyLCBfYjI7XG4gICAgYWJvcnQoKTtcbiAgICBsb2FkaW5nKHRydWUpO1xuICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgICBzdGF0dXNDb2RlLnZhbHVlID0gbnVsbDtcbiAgICBhYm9ydGVkLnZhbHVlID0gZmFsc2U7XG4gICAgZXhlY3V0ZUNvdW50ZXIgKz0gMTtcbiAgICBjb25zdCBjdXJyZW50RXhlY3V0ZUNvdW50ZXIgPSBleGVjdXRlQ291bnRlcjtcbiAgICBjb25zdCBkZWZhdWx0RmV0Y2hPcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiBjb25maWcubWV0aG9kLFxuICAgICAgaGVhZGVyczoge31cbiAgICB9O1xuICAgIGNvbnN0IHBheWxvYWQgPSB0b1ZhbHVlKGNvbmZpZy5wYXlsb2FkKTtcbiAgICBpZiAocGF5bG9hZCkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IGhlYWRlcnNUb09iamVjdChkZWZhdWx0RmV0Y2hPcHRpb25zLmhlYWRlcnMpO1xuICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCk7XG4gICAgICBpZiAoIWNvbmZpZy5wYXlsb2FkVHlwZSAmJiBwYXlsb2FkICYmIChwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBBcnJheS5pc0FycmF5KHByb3RvKSkgJiYgIShwYXlsb2FkIGluc3RhbmNlb2YgRm9ybURhdGEpKVxuICAgICAgICBjb25maWcucGF5bG9hZFR5cGUgPSBcImpzb25cIjtcbiAgICAgIGlmIChjb25maWcucGF5bG9hZFR5cGUpXG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSAoX2EyID0gcGF5bG9hZE1hcHBpbmdbY29uZmlnLnBheWxvYWRUeXBlXSkgIT0gbnVsbCA/IF9hMiA6IGNvbmZpZy5wYXlsb2FkVHlwZTtcbiAgICAgIGRlZmF1bHRGZXRjaE9wdGlvbnMuYm9keSA9IGNvbmZpZy5wYXlsb2FkVHlwZSA9PT0gXCJqc29uXCIgPyBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgfVxuICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHVybDogdG9WYWx1ZSh1cmwpLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICAuLi5kZWZhdWx0RmV0Y2hPcHRpb25zLFxuICAgICAgICAuLi5mZXRjaE9wdGlvbnNcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgaXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5iZWZvcmVGZXRjaClcbiAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dCwgYXdhaXQgb3B0aW9ucy5iZWZvcmVGZXRjaChjb250ZXh0KSk7XG4gICAgaWYgKGlzQ2FuY2VsZWQgfHwgIWZldGNoKSB7XG4gICAgICBsb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZURhdGEgPSBudWxsO1xuICAgIGlmICh0aW1lcilcbiAgICAgIHRpbWVyLnN0YXJ0KCk7XG4gICAgcmV0dXJuIGZldGNoKFxuICAgICAgY29udGV4dC51cmwsXG4gICAgICB7XG4gICAgICAgIC4uLmRlZmF1bHRGZXRjaE9wdGlvbnMsXG4gICAgICAgIC4uLmNvbnRleHQub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnNUb09iamVjdChkZWZhdWx0RmV0Y2hPcHRpb25zLmhlYWRlcnMpLFxuICAgICAgICAgIC4uLmhlYWRlcnNUb09iamVjdCgoX2IyID0gY29udGV4dC5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmhlYWRlcnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApLnRoZW4oYXN5bmMgKGZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgIHJlc3BvbnNlLnZhbHVlID0gZmV0Y2hSZXNwb25zZTtcbiAgICAgIHN0YXR1c0NvZGUudmFsdWUgPSBmZXRjaFJlc3BvbnNlLnN0YXR1cztcbiAgICAgIHJlc3BvbnNlRGF0YSA9IGF3YWl0IGZldGNoUmVzcG9uc2UuY2xvbmUoKVtjb25maWcudHlwZV0oKTtcbiAgICAgIGlmICghZmV0Y2hSZXNwb25zZS5vaykge1xuICAgICAgICBkYXRhLnZhbHVlID0gaW5pdGlhbERhdGEgfHwgbnVsbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZldGNoUmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hZnRlckZldGNoKSB7XG4gICAgICAgICh7IGRhdGE6IHJlc3BvbnNlRGF0YSB9ID0gYXdhaXQgb3B0aW9ucy5hZnRlckZldGNoKHtcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgcmVzcG9uc2U6IGZldGNoUmVzcG9uc2UsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBleGVjdXRlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGRhdGEudmFsdWUgPSByZXNwb25zZURhdGE7XG4gICAgICByZXNwb25zZUV2ZW50LnRyaWdnZXIoZmV0Y2hSZXNwb25zZSk7XG4gICAgICByZXR1cm4gZmV0Y2hSZXNwb25zZTtcbiAgICB9KS5jYXRjaChhc3luYyAoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgbGV0IGVycm9yRGF0YSA9IGZldGNoRXJyb3IubWVzc2FnZSB8fCBmZXRjaEVycm9yLm5hbWU7XG4gICAgICBpZiAob3B0aW9ucy5vbkZldGNoRXJyb3IpIHtcbiAgICAgICAgKHsgZXJyb3I6IGVycm9yRGF0YSwgZGF0YTogcmVzcG9uc2VEYXRhIH0gPSBhd2FpdCBvcHRpb25zLm9uRmV0Y2hFcnJvcih7XG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgIGVycm9yOiBmZXRjaEVycm9yLFxuICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS52YWx1ZSxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGV4ZWN1dGVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgZXJyb3IudmFsdWUgPSBlcnJvckRhdGE7XG4gICAgICBpZiAob3B0aW9ucy51cGRhdGVEYXRhT25FcnJvcilcbiAgICAgICAgZGF0YS52YWx1ZSA9IHJlc3BvbnNlRGF0YTtcbiAgICAgIGVycm9yRXZlbnQudHJpZ2dlcihmZXRjaEVycm9yKTtcbiAgICAgIGlmICh0aHJvd09uRmFpbGVkKVxuICAgICAgICB0aHJvdyBmZXRjaEVycm9yO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBpZiAoY3VycmVudEV4ZWN1dGVDb3VudGVyID09PSBleGVjdXRlQ291bnRlcilcbiAgICAgICAgbG9hZGluZyhmYWxzZSk7XG4gICAgICBpZiAodGltZXIpXG4gICAgICAgIHRpbWVyLnN0b3AoKTtcbiAgICAgIGZpbmFsbHlFdmVudC50cmlnZ2VyKG51bGwpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCByZWZldGNoID0gdG9SZWYob3B0aW9ucy5yZWZldGNoKTtcbiAgd2F0Y2goXG4gICAgW1xuICAgICAgcmVmZXRjaCxcbiAgICAgIHRvUmVmKHVybClcbiAgICBdLFxuICAgIChbcmVmZXRjaDJdKSA9PiByZWZldGNoMiAmJiBleGVjdXRlKCksXG4gICAgeyBkZWVwOiB0cnVlIH1cbiAgKTtcbiAgY29uc3Qgc2hlbGwgPSB7XG4gICAgaXNGaW5pc2hlZDogcmVhZG9ubHkoaXNGaW5pc2hlZCksXG4gICAgaXNGZXRjaGluZzogcmVhZG9ubHkoaXNGZXRjaGluZyksXG4gICAgc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZSxcbiAgICBlcnJvcixcbiAgICBkYXRhLFxuICAgIGNhbkFib3J0LFxuICAgIGFib3J0ZWQsXG4gICAgYWJvcnQsXG4gICAgZXhlY3V0ZSxcbiAgICBvbkZldGNoUmVzcG9uc2U6IHJlc3BvbnNlRXZlbnQub24sXG4gICAgb25GZXRjaEVycm9yOiBlcnJvckV2ZW50Lm9uLFxuICAgIG9uRmV0Y2hGaW5hbGx5OiBmaW5hbGx5RXZlbnQub24sXG4gICAgLy8gbWV0aG9kXG4gICAgZ2V0OiBzZXRNZXRob2QoXCJHRVRcIiksXG4gICAgcHV0OiBzZXRNZXRob2QoXCJQVVRcIiksXG4gICAgcG9zdDogc2V0TWV0aG9kKFwiUE9TVFwiKSxcbiAgICBkZWxldGU6IHNldE1ldGhvZChcIkRFTEVURVwiKSxcbiAgICBwYXRjaDogc2V0TWV0aG9kKFwiUEFUQ0hcIiksXG4gICAgaGVhZDogc2V0TWV0aG9kKFwiSEVBRFwiKSxcbiAgICBvcHRpb25zOiBzZXRNZXRob2QoXCJPUFRJT05TXCIpLFxuICAgIC8vIHR5cGVcbiAgICBqc29uOiBzZXRUeXBlKFwianNvblwiKSxcbiAgICB0ZXh0OiBzZXRUeXBlKFwidGV4dFwiKSxcbiAgICBibG9iOiBzZXRUeXBlKFwiYmxvYlwiKSxcbiAgICBhcnJheUJ1ZmZlcjogc2V0VHlwZShcImFycmF5QnVmZmVyXCIpLFxuICAgIGZvcm1EYXRhOiBzZXRUeXBlKFwiZm9ybURhdGFcIilcbiAgfTtcbiAgZnVuY3Rpb24gc2V0TWV0aG9kKG1ldGhvZCkge1xuICAgIHJldHVybiAocGF5bG9hZCwgcGF5bG9hZFR5cGUpID0+IHtcbiAgICAgIGlmICghaXNGZXRjaGluZy52YWx1ZSkge1xuICAgICAgICBjb25maWcubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBjb25maWcucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIGNvbmZpZy5wYXlsb2FkVHlwZSA9IHBheWxvYWRUeXBlO1xuICAgICAgICBpZiAoaXNSZWYoY29uZmlnLnBheWxvYWQpKSB7XG4gICAgICAgICAgd2F0Y2goXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIHJlZmV0Y2gsXG4gICAgICAgICAgICAgIHRvUmVmKGNvbmZpZy5wYXlsb2FkKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIChbcmVmZXRjaDJdKSA9PiByZWZldGNoMiAmJiBleGVjdXRlKCksXG4gICAgICAgICAgICB7IGRlZXA6IHRydWUgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zaGVsbCxcbiAgICAgICAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdFVudGlsRmluaXNoZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gd2FpdFVudGlsRmluaXNoZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHVudGlsKGlzRmluaXNoZWQpLnRvQmUodHJ1ZSkudGhlbigoKSA9PiByZXNvbHZlKHNoZWxsKSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFpc0ZldGNoaW5nLnZhbHVlKSB7XG4gICAgICAgIGNvbmZpZy50eXBlID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zaGVsbCxcbiAgICAgICAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdFVudGlsRmluaXNoZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKVxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZXhlY3V0ZSgpKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zaGVsbCxcbiAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gd2FpdFVudGlsRmluaXNoZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBqb2luUGF0aHMoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0LmVuZHNXaXRoKFwiL1wiKSAmJiAhZW5kLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGAke3N0YXJ0fS8ke2VuZH1gO1xuICB9XG4gIGlmIChzdGFydC5lbmRzV2l0aChcIi9cIikgJiYgZW5kLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGAke3N0YXJ0LnNsaWNlKDAsIC0xKX0ke2VuZH1gO1xuICB9XG4gIHJldHVybiBgJHtzdGFydH0ke2VuZH1gO1xufVxuXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIG11bHRpcGxlOiB0cnVlLFxuICBhY2NlcHQ6IFwiKlwiLFxuICByZXNldDogZmFsc2UsXG4gIGRpcmVjdG9yeTogZmFsc2Vcbn07XG5mdW5jdGlvbiBwcmVwYXJlSW5pdGlhbEZpbGVzKGZpbGVzKSB7XG4gIGlmICghZmlsZXMpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChmaWxlcyBpbnN0YW5jZW9mIEZpbGVMaXN0KVxuICAgIHJldHVybiBmaWxlcztcbiAgY29uc3QgZHQgPSBuZXcgRGF0YVRyYW5zZmVyKCk7XG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGR0Lml0ZW1zLmFkZChmaWxlKTtcbiAgfVxuICByZXR1cm4gZHQuZmlsZXM7XG59XG5mdW5jdGlvbiB1c2VGaWxlRGlhbG9nKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZpbGVzID0gcmVmKHByZXBhcmVJbml0aWFsRmlsZXMob3B0aW9ucy5pbml0aWFsRmlsZXMpKTtcbiAgY29uc3QgeyBvbjogb25DaGFuZ2UsIHRyaWdnZXI6IGNoYW5nZVRyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvbkNhbmNlbCwgdHJpZ2dlcjogY2FuY2VsVHJpZ2dlciB9ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGxldCBpbnB1dDtcbiAgaWYgKGRvY3VtZW50KSB7XG4gICAgaW5wdXQgPSB1bnJlZkVsZW1lbnQob3B0aW9ucy5pbnB1dCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5vbmNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZmlsZXMudmFsdWUgPSByZXN1bHQuZmlsZXM7XG4gICAgICBjaGFuZ2VUcmlnZ2VyKGZpbGVzLnZhbHVlKTtcbiAgICB9O1xuICAgIGlucHV0Lm9uY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsVHJpZ2dlcigpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgZmlsZXMudmFsdWUgPSBudWxsO1xuICAgIGlmIChpbnB1dCAmJiBpbnB1dC52YWx1ZSkge1xuICAgICAgaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgY2hhbmdlVHJpZ2dlcihudWxsKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9wZW4gPSAobG9jYWxPcHRpb25zKSA9PiB7XG4gICAgaWYgKCFpbnB1dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBfb3B0aW9ucyA9IHtcbiAgICAgIC4uLkRFRkFVTFRfT1BUSU9OUyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAuLi5sb2NhbE9wdGlvbnNcbiAgICB9O1xuICAgIGlucHV0Lm11bHRpcGxlID0gX29wdGlvbnMubXVsdGlwbGU7XG4gICAgaW5wdXQuYWNjZXB0ID0gX29wdGlvbnMuYWNjZXB0O1xuICAgIGlucHV0LndlYmtpdGRpcmVjdG9yeSA9IF9vcHRpb25zLmRpcmVjdG9yeTtcbiAgICBpZiAoaGFzT3duKF9vcHRpb25zLCBcImNhcHR1cmVcIikpXG4gICAgICBpbnB1dC5jYXB0dXJlID0gX29wdGlvbnMuY2FwdHVyZTtcbiAgICBpZiAoX29wdGlvbnMucmVzZXQpXG4gICAgICByZXNldCgpO1xuICAgIGlucHV0LmNsaWNrKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgZmlsZXM6IHJlYWRvbmx5KGZpbGVzKSxcbiAgICBvcGVuLFxuICAgIHJlc2V0LFxuICAgIG9uQ2FuY2VsLFxuICAgIG9uQ2hhbmdlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUZpbGVTeXN0ZW1BY2Nlc3Mob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3c6IF93aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGRhdGFUeXBlID0gXCJUZXh0XCJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdpbmRvdyA9IF93aW5kb3c7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcInNob3dTYXZlRmlsZVBpY2tlclwiIGluIHdpbmRvdyAmJiBcInNob3dPcGVuRmlsZVBpY2tlclwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IGZpbGVIYW5kbGUgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IGRhdGEgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IGZpbGUgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IGZpbGVOYW1lID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGZpbGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICB9KTtcbiAgY29uc3QgZmlsZU1JTUUgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZmlsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUpICE9IG51bGwgPyBfYiA6IFwiXCI7XG4gIH0pO1xuICBjb25zdCBmaWxlU2l6ZSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2l6ZSkgIT0gbnVsbCA/IF9iIDogMDtcbiAgfSk7XG4gIGNvbnN0IGZpbGVMYXN0TW9kaWZpZWQgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZmlsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxhc3RNb2RpZmllZCkgIT0gbnVsbCA/IF9iIDogMDtcbiAgfSk7XG4gIGFzeW5jIGZ1bmN0aW9uIG9wZW4oX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2hhbmRsZV0gPSBhd2FpdCB3aW5kb3cuc2hvd09wZW5GaWxlUGlja2VyKHsgLi4udG9WYWx1ZShvcHRpb25zKSwgLi4uX29wdGlvbnMgfSk7XG4gICAgZmlsZUhhbmRsZS52YWx1ZSA9IGhhbmRsZTtcbiAgICBhd2FpdCB1cGRhdGVEYXRhKCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlKF9vcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGZpbGVIYW5kbGUudmFsdWUgPSBhd2FpdCB3aW5kb3cuc2hvd1NhdmVGaWxlUGlja2VyKHsgLi4ub3B0aW9ucywgLi4uX29wdGlvbnMgfSk7XG4gICAgZGF0YS52YWx1ZSA9IHZvaWQgMDtcbiAgICBhd2FpdCB1cGRhdGVEYXRhKCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc2F2ZShfb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIWZpbGVIYW5kbGUudmFsdWUpXG4gICAgICByZXR1cm4gc2F2ZUFzKF9vcHRpb25zKTtcbiAgICBpZiAoZGF0YS52YWx1ZSkge1xuICAgICAgY29uc3Qgd3JpdGFibGVTdHJlYW0gPSBhd2FpdCBmaWxlSGFuZGxlLnZhbHVlLmNyZWF0ZVdyaXRhYmxlKCk7XG4gICAgICBhd2FpdCB3cml0YWJsZVN0cmVhbS53cml0ZShkYXRhLnZhbHVlKTtcbiAgICAgIGF3YWl0IHdyaXRhYmxlU3RyZWFtLmNsb3NlKCk7XG4gICAgfVxuICAgIGF3YWl0IHVwZGF0ZUZpbGUoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzYXZlQXMoX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgZmlsZUhhbmRsZS52YWx1ZSA9IGF3YWl0IHdpbmRvdy5zaG93U2F2ZUZpbGVQaWNrZXIoeyAuLi5vcHRpb25zLCAuLi5fb3B0aW9ucyB9KTtcbiAgICBpZiAoZGF0YS52YWx1ZSkge1xuICAgICAgY29uc3Qgd3JpdGFibGVTdHJlYW0gPSBhd2FpdCBmaWxlSGFuZGxlLnZhbHVlLmNyZWF0ZVdyaXRhYmxlKCk7XG4gICAgICBhd2FpdCB3cml0YWJsZVN0cmVhbS53cml0ZShkYXRhLnZhbHVlKTtcbiAgICAgIGF3YWl0IHdyaXRhYmxlU3RyZWFtLmNsb3NlKCk7XG4gICAgfVxuICAgIGF3YWl0IHVwZGF0ZUZpbGUoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGRhdGVGaWxlKCkge1xuICAgIHZhciBfYTtcbiAgICBmaWxlLnZhbHVlID0gYXdhaXQgKChfYSA9IGZpbGVIYW5kbGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRGaWxlKCkpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZURhdGEoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBhd2FpdCB1cGRhdGVGaWxlKCk7XG4gICAgY29uc3QgdHlwZSA9IHRvVmFsdWUoZGF0YVR5cGUpO1xuICAgIGlmICh0eXBlID09PSBcIlRleHRcIilcbiAgICAgIGRhdGEudmFsdWUgPSBhd2FpdCAoKF9hID0gZmlsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRleHQoKSk7XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheUJ1ZmZlclwiKVxuICAgICAgZGF0YS52YWx1ZSA9IGF3YWl0ICgoX2IgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXJyYXlCdWZmZXIoKSk7XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJCbG9iXCIpXG4gICAgICBkYXRhLnZhbHVlID0gZmlsZS52YWx1ZTtcbiAgfVxuICB3YXRjaCgoKSA9PiB0b1ZhbHVlKGRhdGFUeXBlKSwgdXBkYXRlRGF0YSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgZGF0YSxcbiAgICBmaWxlLFxuICAgIGZpbGVOYW1lLFxuICAgIGZpbGVNSU1FLFxuICAgIGZpbGVTaXplLFxuICAgIGZpbGVMYXN0TW9kaWZpZWQsXG4gICAgb3BlbixcbiAgICBjcmVhdGUsXG4gICAgc2F2ZSxcbiAgICBzYXZlQXMsXG4gICAgdXBkYXRlRGF0YVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VGb2N1cyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGluaXRpYWxWYWx1ZSA9IGZhbHNlLCBmb2N1c1Zpc2libGUgPSBmYWxzZSwgcHJldmVudFNjcm9sbCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lckZvY3VzZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNvbXB1dGVkKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpKTtcbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgXCJmb2N1c1wiLCAoZXZlbnQpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghZm9jdXNWaXNpYmxlIHx8ICgoX2IgPSAoX2EgPSBldmVudC50YXJnZXQpLm1hdGNoZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBcIjpmb2N1cy12aXNpYmxlXCIpKSlcbiAgICAgIGlubmVyRm9jdXNlZC52YWx1ZSA9IHRydWU7XG4gIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgXCJibHVyXCIsICgpID0+IGlubmVyRm9jdXNlZC52YWx1ZSA9IGZhbHNlLCBsaXN0ZW5lck9wdGlvbnMpO1xuICBjb25zdCBmb2N1c2VkID0gY29tcHV0ZWQoe1xuICAgIGdldDogKCkgPT4gaW5uZXJGb2N1c2VkLnZhbHVlLFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICghdmFsdWUgJiYgaW5uZXJGb2N1c2VkLnZhbHVlKVxuICAgICAgICAoX2EgPSB0YXJnZXRFbGVtZW50LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYmx1cigpO1xuICAgICAgZWxzZSBpZiAodmFsdWUgJiYgIWlubmVyRm9jdXNlZC52YWx1ZSlcbiAgICAgICAgKF9iID0gdGFyZ2V0RWxlbWVudC52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZvY3VzKHsgcHJldmVudFNjcm9sbCB9KTtcbiAgICB9XG4gIH0pO1xuICB3YXRjaChcbiAgICB0YXJnZXRFbGVtZW50LFxuICAgICgpID0+IHtcbiAgICAgIGZvY3VzZWQudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSwgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbiAgcmV0dXJuIHsgZm9jdXNlZCB9O1xufVxuXG5jb25zdCBFVkVOVF9GT0NVU19JTiA9IFwiZm9jdXNpblwiO1xuY29uc3QgRVZFTlRfRk9DVVNfT1VUID0gXCJmb2N1c291dFwiO1xuY29uc3QgUFNFVURPX0NMQVNTX0ZPQ1VTX1dJVEhJTiA9IFwiOmZvY3VzLXdpdGhpblwiO1xuZnVuY3Rpb24gdXNlRm9jdXNXaXRoaW4odGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY29tcHV0ZWQoKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCkpO1xuICBjb25zdCBfZm9jdXNlZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBmb2N1c2VkID0gY29tcHV0ZWQoKCkgPT4gX2ZvY3VzZWQudmFsdWUpO1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdXNlQWN0aXZlRWxlbWVudChvcHRpb25zKTtcbiAgaWYgKCF3aW5kb3cgfHwgIWFjdGl2ZUVsZW1lbnQudmFsdWUpIHtcbiAgICByZXR1cm4geyBmb2N1c2VkIH07XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgRVZFTlRfRk9DVVNfSU4sICgpID0+IF9mb2N1c2VkLnZhbHVlID0gdHJ1ZSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBFVkVOVF9GT0NVU19PVVQsICgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gX2ZvY3VzZWQudmFsdWUgPSAoX2MgPSAoX2IgPSAoX2EgPSB0YXJnZXRFbGVtZW50LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWF0Y2hlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIFBTRVVET19DTEFTU19GT0NVU19XSVRISU4pKSAhPSBudWxsID8gX2MgOiBmYWxzZTtcbiAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgcmV0dXJuIHsgZm9jdXNlZCB9O1xufVxuXG5mdW5jdGlvbiB1c2VGcHMob3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGZwcyA9IHNoYWxsb3dSZWYoMCk7XG4gIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuIGZwcztcbiAgY29uc3QgZXZlcnkgPSAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZXJ5KSAhPSBudWxsID8gX2EgOiAxMDtcbiAgbGV0IGxhc3QgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgbGV0IHRpY2tzID0gMDtcbiAgdXNlUmFmRm4oKCkgPT4ge1xuICAgIHRpY2tzICs9IDE7XG4gICAgaWYgKHRpY2tzID49IGV2ZXJ5KSB7XG4gICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGRpZmYgPSBub3cgLSBsYXN0O1xuICAgICAgZnBzLnZhbHVlID0gTWF0aC5yb3VuZCgxZTMgLyAoZGlmZiAvIHRpY2tzKSk7XG4gICAgICBsYXN0ID0gbm93O1xuICAgICAgdGlja3MgPSAwO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmcHM7XG59XG5cbmNvbnN0IGV2ZW50SGFuZGxlcnMgPSBbXG4gIFwiZnVsbHNjcmVlbmNoYW5nZVwiLFxuICBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcbiAgXCJ3ZWJraXRlbmRmdWxsc2NyZWVuXCIsXG4gIFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICBcIk1TRnVsbHNjcmVlbkNoYW5nZVwiXG5dO1xuZnVuY3Rpb24gdXNlRnVsbHNjcmVlbih0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgYXV0b0V4aXQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGFyZ2V0UmVmID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdW5yZWZFbGVtZW50KHRhcmdldCkpICE9IG51bGwgPyBfYSA6IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH0pO1xuICBjb25zdCBpc0Z1bGxzY3JlZW4gPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgcmVxdWVzdE1ldGhvZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJyZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRFbnRlckZ1bGxzY3JlZW5cIixcbiAgICAgIFwid2Via2l0RW50ZXJGdWxsU2NyZWVuXCIsXG4gICAgICBcIndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1velJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1zUmVxdWVzdEZ1bGxzY3JlZW5cIlxuICAgIF0uZmluZCgobSkgPT4gZG9jdW1lbnQgJiYgbSBpbiBkb2N1bWVudCB8fCB0YXJnZXRSZWYudmFsdWUgJiYgbSBpbiB0YXJnZXRSZWYudmFsdWUpO1xuICB9KTtcbiAgY29uc3QgZXhpdE1ldGhvZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJleGl0RnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRFeGl0RnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRFeGl0RnVsbFNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRDYW5jZWxGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1vekNhbmNlbEZ1bGxTY3JlZW5cIixcbiAgICAgIFwibXNFeGl0RnVsbHNjcmVlblwiXG4gICAgXS5maW5kKChtKSA9PiBkb2N1bWVudCAmJiBtIGluIGRvY3VtZW50IHx8IHRhcmdldFJlZi52YWx1ZSAmJiBtIGluIHRhcmdldFJlZi52YWx1ZSk7XG4gIH0pO1xuICBjb25zdCBmdWxsc2NyZWVuRW5hYmxlZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJmdWxsU2NyZWVuXCIsXG4gICAgICBcIndlYmtpdElzRnVsbFNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlblwiLFxuICAgICAgXCJtb3pGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1zRnVsbHNjcmVlbkVsZW1lbnRcIlxuICAgIF0uZmluZCgobSkgPT4gZG9jdW1lbnQgJiYgbSBpbiBkb2N1bWVudCB8fCB0YXJnZXRSZWYudmFsdWUgJiYgbSBpbiB0YXJnZXRSZWYudmFsdWUpO1xuICB9KTtcbiAgY29uc3QgZnVsbHNjcmVlbkVsZW1lbnRNZXRob2QgPSBbXG4gICAgXCJmdWxsc2NyZWVuRWxlbWVudFwiLFxuICAgIFwid2Via2l0RnVsbHNjcmVlbkVsZW1lbnRcIixcbiAgICBcIm1vekZ1bGxTY3JlZW5FbGVtZW50XCIsXG4gICAgXCJtc0Z1bGxzY3JlZW5FbGVtZW50XCJcbiAgXS5maW5kKChtKSA9PiBkb2N1bWVudCAmJiBtIGluIGRvY3VtZW50KTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gdGFyZ2V0UmVmLnZhbHVlICYmIGRvY3VtZW50ICYmIHJlcXVlc3RNZXRob2QudmFsdWUgIT09IHZvaWQgMCAmJiBleGl0TWV0aG9kLnZhbHVlICE9PSB2b2lkIDAgJiYgZnVsbHNjcmVlbkVuYWJsZWQudmFsdWUgIT09IHZvaWQgMCk7XG4gIGNvbnN0IGlzQ3VycmVudEVsZW1lbnRGdWxsU2NyZWVuID0gKCkgPT4ge1xuICAgIGlmIChmdWxsc2NyZWVuRWxlbWVudE1ldGhvZClcbiAgICAgIHJldHVybiAoZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50W2Z1bGxzY3JlZW5FbGVtZW50TWV0aG9kXSkgPT09IHRhcmdldFJlZi52YWx1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGNvbnN0IGlzRWxlbWVudEZ1bGxTY3JlZW4gPSAoKSA9PiB7XG4gICAgaWYgKGZ1bGxzY3JlZW5FbmFibGVkLnZhbHVlKSB7XG4gICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnRbZnVsbHNjcmVlbkVuYWJsZWQudmFsdWVdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50W2Z1bGxzY3JlZW5FbmFibGVkLnZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldDIgPSB0YXJnZXRSZWYudmFsdWU7XG4gICAgICAgIGlmICgodGFyZ2V0MiA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0MltmdWxsc2NyZWVuRW5hYmxlZC52YWx1ZV0pICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gQm9vbGVhbih0YXJnZXQyW2Z1bGxzY3JlZW5FbmFibGVkLnZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBhc3luYyBmdW5jdGlvbiBleGl0KCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgIWlzRnVsbHNjcmVlbi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZXhpdE1ldGhvZC52YWx1ZSkge1xuICAgICAgaWYgKChkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnRbZXhpdE1ldGhvZC52YWx1ZV0pICE9IG51bGwpIHtcbiAgICAgICAgYXdhaXQgZG9jdW1lbnRbZXhpdE1ldGhvZC52YWx1ZV0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldDIgPSB0YXJnZXRSZWYudmFsdWU7XG4gICAgICAgIGlmICgodGFyZ2V0MiA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0MltleGl0TWV0aG9kLnZhbHVlXSkgIT0gbnVsbClcbiAgICAgICAgICBhd2FpdCB0YXJnZXQyW2V4aXRNZXRob2QudmFsdWVdKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlzRnVsbHNjcmVlbi52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVudGVyKCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgaXNGdWxsc2NyZWVuLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpc0VsZW1lbnRGdWxsU2NyZWVuKCkpXG4gICAgICBhd2FpdCBleGl0KCk7XG4gICAgY29uc3QgdGFyZ2V0MiA9IHRhcmdldFJlZi52YWx1ZTtcbiAgICBpZiAocmVxdWVzdE1ldGhvZC52YWx1ZSAmJiAodGFyZ2V0MiA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0MltyZXF1ZXN0TWV0aG9kLnZhbHVlXSkgIT0gbnVsbCkge1xuICAgICAgYXdhaXQgdGFyZ2V0MltyZXF1ZXN0TWV0aG9kLnZhbHVlXSgpO1xuICAgICAgaXNGdWxsc2NyZWVuLnZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIGF3YWl0IChpc0Z1bGxzY3JlZW4udmFsdWUgPyBleGl0KCkgOiBlbnRlcigpKTtcbiAgfVxuICBjb25zdCBoYW5kbGVyQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgY29uc3QgaXNFbGVtZW50RnVsbFNjcmVlblZhbHVlID0gaXNFbGVtZW50RnVsbFNjcmVlbigpO1xuICAgIGlmICghaXNFbGVtZW50RnVsbFNjcmVlblZhbHVlIHx8IGlzRWxlbWVudEZ1bGxTY3JlZW5WYWx1ZSAmJiBpc0N1cnJlbnRFbGVtZW50RnVsbFNjcmVlbigpKVxuICAgICAgaXNGdWxsc2NyZWVuLnZhbHVlID0gaXNFbGVtZW50RnVsbFNjcmVlblZhbHVlO1xuICB9O1xuICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IGNhcHR1cmU6IGZhbHNlLCBwYXNzaXZlOiB0cnVlIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIGV2ZW50SGFuZGxlcnMsIGhhbmRsZXJDYWxsYmFjaywgbGlzdGVuZXJPcHRpb25zKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcigoKSA9PiB1bnJlZkVsZW1lbnQodGFyZ2V0UmVmKSwgZXZlbnRIYW5kbGVycywgaGFuZGxlckNhbGxiYWNrLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB0cnlPbk1vdW50ZWQoaGFuZGxlckNhbGxiYWNrLCBmYWxzZSk7XG4gIGlmIChhdXRvRXhpdClcbiAgICB0cnlPblNjb3BlRGlzcG9zZShleGl0KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc0Z1bGxzY3JlZW4sXG4gICAgZW50ZXIsXG4gICAgZXhpdCxcbiAgICB0b2dnbGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFwR2FtZXBhZFRvWGJveDM2MENvbnRyb2xsZXIoZ2FtZXBhZCkge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChnYW1lcGFkLnZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgYTogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzBdLFxuICAgICAgICAgIGI6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxXSxcbiAgICAgICAgICB4OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMl0sXG4gICAgICAgICAgeTogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzNdXG4gICAgICAgIH0sXG4gICAgICAgIGJ1bXBlcjoge1xuICAgICAgICAgIGxlZnQ6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1s0XSxcbiAgICAgICAgICByaWdodDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzVdXG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgICAgbGVmdDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzZdLFxuICAgICAgICAgIHJpZ2h0OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbN11cbiAgICAgICAgfSxcbiAgICAgICAgc3RpY2s6IHtcbiAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICBob3Jpem9udGFsOiBnYW1lcGFkLnZhbHVlLmF4ZXNbMF0sXG4gICAgICAgICAgICB2ZXJ0aWNhbDogZ2FtZXBhZC52YWx1ZS5heGVzWzFdLFxuICAgICAgICAgICAgYnV0dG9uOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMTBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogZ2FtZXBhZC52YWx1ZS5heGVzWzJdLFxuICAgICAgICAgICAgdmVydGljYWw6IGdhbWVwYWQudmFsdWUuYXhlc1szXSxcbiAgICAgICAgICAgIGJ1dHRvbjogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzExXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZHBhZDoge1xuICAgICAgICAgIHVwOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMTJdLFxuICAgICAgICAgIGRvd246IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxM10sXG4gICAgICAgICAgbGVmdDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzE0XSxcbiAgICAgICAgICByaWdodDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzE1XVxuICAgICAgICB9LFxuICAgICAgICBiYWNrOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbOF0sXG4gICAgICAgIHN0YXJ0OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbOV1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUdhbWVwYWQob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJnZXRHYW1lcGFkc1wiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGdhbWVwYWRzID0gcmVmKFtdKTtcbiAgY29uc3Qgb25Db25uZWN0ZWRIb29rID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IG9uRGlzY29ubmVjdGVkSG9vayA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBzdGF0ZUZyb21HYW1lcGFkID0gKGdhbWVwYWQpID0+IHtcbiAgICBjb25zdCBoYXB0aWNBY3R1YXRvcnMgPSBbXTtcbiAgICBjb25zdCB2aWJyYXRpb25BY3R1YXRvciA9IFwidmlicmF0aW9uQWN0dWF0b3JcIiBpbiBnYW1lcGFkID8gZ2FtZXBhZC52aWJyYXRpb25BY3R1YXRvciA6IG51bGw7XG4gICAgaWYgKHZpYnJhdGlvbkFjdHVhdG9yKVxuICAgICAgaGFwdGljQWN0dWF0b3JzLnB1c2godmlicmF0aW9uQWN0dWF0b3IpO1xuICAgIGlmIChnYW1lcGFkLmhhcHRpY0FjdHVhdG9ycylcbiAgICAgIGhhcHRpY0FjdHVhdG9ycy5wdXNoKC4uLmdhbWVwYWQuaGFwdGljQWN0dWF0b3JzKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGdhbWVwYWQuaWQsXG4gICAgICBpbmRleDogZ2FtZXBhZC5pbmRleCxcbiAgICAgIGNvbm5lY3RlZDogZ2FtZXBhZC5jb25uZWN0ZWQsXG4gICAgICBtYXBwaW5nOiBnYW1lcGFkLm1hcHBpbmcsXG4gICAgICB0aW1lc3RhbXA6IGdhbWVwYWQudGltZXN0YW1wLFxuICAgICAgdmlicmF0aW9uQWN0dWF0b3I6IGdhbWVwYWQudmlicmF0aW9uQWN0dWF0b3IsXG4gICAgICBoYXB0aWNBY3R1YXRvcnMsXG4gICAgICBheGVzOiBnYW1lcGFkLmF4ZXMubWFwKChheGVzKSA9PiBheGVzKSxcbiAgICAgIGJ1dHRvbnM6IGdhbWVwYWQuYnV0dG9ucy5tYXAoKGJ1dHRvbikgPT4gKHsgcHJlc3NlZDogYnV0dG9uLnByZXNzZWQsIHRvdWNoZWQ6IGJ1dHRvbi50b3VjaGVkLCB2YWx1ZTogYnV0dG9uLnZhbHVlIH0pKVxuICAgIH07XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUdhbWVwYWRTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBfZ2FtZXBhZHMgPSAobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSkgfHwgW107XG4gICAgZm9yIChjb25zdCBnYW1lcGFkIG9mIF9nYW1lcGFkcykge1xuICAgICAgaWYgKGdhbWVwYWQgJiYgZ2FtZXBhZHMudmFsdWVbZ2FtZXBhZC5pbmRleF0pXG4gICAgICAgIGdhbWVwYWRzLnZhbHVlW2dhbWVwYWQuaW5kZXhdID0gc3RhdGVGcm9tR2FtZXBhZChnYW1lcGFkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHsgaXNBY3RpdmUsIHBhdXNlLCByZXN1bWUgfSA9IHVzZVJhZkZuKHVwZGF0ZUdhbWVwYWRTdGF0ZSk7XG4gIGNvbnN0IG9uR2FtZXBhZENvbm5lY3RlZCA9IChnYW1lcGFkKSA9PiB7XG4gICAgaWYgKCFnYW1lcGFkcy52YWx1ZS5zb21lKCh7IGluZGV4IH0pID0+IGluZGV4ID09PSBnYW1lcGFkLmluZGV4KSkge1xuICAgICAgZ2FtZXBhZHMudmFsdWUucHVzaChzdGF0ZUZyb21HYW1lcGFkKGdhbWVwYWQpKTtcbiAgICAgIG9uQ29ubmVjdGVkSG9vay50cmlnZ2VyKGdhbWVwYWQuaW5kZXgpO1xuICAgIH1cbiAgICByZXN1bWUoKTtcbiAgfTtcbiAgY29uc3Qgb25HYW1lcGFkRGlzY29ubmVjdGVkID0gKGdhbWVwYWQpID0+IHtcbiAgICBnYW1lcGFkcy52YWx1ZSA9IGdhbWVwYWRzLnZhbHVlLmZpbHRlcigoeCkgPT4geC5pbmRleCAhPT0gZ2FtZXBhZC5pbmRleCk7XG4gICAgb25EaXNjb25uZWN0ZWRIb29rLnRyaWdnZXIoZ2FtZXBhZC5pbmRleCk7XG4gIH07XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICB1c2VFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGNvbm5lY3RlZFwiLCAoZSkgPT4gb25HYW1lcGFkQ29ubmVjdGVkKGUuZ2FtZXBhZCksIGxpc3RlbmVyT3B0aW9ucyk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsIChlKSA9PiBvbkdhbWVwYWREaXNjb25uZWN0ZWQoZS5nYW1lcGFkKSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdHJ5T25Nb3VudGVkKCgpID0+IHtcbiAgICBjb25zdCBfZ2FtZXBhZHMgPSAobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSkgfHwgW107XG4gICAgZm9yIChjb25zdCBnYW1lcGFkIG9mIF9nYW1lcGFkcykge1xuICAgICAgaWYgKGdhbWVwYWQgJiYgZ2FtZXBhZHMudmFsdWVbZ2FtZXBhZC5pbmRleF0pXG4gICAgICAgIG9uR2FtZXBhZENvbm5lY3RlZChnYW1lcGFkKTtcbiAgICB9XG4gIH0pO1xuICBwYXVzZSgpO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIG9uQ29ubmVjdGVkOiBvbkNvbm5lY3RlZEhvb2sub24sXG4gICAgb25EaXNjb25uZWN0ZWQ6IG9uRGlzY29ubmVjdGVkSG9vay5vbixcbiAgICBnYW1lcGFkcyxcbiAgICBwYXVzZSxcbiAgICByZXN1bWUsXG4gICAgaXNBY3RpdmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlR2VvbG9jYXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVIaWdoQWNjdXJhY3kgPSB0cnVlLFxuICAgIG1heGltdW1BZ2UgPSAzZTQsXG4gICAgdGltZW91dCA9IDI3ZTMsXG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICBpbW1lZGlhdGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJnZW9sb2NhdGlvblwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGxvY2F0ZWRBdCA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgY29vcmRzID0gcmVmKHtcbiAgICBhY2N1cmFjeTogMCxcbiAgICBsYXRpdHVkZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGxvbmdpdHVkZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGFsdGl0dWRlOiBudWxsLFxuICAgIGFsdGl0dWRlQWNjdXJhY3k6IG51bGwsXG4gICAgaGVhZGluZzogbnVsbCxcbiAgICBzcGVlZDogbnVsbFxuICB9KTtcbiAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBsb2NhdGVkQXQudmFsdWUgPSBwb3NpdGlvbi50aW1lc3RhbXA7XG4gICAgY29vcmRzLnZhbHVlID0gcG9zaXRpb24uY29vcmRzO1xuICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgfVxuICBsZXQgd2F0Y2hlcjtcbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgICAgd2F0Y2hlciA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKFxuICAgICAgICB1cGRhdGVQb3NpdGlvbixcbiAgICAgICAgKGVycikgPT4gZXJyb3IudmFsdWUgPSBlcnIsXG4gICAgICAgIHtcbiAgICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3ksXG4gICAgICAgICAgbWF4aW11bUFnZSxcbiAgICAgICAgICB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgcmVzdW1lKCk7XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmICh3YXRjaGVyICYmIG5hdmlnYXRvcilcbiAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHdhdGNoZXIpO1xuICB9XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBwYXVzZSgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBjb29yZHMsXG4gICAgbG9jYXRlZEF0LFxuICAgIGVycm9yLFxuICAgIHJlc3VtZSxcbiAgICBwYXVzZVxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0RXZlbnRzJDEgPSBbXCJtb3VzZW1vdmVcIiwgXCJtb3VzZWRvd25cIiwgXCJyZXNpemVcIiwgXCJrZXlkb3duXCIsIFwidG91Y2hzdGFydFwiLCBcIndoZWVsXCJdO1xuY29uc3Qgb25lTWludXRlID0gNmU0O1xuZnVuY3Rpb24gdXNlSWRsZSh0aW1lb3V0ID0gb25lTWludXRlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGluaXRpYWxTdGF0ZSA9IGZhbHNlLFxuICAgIGxpc3RlbkZvclZpc2liaWxpdHlDaGFuZ2UgPSB0cnVlLFxuICAgIGV2ZW50cyA9IGRlZmF1bHRFdmVudHMkMSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGV2ZW50RmlsdGVyID0gdGhyb3R0bGVGaWx0ZXIoNTApXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpZGxlID0gc2hhbGxvd1JlZihpbml0aWFsU3RhdGUpO1xuICBjb25zdCBsYXN0QWN0aXZlID0gc2hhbGxvd1JlZih0aW1lc3RhbXAoKSk7XG4gIGxldCB0aW1lcjtcbiAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgaWRsZS52YWx1ZSA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGlkbGUudmFsdWUgPSB0cnVlLCB0aW1lb3V0KTtcbiAgfTtcbiAgY29uc3Qgb25FdmVudCA9IGNyZWF0ZUZpbHRlcldyYXBwZXIoXG4gICAgZXZlbnRGaWx0ZXIsXG4gICAgKCkgPT4ge1xuICAgICAgbGFzdEFjdGl2ZS52YWx1ZSA9IHRpbWVzdGFtcCgpO1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gICk7XG4gIGlmICh3aW5kb3cpIHtcbiAgICBjb25zdCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cylcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBldmVudCwgb25FdmVudCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICBpZiAobGlzdGVuRm9yVmlzaWJpbGl0eUNoYW5nZSkge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pXG4gICAgICAgICAgb25FdmVudCgpO1xuICAgICAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKCFpbml0aWFsU3RhdGUpXG4gICAgICByZXNldCgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWRsZSxcbiAgICBsYXN0QWN0aXZlLFxuICAgIHJlc2V0XG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgY29uc3QgeyBzcmMsIHNyY3NldCwgc2l6ZXMsIGNsYXNzOiBjbGF6eiwgbG9hZGluZywgY3Jvc3NvcmlnaW4sIHJlZmVycmVyUG9saWN5LCB3aWR0aCwgaGVpZ2h0LCBkZWNvZGluZywgZmV0Y2hQcmlvcml0eSwgaXNtYXAsIHVzZW1hcCB9ID0gb3B0aW9ucztcbiAgICBpbWcuc3JjID0gc3JjO1xuICAgIGlmIChzcmNzZXQgIT0gbnVsbClcbiAgICAgIGltZy5zcmNzZXQgPSBzcmNzZXQ7XG4gICAgaWYgKHNpemVzICE9IG51bGwpXG4gICAgICBpbWcuc2l6ZXMgPSBzaXplcztcbiAgICBpZiAoY2xhenogIT0gbnVsbClcbiAgICAgIGltZy5jbGFzc05hbWUgPSBjbGF6ejtcbiAgICBpZiAobG9hZGluZyAhPSBudWxsKVxuICAgICAgaW1nLmxvYWRpbmcgPSBsb2FkaW5nO1xuICAgIGlmIChjcm9zc29yaWdpbiAhPSBudWxsKVxuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NvcmlnaW47XG4gICAgaWYgKHJlZmVycmVyUG9saWN5ICE9IG51bGwpXG4gICAgICBpbWcucmVmZXJyZXJQb2xpY3kgPSByZWZlcnJlclBvbGljeTtcbiAgICBpZiAod2lkdGggIT0gbnVsbClcbiAgICAgIGltZy53aWR0aCA9IHdpZHRoO1xuICAgIGlmIChoZWlnaHQgIT0gbnVsbClcbiAgICAgIGltZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKGRlY29kaW5nICE9IG51bGwpXG4gICAgICBpbWcuZGVjb2RpbmcgPSBkZWNvZGluZztcbiAgICBpZiAoZmV0Y2hQcmlvcml0eSAhPSBudWxsKVxuICAgICAgaW1nLmZldGNoUHJpb3JpdHkgPSBmZXRjaFByaW9yaXR5O1xuICAgIGlmIChpc21hcCAhPSBudWxsKVxuICAgICAgaW1nLmlzTWFwID0gaXNtYXA7XG4gICAgaWYgKHVzZW1hcCAhPSBudWxsKVxuICAgICAgaW1nLnVzZU1hcCA9IHVzZW1hcDtcbiAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZShpbWcpO1xuICAgIGltZy5vbmVycm9yID0gcmVqZWN0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUltYWdlKG9wdGlvbnMsIGFzeW5jU3RhdGVPcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VBc3luY1N0YXRlKFxuICAgICgpID0+IGxvYWRJbWFnZSh0b1ZhbHVlKG9wdGlvbnMpKSxcbiAgICB2b2lkIDAsXG4gICAge1xuICAgICAgcmVzZXRPbkV4ZWN1dGU6IHRydWUsXG4gICAgICAuLi5hc3luY1N0YXRlT3B0aW9uc1xuICAgIH1cbiAgKTtcbiAgd2F0Y2goXG4gICAgKCkgPT4gdG9WYWx1ZShvcHRpb25zKSxcbiAgICAoKSA9PiBzdGF0ZS5leGVjdXRlKGFzeW5jU3RhdGVPcHRpb25zLmRlbGF5KSxcbiAgICB7IGRlZXA6IHRydWUgfVxuICApO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVFbGVtZW50KGVsKSB7XG4gIGlmICh0eXBlb2YgV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGVsIGluc3RhbmNlb2YgV2luZG93KVxuICAgIHJldHVybiBlbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmICh0eXBlb2YgRG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZWwgaW5zdGFuY2VvZiBEb2N1bWVudClcbiAgICByZXR1cm4gZWwuZG9jdW1lbnRFbGVtZW50O1xuICByZXR1cm4gZWw7XG59XG5cbmNvbnN0IEFSUklWRURfU1RBVEVfVEhSRVNIT0xEX1BJWEVMUyA9IDE7XG5mdW5jdGlvbiB1c2VTY3JvbGwoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0aHJvdHRsZSA9IDAsXG4gICAgaWRsZSA9IDIwMCxcbiAgICBvblN0b3AgPSBub29wLFxuICAgIG9uU2Nyb2xsID0gbm9vcCxcbiAgICBvZmZzZXQgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LFxuICAgIG9ic2VydmU6IF9vYnNlcnZlID0ge1xuICAgICAgbXV0YXRpb246IGZhbHNlXG4gICAgfSxcbiAgICBldmVudExpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0sXG4gICAgYmVoYXZpb3IgPSBcImF1dG9cIixcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIG9uRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBvYnNlcnZlID0gdHlwZW9mIF9vYnNlcnZlID09PSBcImJvb2xlYW5cIiA/IHtcbiAgICBtdXRhdGlvbjogX29ic2VydmVcbiAgfSA6IF9vYnNlcnZlO1xuICBjb25zdCBpbnRlcm5hbFggPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBpbnRlcm5hbFkgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCB4ID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbFgudmFsdWU7XG4gICAgfSxcbiAgICBzZXQoeDIpIHtcbiAgICAgIHNjcm9sbFRvKHgyLCB2b2lkIDApO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHkgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGludGVybmFsWS52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh5Mikge1xuICAgICAgc2Nyb2xsVG8odm9pZCAwLCB5Mik7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gc2Nyb2xsVG8oX3gsIF95KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IF9lbGVtZW50ID0gdG9WYWx1ZShlbGVtZW50KTtcbiAgICBpZiAoIV9lbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIChfYyA9IF9lbGVtZW50IGluc3RhbmNlb2YgRG9jdW1lbnQgPyB3aW5kb3cuZG9jdW1lbnQuYm9keSA6IF9lbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2Nyb2xsVG8oe1xuICAgICAgdG9wOiAoX2EgPSB0b1ZhbHVlKF95KSkgIT0gbnVsbCA/IF9hIDogeS52YWx1ZSxcbiAgICAgIGxlZnQ6IChfYiA9IHRvVmFsdWUoX3gpKSAhPSBudWxsID8gX2IgOiB4LnZhbHVlLFxuICAgICAgYmVoYXZpb3I6IHRvVmFsdWUoYmVoYXZpb3IpXG4gICAgfSk7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gKChfZCA9IF9lbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudC5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmRvY3VtZW50RWxlbWVudCkgfHwgKF9lbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudC5kb2N1bWVudEVsZW1lbnQpIHx8IF9lbGVtZW50O1xuICAgIGlmICh4ICE9IG51bGwpXG4gICAgICBpbnRlcm5hbFgudmFsdWUgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICBpZiAoeSAhPSBudWxsKVxuICAgICAgaW50ZXJuYWxZLnZhbHVlID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgfVxuICBjb25zdCBpc1Njcm9sbGluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBhcnJpdmVkU3RhdGUgPSByZWFjdGl2ZSh7XG4gICAgbGVmdDogdHJ1ZSxcbiAgICByaWdodDogZmFsc2UsXG4gICAgdG9wOiB0cnVlLFxuICAgIGJvdHRvbTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGRpcmVjdGlvbnMgPSByZWFjdGl2ZSh7XG4gICAgbGVmdDogZmFsc2UsXG4gICAgcmlnaHQ6IGZhbHNlLFxuICAgIHRvcDogZmFsc2UsXG4gICAgYm90dG9tOiBmYWxzZVxuICB9KTtcbiAgY29uc3Qgb25TY3JvbGxFbmQgPSAoZSkgPT4ge1xuICAgIGlmICghaXNTY3JvbGxpbmcudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaXNTY3JvbGxpbmcudmFsdWUgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLmxlZnQgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLnJpZ2h0ID0gZmFsc2U7XG4gICAgZGlyZWN0aW9ucy50b3AgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLmJvdHRvbSA9IGZhbHNlO1xuICAgIG9uU3RvcChlKTtcbiAgfTtcbiAgY29uc3Qgb25TY3JvbGxFbmREZWJvdW5jZWQgPSB1c2VEZWJvdW5jZUZuKG9uU2Nyb2xsRW5kLCB0aHJvdHRsZSArIGlkbGUpO1xuICBjb25zdCBzZXRBcnJpdmVkU3RhdGUgPSAodGFyZ2V0KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsID0gKChfYSA9IHRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZG9jdW1lbnRFbGVtZW50KSB8fCAodGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQuZG9jdW1lbnRFbGVtZW50KSB8fCB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBjb25zdCB7IGRpc3BsYXksIGZsZXhEaXJlY3Rpb24sIGRpcmVjdGlvbiB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgY29uc3QgZGlyZWN0aW9uTXVsdGlwbGVyID0gZGlyZWN0aW9uID09PSBcInJ0bFwiID8gLTEgOiAxO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgIGRpcmVjdGlvbnMubGVmdCA9IHNjcm9sbExlZnQgPCBpbnRlcm5hbFgudmFsdWU7XG4gICAgZGlyZWN0aW9ucy5yaWdodCA9IHNjcm9sbExlZnQgPiBpbnRlcm5hbFgudmFsdWU7XG4gICAgY29uc3QgbGVmdCA9IE1hdGguYWJzKHNjcm9sbExlZnQgKiBkaXJlY3Rpb25NdWx0aXBsZXIpIDw9IChvZmZzZXQubGVmdCB8fCAwKTtcbiAgICBjb25zdCByaWdodCA9IE1hdGguYWJzKHNjcm9sbExlZnQgKiBkaXJlY3Rpb25NdWx0aXBsZXIpICsgZWwuY2xpZW50V2lkdGggPj0gZWwuc2Nyb2xsV2lkdGggLSAob2Zmc2V0LnJpZ2h0IHx8IDApIC0gQVJSSVZFRF9TVEFURV9USFJFU0hPTERfUElYRUxTO1xuICAgIGlmIChkaXNwbGF5ID09PSBcImZsZXhcIiAmJiBmbGV4RGlyZWN0aW9uID09PSBcInJvdy1yZXZlcnNlXCIpIHtcbiAgICAgIGFycml2ZWRTdGF0ZS5sZWZ0ID0gcmlnaHQ7XG4gICAgICBhcnJpdmVkU3RhdGUucmlnaHQgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJpdmVkU3RhdGUubGVmdCA9IGxlZnQ7XG4gICAgICBhcnJpdmVkU3RhdGUucmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgaW50ZXJuYWxYLnZhbHVlID0gc2Nyb2xsTGVmdDtcbiAgICBsZXQgc2Nyb2xsVG9wID0gZWwuc2Nyb2xsVG9wO1xuICAgIGlmICh0YXJnZXQgPT09IHdpbmRvdy5kb2N1bWVudCAmJiAhc2Nyb2xsVG9wKVxuICAgICAgc2Nyb2xsVG9wID0gd2luZG93LmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgIGRpcmVjdGlvbnMudG9wID0gc2Nyb2xsVG9wIDwgaW50ZXJuYWxZLnZhbHVlO1xuICAgIGRpcmVjdGlvbnMuYm90dG9tID0gc2Nyb2xsVG9wID4gaW50ZXJuYWxZLnZhbHVlO1xuICAgIGNvbnN0IHRvcCA9IE1hdGguYWJzKHNjcm9sbFRvcCkgPD0gKG9mZnNldC50b3AgfHwgMCk7XG4gICAgY29uc3QgYm90dG9tID0gTWF0aC5hYnMoc2Nyb2xsVG9wKSArIGVsLmNsaWVudEhlaWdodCA+PSBlbC5zY3JvbGxIZWlnaHQgLSAob2Zmc2V0LmJvdHRvbSB8fCAwKSAtIEFSUklWRURfU1RBVEVfVEhSRVNIT0xEX1BJWEVMUztcbiAgICBpZiAoZGlzcGxheSA9PT0gXCJmbGV4XCIgJiYgZmxleERpcmVjdGlvbiA9PT0gXCJjb2x1bW4tcmV2ZXJzZVwiKSB7XG4gICAgICBhcnJpdmVkU3RhdGUudG9wID0gYm90dG9tO1xuICAgICAgYXJyaXZlZFN0YXRlLmJvdHRvbSA9IHRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyaXZlZFN0YXRlLnRvcCA9IHRvcDtcbiAgICAgIGFycml2ZWRTdGF0ZS5ib3R0b20gPSBib3R0b207XG4gICAgfVxuICAgIGludGVybmFsWS52YWx1ZSA9IHNjcm9sbFRvcDtcbiAgfTtcbiAgY29uc3Qgb25TY3JvbGxIYW5kbGVyID0gKGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF3aW5kb3cpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXZlbnRUYXJnZXQgPSAoX2EgPSBlLnRhcmdldC5kb2N1bWVudEVsZW1lbnQpICE9IG51bGwgPyBfYSA6IGUudGFyZ2V0O1xuICAgIHNldEFycml2ZWRTdGF0ZShldmVudFRhcmdldCk7XG4gICAgaXNTY3JvbGxpbmcudmFsdWUgPSB0cnVlO1xuICAgIG9uU2Nyb2xsRW5kRGVib3VuY2VkKGUpO1xuICAgIG9uU2Nyb2xsKGUpO1xuICB9O1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIGVsZW1lbnQsXG4gICAgXCJzY3JvbGxcIixcbiAgICB0aHJvdHRsZSA/IHVzZVRocm90dGxlRm4ob25TY3JvbGxIYW5kbGVyLCB0aHJvdHRsZSwgdHJ1ZSwgZmFsc2UpIDogb25TY3JvbGxIYW5kbGVyLFxuICAgIGV2ZW50TGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IF9lbGVtZW50ID0gdG9WYWx1ZShlbGVtZW50KTtcbiAgICAgIGlmICghX2VsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHNldEFycml2ZWRTdGF0ZShfZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoKG9ic2VydmUgPT0gbnVsbCA/IHZvaWQgMCA6IG9ic2VydmUubXV0YXRpb24pICYmIGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50ICE9PSB3aW5kb3cgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICB1c2VNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgZWxlbWVudCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgX2VsZW1lbnQgPSB0b1ZhbHVlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoIV9lbGVtZW50KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0QXJyaXZlZFN0YXRlKF9lbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICBlbGVtZW50LFxuICAgIFwic2Nyb2xsZW5kXCIsXG4gICAgb25TY3JvbGxFbmQsXG4gICAgZXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgaXNTY3JvbGxpbmcsXG4gICAgYXJyaXZlZFN0YXRlLFxuICAgIGRpcmVjdGlvbnMsXG4gICAgbWVhc3VyZSgpIHtcbiAgICAgIGNvbnN0IF9lbGVtZW50ID0gdG9WYWx1ZShlbGVtZW50KTtcbiAgICAgIGlmICh3aW5kb3cgJiYgX2VsZW1lbnQpXG4gICAgICAgIHNldEFycml2ZWRTdGF0ZShfZWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VJbmZpbml0ZVNjcm9sbChlbGVtZW50LCBvbkxvYWRNb3JlLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uID0gXCJib3R0b21cIixcbiAgICBpbnRlcnZhbCA9IDEwMCxcbiAgICBjYW5Mb2FkTW9yZSA9ICgpID0+IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHN0YXRlID0gcmVhY3RpdmUodXNlU2Nyb2xsKFxuICAgIGVsZW1lbnQsXG4gICAge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICBbZGlyZWN0aW9uXTogKF9hID0gb3B0aW9ucy5kaXN0YW5jZSkgIT0gbnVsbCA/IF9hIDogMCxcbiAgICAgICAgLi4ub3B0aW9ucy5vZmZzZXRcbiAgICAgIH1cbiAgICB9XG4gICkpO1xuICBjb25zdCBwcm9taXNlID0gcmVmKCk7XG4gIGNvbnN0IGlzTG9hZGluZyA9IGNvbXB1dGVkKCgpID0+ICEhcHJvbWlzZS52YWx1ZSk7XG4gIGNvbnN0IG9ic2VydmVkRWxlbWVudCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gcmVzb2x2ZUVsZW1lbnQodG9WYWx1ZShlbGVtZW50KSk7XG4gIH0pO1xuICBjb25zdCBpc0VsZW1lbnRWaXNpYmxlID0gdXNlRWxlbWVudFZpc2liaWxpdHkob2JzZXJ2ZWRFbGVtZW50KTtcbiAgZnVuY3Rpb24gY2hlY2tBbmRMb2FkKCkge1xuICAgIHN0YXRlLm1lYXN1cmUoKTtcbiAgICBpZiAoIW9ic2VydmVkRWxlbWVudC52YWx1ZSB8fCAhaXNFbGVtZW50VmlzaWJsZS52YWx1ZSB8fCAhY2FuTG9hZE1vcmUob2JzZXJ2ZWRFbGVtZW50LnZhbHVlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0LCBzY3JvbGxXaWR0aCwgY2xpZW50V2lkdGggfSA9IG9ic2VydmVkRWxlbWVudC52YWx1ZTtcbiAgICBjb25zdCBpc05hcnJvd2VyID0gZGlyZWN0aW9uID09PSBcImJvdHRvbVwiIHx8IGRpcmVjdGlvbiA9PT0gXCJ0b3BcIiA/IHNjcm9sbEhlaWdodCA8PSBjbGllbnRIZWlnaHQgOiBzY3JvbGxXaWR0aCA8PSBjbGllbnRXaWR0aDtcbiAgICBpZiAoc3RhdGUuYXJyaXZlZFN0YXRlW2RpcmVjdGlvbl0gfHwgaXNOYXJyb3dlcikge1xuICAgICAgaWYgKCFwcm9taXNlLnZhbHVlKSB7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgb25Mb2FkTW9yZShzdGF0ZSksXG4gICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwpKVxuICAgICAgICBdKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICBuZXh0VGljaygoKSA9PiBjaGVja0FuZExvYWQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdG9wID0gd2F0Y2goXG4gICAgKCkgPT4gW3N0YXRlLmFycml2ZWRTdGF0ZVtkaXJlY3Rpb25dLCBpc0VsZW1lbnRWaXNpYmxlLnZhbHVlXSxcbiAgICBjaGVja0FuZExvYWQsXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICB0cnlPblVubW91bnRlZChzdG9wKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmcsXG4gICAgcmVzZXQoKSB7XG4gICAgICBuZXh0VGljaygoKSA9PiBjaGVja0FuZExvYWQoKSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0RXZlbnRzID0gW1wibW91c2Vkb3duXCIsIFwibW91c2V1cFwiLCBcImtleWRvd25cIiwgXCJrZXl1cFwiXTtcbmZ1bmN0aW9uIHVzZUtleU1vZGlmaWVyKG1vZGlmaWVyLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGV2ZW50cyA9IGRlZmF1bHRFdmVudHMsXG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgaW5pdGlhbCA9IG51bGxcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHN0YXRlID0gc2hhbGxvd1JlZihpbml0aWFsKTtcbiAgaWYgKGRvY3VtZW50KSB7XG4gICAgZXZlbnRzLmZvckVhY2goKGxpc3RlbmVyRXZlbnQpID0+IHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIGxpc3RlbmVyRXZlbnQsIChldnQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBldnQuZ2V0TW9kaWZpZXJTdGF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHN0YXRlLnZhbHVlID0gZXZ0LmdldE1vZGlmaWVyU3RhdGUobW9kaWZpZXIpO1xuICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gdXNlTG9jYWxTdG9yYWdlKGtleSwgaW5pdGlhbFZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICByZXR1cm4gdXNlU3RvcmFnZShrZXksIGluaXRpYWxWYWx1ZSwgd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubG9jYWxTdG9yYWdlLCBvcHRpb25zKTtcbn1cblxuY29uc3QgRGVmYXVsdE1hZ2ljS2V5c0FsaWFzTWFwID0ge1xuICBjdHJsOiBcImNvbnRyb2xcIixcbiAgY29tbWFuZDogXCJtZXRhXCIsXG4gIGNtZDogXCJtZXRhXCIsXG4gIG9wdGlvbjogXCJhbHRcIixcbiAgdXA6IFwiYXJyb3d1cFwiLFxuICBkb3duOiBcImFycm93ZG93blwiLFxuICBsZWZ0OiBcImFycm93bGVmdFwiLFxuICByaWdodDogXCJhcnJvd3JpZ2h0XCJcbn07XG5cbmZ1bmN0aW9uIHVzZU1hZ2ljS2V5cyhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHJlYWN0aXZlOiB1c2VSZWFjdGl2ZSA9IGZhbHNlLFxuICAgIHRhcmdldCA9IGRlZmF1bHRXaW5kb3csXG4gICAgYWxpYXNNYXAgPSBEZWZhdWx0TWFnaWNLZXlzQWxpYXNNYXAsXG4gICAgcGFzc2l2ZSA9IHRydWUsXG4gICAgb25FdmVudEZpcmVkID0gbm9vcFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY3VycmVudCA9IHJlYWN0aXZlKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICBjb25zdCBvYmogPSB7XG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgY3VycmVudFxuICB9O1xuICBjb25zdCByZWZzID0gdXNlUmVhY3RpdmUgPyByZWFjdGl2ZShvYmopIDogb2JqO1xuICBjb25zdCBtZXRhRGVwcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHNoaWZ0RGVwcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHVzZWRLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gc2V0UmVmcyhrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiByZWZzKSB7XG4gICAgICBpZiAodXNlUmVhY3RpdmUpXG4gICAgICAgIHJlZnNba2V5XSA9IHZhbHVlO1xuICAgICAgZWxzZVxuICAgICAgICByZWZzW2tleV0udmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY3VycmVudC5jbGVhcigpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHVzZWRLZXlzKVxuICAgICAgc2V0UmVmcyhrZXksIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSZWZzKGUsIHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBrZXkgPSAoX2EgPSBlLmtleSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29kZSA9IChfYiA9IGUuY29kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdmFsdWVzID0gW2NvZGUsIGtleV0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgY3VycmVudC5hZGQoa2V5KTtcbiAgICAgIGVsc2VcbiAgICAgICAgY3VycmVudC5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkyIG9mIHZhbHVlcykge1xuICAgICAgdXNlZEtleXMuYWRkKGtleTIpO1xuICAgICAgc2V0UmVmcyhrZXkyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwic2hpZnRcIiAmJiAhdmFsdWUpIHtcbiAgICAgIHNoaWZ0RGVwcy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICAgIGN1cnJlbnQuZGVsZXRlKGtleTIpO1xuICAgICAgICBzZXRSZWZzKGtleTIsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgc2hpZnREZXBzLmNsZWFyKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZS5nZXRNb2RpZmllclN0YXRlID09PSBcImZ1bmN0aW9uXCIgJiYgZS5nZXRNb2RpZmllclN0YXRlKFwiU2hpZnRcIikgJiYgdmFsdWUpIHtcbiAgICAgIFsuLi5jdXJyZW50LCAuLi52YWx1ZXNdLmZvckVhY2goKGtleTIpID0+IHNoaWZ0RGVwcy5hZGQoa2V5MikpO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSBcIm1ldGFcIiAmJiAhdmFsdWUpIHtcbiAgICAgIG1ldGFEZXBzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgICAgY3VycmVudC5kZWxldGUoa2V5Mik7XG4gICAgICAgIHNldFJlZnMoa2V5MiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICBtZXRhRGVwcy5jbGVhcigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGUuZ2V0TW9kaWZpZXJTdGF0ZSA9PT0gXCJmdW5jdGlvblwiICYmIGUuZ2V0TW9kaWZpZXJTdGF0ZShcIk1ldGFcIikgJiYgdmFsdWUpIHtcbiAgICAgIFsuLi5jdXJyZW50LCAuLi52YWx1ZXNdLmZvckVhY2goKGtleTIpID0+IG1ldGFEZXBzLmFkZChrZXkyKSk7XG4gICAgfVxuICB9XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICB1cGRhdGVSZWZzKGUsIHRydWUpO1xuICAgIHJldHVybiBvbkV2ZW50RmlyZWQoZSk7XG4gIH0sIHsgcGFzc2l2ZSB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwia2V5dXBcIiwgKGUpID0+IHtcbiAgICB1cGRhdGVSZWZzKGUsIGZhbHNlKTtcbiAgICByZXR1cm4gb25FdmVudEZpcmVkKGUpO1xuICB9LCB7IHBhc3NpdmUgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHJlc2V0LCB7IHBhc3NpdmUgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCByZXNldCwgeyBwYXNzaXZlIH0pO1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShcbiAgICByZWZzLFxuICAgIHtcbiAgICAgIGdldCh0YXJnZXQyLCBwcm9wLCByZWMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQyLCBwcm9wLCByZWMpO1xuICAgICAgICBwcm9wID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocHJvcCBpbiBhbGlhc01hcClcbiAgICAgICAgICBwcm9wID0gYWxpYXNNYXBbcHJvcF07XG4gICAgICAgIGlmICghKHByb3AgaW4gcmVmcykpIHtcbiAgICAgICAgICBpZiAoL1srXy1dLy50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gcHJvcC5zcGxpdCgvWytfLV0vZykubWFwKChpKSA9PiBpLnRyaW0oKSk7XG4gICAgICAgICAgICByZWZzW3Byb3BdID0gY29tcHV0ZWQoKCkgPT4ga2V5cy5tYXAoKGtleSkgPT4gdG9WYWx1ZShwcm94eVtrZXldKSkuZXZlcnkoQm9vbGVhbikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWZzW3Byb3BdID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBSZWZsZWN0LmdldCh0YXJnZXQyLCBwcm9wLCByZWMpO1xuICAgICAgICByZXR1cm4gdXNlUmVhY3RpdmUgPyB0b1ZhbHVlKHIpIDogcjtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiBwcm94eTtcbn1cblxuZnVuY3Rpb24gdXNpbmdFbFJlZihzb3VyY2UsIGNiKSB7XG4gIGlmICh0b1ZhbHVlKHNvdXJjZSkpXG4gICAgY2IodG9WYWx1ZShzb3VyY2UpKTtcbn1cbmZ1bmN0aW9uIHRpbWVSYW5nZVRvQXJyYXkodGltZVJhbmdlcykge1xuICBsZXQgcmFuZ2VzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlcy5sZW5ndGg7ICsraSlcbiAgICByYW5nZXMgPSBbLi4ucmFuZ2VzLCBbdGltZVJhbmdlcy5zdGFydChpKSwgdGltZVJhbmdlcy5lbmQoaSldXTtcbiAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIHRyYWNrc1RvQXJyYXkodHJhY2tzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRyYWNrcykubWFwKCh7IGxhYmVsLCBraW5kLCBsYW5ndWFnZSwgbW9kZSwgYWN0aXZlQ3VlcywgY3VlcywgaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZSB9LCBpZCkgPT4gKHsgaWQsIGxhYmVsLCBraW5kLCBsYW5ndWFnZSwgbW9kZSwgYWN0aXZlQ3VlcywgY3VlcywgaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZSB9KSk7XG59XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3JjOiBcIlwiLFxuICB0cmFja3M6IFtdXG59O1xuZnVuY3Rpb24gdXNlTWVkaWFDb250cm9scyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICB0YXJnZXQgPSB0b1JlZih0YXJnZXQpO1xuICBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBkdXJhdGlvbiA9IHNoYWxsb3dSZWYoMCk7XG4gIGNvbnN0IHNlZWtpbmcgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3Qgdm9sdW1lID0gc2hhbGxvd1JlZigxKTtcbiAgY29uc3Qgd2FpdGluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBlbmRlZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBwbGF5aW5nID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHJhdGUgPSBzaGFsbG93UmVmKDEpO1xuICBjb25zdCBzdGFsbGVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGJ1ZmZlcmVkID0gcmVmKFtdKTtcbiAgY29uc3QgdHJhY2tzID0gcmVmKFtdKTtcbiAgY29uc3Qgc2VsZWN0ZWRUcmFjayA9IHNoYWxsb3dSZWYoLTEpO1xuICBjb25zdCBpc1BpY3R1cmVJblBpY3R1cmUgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgbXV0ZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3Qgc3VwcG9ydHNQaWN0dXJlSW5QaWN0dXJlID0gZG9jdW1lbnQgJiYgXCJwaWN0dXJlSW5QaWN0dXJlRW5hYmxlZFwiIGluIGRvY3VtZW50O1xuICBjb25zdCBzb3VyY2VFcnJvckV2ZW50ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IHBsYXliYWNrRXJyb3JFdmVudCA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBkaXNhYmxlVHJhY2sgPSAodHJhY2spID0+IHtcbiAgICB1c2luZ0VsUmVmKHRhcmdldCwgKGVsKSA9PiB7XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSB0eXBlb2YgdHJhY2sgPT09IFwibnVtYmVyXCIgPyB0cmFjayA6IHRyYWNrLmlkO1xuICAgICAgICBlbC50ZXh0VHJhY2tzW2lkXS5tb2RlID0gXCJkaXNhYmxlZFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbC50ZXh0VHJhY2tzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGVsLnRleHRUcmFja3NbaV0ubW9kZSA9IFwiZGlzYWJsZWRcIjtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkVHJhY2sudmFsdWUgPSAtMTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZW5hYmxlVHJhY2sgPSAodHJhY2ssIGRpc2FibGVUcmFja3MgPSB0cnVlKSA9PiB7XG4gICAgdXNpbmdFbFJlZih0YXJnZXQsIChlbCkgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0eXBlb2YgdHJhY2sgPT09IFwibnVtYmVyXCIgPyB0cmFjayA6IHRyYWNrLmlkO1xuICAgICAgaWYgKGRpc2FibGVUcmFja3MpXG4gICAgICAgIGRpc2FibGVUcmFjaygpO1xuICAgICAgZWwudGV4dFRyYWNrc1tpZF0ubW9kZSA9IFwic2hvd2luZ1wiO1xuICAgICAgc2VsZWN0ZWRUcmFjay52YWx1ZSA9IGlkO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCB0b2dnbGVQaWN0dXJlSW5QaWN0dXJlID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1c2luZ0VsUmVmKHRhcmdldCwgYXN5bmMgKGVsKSA9PiB7XG4gICAgICAgIGlmIChzdXBwb3J0c1BpY3R1cmVJblBpY3R1cmUpIHtcbiAgICAgICAgICBpZiAoIWlzUGljdHVyZUluUGljdHVyZS52YWx1ZSkge1xuICAgICAgICAgICAgZWwucmVxdWVzdFBpY3R1cmVJblBpY3R1cmUoKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRQaWN0dXJlSW5QaWN0dXJlKCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc3JjID0gdG9WYWx1ZShvcHRpb25zLnNyYyk7XG4gICAgbGV0IHNvdXJjZXMgPSBbXTtcbiAgICBpZiAoIXNyYylcbiAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHNvdXJjZXMgPSBbeyBzcmMgfV07XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgc291cmNlcyA9IHNyYztcbiAgICBlbHNlIGlmIChpc09iamVjdChzcmMpKVxuICAgICAgc291cmNlcyA9IFtzcmNdO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIikuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgICBzb3VyY2VzLmZvckVhY2goKHsgc3JjOiBzcmMyLCB0eXBlLCBtZWRpYSB9KSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuICAgICAgc291cmNlLnNldEF0dHJpYnV0ZShcInNyY1wiLCBzcmMyKTtcbiAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHR5cGUgfHwgXCJcIik7XG4gICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEgfHwgXCJcIik7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKHNvdXJjZSwgXCJlcnJvclwiLCBzb3VyY2VFcnJvckV2ZW50LnRyaWdnZXIsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgICBlbC5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICAgIH0pO1xuICAgIGVsLmxvYWQoKTtcbiAgfSk7XG4gIHdhdGNoKFt0YXJnZXQsIHZvbHVtZV0sICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLnZvbHVtZSA9IHZvbHVtZS52YWx1ZTtcbiAgfSk7XG4gIHdhdGNoKFt0YXJnZXQsIG11dGVkXSwgKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgZWwubXV0ZWQgPSBtdXRlZC52YWx1ZTtcbiAgfSk7XG4gIHdhdGNoKFt0YXJnZXQsIHJhdGVdLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC5wbGF5YmFja1JhdGUgPSByYXRlLnZhbHVlO1xuICB9KTtcbiAgd2F0Y2hFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZG9jdW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IHRvVmFsdWUob3B0aW9ucy50cmFja3MpO1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghdGV4dFRyYWNrcyB8fCAhdGV4dFRyYWNrcy5sZW5ndGggfHwgIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0cmFja1wiKS5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZSgpKTtcbiAgICB0ZXh0VHJhY2tzLmZvckVhY2goKHsgZGVmYXVsdDogaXNEZWZhdWx0LCBraW5kLCBsYWJlbCwgc3JjLCBzcmNMYW5nIH0sIGkpID0+IHtcbiAgICAgIGNvbnN0IHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyYWNrXCIpO1xuICAgICAgdHJhY2suZGVmYXVsdCA9IGlzRGVmYXVsdCB8fCBmYWxzZTtcbiAgICAgIHRyYWNrLmtpbmQgPSBraW5kO1xuICAgICAgdHJhY2subGFiZWwgPSBsYWJlbDtcbiAgICAgIHRyYWNrLnNyYyA9IHNyYztcbiAgICAgIHRyYWNrLnNyY2xhbmcgPSBzcmNMYW5nO1xuICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpXG4gICAgICAgIHNlbGVjdGVkVHJhY2sudmFsdWUgPSBpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodHJhY2spO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgeyBpZ25vcmVVcGRhdGVzOiBpZ25vcmVDdXJyZW50VGltZVVwZGF0ZXMgfSA9IHdhdGNoSWdub3JhYmxlKGN1cnJlbnRUaW1lLCAodGltZSkgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgZWwuY3VycmVudFRpbWUgPSB0aW1lO1xuICB9KTtcbiAgY29uc3QgeyBpZ25vcmVVcGRhdGVzOiBpZ25vcmVQbGF5aW5nVXBkYXRlcyB9ID0gd2F0Y2hJZ25vcmFibGUocGxheWluZywgKGlzUGxheWluZykgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGlzUGxheWluZykge1xuICAgICAgZWwucGxheSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHBsYXliYWNrRXJyb3JFdmVudC50cmlnZ2VyKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJ0aW1ldXBkYXRlXCIsXG4gICAgKCkgPT4gaWdub3JlQ3VycmVudFRpbWVVcGRhdGVzKCgpID0+IGN1cnJlbnRUaW1lLnZhbHVlID0gdG9WYWx1ZSh0YXJnZXQpLmN1cnJlbnRUaW1lKSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJkdXJhdGlvbmNoYW5nZVwiLFxuICAgICgpID0+IGR1cmF0aW9uLnZhbHVlID0gdG9WYWx1ZSh0YXJnZXQpLmR1cmF0aW9uLFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcInByb2dyZXNzXCIsXG4gICAgKCkgPT4gYnVmZmVyZWQudmFsdWUgPSB0aW1lUmFuZ2VUb0FycmF5KHRvVmFsdWUodGFyZ2V0KS5idWZmZXJlZCksXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwic2Vla2luZ1wiLFxuICAgICgpID0+IHNlZWtpbmcudmFsdWUgPSB0cnVlLFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcInNlZWtlZFwiLFxuICAgICgpID0+IHNlZWtpbmcudmFsdWUgPSBmYWxzZSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgW1wid2FpdGluZ1wiLCBcImxvYWRzdGFydFwiXSxcbiAgICAoKSA9PiB7XG4gICAgICB3YWl0aW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGlnbm9yZVBsYXlpbmdVcGRhdGVzKCgpID0+IHBsYXlpbmcudmFsdWUgPSBmYWxzZSk7XG4gICAgfSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJsb2FkZWRkYXRhXCIsXG4gICAgKCkgPT4gd2FpdGluZy52YWx1ZSA9IGZhbHNlLFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcInBsYXlpbmdcIixcbiAgICAoKSA9PiB7XG4gICAgICB3YWl0aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICBlbmRlZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgaWdub3JlUGxheWluZ1VwZGF0ZXMoKCkgPT4gcGxheWluZy52YWx1ZSA9IHRydWUpO1xuICAgIH0sXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwicmF0ZWNoYW5nZVwiLFxuICAgICgpID0+IHJhdGUudmFsdWUgPSB0b1ZhbHVlKHRhcmdldCkucGxheWJhY2tSYXRlLFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcInN0YWxsZWRcIixcbiAgICAoKSA9PiBzdGFsbGVkLnZhbHVlID0gdHJ1ZSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJlbmRlZFwiLFxuICAgICgpID0+IGVuZGVkLnZhbHVlID0gdHJ1ZSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJwYXVzZVwiLFxuICAgICgpID0+IGlnbm9yZVBsYXlpbmdVcGRhdGVzKCgpID0+IHBsYXlpbmcudmFsdWUgPSBmYWxzZSksXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwicGxheVwiLFxuICAgICgpID0+IGlnbm9yZVBsYXlpbmdVcGRhdGVzKCgpID0+IHBsYXlpbmcudmFsdWUgPSB0cnVlKSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJlbnRlcnBpY3R1cmVpbnBpY3R1cmVcIixcbiAgICAoKSA9PiBpc1BpY3R1cmVJblBpY3R1cmUudmFsdWUgPSB0cnVlLFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcImxlYXZlcGljdHVyZWlucGljdHVyZVwiLFxuICAgICgpID0+IGlzUGljdHVyZUluUGljdHVyZS52YWx1ZSA9IGZhbHNlLFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcInZvbHVtZWNoYW5nZVwiLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgICAgaWYgKCFlbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdm9sdW1lLnZhbHVlID0gZWwudm9sdW1lO1xuICAgICAgbXV0ZWQudmFsdWUgPSBlbC5tdXRlZDtcbiAgICB9LFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgY29uc3Qgc3RvcCA9IHdhdGNoKFt0YXJnZXRdLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBzdG9wKCk7XG4gICAgbGlzdGVuZXJzWzBdID0gdXNlRXZlbnRMaXN0ZW5lcihlbC50ZXh0VHJhY2tzLCBcImFkZHRyYWNrXCIsICgpID0+IHRyYWNrcy52YWx1ZSA9IHRyYWNrc1RvQXJyYXkoZWwudGV4dFRyYWNrcyksIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgbGlzdGVuZXJzWzFdID0gdXNlRXZlbnRMaXN0ZW5lcihlbC50ZXh0VHJhY2tzLCBcInJlbW92ZXRyYWNrXCIsICgpID0+IHRyYWNrcy52YWx1ZSA9IHRyYWNrc1RvQXJyYXkoZWwudGV4dFRyYWNrcyksIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgbGlzdGVuZXJzWzJdID0gdXNlRXZlbnRMaXN0ZW5lcihlbC50ZXh0VHJhY2tzLCBcImNoYW5nZVwiLCAoKSA9PiB0cmFja3MudmFsdWUgPSB0cmFja3NUb0FycmF5KGVsLnRleHRUcmFja3MpLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4gbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKSk7XG4gIHJldHVybiB7XG4gICAgY3VycmVudFRpbWUsXG4gICAgZHVyYXRpb24sXG4gICAgd2FpdGluZyxcbiAgICBzZWVraW5nLFxuICAgIGVuZGVkLFxuICAgIHN0YWxsZWQsXG4gICAgYnVmZmVyZWQsXG4gICAgcGxheWluZyxcbiAgICByYXRlLFxuICAgIC8vIFZvbHVtZVxuICAgIHZvbHVtZSxcbiAgICBtdXRlZCxcbiAgICAvLyBUcmFja3NcbiAgICB0cmFja3MsXG4gICAgc2VsZWN0ZWRUcmFjayxcbiAgICBlbmFibGVUcmFjayxcbiAgICBkaXNhYmxlVHJhY2ssXG4gICAgLy8gUGljdHVyZSBpbiBQaWN0dXJlXG4gICAgc3VwcG9ydHNQaWN0dXJlSW5QaWN0dXJlLFxuICAgIHRvZ2dsZVBpY3R1cmVJblBpY3R1cmUsXG4gICAgaXNQaWN0dXJlSW5QaWN0dXJlLFxuICAgIC8vIEV2ZW50c1xuICAgIG9uU291cmNlRXJyb3I6IHNvdXJjZUVycm9yRXZlbnQub24sXG4gICAgb25QbGF5YmFja0Vycm9yOiBwbGF5YmFja0Vycm9yRXZlbnQub25cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTWVtb2l6ZShyZXNvbHZlciwgb3B0aW9ucykge1xuICBjb25zdCBpbml0Q2FjaGUgPSAoKSA9PiB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FjaGUpXG4gICAgICByZXR1cm4gc2hhbGxvd1JlYWN0aXZlKG9wdGlvbnMuY2FjaGUpO1xuICAgIHJldHVybiBzaGFsbG93UmVhY3RpdmUoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH07XG4gIGNvbnN0IGNhY2hlID0gaW5pdENhY2hlKCk7XG4gIGNvbnN0IGdlbmVyYXRlS2V5ID0gKC4uLmFyZ3MpID0+IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldEtleSkgPyBvcHRpb25zLmdldEtleSguLi5hcmdzKSA6IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICBjb25zdCBfbG9hZERhdGEgPSAoa2V5LCAuLi5hcmdzKSA9PiB7XG4gICAgY2FjaGUuc2V0KGtleSwgcmVzb2x2ZXIoLi4uYXJncykpO1xuICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgfTtcbiAgY29uc3QgbG9hZERhdGEgPSAoLi4uYXJncykgPT4gX2xvYWREYXRhKGdlbmVyYXRlS2V5KC4uLmFyZ3MpLCAuLi5hcmdzKTtcbiAgY29uc3QgZGVsZXRlRGF0YSA9ICguLi5hcmdzKSA9PiB7XG4gICAgY2FjaGUuZGVsZXRlKGdlbmVyYXRlS2V5KC4uLmFyZ3MpKTtcbiAgfTtcbiAgY29uc3QgY2xlYXJEYXRhID0gKCkgPT4ge1xuICAgIGNhY2hlLmNsZWFyKCk7XG4gIH07XG4gIGNvbnN0IG1lbW9pemVkID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBrZXkgPSBnZW5lcmF0ZUtleSguLi5hcmdzKTtcbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpXG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgcmV0dXJuIF9sb2FkRGF0YShrZXksIC4uLmFyZ3MpO1xuICB9O1xuICBtZW1vaXplZC5sb2FkID0gbG9hZERhdGE7XG4gIG1lbW9pemVkLmRlbGV0ZSA9IGRlbGV0ZURhdGE7XG4gIG1lbW9pemVkLmNsZWFyID0gY2xlYXJEYXRhO1xuICBtZW1vaXplZC5nZW5lcmF0ZUtleSA9IGdlbmVyYXRlS2V5O1xuICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9yeShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgbWVtb3J5ID0gcmVmKCk7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm1lbW9yeVwiIGluIHBlcmZvcm1hbmNlKTtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgY29uc3QgeyBpbnRlcnZhbCA9IDFlMyB9ID0gb3B0aW9ucztcbiAgICB1c2VJbnRlcnZhbEZuKCgpID0+IHtcbiAgICAgIG1lbW9yeS52YWx1ZSA9IHBlcmZvcm1hbmNlLm1lbW9yeTtcbiAgICB9LCBpbnRlcnZhbCwgeyBpbW1lZGlhdGU6IG9wdGlvbnMuaW1tZWRpYXRlLCBpbW1lZGlhdGVDYWxsYmFjazogb3B0aW9ucy5pbW1lZGlhdGVDYWxsYmFjayB9KTtcbiAgfVxuICByZXR1cm4geyBpc1N1cHBvcnRlZCwgbWVtb3J5IH07XG59XG5cbmNvbnN0IFVzZU1vdXNlQnVpbHRpbkV4dHJhY3RvcnMgPSB7XG4gIHBhZ2U6IChldmVudCkgPT4gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV0sXG4gIGNsaWVudDogKGV2ZW50KSA9PiBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV0sXG4gIHNjcmVlbjogKGV2ZW50KSA9PiBbZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWV0sXG4gIG1vdmVtZW50OiAoZXZlbnQpID0+IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCA/IFtldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WV0gOiBudWxsXG59O1xuZnVuY3Rpb24gdXNlTW91c2Uob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlID0gXCJwYWdlXCIsXG4gICAgdG91Y2ggPSB0cnVlLFxuICAgIHJlc2V0T25Ub3VjaEVuZHMgPSBmYWxzZSxcbiAgICBpbml0aWFsVmFsdWUgPSB7IHg6IDAsIHk6IDAgfSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIHRhcmdldCA9IHdpbmRvdyxcbiAgICBzY3JvbGwgPSB0cnVlLFxuICAgIGV2ZW50RmlsdGVyXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgX3ByZXZNb3VzZUV2ZW50ID0gbnVsbDtcbiAgbGV0IF9wcmV2U2Nyb2xsWCA9IDA7XG4gIGxldCBfcHJldlNjcm9sbFkgPSAwO1xuICBjb25zdCB4ID0gc2hhbGxvd1JlZihpbml0aWFsVmFsdWUueCk7XG4gIGNvbnN0IHkgPSBzaGFsbG93UmVmKGluaXRpYWxWYWx1ZS55KTtcbiAgY29uc3Qgc291cmNlVHlwZSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGV4dHJhY3RvciA9IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgPyB0eXBlIDogVXNlTW91c2VCdWlsdGluRXh0cmFjdG9yc1t0eXBlXTtcbiAgY29uc3QgbW91c2VIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdG9yKGV2ZW50KTtcbiAgICBfcHJldk1vdXNlRXZlbnQgPSBldmVudDtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBbeC52YWx1ZSwgeS52YWx1ZV0gPSByZXN1bHQ7XG4gICAgICBzb3VyY2VUeXBlLnZhbHVlID0gXCJtb3VzZVwiO1xuICAgIH1cbiAgICBpZiAod2luZG93KSB7XG4gICAgICBfcHJldlNjcm9sbFggPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgIF9wcmV2U2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdG91Y2hIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdG9yKGV2ZW50LnRvdWNoZXNbMF0pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBbeC52YWx1ZSwgeS52YWx1ZV0gPSByZXN1bHQ7XG4gICAgICAgIHNvdXJjZVR5cGUudmFsdWUgPSBcInRvdWNoXCI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzY3JvbGxIYW5kbGVyID0gKCkgPT4ge1xuICAgIGlmICghX3ByZXZNb3VzZUV2ZW50IHx8ICF3aW5kb3cpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcG9zID0gZXh0cmFjdG9yKF9wcmV2TW91c2VFdmVudCk7XG4gICAgaWYgKF9wcmV2TW91c2VFdmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgJiYgcG9zKSB7XG4gICAgICB4LnZhbHVlID0gcG9zWzBdICsgd2luZG93LnNjcm9sbFggLSBfcHJldlNjcm9sbFg7XG4gICAgICB5LnZhbHVlID0gcG9zWzFdICsgd2luZG93LnNjcm9sbFkgLSBfcHJldlNjcm9sbFk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICB4LnZhbHVlID0gaW5pdGlhbFZhbHVlLng7XG4gICAgeS52YWx1ZSA9IGluaXRpYWxWYWx1ZS55O1xuICB9O1xuICBjb25zdCBtb3VzZUhhbmRsZXJXcmFwcGVyID0gZXZlbnRGaWx0ZXIgPyAoZXZlbnQpID0+IGV2ZW50RmlsdGVyKCgpID0+IG1vdXNlSGFuZGxlcihldmVudCksIHt9KSA6IChldmVudCkgPT4gbW91c2VIYW5kbGVyKGV2ZW50KTtcbiAgY29uc3QgdG91Y2hIYW5kbGVyV3JhcHBlciA9IGV2ZW50RmlsdGVyID8gKGV2ZW50KSA9PiBldmVudEZpbHRlcigoKSA9PiB0b3VjaEhhbmRsZXIoZXZlbnQpLCB7fSkgOiAoZXZlbnQpID0+IHRvdWNoSGFuZGxlcihldmVudCk7XG4gIGNvbnN0IHNjcm9sbEhhbmRsZXJXcmFwcGVyID0gZXZlbnRGaWx0ZXIgPyAoKSA9PiBldmVudEZpbHRlcigoKSA9PiBzY3JvbGxIYW5kbGVyKCksIHt9KSA6ICgpID0+IHNjcm9sbEhhbmRsZXIoKTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBbXCJtb3VzZW1vdmVcIiwgXCJkcmFnb3ZlclwiXSwgbW91c2VIYW5kbGVyV3JhcHBlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICBpZiAodG91Y2ggJiYgdHlwZSAhPT0gXCJtb3ZlbWVudFwiKSB7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgW1widG91Y2hzdGFydFwiLCBcInRvdWNobW92ZVwiXSwgdG91Y2hIYW5kbGVyV3JhcHBlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICAgIGlmIChyZXNldE9uVG91Y2hFbmRzKVxuICAgICAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJ0b3VjaGVuZFwiLCByZXNldCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHNjcm9sbCAmJiB0eXBlID09PSBcInBhZ2VcIilcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInNjcm9sbFwiLCBzY3JvbGxIYW5kbGVyV3JhcHBlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBzb3VyY2VUeXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1vdXNlSW5FbGVtZW50KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3dSZXNpemUgPSB0cnVlLFxuICAgIHdpbmRvd1Njcm9sbCA9IHRydWUsXG4gICAgaGFuZGxlT3V0c2lkZSA9IHRydWUsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBcInBhZ2VcIjtcbiAgY29uc3QgeyB4LCB5LCBzb3VyY2VUeXBlIH0gPSB1c2VNb3VzZShvcHRpb25zKTtcbiAgY29uc3QgdGFyZ2V0UmVmID0gc2hhbGxvd1JlZih0YXJnZXQgIT0gbnVsbCA/IHRhcmdldCA6IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50LmJvZHkpO1xuICBjb25zdCBlbGVtZW50WCA9IHNoYWxsb3dSZWYoMCk7XG4gIGNvbnN0IGVsZW1lbnRZID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgZWxlbWVudFBvc2l0aW9uWCA9IHNoYWxsb3dSZWYoMCk7XG4gIGNvbnN0IGVsZW1lbnRQb3NpdGlvblkgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBlbGVtZW50SGVpZ2h0ID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgZWxlbWVudFdpZHRoID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgaXNPdXRzaWRlID0gc2hhbGxvd1JlZih0cnVlKTtcbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldFJlZik7XG4gICAgaWYgKCFlbCB8fCAhKGVsIGluc3RhbmNlb2YgRWxlbWVudCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGVsZW1lbnRQb3NpdGlvblgudmFsdWUgPSBsZWZ0ICsgKHR5cGUgPT09IFwicGFnZVwiID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogMCk7XG4gICAgZWxlbWVudFBvc2l0aW9uWS52YWx1ZSA9IHRvcCArICh0eXBlID09PSBcInBhZ2VcIiA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IDApO1xuICAgIGVsZW1lbnRIZWlnaHQudmFsdWUgPSBoZWlnaHQ7XG4gICAgZWxlbWVudFdpZHRoLnZhbHVlID0gd2lkdGg7XG4gICAgY29uc3QgZWxYID0geC52YWx1ZSAtIGVsZW1lbnRQb3NpdGlvblgudmFsdWU7XG4gICAgY29uc3QgZWxZID0geS52YWx1ZSAtIGVsZW1lbnRQb3NpdGlvblkudmFsdWU7XG4gICAgaXNPdXRzaWRlLnZhbHVlID0gd2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwIHx8IGVsWCA8IDAgfHwgZWxZIDwgMCB8fCBlbFggPiB3aWR0aCB8fCBlbFkgPiBoZWlnaHQ7XG4gICAgaWYgKGhhbmRsZU91dHNpZGUpIHtcbiAgICAgIGVsZW1lbnRYLnZhbHVlID0gZWxYO1xuICAgICAgZWxlbWVudFkudmFsdWUgPSBlbFk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0b3BGbkxpc3QgPSBbXTtcbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzdG9wRm5MaXN0LmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICBzdG9wRm5MaXN0Lmxlbmd0aCA9IDA7XG4gIH1cbiAgdHJ5T25Nb3VudGVkKCgpID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG4gIGlmICh3aW5kb3cpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdG9wOiBzdG9wUmVzaXplT2JzZXJ2ZXJcbiAgICB9ID0gdXNlUmVzaXplT2JzZXJ2ZXIodGFyZ2V0UmVmLCB1cGRhdGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0b3A6IHN0b3BNdXRhdGlvbk9ic2VydmVyXG4gICAgfSA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIodGFyZ2V0UmVmLCB1cGRhdGUsIHtcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wic3R5bGVcIiwgXCJjbGFzc1wiXVxuICAgIH0pO1xuICAgIGNvbnN0IHN0b3BXYXRjaCA9IHdhdGNoKFxuICAgICAgW3RhcmdldFJlZiwgeCwgeV0sXG4gICAgICB1cGRhdGVcbiAgICApO1xuICAgIHN0b3BGbkxpc3QucHVzaChcbiAgICAgIHN0b3BSZXNpemVPYnNlcnZlcixcbiAgICAgIHN0b3BNdXRhdGlvbk9ic2VydmVyLFxuICAgICAgc3RvcFdhdGNoXG4gICAgKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcIm1vdXNlbGVhdmVcIixcbiAgICAgICgpID0+IGlzT3V0c2lkZS52YWx1ZSA9IHRydWUsXG4gICAgICB7IHBhc3NpdmU6IHRydWUgfVxuICAgICk7XG4gICAgaWYgKHdpbmRvd1Njcm9sbCkge1xuICAgICAgc3RvcEZuTGlzdC5wdXNoKFxuICAgICAgICB1c2VFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHVwZGF0ZSwgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAod2luZG93UmVzaXplKSB7XG4gICAgICBzdG9wRm5MaXN0LnB1c2goXG4gICAgICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHNvdXJjZVR5cGUsXG4gICAgZWxlbWVudFgsXG4gICAgZWxlbWVudFksXG4gICAgZWxlbWVudFBvc2l0aW9uWCxcbiAgICBlbGVtZW50UG9zaXRpb25ZLFxuICAgIGVsZW1lbnRIZWlnaHQsXG4gICAgZWxlbWVudFdpZHRoLFxuICAgIGlzT3V0c2lkZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1vdXNlUHJlc3NlZChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRvdWNoID0gdHJ1ZSxcbiAgICBkcmFnID0gdHJ1ZSxcbiAgICBjYXB0dXJlID0gZmFsc2UsXG4gICAgaW5pdGlhbFZhbHVlID0gZmFsc2UsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJlc3NlZCA9IHNoYWxsb3dSZWYoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgc291cmNlVHlwZSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZXNzZWQsXG4gICAgICBzb3VyY2VUeXBlXG4gICAgfTtcbiAgfVxuICBjb25zdCBvblByZXNzZWQgPSAoc3JjVHlwZSkgPT4gKGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHByZXNzZWQudmFsdWUgPSB0cnVlO1xuICAgIHNvdXJjZVR5cGUudmFsdWUgPSBzcmNUeXBlO1xuICAgIChfYSA9IG9wdGlvbnMub25QcmVzc2VkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBldmVudCk7XG4gIH07XG4gIGNvbnN0IG9uUmVsZWFzZWQgPSAoZXZlbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcHJlc3NlZC52YWx1ZSA9IGZhbHNlO1xuICAgIHNvdXJjZVR5cGUudmFsdWUgPSBudWxsO1xuICAgIChfYSA9IG9wdGlvbnMub25SZWxlYXNlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgZXZlbnQpO1xuICB9O1xuICBjb25zdCB0YXJnZXQgPSBjb21wdXRlZCgoKSA9PiB1bnJlZkVsZW1lbnQob3B0aW9ucy50YXJnZXQpIHx8IHdpbmRvdyk7XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9O1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJtb3VzZWRvd25cIiwgb25QcmVzc2VkKFwibW91c2VcIiksIGxpc3RlbmVyT3B0aW9ucyk7XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm1vdXNlbGVhdmVcIiwgb25SZWxlYXNlZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwibW91c2V1cFwiLCBvblJlbGVhc2VkLCBsaXN0ZW5lck9wdGlvbnMpO1xuICBpZiAoZHJhZykge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyYWdzdGFydFwiLCBvblByZXNzZWQoXCJtb3VzZVwiKSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJkcm9wXCIsIG9uUmVsZWFzZWQsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiZHJhZ2VuZFwiLCBvblJlbGVhc2VkLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIGlmICh0b3VjaCkge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInRvdWNoc3RhcnRcIiwgb25QcmVzc2VkKFwidG91Y2hcIiksIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hlbmRcIiwgb25SZWxlYXNlZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaGNhbmNlbFwiLCBvblJlbGVhc2VkLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJlc3NlZCxcbiAgICBzb3VyY2VUeXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU5hdmlnYXRvckxhbmd1YWdlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Lm5hdmlnYXRvcjtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwibGFuZ3VhZ2VcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBsYW5ndWFnZSA9IHNoYWxsb3dSZWYobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJsYW5ndWFnZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgaWYgKG5hdmlnYXRvcilcbiAgICAgIGxhbmd1YWdlLnZhbHVlID0gbmF2aWdhdG9yLmxhbmd1YWdlO1xuICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgbGFuZ3VhZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTmV0d29yayhvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImNvbm5lY3Rpb25cIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBpc09ubGluZSA9IHNoYWxsb3dSZWYodHJ1ZSk7XG4gIGNvbnN0IHNhdmVEYXRhID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IG9mZmxpbmVBdCA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3Qgb25saW5lQXQgPSBzaGFsbG93UmVmKHZvaWQgMCk7XG4gIGNvbnN0IGRvd25saW5rID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCBkb3dubGlua01heCA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3QgcnR0ID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCBlZmZlY3RpdmVUeXBlID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCB0eXBlID0gc2hhbGxvd1JlZihcInVua25vd25cIik7XG4gIGNvbnN0IGNvbm5lY3Rpb24gPSBpc1N1cHBvcnRlZC52YWx1ZSAmJiBuYXZpZ2F0b3IuY29ubmVjdGlvbjtcbiAgZnVuY3Rpb24gdXBkYXRlTmV0d29ya0luZm9ybWF0aW9uKCkge1xuICAgIGlmICghbmF2aWdhdG9yKVxuICAgICAgcmV0dXJuO1xuICAgIGlzT25saW5lLnZhbHVlID0gbmF2aWdhdG9yLm9uTGluZTtcbiAgICBvZmZsaW5lQXQudmFsdWUgPSBpc09ubGluZS52YWx1ZSA/IHZvaWQgMCA6IERhdGUubm93KCk7XG4gICAgb25saW5lQXQudmFsdWUgPSBpc09ubGluZS52YWx1ZSA/IERhdGUubm93KCkgOiB2b2lkIDA7XG4gICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgIGRvd25saW5rLnZhbHVlID0gY29ubmVjdGlvbi5kb3dubGluaztcbiAgICAgIGRvd25saW5rTWF4LnZhbHVlID0gY29ubmVjdGlvbi5kb3dubGlua01heDtcbiAgICAgIGVmZmVjdGl2ZVR5cGUudmFsdWUgPSBjb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGU7XG4gICAgICBydHQudmFsdWUgPSBjb25uZWN0aW9uLnJ0dDtcbiAgICAgIHNhdmVEYXRhLnZhbHVlID0gY29ubmVjdGlvbi5zYXZlRGF0YTtcbiAgICAgIHR5cGUudmFsdWUgPSBjb25uZWN0aW9uLnR5cGU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICBpZiAod2luZG93KSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICBpc09ubGluZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgb2ZmbGluZUF0LnZhbHVlID0gRGF0ZS5ub3coKTtcbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm9ubGluZVwiLCAoKSA9PiB7XG4gICAgICBpc09ubGluZS52YWx1ZSA9IHRydWU7XG4gICAgICBvbmxpbmVBdC52YWx1ZSA9IERhdGUubm93KCk7XG4gICAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICBpZiAoY29ubmVjdGlvbilcbiAgICB1c2VFdmVudExpc3RlbmVyKGNvbm5lY3Rpb24sIFwiY2hhbmdlXCIsIHVwZGF0ZU5ldHdvcmtJbmZvcm1hdGlvbiwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdXBkYXRlTmV0d29ya0luZm9ybWF0aW9uKCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNPbmxpbmU6IHJlYWRvbmx5KGlzT25saW5lKSxcbiAgICBzYXZlRGF0YTogcmVhZG9ubHkoc2F2ZURhdGEpLFxuICAgIG9mZmxpbmVBdDogcmVhZG9ubHkob2ZmbGluZUF0KSxcbiAgICBvbmxpbmVBdDogcmVhZG9ubHkob25saW5lQXQpLFxuICAgIGRvd25saW5rOiByZWFkb25seShkb3dubGluayksXG4gICAgZG93bmxpbmtNYXg6IHJlYWRvbmx5KGRvd25saW5rTWF4KSxcbiAgICBlZmZlY3RpdmVUeXBlOiByZWFkb25seShlZmZlY3RpdmVUeXBlKSxcbiAgICBydHQ6IHJlYWRvbmx5KHJ0dCksXG4gICAgdHlwZTogcmVhZG9ubHkodHlwZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTm93KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHM6IGV4cG9zZUNvbnRyb2xzID0gZmFsc2UsXG4gICAgaW50ZXJ2YWwgPSBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG5vdyA9IHJlZigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSk7XG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IG5vdy52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBjb25zdCBjb250cm9scyA9IGludGVydmFsID09PSBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiID8gdXNlUmFmRm4odXBkYXRlLCB7IGltbWVkaWF0ZSB9KSA6IHVzZUludGVydmFsRm4odXBkYXRlLCBpbnRlcnZhbCwgeyBpbW1lZGlhdGUgfSk7XG4gIGlmIChleHBvc2VDb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICBub3csXG4gICAgICAuLi5jb250cm9sc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VPYmplY3RVcmwob2JqZWN0KSB7XG4gIGNvbnN0IHVybCA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgcmVsZWFzZSA9ICgpID0+IHtcbiAgICBpZiAodXJsLnZhbHVlKVxuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwudmFsdWUpO1xuICAgIHVybC52YWx1ZSA9IHZvaWQgMDtcbiAgfTtcbiAgd2F0Y2goXG4gICAgKCkgPT4gdG9WYWx1ZShvYmplY3QpLFxuICAgIChuZXdPYmplY3QpID0+IHtcbiAgICAgIHJlbGVhc2UoKTtcbiAgICAgIGlmIChuZXdPYmplY3QpXG4gICAgICAgIHVybC52YWx1ZSA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3T2JqZWN0KTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgdHJ5T25TY29wZURpc3Bvc2UocmVsZWFzZSk7XG4gIHJldHVybiByZWFkb25seSh1cmwpO1xufVxuXG5mdW5jdGlvbiB1c2VDbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IGlzUmVhZG9ubHkodmFsdWUpKVxuICAgIHJldHVybiBjb21wdXRlZCgoKSA9PiBjbGFtcCh0b1ZhbHVlKHZhbHVlKSwgdG9WYWx1ZShtaW4pLCB0b1ZhbHVlKG1heCkpKTtcbiAgY29uc3QgX3ZhbHVlID0gcmVmKHZhbHVlKTtcbiAgcmV0dXJuIGNvbXB1dGVkKHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gX3ZhbHVlLnZhbHVlID0gY2xhbXAoX3ZhbHVlLnZhbHVlLCB0b1ZhbHVlKG1pbiksIHRvVmFsdWUobWF4KSk7XG4gICAgfSxcbiAgICBzZXQodmFsdWUyKSB7XG4gICAgICBfdmFsdWUudmFsdWUgPSBjbGFtcCh2YWx1ZTIsIHRvVmFsdWUobWluKSwgdG9WYWx1ZShtYXgpKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VPZmZzZXRQYWdpbmF0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHRvdGFsID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHBhZ2VTaXplID0gMTAsXG4gICAgcGFnZSA9IDEsXG4gICAgb25QYWdlQ2hhbmdlID0gbm9vcCxcbiAgICBvblBhZ2VTaXplQ2hhbmdlID0gbm9vcCxcbiAgICBvblBhZ2VDb3VudENoYW5nZSA9IG5vb3BcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGN1cnJlbnRQYWdlU2l6ZSA9IHVzZUNsYW1wKHBhZ2VTaXplLCAxLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICBjb25zdCBwYWdlQ291bnQgPSBjb21wdXRlZCgoKSA9PiBNYXRoLm1heChcbiAgICAxLFxuICAgIE1hdGguY2VpbCh0b1ZhbHVlKHRvdGFsKSAvIHRvVmFsdWUoY3VycmVudFBhZ2VTaXplKSlcbiAgKSk7XG4gIGNvbnN0IGN1cnJlbnRQYWdlID0gdXNlQ2xhbXAocGFnZSwgMSwgcGFnZUNvdW50KTtcbiAgY29uc3QgaXNGaXJzdFBhZ2UgPSBjb21wdXRlZCgoKSA9PiBjdXJyZW50UGFnZS52YWx1ZSA9PT0gMSk7XG4gIGNvbnN0IGlzTGFzdFBhZ2UgPSBjb21wdXRlZCgoKSA9PiBjdXJyZW50UGFnZS52YWx1ZSA9PT0gcGFnZUNvdW50LnZhbHVlKTtcbiAgaWYgKGlzUmVmKHBhZ2UpKSB7XG4gICAgc3luY1JlZihwYWdlLCBjdXJyZW50UGFnZSwge1xuICAgICAgZGlyZWN0aW9uOiBpc1JlYWRvbmx5KHBhZ2UpID8gXCJsdHJcIiA6IFwiYm90aFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzUmVmKHBhZ2VTaXplKSkge1xuICAgIHN5bmNSZWYocGFnZVNpemUsIGN1cnJlbnRQYWdlU2l6ZSwge1xuICAgICAgZGlyZWN0aW9uOiBpc1JlYWRvbmx5KHBhZ2VTaXplKSA/IFwibHRyXCIgOiBcImJvdGhcIlxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgY3VycmVudFBhZ2UudmFsdWUtLTtcbiAgfVxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGN1cnJlbnRQYWdlLnZhbHVlKys7XG4gIH1cbiAgY29uc3QgcmV0dXJuVmFsdWUgPSB7XG4gICAgY3VycmVudFBhZ2UsXG4gICAgY3VycmVudFBhZ2VTaXplLFxuICAgIHBhZ2VDb3VudCxcbiAgICBpc0ZpcnN0UGFnZSxcbiAgICBpc0xhc3RQYWdlLFxuICAgIHByZXYsXG4gICAgbmV4dFxuICB9O1xuICB3YXRjaChjdXJyZW50UGFnZSwgKCkgPT4ge1xuICAgIG9uUGFnZUNoYW5nZShyZWFjdGl2ZShyZXR1cm5WYWx1ZSkpO1xuICB9KTtcbiAgd2F0Y2goY3VycmVudFBhZ2VTaXplLCAoKSA9PiB7XG4gICAgb25QYWdlU2l6ZUNoYW5nZShyZWFjdGl2ZShyZXR1cm5WYWx1ZSkpO1xuICB9KTtcbiAgd2F0Y2gocGFnZUNvdW50LCAoKSA9PiB7XG4gICAgb25QYWdlQ291bnRDaGFuZ2UocmVhY3RpdmUocmV0dXJuVmFsdWUpKTtcbiAgfSk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlT25saW5lKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGlzT25saW5lIH0gPSB1c2VOZXR3b3JrKG9wdGlvbnMpO1xuICByZXR1cm4gaXNPbmxpbmU7XG59XG5cbmZ1bmN0aW9uIHVzZVBhZ2VMZWF2ZShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCBpc0xlZnQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuICAgIGNvbnN0IGZyb20gPSBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRvRWxlbWVudDtcbiAgICBpc0xlZnQudmFsdWUgPSAhZnJvbTtcbiAgfTtcbiAgaWYgKHdpbmRvdykge1xuICAgIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm1vdXNlb3V0XCIsIGhhbmRsZXIsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3cuZG9jdW1lbnQsIFwibW91c2VsZWF2ZVwiLCBoYW5kbGVyLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LmRvY3VtZW50LCBcIm1vdXNlZW50ZXJcIiwgaGFuZGxlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gaXNMZWZ0O1xufVxuXG5mdW5jdGlvbiB1c2VTY3JlZW5PcmllbnRhdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcInNjcmVlblwiIGluIHdpbmRvdyAmJiBcIm9yaWVudGF0aW9uXCIgaW4gd2luZG93LnNjcmVlbik7XG4gIGNvbnN0IHNjcmVlbk9yaWVudGF0aW9uID0gaXNTdXBwb3J0ZWQudmFsdWUgPyB3aW5kb3cuc2NyZWVuLm9yaWVudGF0aW9uIDoge307XG4gIGNvbnN0IG9yaWVudGF0aW9uID0gcmVmKHNjcmVlbk9yaWVudGF0aW9uLnR5cGUpO1xuICBjb25zdCBhbmdsZSA9IHNoYWxsb3dSZWYoc2NyZWVuT3JpZW50YXRpb24uYW5nbGUgfHwgMCk7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm9yaWVudGF0aW9uY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIG9yaWVudGF0aW9uLnZhbHVlID0gc2NyZWVuT3JpZW50YXRpb24udHlwZTtcbiAgICAgIGFuZ2xlLnZhbHVlID0gc2NyZWVuT3JpZW50YXRpb24uYW5nbGU7XG4gICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB9XG4gIGNvbnN0IGxvY2tPcmllbnRhdGlvbiA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHR5cGVvZiBzY3JlZW5PcmllbnRhdGlvbi5sb2NrID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gc2NyZWVuT3JpZW50YXRpb24ubG9jayh0eXBlKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZFwiKSk7XG4gIH07XG4gIGNvbnN0IHVubG9ja09yaWVudGF0aW9uID0gKCkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB0eXBlb2Ygc2NyZWVuT3JpZW50YXRpb24udW5sb2NrID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBzY3JlZW5PcmllbnRhdGlvbi51bmxvY2soKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBvcmllbnRhdGlvbixcbiAgICBhbmdsZSxcbiAgICBsb2NrT3JpZW50YXRpb24sXG4gICAgdW5sb2NrT3JpZW50YXRpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUGFyYWxsYXgodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGRldmljZU9yaWVudGF0aW9uVGlsdEFkanVzdCA9IChpKSA9PiBpLFxuICAgIGRldmljZU9yaWVudGF0aW9uUm9sbEFkanVzdCA9IChpKSA9PiBpLFxuICAgIG1vdXNlVGlsdEFkanVzdCA9IChpKSA9PiBpLFxuICAgIG1vdXNlUm9sbEFkanVzdCA9IChpKSA9PiBpLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG9yaWVudGF0aW9uID0gcmVhY3RpdmUodXNlRGV2aWNlT3JpZW50YXRpb24oeyB3aW5kb3cgfSkpO1xuICBjb25zdCBzY3JlZW5PcmllbnRhdGlvbiA9IHJlYWN0aXZlKHVzZVNjcmVlbk9yaWVudGF0aW9uKHsgd2luZG93IH0pKTtcbiAgY29uc3Qge1xuICAgIGVsZW1lbnRYOiB4LFxuICAgIGVsZW1lbnRZOiB5LFxuICAgIGVsZW1lbnRXaWR0aDogd2lkdGgsXG4gICAgZWxlbWVudEhlaWdodDogaGVpZ2h0XG4gIH0gPSB1c2VNb3VzZUluRWxlbWVudCh0YXJnZXQsIHsgaGFuZGxlT3V0c2lkZTogZmFsc2UsIHdpbmRvdyB9KTtcbiAgY29uc3Qgc291cmNlID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChvcmllbnRhdGlvbi5pc1N1cHBvcnRlZCAmJiAob3JpZW50YXRpb24uYWxwaGEgIT0gbnVsbCAmJiBvcmllbnRhdGlvbi5hbHBoYSAhPT0gMCB8fCBvcmllbnRhdGlvbi5nYW1tYSAhPSBudWxsICYmIG9yaWVudGF0aW9uLmdhbW1hICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFwiZGV2aWNlT3JpZW50YXRpb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIFwibW91c2VcIjtcbiAgfSk7XG4gIGNvbnN0IHJvbGwgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKHNvdXJjZS52YWx1ZSA9PT0gXCJkZXZpY2VPcmllbnRhdGlvblwiKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBzd2l0Y2ggKHNjcmVlbk9yaWVudGF0aW9uLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJsYW5kc2NhcGUtcHJpbWFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gb3JpZW50YXRpb24uZ2FtbWEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxhbmRzY2FwZS1zZWNvbmRhcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IC1vcmllbnRhdGlvbi5nYW1tYSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicG9ydHJhaXQtcHJpbWFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gLW9yaWVudGF0aW9uLmJldGEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvcnRyYWl0LXNlY29uZGFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gb3JpZW50YXRpb24uYmV0YSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbHVlID0gLW9yaWVudGF0aW9uLmJldGEgLyA5MDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2VPcmllbnRhdGlvblJvbGxBZGp1c3QodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IC0oeS52YWx1ZSAtIGhlaWdodC52YWx1ZSAvIDIpIC8gaGVpZ2h0LnZhbHVlO1xuICAgICAgcmV0dXJuIG1vdXNlUm9sbEFkanVzdCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgdGlsdCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoc291cmNlLnZhbHVlID09PSBcImRldmljZU9yaWVudGF0aW9uXCIpIHtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIHN3aXRjaCAoc2NyZWVuT3JpZW50YXRpb24ub3JpZW50YXRpb24pIHtcbiAgICAgICAgY2FzZSBcImxhbmRzY2FwZS1wcmltYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSBvcmllbnRhdGlvbi5iZXRhIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsYW5kc2NhcGUtc2Vjb25kYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSAtb3JpZW50YXRpb24uYmV0YSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicG9ydHJhaXQtcHJpbWFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gb3JpZW50YXRpb24uZ2FtbWEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvcnRyYWl0LXNlY29uZGFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gLW9yaWVudGF0aW9uLmdhbW1hIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSBvcmllbnRhdGlvbi5nYW1tYSAvIDkwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZU9yaWVudGF0aW9uVGlsdEFkanVzdCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gKHgudmFsdWUgLSB3aWR0aC52YWx1ZSAvIDIpIC8gd2lkdGgudmFsdWU7XG4gICAgICByZXR1cm4gbW91c2VUaWx0QWRqdXN0KHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyByb2xsLCB0aWx0LCBzb3VyY2UgfTtcbn1cblxuZnVuY3Rpb24gdXNlUGFyZW50RWxlbWVudChlbGVtZW50ID0gdXNlQ3VycmVudEVsZW1lbnQoKSkge1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gc2hhbGxvd1JlZigpO1xuICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQoZWxlbWVudCk7XG4gICAgaWYgKGVsKVxuICAgICAgcGFyZW50RWxlbWVudC52YWx1ZSA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH07XG4gIHRyeU9uTW91bnRlZCh1cGRhdGUpO1xuICB3YXRjaCgoKSA9PiB0b1ZhbHVlKGVsZW1lbnQpLCB1cGRhdGUpO1xuICByZXR1cm4gcGFyZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gdXNlUGVyZm9ybWFuY2VPYnNlcnZlcihvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIC4uLnBlcmZvcm1hbmNlT3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwiUGVyZm9ybWFuY2VPYnNlcnZlclwiIGluIHdpbmRvdyk7XG4gIGxldCBvYnNlcnZlcjtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBvYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9O1xuICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICAgIHN0b3AoKTtcbiAgICAgIG9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShwZXJmb3JtYW5jZU9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbiAgdHJ5T25TY29wZURpc3Bvc2Uoc3RvcCk7XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgc3RhcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBzdGFydCxcbiAgICBzdG9wXG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgcG9pbnRlcklkOiAwLFxuICBwcmVzc3VyZTogMCxcbiAgdGlsdFg6IDAsXG4gIHRpbHRZOiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICB0d2lzdDogMCxcbiAgcG9pbnRlclR5cGU6IG51bGxcbn07XG5jb25zdCBrZXlzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5rZXlzKGRlZmF1bHRTdGF0ZSk7XG5mdW5jdGlvbiB1c2VQb2ludGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNJbnNpZGUgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3Qgc3RhdGUgPSByZWYob3B0aW9ucy5pbml0aWFsVmFsdWUgfHwge30pO1xuICBPYmplY3QuYXNzaWduKHN0YXRlLnZhbHVlLCBkZWZhdWx0U3RhdGUsIHN0YXRlLnZhbHVlKTtcbiAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGlzSW5zaWRlLnZhbHVlID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy5wb2ludGVyVHlwZXMgJiYgIW9wdGlvbnMucG9pbnRlclR5cGVzLmluY2x1ZGVzKGV2ZW50LnBvaW50ZXJUeXBlKSlcbiAgICAgIHJldHVybjtcbiAgICBzdGF0ZS52YWx1ZSA9IG9iamVjdFBpY2soZXZlbnQsIGtleXMsIGZhbHNlKTtcbiAgfTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBbXCJwb2ludGVyZG93blwiLCBcInBvaW50ZXJtb3ZlXCIsIFwicG9pbnRlcnVwXCJdLCBoYW5kbGVyLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBvaW50ZXJsZWF2ZVwiLCAoKSA9PiBpc0luc2lkZS52YWx1ZSA9IGZhbHNlLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4udG9SZWZzKHN0YXRlKSxcbiAgICBpc0luc2lkZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQb2ludGVyTG9jayh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50IH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBkb2N1bWVudCAmJiBcInBvaW50ZXJMb2NrRWxlbWVudFwiIGluIGRvY3VtZW50KTtcbiAgY29uc3QgZWxlbWVudCA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgdHJpZ2dlckVsZW1lbnQgPSBzaGFsbG93UmVmKCk7XG4gIGxldCB0YXJnZXRFbGVtZW50O1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInBvaW50ZXJsb2NrY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gKF9hID0gZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50KSAhPSBudWxsID8gX2EgOiBlbGVtZW50LnZhbHVlO1xuICAgICAgaWYgKHRhcmdldEVsZW1lbnQgJiYgY3VycmVudEVsZW1lbnQgPT09IHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudDtcbiAgICAgICAgaWYgKCFlbGVtZW50LnZhbHVlKVxuICAgICAgICAgIHRhcmdldEVsZW1lbnQgPSB0cmlnZ2VyRWxlbWVudC52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInBvaW50ZXJsb2NrZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSAoX2EgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQpICE9IG51bGwgPyBfYSA6IGVsZW1lbnQudmFsdWU7XG4gICAgICBpZiAodGFyZ2V0RWxlbWVudCAmJiBjdXJyZW50RWxlbWVudCA9PT0gdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgPyBcInJlbGVhc2VcIiA6IFwiYWNxdWlyZVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byAke2FjdGlvbn0gcG9pbnRlciBsb2NrLmApO1xuICAgICAgfVxuICAgIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbG9jayhlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2ludGVyIExvY2sgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyLlwiKTtcbiAgICB0cmlnZ2VyRWxlbWVudC52YWx1ZSA9IGUgaW5zdGFuY2VvZiBFdmVudCA/IGUuY3VycmVudFRhcmdldCA6IG51bGw7XG4gICAgdGFyZ2V0RWxlbWVudCA9IGUgaW5zdGFuY2VvZiBFdmVudCA/IChfYSA9IHVucmVmRWxlbWVudCh0YXJnZXQpKSAhPSBudWxsID8gX2EgOiB0cmlnZ2VyRWxlbWVudC52YWx1ZSA6IHVucmVmRWxlbWVudChlKTtcbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgZWxlbWVudCB1bmRlZmluZWQuXCIpO1xuICAgIHRhcmdldEVsZW1lbnQucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgcmV0dXJuIGF3YWl0IHVudGlsKGVsZW1lbnQpLnRvQmUodGFyZ2V0RWxlbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdW5sb2NrKCkge1xuICAgIGlmICghZWxlbWVudC52YWx1ZSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2soKTtcbiAgICBhd2FpdCB1bnRpbChlbGVtZW50KS50b0JlTnVsbCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgZWxlbWVudCxcbiAgICB0cmlnZ2VyRWxlbWVudCxcbiAgICBsb2NrLFxuICAgIHVubG9ja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQb2ludGVyU3dpcGUodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgdGFyZ2V0UmVmID0gdG9SZWYodGFyZ2V0KTtcbiAgY29uc3Qge1xuICAgIHRocmVzaG9sZCA9IDUwLFxuICAgIG9uU3dpcGUsXG4gICAgb25Td2lwZUVuZCxcbiAgICBvblN3aXBlU3RhcnQsXG4gICAgZGlzYWJsZVRleHRTZWxlY3QgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcG9zU3RhcnQgPSByZWFjdGl2ZSh7IHg6IDAsIHk6IDAgfSk7XG4gIGNvbnN0IHVwZGF0ZVBvc1N0YXJ0ID0gKHgsIHkpID0+IHtcbiAgICBwb3NTdGFydC54ID0geDtcbiAgICBwb3NTdGFydC55ID0geTtcbiAgfTtcbiAgY29uc3QgcG9zRW5kID0gcmVhY3RpdmUoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCB1cGRhdGVQb3NFbmQgPSAoeCwgeSkgPT4ge1xuICAgIHBvc0VuZC54ID0geDtcbiAgICBwb3NFbmQueSA9IHk7XG4gIH07XG4gIGNvbnN0IGRpc3RhbmNlWCA9IGNvbXB1dGVkKCgpID0+IHBvc1N0YXJ0LnggLSBwb3NFbmQueCk7XG4gIGNvbnN0IGRpc3RhbmNlWSA9IGNvbXB1dGVkKCgpID0+IHBvc1N0YXJ0LnkgLSBwb3NFbmQueSk7XG4gIGNvbnN0IHsgbWF4LCBhYnMgfSA9IE1hdGg7XG4gIGNvbnN0IGlzVGhyZXNob2xkRXhjZWVkZWQgPSBjb21wdXRlZCgoKSA9PiBtYXgoYWJzKGRpc3RhbmNlWC52YWx1ZSksIGFicyhkaXN0YW5jZVkudmFsdWUpKSA+PSB0aHJlc2hvbGQpO1xuICBjb25zdCBpc1N3aXBpbmcgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgaXNQb2ludGVyRG93biA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBkaXJlY3Rpb24gPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKCFpc1RocmVzaG9sZEV4Y2VlZGVkLnZhbHVlKVxuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIGlmIChhYnMoZGlzdGFuY2VYLnZhbHVlKSA+IGFicyhkaXN0YW5jZVkudmFsdWUpKSB7XG4gICAgICByZXR1cm4gZGlzdGFuY2VYLnZhbHVlID4gMCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlzdGFuY2VZLnZhbHVlID4gMCA/IFwidXBcIiA6IFwiZG93blwiO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGV2ZW50SXNBbGxvd2VkID0gKGUpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBpc1JlbGVhc2luZ0J1dHRvbiA9IGUuYnV0dG9ucyA9PT0gMDtcbiAgICBjb25zdCBpc1ByaW1hcnlCdXR0b24gPSBlLmJ1dHRvbnMgPT09IDE7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMucG9pbnRlclR5cGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoZS5wb2ludGVyVHlwZSkpICE9IG51bGwgPyBfYiA6IGlzUmVsZWFzaW5nQnV0dG9uIHx8IGlzUHJpbWFyeUJ1dHRvbikgIT0gbnVsbCA/IF9jIDogdHJ1ZTtcbiAgfTtcbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIGNvbnN0IHN0b3BzID0gW1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBvaW50ZXJkb3duXCIsIChlKSA9PiB7XG4gICAgICBpZiAoIWV2ZW50SXNBbGxvd2VkKGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpc1BvaW50ZXJEb3duLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICBldmVudFRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRUYXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuICAgICAgY29uc3QgeyBjbGllbnRYOiB4LCBjbGllbnRZOiB5IH0gPSBlO1xuICAgICAgdXBkYXRlUG9zU3RhcnQoeCwgeSk7XG4gICAgICB1cGRhdGVQb3NFbmQoeCwgeSk7XG4gICAgICBvblN3aXBlU3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3dpcGVTdGFydChlKTtcbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBvaW50ZXJtb3ZlXCIsIChlKSA9PiB7XG4gICAgICBpZiAoIWV2ZW50SXNBbGxvd2VkKGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIWlzUG9pbnRlckRvd24udmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgY2xpZW50WDogeCwgY2xpZW50WTogeSB9ID0gZTtcbiAgICAgIHVwZGF0ZVBvc0VuZCh4LCB5KTtcbiAgICAgIGlmICghaXNTd2lwaW5nLnZhbHVlICYmIGlzVGhyZXNob2xkRXhjZWVkZWQudmFsdWUpXG4gICAgICAgIGlzU3dpcGluZy52YWx1ZSA9IHRydWU7XG4gICAgICBpZiAoaXNTd2lwaW5nLnZhbHVlKVxuICAgICAgICBvblN3aXBlID09IG51bGwgPyB2b2lkIDAgOiBvblN3aXBlKGUpO1xuICAgIH0sIGxpc3RlbmVyT3B0aW9ucyksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwicG9pbnRlcnVwXCIsIChlKSA9PiB7XG4gICAgICBpZiAoIWV2ZW50SXNBbGxvd2VkKGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoaXNTd2lwaW5nLnZhbHVlKVxuICAgICAgICBvblN3aXBlRW5kID09IG51bGwgPyB2b2lkIDAgOiBvblN3aXBlRW5kKGUsIGRpcmVjdGlvbi52YWx1ZSk7XG4gICAgICBpc1BvaW50ZXJEb3duLnZhbHVlID0gZmFsc2U7XG4gICAgICBpc1N3aXBpbmcudmFsdWUgPSBmYWxzZTtcbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpXG4gIF07XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAoX2IgPSAoX2EgPSB0YXJnZXRSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNldFByb3BlcnR5KFwidG91Y2gtYWN0aW9uXCIsIFwicGFuLXlcIik7XG4gICAgaWYgKGRpc2FibGVUZXh0U2VsZWN0KSB7XG4gICAgICAoX2QgPSAoX2MgPSB0YXJnZXRSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnNldFByb3BlcnR5KFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiLCBcIm5vbmVcIik7XG4gICAgICAoX2YgPSAoX2UgPSB0YXJnZXRSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfZS5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnNldFByb3BlcnR5KFwiLW1zLXVzZXItc2VsZWN0XCIsIFwibm9uZVwiKTtcbiAgICAgIChfaCA9IChfZyA9IHRhcmdldFJlZi52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2guc2V0UHJvcGVydHkoXCJ1c2VyLXNlbGVjdFwiLCBcIm5vbmVcIik7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHN0b3BzLmZvckVhY2goKHMpID0+IHMoKSk7XG4gIHJldHVybiB7XG4gICAgaXNTd2lwaW5nOiByZWFkb25seShpc1N3aXBpbmcpLFxuICAgIGRpcmVjdGlvbjogcmVhZG9ubHkoZGlyZWN0aW9uKSxcbiAgICBwb3NTdGFydDogcmVhZG9ubHkocG9zU3RhcnQpLFxuICAgIHBvc0VuZDogcmVhZG9ubHkocG9zRW5kKSxcbiAgICBkaXN0YW5jZVgsXG4gICAgZGlzdGFuY2VZLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmVycmVkQ29sb3JTY2hlbWUob3B0aW9ucykge1xuICBjb25zdCBpc0xpZ2h0ID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHQpXCIsIG9wdGlvbnMpO1xuICBjb25zdCBpc0RhcmsgPSB1c2VNZWRpYVF1ZXJ5KFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoaXNEYXJrLnZhbHVlKVxuICAgICAgcmV0dXJuIFwiZGFya1wiO1xuICAgIGlmIChpc0xpZ2h0LnZhbHVlKVxuICAgICAgcmV0dXJuIFwibGlnaHRcIjtcbiAgICByZXR1cm4gXCJuby1wcmVmZXJlbmNlXCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWRDb250cmFzdChvcHRpb25zKSB7XG4gIGNvbnN0IGlzTW9yZSA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1jb250cmFzdDogbW9yZSlcIiwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzTGVzcyA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1jb250cmFzdDogbGVzcylcIiwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzQ3VzdG9tID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbnRyYXN0OiBjdXN0b20pXCIsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChpc01vcmUudmFsdWUpXG4gICAgICByZXR1cm4gXCJtb3JlXCI7XG4gICAgaWYgKGlzTGVzcy52YWx1ZSlcbiAgICAgIHJldHVybiBcImxlc3NcIjtcbiAgICBpZiAoaXNDdXN0b20udmFsdWUpXG4gICAgICByZXR1cm4gXCJjdXN0b21cIjtcbiAgICByZXR1cm4gXCJuby1wcmVmZXJlbmNlXCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWRMYW5ndWFnZXMob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgaWYgKCF3aW5kb3cpXG4gICAgcmV0dXJuIHJlZihbXCJlblwiXSk7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IHZhbHVlID0gcmVmKG5hdmlnYXRvci5sYW5ndWFnZXMpO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJsYW5ndWFnZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgdmFsdWUudmFsdWUgPSBuYXZpZ2F0b3IubGFuZ3VhZ2VzO1xuICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmVycmVkUmVkdWNlZE1vdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IGlzUmVkdWNlZCA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoaXNSZWR1Y2VkLnZhbHVlKVxuICAgICAgcmV0dXJuIFwicmVkdWNlXCI7XG4gICAgcmV0dXJuIFwibm8tcHJlZmVyZW5jZVwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmVycmVkUmVkdWNlZFRyYW5zcGFyZW5jeShvcHRpb25zKSB7XG4gIGNvbnN0IGlzUmVkdWNlZCA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1yZWR1Y2VkLXRyYW5zcGFyZW5jeTogcmVkdWNlKVwiLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoaXNSZWR1Y2VkLnZhbHVlKVxuICAgICAgcmV0dXJuIFwicmVkdWNlXCI7XG4gICAgcmV0dXJuIFwibm8tcHJlZmVyZW5jZVwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICBjb25zdCBwcmV2aW91cyA9IHNoYWxsb3dSZWYoaW5pdGlhbFZhbHVlKTtcbiAgd2F0Y2goXG4gICAgdG9SZWYodmFsdWUpLFxuICAgIChfLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgcHJldmlvdXMudmFsdWUgPSBvbGRWYWx1ZTtcbiAgICB9LFxuICAgIHsgZmx1c2g6IFwic3luY1wiIH1cbiAgKTtcbiAgcmV0dXJuIHJlYWRvbmx5KHByZXZpb3VzKTtcbn1cblxuY29uc3QgdG9wVmFyTmFtZSA9IFwiLS12dWV1c2Utc2FmZS1hcmVhLXRvcFwiO1xuY29uc3QgcmlnaHRWYXJOYW1lID0gXCItLXZ1ZXVzZS1zYWZlLWFyZWEtcmlnaHRcIjtcbmNvbnN0IGJvdHRvbVZhck5hbWUgPSBcIi0tdnVldXNlLXNhZmUtYXJlYS1ib3R0b21cIjtcbmNvbnN0IGxlZnRWYXJOYW1lID0gXCItLXZ1ZXVzZS1zYWZlLWFyZWEtbGVmdFwiO1xuZnVuY3Rpb24gdXNlU2NyZWVuU2FmZUFyZWEoKSB7XG4gIGNvbnN0IHRvcCA9IHNoYWxsb3dSZWYoXCJcIik7XG4gIGNvbnN0IHJpZ2h0ID0gc2hhbGxvd1JlZihcIlwiKTtcbiAgY29uc3QgYm90dG9tID0gc2hhbGxvd1JlZihcIlwiKTtcbiAgY29uc3QgbGVmdCA9IHNoYWxsb3dSZWYoXCJcIik7XG4gIGlmIChpc0NsaWVudCkge1xuICAgIGNvbnN0IHRvcENzc1ZhciA9IHVzZUNzc1Zhcih0b3BWYXJOYW1lKTtcbiAgICBjb25zdCByaWdodENzc1ZhciA9IHVzZUNzc1ZhcihyaWdodFZhck5hbWUpO1xuICAgIGNvbnN0IGJvdHRvbUNzc1ZhciA9IHVzZUNzc1Zhcihib3R0b21WYXJOYW1lKTtcbiAgICBjb25zdCBsZWZ0Q3NzVmFyID0gdXNlQ3NzVmFyKGxlZnRWYXJOYW1lKTtcbiAgICB0b3BDc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpXCI7XG4gICAgcmlnaHRDc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweClcIjtcbiAgICBib3R0b21Dc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpXCI7XG4gICAgbGVmdENzc1Zhci52YWx1ZSA9IFwiZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpXCI7XG4gICAgdHJ5T25Nb3VudGVkKHVwZGF0ZSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1c2VEZWJvdW5jZUZuKHVwZGF0ZSksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdG9wLnZhbHVlID0gZ2V0VmFsdWUodG9wVmFyTmFtZSk7XG4gICAgcmlnaHQudmFsdWUgPSBnZXRWYWx1ZShyaWdodFZhck5hbWUpO1xuICAgIGJvdHRvbS52YWx1ZSA9IGdldFZhbHVlKGJvdHRvbVZhck5hbWUpO1xuICAgIGxlZnQudmFsdWUgPSBnZXRWYWx1ZShsZWZ0VmFyTmFtZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgdXBkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShwb3NpdGlvbikge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiB1c2VTY3JpcHRUYWcoc3JjLCBvbkxvYWRlZCA9IG5vb3AsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBtYW51YWwgPSBmYWxzZSxcbiAgICB0eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIixcbiAgICBhc3luYyA9IHRydWUsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgcmVmZXJyZXJQb2xpY3ksXG4gICAgbm9Nb2R1bGUsXG4gICAgZGVmZXIsXG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgYXR0cnMgPSB7fSxcbiAgICBub25jZSA9IHZvaWQgMFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2NyaXB0VGFnID0gc2hhbGxvd1JlZihudWxsKTtcbiAgbGV0IF9wcm9taXNlID0gbnVsbDtcbiAgY29uc3QgbG9hZFNjcmlwdCA9ICh3YWl0Rm9yU2NyaXB0TG9hZCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVXaXRoRWxlbWVudCA9IChlbDIpID0+IHtcbiAgICAgIHNjcmlwdFRhZy52YWx1ZSA9IGVsMjtcbiAgICAgIHJlc29sdmUoZWwyKTtcbiAgICAgIHJldHVybiBlbDI7XG4gICAgfTtcbiAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNob3VsZEFwcGVuZCA9IGZhbHNlO1xuICAgIGxldCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmM9XCIke3RvVmFsdWUoc3JjKX1cIl1gKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICBlbC50eXBlID0gdHlwZTtcbiAgICAgIGVsLmFzeW5jID0gYXN5bmM7XG4gICAgICBlbC5zcmMgPSB0b1ZhbHVlKHNyYyk7XG4gICAgICBpZiAoZGVmZXIpXG4gICAgICAgIGVsLmRlZmVyID0gZGVmZXI7XG4gICAgICBpZiAoY3Jvc3NPcmlnaW4pXG4gICAgICAgIGVsLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICBpZiAobm9Nb2R1bGUpXG4gICAgICAgIGVsLm5vTW9kdWxlID0gbm9Nb2R1bGU7XG4gICAgICBpZiAocmVmZXJyZXJQb2xpY3kpXG4gICAgICAgIGVsLnJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3k7XG4gICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgZWwubm9uY2UgPSBub25jZTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKGF0dHJzKS5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSk7XG4gICAgICBzaG91bGRBcHBlbmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWwuaGFzQXR0cmlidXRlKFwiZGF0YS1sb2FkZWRcIikpIHtcbiAgICAgIHJlc29sdmVXaXRoRWxlbWVudChlbCk7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZWwsIFwiZXJyb3JcIiwgKGV2ZW50KSA9PiByZWplY3QoZXZlbnQpLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZWwsIFwiYWJvcnRcIiwgKGV2ZW50KSA9PiByZWplY3QoZXZlbnQpLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZWwsIFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWxvYWRlZFwiLCBcInRydWVcIik7XG4gICAgICBvbkxvYWRlZChlbCk7XG4gICAgICByZXNvbHZlV2l0aEVsZW1lbnQoZWwpO1xuICAgIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgaWYgKHNob3VsZEFwcGVuZClcbiAgICAgIGVsID0gZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlbCk7XG4gICAgaWYgKCF3YWl0Rm9yU2NyaXB0TG9hZClcbiAgICAgIHJlc29sdmVXaXRoRWxlbWVudChlbCk7XG4gIH0pO1xuICBjb25zdCBsb2FkID0gKHdhaXRGb3JTY3JpcHRMb2FkID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghX3Byb21pc2UpXG4gICAgICBfcHJvbWlzZSA9IGxvYWRTY3JpcHQod2FpdEZvclNjcmlwdExvYWQpO1xuICAgIHJldHVybiBfcHJvbWlzZTtcbiAgfTtcbiAgY29uc3QgdW5sb2FkID0gKCkgPT4ge1xuICAgIGlmICghZG9jdW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgX3Byb21pc2UgPSBudWxsO1xuICAgIGlmIChzY3JpcHRUYWcudmFsdWUpXG4gICAgICBzY3JpcHRUYWcudmFsdWUgPSBudWxsO1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyYz1cIiR7dG9WYWx1ZShzcmMpfVwiXWApO1xuICAgIGlmIChlbClcbiAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoZWwpO1xuICB9O1xuICBpZiAoaW1tZWRpYXRlICYmICFtYW51YWwpXG4gICAgdHJ5T25Nb3VudGVkKGxvYWQpO1xuICBpZiAoIW1hbnVhbClcbiAgICB0cnlPblVubW91bnRlZCh1bmxvYWQpO1xuICByZXR1cm4geyBzY3JpcHRUYWcsIGxvYWQsIHVubG9hZCB9O1xufVxuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93U2Nyb2xsKGVsZSkge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZSk7XG4gIGlmIChzdHlsZS5vdmVyZmxvd1ggPT09IFwic2Nyb2xsXCIgfHwgc3R5bGUub3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8IHN0eWxlLm92ZXJmbG93WCA9PT0gXCJhdXRvXCIgJiYgZWxlLmNsaWVudFdpZHRoIDwgZWxlLnNjcm9sbFdpZHRoIHx8IHN0eWxlLm92ZXJmbG93WSA9PT0gXCJhdXRvXCIgJiYgZWxlLmNsaWVudEhlaWdodCA8IGVsZS5zY3JvbGxIZWlnaHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbGUucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQudGFnTmFtZSA9PT0gXCJCT0RZXCIpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNoZWNrT3ZlcmZsb3dTY3JvbGwocGFyZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQocmF3RXZlbnQpIHtcbiAgY29uc3QgZSA9IHJhd0V2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgY29uc3QgX3RhcmdldCA9IGUudGFyZ2V0O1xuICBpZiAoY2hlY2tPdmVyZmxvd1Njcm9sbChfdGFyZ2V0KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBlbEluaXRpYWxPdmVyZmxvdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdXNlU2Nyb2xsTG9jayhlbGVtZW50LCBpbml0aWFsU3RhdGUgPSBmYWxzZSkge1xuICBjb25zdCBpc0xvY2tlZCA9IHNoYWxsb3dSZWYoaW5pdGlhbFN0YXRlKTtcbiAgbGV0IHN0b3BUb3VjaE1vdmVMaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpbml0aWFsT3ZlcmZsb3cgPSBcIlwiO1xuICB3YXRjaCh0b1JlZihlbGVtZW50KSwgKGVsKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gcmVzb2x2ZUVsZW1lbnQodG9WYWx1ZShlbCkpO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IGVsZSA9IHRhcmdldDtcbiAgICAgIGlmICghZWxJbml0aWFsT3ZlcmZsb3cuZ2V0KGVsZSkpXG4gICAgICAgIGVsSW5pdGlhbE92ZXJmbG93LnNldChlbGUsIGVsZS5zdHlsZS5vdmVyZmxvdyk7XG4gICAgICBpZiAoZWxlLnN0eWxlLm92ZXJmbG93ICE9PSBcImhpZGRlblwiKVxuICAgICAgICBpbml0aWFsT3ZlcmZsb3cgPSBlbGUuc3R5bGUub3ZlcmZsb3c7XG4gICAgICBpZiAoZWxlLnN0eWxlLm92ZXJmbG93ID09PSBcImhpZGRlblwiKVxuICAgICAgICByZXR1cm4gaXNMb2NrZWQudmFsdWUgPSB0cnVlO1xuICAgICAgaWYgKGlzTG9ja2VkLnZhbHVlKVxuICAgICAgICByZXR1cm4gZWxlLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWVcbiAgfSk7XG4gIGNvbnN0IGxvY2sgPSAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSByZXNvbHZlRWxlbWVudCh0b1ZhbHVlKGVsZW1lbnQpKTtcbiAgICBpZiAoIWVsIHx8IGlzTG9ja2VkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpc0lPUykge1xuICAgICAgc3RvcFRvdWNoTW92ZUxpc3RlbmVyID0gdXNlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgZWwsXG4gICAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgcGFzc2l2ZTogZmFsc2UgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIGlzTG9ja2VkLnZhbHVlID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgdW5sb2NrID0gKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gcmVzb2x2ZUVsZW1lbnQodG9WYWx1ZShlbGVtZW50KSk7XG4gICAgaWYgKCFlbCB8fCAhaXNMb2NrZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGlzSU9TKVxuICAgICAgc3RvcFRvdWNoTW92ZUxpc3RlbmVyID09IG51bGwgPyB2b2lkIDAgOiBzdG9wVG91Y2hNb3ZlTGlzdGVuZXIoKTtcbiAgICBlbC5zdHlsZS5vdmVyZmxvdyA9IGluaXRpYWxPdmVyZmxvdztcbiAgICBlbEluaXRpYWxPdmVyZmxvdy5kZWxldGUoZWwpO1xuICAgIGlzTG9ja2VkLnZhbHVlID0gZmFsc2U7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHVubG9jayk7XG4gIHJldHVybiBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGlzTG9ja2VkLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIGlmICh2KVxuICAgICAgICBsb2NrKCk7XG4gICAgICBlbHNlIHVubG9jaygpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVNlc3Npb25TdG9yYWdlKGtleSwgaW5pdGlhbFZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICByZXR1cm4gdXNlU3RvcmFnZShrZXksIGluaXRpYWxWYWx1ZSwgd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiB1c2VTaGFyZShzaGFyZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvciB9ID0gb3B0aW9ucztcbiAgY29uc3QgX25hdmlnYXRvciA9IG5hdmlnYXRvcjtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gX25hdmlnYXRvciAmJiBcImNhblNoYXJlXCIgaW4gX25hdmlnYXRvcik7XG4gIGNvbnN0IHNoYXJlID0gYXN5bmMgKG92ZXJyaWRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAuLi50b1ZhbHVlKHNoYXJlT3B0aW9ucyksXG4gICAgICAgIC4uLnRvVmFsdWUob3ZlcnJpZGVPcHRpb25zKVxuICAgICAgfTtcbiAgICAgIGxldCBncmFudGVkID0gdHJ1ZTtcbiAgICAgIGlmIChkYXRhLmZpbGVzICYmIF9uYXZpZ2F0b3IuY2FuU2hhcmUpXG4gICAgICAgIGdyYW50ZWQgPSBfbmF2aWdhdG9yLmNhblNoYXJlKHsgZmlsZXM6IGRhdGEuZmlsZXMgfSk7XG4gICAgICBpZiAoZ3JhbnRlZClcbiAgICAgICAgcmV0dXJuIF9uYXZpZ2F0b3Iuc2hhcmUoZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHNoYXJlXG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRTb3J0Rm4gPSAoc291cmNlLCBjb21wYXJlRm4pID0+IHNvdXJjZS5zb3J0KGNvbXBhcmVGbik7XG5jb25zdCBkZWZhdWx0Q29tcGFyZSA9IChhLCBiKSA9PiBhIC0gYjtcbmZ1bmN0aW9uIHVzZVNvcnRlZCguLi5hcmdzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgW3NvdXJjZV0gPSBhcmdzO1xuICBsZXQgY29tcGFyZUZuID0gZGVmYXVsdENvbXBhcmU7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgICBjb21wYXJlRm4gPSAoX2EgPSBvcHRpb25zLmNvbXBhcmVGbikgIT0gbnVsbCA/IF9hIDogZGVmYXVsdENvbXBhcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBhcmVGbiA9IChfYiA9IGFyZ3NbMV0pICE9IG51bGwgPyBfYiA6IGRlZmF1bHRDb21wYXJlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICBjb21wYXJlRm4gPSAoX2MgPSBhcmdzWzFdKSAhPSBudWxsID8gX2MgOiBkZWZhdWx0Q29tcGFyZTtcbiAgICBvcHRpb25zID0gKF9kID0gYXJnc1syXSkgIT0gbnVsbCA/IF9kIDoge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGRpcnR5ID0gZmFsc2UsXG4gICAgc29ydEZuID0gZGVmYXVsdFNvcnRGblxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFkaXJ0eSlcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gc29ydEZuKFsuLi50b1ZhbHVlKHNvdXJjZSldLCBjb21wYXJlRm4pKTtcbiAgd2F0Y2hFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNvcnRGbih0b1ZhbHVlKHNvdXJjZSksIGNvbXBhcmVGbik7XG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpXG4gICAgICBzb3VyY2UudmFsdWUgPSByZXN1bHQ7XG4gICAgZWxzZVxuICAgICAgc291cmNlLnNwbGljZSgwLCBzb3VyY2UubGVuZ3RoLCAuLi5yZXN1bHQpO1xuICB9KTtcbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZnVuY3Rpb24gdXNlU3BlZWNoUmVjb2duaXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcmltUmVzdWx0cyA9IHRydWUsXG4gICAgY29udGludW91cyA9IHRydWUsXG4gICAgbWF4QWx0ZXJuYXRpdmVzID0gMSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBsYW5nID0gdG9SZWYob3B0aW9ucy5sYW5nIHx8IFwiZW4tVVNcIik7XG4gIGNvbnN0IGlzTGlzdGVuaW5nID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGlzRmluYWwgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgcmVzdWx0ID0gc2hhbGxvd1JlZihcIlwiKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKHZvaWQgMCk7XG4gIGxldCByZWNvZ25pdGlvbjtcbiAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgaXNMaXN0ZW5pbmcudmFsdWUgPSB0cnVlO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGlzTGlzdGVuaW5nLnZhbHVlID0gZmFsc2U7XG4gIH07XG4gIGNvbnN0IHRvZ2dsZSA9ICh2YWx1ZSA9ICFpc0xpc3RlbmluZy52YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc3RhcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcCgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgU3BlZWNoUmVjb2duaXRpb24gPSB3aW5kb3cgJiYgKHdpbmRvdy5TcGVlY2hSZWNvZ25pdGlvbiB8fCB3aW5kb3cud2Via2l0U3BlZWNoUmVjb2duaXRpb24pO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBTcGVlY2hSZWNvZ25pdGlvbik7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIHJlY29nbml0aW9uID0gbmV3IFNwZWVjaFJlY29nbml0aW9uKCk7XG4gICAgcmVjb2duaXRpb24uY29udGludW91cyA9IGNvbnRpbnVvdXM7XG4gICAgcmVjb2duaXRpb24uaW50ZXJpbVJlc3VsdHMgPSBpbnRlcmltUmVzdWx0cztcbiAgICByZWNvZ25pdGlvbi5sYW5nID0gdG9WYWx1ZShsYW5nKTtcbiAgICByZWNvZ25pdGlvbi5tYXhBbHRlcm5hdGl2ZXMgPSBtYXhBbHRlcm5hdGl2ZXM7XG4gICAgcmVjb2duaXRpb24ub25zdGFydCA9ICgpID0+IHtcbiAgICAgIGlzTGlzdGVuaW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGlzRmluYWwudmFsdWUgPSBmYWxzZTtcbiAgICB9O1xuICAgIHdhdGNoKGxhbmcsIChsYW5nMikgPT4ge1xuICAgICAgaWYgKHJlY29nbml0aW9uICYmICFpc0xpc3RlbmluZy52YWx1ZSlcbiAgICAgICAgcmVjb2duaXRpb24ubGFuZyA9IGxhbmcyO1xuICAgIH0pO1xuICAgIHJlY29nbml0aW9uLm9ucmVzdWx0ID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UmVzdWx0ID0gZXZlbnQucmVzdWx0c1tldmVudC5yZXN1bHRJbmRleF07XG4gICAgICBjb25zdCB7IHRyYW5zY3JpcHQgfSA9IGN1cnJlbnRSZXN1bHRbMF07XG4gICAgICBpc0ZpbmFsLnZhbHVlID0gY3VycmVudFJlc3VsdC5pc0ZpbmFsO1xuICAgICAgcmVzdWx0LnZhbHVlID0gdHJhbnNjcmlwdDtcbiAgICAgIGVycm9yLnZhbHVlID0gdm9pZCAwO1xuICAgIH07XG4gICAgcmVjb2duaXRpb24ub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgZXJyb3IudmFsdWUgPSBldmVudDtcbiAgICB9O1xuICAgIHJlY29nbml0aW9uLm9uZW5kID0gKCkgPT4ge1xuICAgICAgaXNMaXN0ZW5pbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgIHJlY29nbml0aW9uLmxhbmcgPSB0b1ZhbHVlKGxhbmcpO1xuICAgIH07XG4gICAgd2F0Y2goaXNMaXN0ZW5pbmcsIChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChuZXdWYWx1ZSlcbiAgICAgICAgcmVjb2duaXRpb24uc3RhcnQoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVjb2duaXRpb24uc3RvcCgpO1xuICAgIH0pO1xuICB9XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBzdG9wKCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzTGlzdGVuaW5nLFxuICAgIGlzRmluYWwsXG4gICAgcmVjb2duaXRpb24sXG4gICAgcmVzdWx0LFxuICAgIGVycm9yLFxuICAgIHRvZ2dsZSxcbiAgICBzdGFydCxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNwZWVjaFN5bnRoZXNpcyh0ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBpdGNoID0gMSxcbiAgICByYXRlID0gMSxcbiAgICB2b2x1bWUgPSAxLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHN5bnRoID0gd2luZG93ICYmIHdpbmRvdy5zcGVlY2hTeW50aGVzaXM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHN5bnRoKTtcbiAgY29uc3QgaXNQbGF5aW5nID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHN0YXR1cyA9IHNoYWxsb3dSZWYoXCJpbml0XCIpO1xuICBjb25zdCBzcG9rZW5UZXh0ID0gdG9SZWYodGV4dCB8fCBcIlwiKTtcbiAgY29uc3QgbGFuZyA9IHRvUmVmKG9wdGlvbnMubGFuZyB8fCBcImVuLVVTXCIpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3QgdG9nZ2xlID0gKHZhbHVlID0gIWlzUGxheWluZy52YWx1ZSkgPT4ge1xuICAgIGlzUGxheWluZy52YWx1ZSA9IHZhbHVlO1xuICB9O1xuICBjb25zdCBiaW5kRXZlbnRzRm9yVXR0ZXJhbmNlID0gKHV0dGVyYW5jZTIpID0+IHtcbiAgICB1dHRlcmFuY2UyLmxhbmcgPSB0b1ZhbHVlKGxhbmcpO1xuICAgIHV0dGVyYW5jZTIudm9pY2UgPSB0b1ZhbHVlKG9wdGlvbnMudm9pY2UpIHx8IG51bGw7XG4gICAgdXR0ZXJhbmNlMi5waXRjaCA9IHRvVmFsdWUocGl0Y2gpO1xuICAgIHV0dGVyYW5jZTIucmF0ZSA9IHRvVmFsdWUocmF0ZSk7XG4gICAgdXR0ZXJhbmNlMi52b2x1bWUgPSB2b2x1bWU7XG4gICAgdXR0ZXJhbmNlMi5vbnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaXNQbGF5aW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwicGxheVwiO1xuICAgIH07XG4gICAgdXR0ZXJhbmNlMi5vbnBhdXNlID0gKCkgPT4ge1xuICAgICAgaXNQbGF5aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcInBhdXNlXCI7XG4gICAgfTtcbiAgICB1dHRlcmFuY2UyLm9ucmVzdW1lID0gKCkgPT4ge1xuICAgICAgaXNQbGF5aW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwicGxheVwiO1xuICAgIH07XG4gICAgdXR0ZXJhbmNlMi5vbmVuZCA9ICgpID0+IHtcbiAgICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJlbmRcIjtcbiAgICB9O1xuICAgIHV0dGVyYW5jZTIub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgZXJyb3IudmFsdWUgPSBldmVudDtcbiAgICB9O1xuICB9O1xuICBjb25zdCB1dHRlcmFuY2UgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaXNQbGF5aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgc3RhdHVzLnZhbHVlID0gXCJpbml0XCI7XG4gICAgY29uc3QgbmV3VXR0ZXJhbmNlID0gbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZShzcG9rZW5UZXh0LnZhbHVlKTtcbiAgICBiaW5kRXZlbnRzRm9yVXR0ZXJhbmNlKG5ld1V0dGVyYW5jZSk7XG4gICAgcmV0dXJuIG5ld1V0dGVyYW5jZTtcbiAgfSk7XG4gIGNvbnN0IHNwZWFrID0gKCkgPT4ge1xuICAgIHN5bnRoLmNhbmNlbCgpO1xuICAgIGlmICh1dHRlcmFuY2UpXG4gICAgICBzeW50aC5zcGVhayh1dHRlcmFuY2UudmFsdWUpO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIHN5bnRoLmNhbmNlbCgpO1xuICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICBiaW5kRXZlbnRzRm9yVXR0ZXJhbmNlKHV0dGVyYW5jZS52YWx1ZSk7XG4gICAgd2F0Y2gobGFuZywgKGxhbmcyKSA9PiB7XG4gICAgICBpZiAodXR0ZXJhbmNlLnZhbHVlICYmICFpc1BsYXlpbmcudmFsdWUpXG4gICAgICAgIHV0dGVyYW5jZS52YWx1ZS5sYW5nID0gbGFuZzI7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMudm9pY2UpIHtcbiAgICAgIHdhdGNoKG9wdGlvbnMudm9pY2UsICgpID0+IHtcbiAgICAgICAgc3ludGguY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgd2F0Y2goaXNQbGF5aW5nLCAoKSA9PiB7XG4gICAgICBpZiAoaXNQbGF5aW5nLnZhbHVlKVxuICAgICAgICBzeW50aC5yZXN1bWUoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3ludGgucGF1c2UoKTtcbiAgICB9KTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgaXNQbGF5aW5nLnZhbHVlID0gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzUGxheWluZyxcbiAgICBzdGF0dXMsXG4gICAgdXR0ZXJhbmNlLFxuICAgIGVycm9yLFxuICAgIHN0b3AsXG4gICAgdG9nZ2xlLFxuICAgIHNwZWFrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVN0ZXBwZXIoc3RlcHMsIGluaXRpYWxTdGVwKSB7XG4gIGNvbnN0IHN0ZXBzUmVmID0gcmVmKHN0ZXBzKTtcbiAgY29uc3Qgc3RlcE5hbWVzID0gY29tcHV0ZWQoKCkgPT4gQXJyYXkuaXNBcnJheShzdGVwc1JlZi52YWx1ZSkgPyBzdGVwc1JlZi52YWx1ZSA6IE9iamVjdC5rZXlzKHN0ZXBzUmVmLnZhbHVlKSk7XG4gIGNvbnN0IGluZGV4ID0gcmVmKHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKGluaXRpYWxTdGVwICE9IG51bGwgPyBpbml0aWFsU3RlcCA6IHN0ZXBOYW1lcy52YWx1ZVswXSkpO1xuICBjb25zdCBjdXJyZW50ID0gY29tcHV0ZWQoKCkgPT4gYXQoaW5kZXgudmFsdWUpKTtcbiAgY29uc3QgaXNGaXJzdCA9IGNvbXB1dGVkKCgpID0+IGluZGV4LnZhbHVlID09PSAwKTtcbiAgY29uc3QgaXNMYXN0ID0gY29tcHV0ZWQoKCkgPT4gaW5kZXgudmFsdWUgPT09IHN0ZXBOYW1lcy52YWx1ZS5sZW5ndGggLSAxKTtcbiAgY29uc3QgbmV4dCA9IGNvbXB1dGVkKCgpID0+IHN0ZXBOYW1lcy52YWx1ZVtpbmRleC52YWx1ZSArIDFdKTtcbiAgY29uc3QgcHJldmlvdXMgPSBjb21wdXRlZCgoKSA9PiBzdGVwTmFtZXMudmFsdWVbaW5kZXgudmFsdWUgLSAxXSk7XG4gIGZ1bmN0aW9uIGF0KGluZGV4Mikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0ZXBzUmVmLnZhbHVlKSlcbiAgICAgIHJldHVybiBzdGVwc1JlZi52YWx1ZVtpbmRleDJdO1xuICAgIHJldHVybiBzdGVwc1JlZi52YWx1ZVtzdGVwTmFtZXMudmFsdWVbaW5kZXgyXV07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KHN0ZXApIHtcbiAgICBpZiAoIXN0ZXBOYW1lcy52YWx1ZS5pbmNsdWRlcyhzdGVwKSlcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gYXQoc3RlcE5hbWVzLnZhbHVlLmluZGV4T2Yoc3RlcCkpO1xuICB9XG4gIGZ1bmN0aW9uIGdvVG8oc3RlcCkge1xuICAgIGlmIChzdGVwTmFtZXMudmFsdWUuaW5jbHVkZXMoc3RlcCkpXG4gICAgICBpbmRleC52YWx1ZSA9IHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApO1xuICB9XG4gIGZ1bmN0aW9uIGdvVG9OZXh0KCkge1xuICAgIGlmIChpc0xhc3QudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaW5kZXgudmFsdWUrKztcbiAgfVxuICBmdW5jdGlvbiBnb1RvUHJldmlvdXMoKSB7XG4gICAgaWYgKGlzRmlyc3QudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaW5kZXgudmFsdWUtLTtcbiAgfVxuICBmdW5jdGlvbiBnb0JhY2tUbyhzdGVwKSB7XG4gICAgaWYgKGlzQWZ0ZXIoc3RlcCkpXG4gICAgICBnb1RvKHN0ZXApO1xuICB9XG4gIGZ1bmN0aW9uIGlzTmV4dChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApID09PSBpbmRleC52YWx1ZSArIDE7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmV2aW91cyhzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApID09PSBpbmRleC52YWx1ZSAtIDE7XG4gIH1cbiAgZnVuY3Rpb24gaXNDdXJyZW50KHN0ZXApIHtcbiAgICByZXR1cm4gc3RlcE5hbWVzLnZhbHVlLmluZGV4T2Yoc3RlcCkgPT09IGluZGV4LnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQmVmb3JlKHN0ZXApIHtcbiAgICByZXR1cm4gaW5kZXgudmFsdWUgPCBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc0FmdGVyKHN0ZXApIHtcbiAgICByZXR1cm4gaW5kZXgudmFsdWUgPiBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXBzOiBzdGVwc1JlZixcbiAgICBzdGVwTmFtZXMsXG4gICAgaW5kZXgsXG4gICAgY3VycmVudCxcbiAgICBuZXh0LFxuICAgIHByZXZpb3VzLFxuICAgIGlzRmlyc3QsXG4gICAgaXNMYXN0LFxuICAgIGF0LFxuICAgIGdldCxcbiAgICBnb1RvLFxuICAgIGdvVG9OZXh0LFxuICAgIGdvVG9QcmV2aW91cyxcbiAgICBnb0JhY2tUbyxcbiAgICBpc05leHQsXG4gICAgaXNQcmV2aW91cyxcbiAgICBpc0N1cnJlbnQsXG4gICAgaXNCZWZvcmUsXG4gICAgaXNBZnRlclxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTdG9yYWdlQXN5bmMoa2V5LCBpbml0aWFsVmFsdWUsIHN0b3JhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBmbHVzaCA9IFwicHJlXCIsXG4gICAgZGVlcCA9IHRydWUsXG4gICAgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcyA9IHRydWUsXG4gICAgd3JpdGVEZWZhdWx0cyA9IHRydWUsXG4gICAgbWVyZ2VEZWZhdWx0cyA9IGZhbHNlLFxuICAgIHNoYWxsb3csXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBldmVudEZpbHRlcixcbiAgICBvbkVycm9yID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmF3SW5pdCA9IHRvVmFsdWUoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdHlwZSA9IGd1ZXNzU2VyaWFsaXplclR5cGUocmF3SW5pdCk7XG4gIGNvbnN0IGRhdGEgPSAoc2hhbGxvdyA/IHNoYWxsb3dSZWYgOiByZWYpKHRvVmFsdWUoaW5pdGlhbFZhbHVlKSk7XG4gIGNvbnN0IHNlcmlhbGl6ZXIgPSAoX2EgPSBvcHRpb25zLnNlcmlhbGl6ZXIpICE9IG51bGwgPyBfYSA6IFN0b3JhZ2VTZXJpYWxpemVyc1t0eXBlXTtcbiAgaWYgKCFzdG9yYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0b3JhZ2UgPSBnZXRTU1JIYW5kbGVyKFwiZ2V0RGVmYXVsdFN0b3JhZ2VBc3luY1wiLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gZGVmYXVsdFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5sb2NhbFN0b3JhZ2U7XG4gICAgICB9KSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICBpZiAoIXN0b3JhZ2UgfHwgZXZlbnQgJiYgZXZlbnQua2V5ICE9PSBrZXkpXG4gICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gZXZlbnQgPyBldmVudC5uZXdWYWx1ZSA6IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgaWYgKHJhd1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGF0YS52YWx1ZSA9IHJhd0luaXQ7XG4gICAgICAgIGlmICh3cml0ZURlZmF1bHRzICYmIHJhd0luaXQgIT09IG51bGwpXG4gICAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXRJdGVtKGtleSwgYXdhaXQgc2VyaWFsaXplci53cml0ZShyYXdJbml0KSk7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlRGVmYXVsdHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBzZXJpYWxpemVyLnJlYWQocmF3VmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIG1lcmdlRGVmYXVsdHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBkYXRhLnZhbHVlID0gbWVyZ2VEZWZhdWx0cyh2YWx1ZSwgcmF3SW5pdCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgIGRhdGEudmFsdWUgPSB7IC4uLnJhd0luaXQsIC4uLnZhbHVlIH07XG4gICAgICAgIGVsc2UgZGF0YS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS52YWx1ZSA9IGF3YWl0IHNlcmlhbGl6ZXIucmVhZChyYXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgcmVhZCgpO1xuICBpZiAod2luZG93ICYmIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwic3RvcmFnZVwiLCAoZSkgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiByZWFkKGUpKSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICBpZiAoc3RvcmFnZSkge1xuICAgIHdhdGNoV2l0aEZpbHRlcihcbiAgICAgIGRhdGEsXG4gICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0SXRlbShrZXksIGF3YWl0IHNlcmlhbGl6ZXIud3JpdGUoZGF0YS52YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZmx1c2gsXG4gICAgICAgIGRlZXAsXG4gICAgICAgIGV2ZW50RmlsdGVyXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxubGV0IF9pZCA9IDA7XG5mdW5jdGlvbiB1c2VTdHlsZVRhZyhjc3MsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBpc0xvYWRlZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBtYW51YWwgPSBmYWxzZSxcbiAgICBpZCA9IGB2dWV1c2Vfc3R5bGV0YWdfJHsrK19pZH1gXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjc3NSZWYgPSBzaGFsbG93UmVmKGNzcyk7XG4gIGxldCBzdG9wID0gKCkgPT4ge1xuICB9O1xuICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgIGlmICghZG9jdW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGlmICghZWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGVsLmlkID0gaWQ7XG4gICAgICBpZiAob3B0aW9ucy5ub25jZSlcbiAgICAgICAgZWwubm9uY2UgPSBvcHRpb25zLm5vbmNlO1xuICAgICAgaWYgKG9wdGlvbnMubWVkaWEpXG4gICAgICAgIGVsLm1lZGlhID0gb3B0aW9ucy5tZWRpYTtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBpZiAoaXNMb2FkZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RvcCA9IHdhdGNoKFxuICAgICAgY3NzUmVmLFxuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICAgICk7XG4gICAgaXNMb2FkZWQudmFsdWUgPSB0cnVlO1xuICB9O1xuICBjb25zdCB1bmxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudCB8fCAhaXNMb2FkZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RvcCgpO1xuICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpc0xvYWRlZC52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICBpZiAoaW1tZWRpYXRlICYmICFtYW51YWwpXG4gICAgdHJ5T25Nb3VudGVkKGxvYWQpO1xuICBpZiAoIW1hbnVhbClcbiAgICB0cnlPblNjb3BlRGlzcG9zZSh1bmxvYWQpO1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIGNzczogY3NzUmVmLFxuICAgIHVubG9hZCxcbiAgICBsb2FkLFxuICAgIGlzTG9hZGVkOiByZWFkb25seShpc0xvYWRlZClcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU3dpcGUodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRocmVzaG9sZCA9IDUwLFxuICAgIG9uU3dpcGUsXG4gICAgb25Td2lwZUVuZCxcbiAgICBvblN3aXBlU3RhcnQsXG4gICAgcGFzc2l2ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNvb3Jkc1N0YXJ0ID0gcmVhY3RpdmUoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCBjb29yZHNFbmQgPSByZWFjdGl2ZSh7IHg6IDAsIHk6IDAgfSk7XG4gIGNvbnN0IGRpZmZYID0gY29tcHV0ZWQoKCkgPT4gY29vcmRzU3RhcnQueCAtIGNvb3Jkc0VuZC54KTtcbiAgY29uc3QgZGlmZlkgPSBjb21wdXRlZCgoKSA9PiBjb29yZHNTdGFydC55IC0gY29vcmRzRW5kLnkpO1xuICBjb25zdCB7IG1heCwgYWJzIH0gPSBNYXRoO1xuICBjb25zdCBpc1RocmVzaG9sZEV4Y2VlZGVkID0gY29tcHV0ZWQoKCkgPT4gbWF4KGFicyhkaWZmWC52YWx1ZSksIGFicyhkaWZmWS52YWx1ZSkpID49IHRocmVzaG9sZCk7XG4gIGNvbnN0IGlzU3dpcGluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBkaXJlY3Rpb24gPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKCFpc1RocmVzaG9sZEV4Y2VlZGVkLnZhbHVlKVxuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIGlmIChhYnMoZGlmZlgudmFsdWUpID4gYWJzKGRpZmZZLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIGRpZmZYLnZhbHVlID4gMCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlmZlkudmFsdWUgPiAwID8gXCJ1cFwiIDogXCJkb3duXCI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZ2V0VG91Y2hFdmVudENvb3JkcyA9IChlKSA9PiBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXTtcbiAgY29uc3QgdXBkYXRlQ29vcmRzU3RhcnQgPSAoeCwgeSkgPT4ge1xuICAgIGNvb3Jkc1N0YXJ0LnggPSB4O1xuICAgIGNvb3Jkc1N0YXJ0LnkgPSB5O1xuICB9O1xuICBjb25zdCB1cGRhdGVDb29yZHNFbmQgPSAoeCwgeSkgPT4ge1xuICAgIGNvb3Jkc0VuZC54ID0geDtcbiAgICBjb29yZHNFbmQueSA9IHk7XG4gIH07XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZSwgY2FwdHVyZTogIXBhc3NpdmUgfTtcbiAgY29uc3Qgb25Ub3VjaEVuZCA9IChlKSA9PiB7XG4gICAgaWYgKGlzU3dpcGluZy52YWx1ZSlcbiAgICAgIG9uU3dpcGVFbmQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3dpcGVFbmQoZSwgZGlyZWN0aW9uLnZhbHVlKTtcbiAgICBpc1N3aXBpbmcudmFsdWUgPSBmYWxzZTtcbiAgfTtcbiAgY29uc3Qgc3RvcHMgPSBbXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidG91Y2hzdGFydFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGdldFRvdWNoRXZlbnRDb29yZHMoZSk7XG4gICAgICB1cGRhdGVDb29yZHNTdGFydCh4LCB5KTtcbiAgICAgIHVwZGF0ZUNvb3Jkc0VuZCh4LCB5KTtcbiAgICAgIG9uU3dpcGVTdGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZVN0YXJ0KGUpO1xuICAgIH0sIGxpc3RlbmVyT3B0aW9ucyksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidG91Y2htb3ZlXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgW3gsIHldID0gZ2V0VG91Y2hFdmVudENvb3JkcyhlKTtcbiAgICAgIHVwZGF0ZUNvb3Jkc0VuZCh4LCB5KTtcbiAgICAgIGlmIChsaXN0ZW5lck9wdGlvbnMuY2FwdHVyZSAmJiAhbGlzdGVuZXJPcHRpb25zLnBhc3NpdmUgJiYgTWF0aC5hYnMoZGlmZlgudmFsdWUpID4gTWF0aC5hYnMoZGlmZlkudmFsdWUpKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlzU3dpcGluZy52YWx1ZSAmJiBpc1RocmVzaG9sZEV4Y2VlZGVkLnZhbHVlKVxuICAgICAgICBpc1N3aXBpbmcudmFsdWUgPSB0cnVlO1xuICAgICAgaWYgKGlzU3dpcGluZy52YWx1ZSlcbiAgICAgICAgb25Td2lwZSA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZShlKTtcbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBbXCJ0b3VjaGVuZFwiLCBcInRvdWNoY2FuY2VsXCJdLCBvblRvdWNoRW5kLCBsaXN0ZW5lck9wdGlvbnMpXG4gIF07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiBzdG9wcy5mb3JFYWNoKChzKSA9PiBzKCkpO1xuICByZXR1cm4ge1xuICAgIGlzU3dpcGluZyxcbiAgICBkaXJlY3Rpb24sXG4gICAgY29vcmRzU3RhcnQsXG4gICAgY29vcmRzRW5kLFxuICAgIGxlbmd0aFg6IGRpZmZYLFxuICAgIGxlbmd0aFk6IGRpZmZZLFxuICAgIHN0b3AsXG4gICAgLy8gVE9ETzogUmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbiAgICBpc1Bhc3NpdmVFdmVudFN1cHBvcnRlZDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUZW1wbGF0ZVJlZnNMaXN0KCkge1xuICBjb25zdCByZWZzID0gcmVmKFtdKTtcbiAgcmVmcy52YWx1ZS5zZXQgPSAoZWwpID0+IHtcbiAgICBpZiAoZWwpXG4gICAgICByZWZzLnZhbHVlLnB1c2goZWwpO1xuICB9O1xuICBvbkJlZm9yZVVwZGF0ZSgoKSA9PiB7XG4gICAgcmVmcy52YWx1ZS5sZW5ndGggPSAwO1xuICB9KTtcbiAgcmV0dXJuIHJlZnM7XG59XG5cbmZ1bmN0aW9uIHVzZVRleHREaXJlY3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBzZWxlY3RvciA9IFwiaHRtbFwiLFxuICAgIG9ic2VydmUgPSBmYWxzZSxcbiAgICBpbml0aWFsVmFsdWUgPSBcImx0clwiXG4gIH0gPSBvcHRpb25zO1xuICBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRBdHRyaWJ1dGUoXCJkaXJcIikpICE9IG51bGwgPyBfYiA6IGluaXRpYWxWYWx1ZTtcbiAgfVxuICBjb25zdCBkaXIgPSByZWYoZ2V0VmFsdWUoKSk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiBkaXIudmFsdWUgPSBnZXRWYWx1ZSgpKTtcbiAgaWYgKG9ic2VydmUgJiYgZG9jdW1lbnQpIHtcbiAgICB1c2VNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gICAgICAoKSA9PiBkaXIudmFsdWUgPSBnZXRWYWx1ZSgpLFxuICAgICAgeyBhdHRyaWJ1dGVzOiB0cnVlIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGRpci52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgZGlyLnZhbHVlID0gdjtcbiAgICAgIGlmICghZG9jdW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChkaXIudmFsdWUpXG4gICAgICAgIChfYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0QXR0cmlidXRlKFwiZGlyXCIsIGRpci52YWx1ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIChfYiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2IucmVtb3ZlQXR0cmlidXRlKFwiZGlyXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlc0Zyb21TZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmFuZ2VDb3VudCA9IChfYSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50KSAhPSBudWxsID8gX2EgOiAwO1xuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogcmFuZ2VDb3VudCB9LCAoXywgaSkgPT4gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkpO1xufVxuZnVuY3Rpb24gdXNlVGV4dFNlbGVjdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHJlZihudWxsKTtcbiAgY29uc3QgdGV4dCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBzZWxlY3Rpb24udmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICB9KTtcbiAgY29uc3QgcmFuZ2VzID0gY29tcHV0ZWQoKCkgPT4gc2VsZWN0aW9uLnZhbHVlID8gZ2V0UmFuZ2VzRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24udmFsdWUpIDogW10pO1xuICBjb25zdCByZWN0cyA9IGNvbXB1dGVkKCgpID0+IHJhbmdlcy52YWx1ZS5tYXAoKHJhbmdlKSA9PiByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpO1xuICBmdW5jdGlvbiBvblNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBzZWxlY3Rpb24udmFsdWUgPSBudWxsO1xuICAgIGlmICh3aW5kb3cpXG4gICAgICBzZWxlY3Rpb24udmFsdWUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIH1cbiAgaWYgKHdpbmRvdylcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdy5kb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgb25TZWxlY3Rpb25DaGFuZ2UsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0LFxuICAgIHJlY3RzLFxuICAgIHJhbmdlcyxcbiAgICBzZWxlY3Rpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJ5UmVxdWVzdEFuaW1hdGlvbkZyYW1lKHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIGZuKSB7XG4gIGlmICh3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICB9IGVsc2Uge1xuICAgIGZuKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVRleHRhcmVhQXV0b3NpemUob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGV4dGFyZWEgPSB0b1JlZihvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmVsZW1lbnQpO1xuICBjb25zdCBpbnB1dCA9IHRvUmVmKChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5wdXQpICE9IG51bGwgPyBfYSA6IFwiXCIpO1xuICBjb25zdCBzdHlsZVByb3AgPSAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0eWxlUHJvcCkgIT0gbnVsbCA/IF9iIDogXCJoZWlnaHRcIjtcbiAgY29uc3QgdGV4dGFyZWFTY3JvbGxIZWlnaHQgPSBzaGFsbG93UmVmKDEpO1xuICBjb25zdCB0ZXh0YXJlYU9sZFdpZHRoID0gc2hhbGxvd1JlZigwKTtcbiAgZnVuY3Rpb24gdHJpZ2dlclJlc2l6ZSgpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghdGV4dGFyZWEudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGhlaWdodCA9IFwiXCI7XG4gICAgdGV4dGFyZWEudmFsdWUuc3R5bGVbc3R5bGVQcm9wXSA9IFwiMXB4XCI7XG4gICAgdGV4dGFyZWFTY3JvbGxIZWlnaHQudmFsdWUgPSAoX2EyID0gdGV4dGFyZWEudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Nyb2xsSGVpZ2h0O1xuICAgIGNvbnN0IF9zdHlsZVRhcmdldCA9IHRvVmFsdWUob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zdHlsZVRhcmdldCk7XG4gICAgaWYgKF9zdHlsZVRhcmdldClcbiAgICAgIF9zdHlsZVRhcmdldC5zdHlsZVtzdHlsZVByb3BdID0gYCR7dGV4dGFyZWFTY3JvbGxIZWlnaHQudmFsdWV9cHhgO1xuICAgIGVsc2VcbiAgICAgIGhlaWdodCA9IGAke3RleHRhcmVhU2Nyb2xsSGVpZ2h0LnZhbHVlfXB4YDtcbiAgICB0ZXh0YXJlYS52YWx1ZS5zdHlsZVtzdHlsZVByb3BdID0gaGVpZ2h0O1xuICB9XG4gIHdhdGNoKFtpbnB1dCwgdGV4dGFyZWFdLCAoKSA9PiBuZXh0VGljayh0cmlnZ2VyUmVzaXplKSwgeyBpbW1lZGlhdGU6IHRydWUgfSk7XG4gIHdhdGNoKHRleHRhcmVhU2Nyb2xsSGVpZ2h0LCAoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXNpemUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKTtcbiAgfSk7XG4gIHVzZVJlc2l6ZU9ic2VydmVyKHRleHRhcmVhLCAoW3sgY29udGVudFJlY3QgfV0pID0+IHtcbiAgICBpZiAodGV4dGFyZWFPbGRXaWR0aC52YWx1ZSA9PT0gY29udGVudFJlY3Qud2lkdGgpXG4gICAgICByZXR1cm47XG4gICAgdHJ5UmVxdWVzdEFuaW1hdGlvbkZyYW1lKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGV4dGFyZWFPbGRXaWR0aC52YWx1ZSA9IGNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgdHJpZ2dlclJlc2l6ZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMud2F0Y2gpXG4gICAgd2F0Y2gob3B0aW9ucy53YXRjaCwgdHJpZ2dlclJlc2l6ZSwgeyBpbW1lZGlhdGU6IHRydWUsIGRlZXA6IHRydWUgfSk7XG4gIHJldHVybiB7XG4gICAgdGV4dGFyZWEsXG4gICAgaW5wdXQsXG4gICAgdHJpZ2dlclJlc2l6ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUaHJvdHRsZWRSZWZIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgdGhyb3R0bGUgPSAyMDAsIHRyYWlsaW5nID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmlsdGVyID0gdGhyb3R0bGVGaWx0ZXIodGhyb3R0bGUsIHRyYWlsaW5nKTtcbiAgY29uc3QgaGlzdG9yeSA9IHVzZVJlZkhpc3Rvcnkoc291cmNlLCB7IC4uLm9wdGlvbnMsIGV2ZW50RmlsdGVyOiBmaWx0ZXIgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uaGlzdG9yeVxuICB9O1xufVxuXG5jb25zdCBERUZBVUxUX1VOSVRTID0gW1xuICB7IG1heDogNmU0LCB2YWx1ZTogMWUzLCBuYW1lOiBcInNlY29uZFwiIH0sXG4gIHsgbWF4OiAyNzZlNCwgdmFsdWU6IDZlNCwgbmFtZTogXCJtaW51dGVcIiB9LFxuICB7IG1heDogNzJlNiwgdmFsdWU6IDM2ZTUsIG5hbWU6IFwiaG91clwiIH0sXG4gIHsgbWF4OiA1MTg0ZTUsIHZhbHVlOiA4NjRlNSwgbmFtZTogXCJkYXlcIiB9LFxuICB7IG1heDogMjQxOTJlNSwgdmFsdWU6IDYwNDhlNSwgbmFtZTogXCJ3ZWVrXCIgfSxcbiAgeyBtYXg6IDI4NTEyZTYsIHZhbHVlOiAyNTkyZTYsIG5hbWU6IFwibW9udGhcIiB9LFxuICB7IG1heDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB2YWx1ZTogMzE1MzZlNiwgbmFtZTogXCJ5ZWFyXCIgfVxuXTtcbmNvbnN0IERFRkFVTFRfTUVTU0FHRVMgPSB7XG4gIGp1c3ROb3c6IFwianVzdCBub3dcIixcbiAgcGFzdDogKG4pID0+IG4ubWF0Y2goL1xcZC8pID8gYCR7bn0gYWdvYCA6IG4sXG4gIGZ1dHVyZTogKG4pID0+IG4ubWF0Y2goL1xcZC8pID8gYGluICR7bn1gIDogbixcbiAgbW9udGg6IChuLCBwYXN0KSA9PiBuID09PSAxID8gcGFzdCA/IFwibGFzdCBtb250aFwiIDogXCJuZXh0IG1vbnRoXCIgOiBgJHtufSBtb250aCR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgeWVhcjogKG4sIHBhc3QpID0+IG4gPT09IDEgPyBwYXN0ID8gXCJsYXN0IHllYXJcIiA6IFwibmV4dCB5ZWFyXCIgOiBgJHtufSB5ZWFyJHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICBkYXk6IChuLCBwYXN0KSA9PiBuID09PSAxID8gcGFzdCA/IFwieWVzdGVyZGF5XCIgOiBcInRvbW9ycm93XCIgOiBgJHtufSBkYXkke24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIHdlZWs6IChuLCBwYXN0KSA9PiBuID09PSAxID8gcGFzdCA/IFwibGFzdCB3ZWVrXCIgOiBcIm5leHQgd2Vla1wiIDogYCR7bn0gd2VlayR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgaG91cjogKG4pID0+IGAke259IGhvdXIke24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIG1pbnV0ZTogKG4pID0+IGAke259IG1pbnV0ZSR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgc2Vjb25kOiAobikgPT4gYCR7bn0gc2Vjb25kJHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICBpbnZhbGlkOiBcIlwiXG59O1xuZnVuY3Rpb24gREVGQVVMVF9GT1JNQVRURVIoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKTtcbn1cbmZ1bmN0aW9uIHVzZVRpbWVBZ28odGltZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBjb250cm9sczogZXhwb3NlQ29udHJvbHMgPSBmYWxzZSxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IDNlNFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBub3csIC4uLmNvbnRyb2xzIH0gPSB1c2VOb3coeyBpbnRlcnZhbDogdXBkYXRlSW50ZXJ2YWwsIGNvbnRyb2xzOiB0cnVlIH0pO1xuICBjb25zdCB0aW1lQWdvID0gY29tcHV0ZWQoKCkgPT4gZm9ybWF0VGltZUFnbyhuZXcgRGF0ZSh0b1ZhbHVlKHRpbWUpKSwgb3B0aW9ucywgdG9WYWx1ZShub3cpKSk7XG4gIGlmIChleHBvc2VDb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lQWdvLFxuICAgICAgLi4uY29udHJvbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aW1lQWdvO1xuICB9XG59XG5mdW5jdGlvbiBmb3JtYXRUaW1lQWdvKGZyb20sIG9wdGlvbnMgPSB7fSwgbm93ID0gRGF0ZS5ub3coKSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBtYXgsXG4gICAgbWVzc2FnZXMgPSBERUZBVUxUX01FU1NBR0VTLFxuICAgIGZ1bGxEYXRlRm9ybWF0dGVyID0gREVGQVVMVF9GT1JNQVRURVIsXG4gICAgdW5pdHMgPSBERUZBVUxUX1VOSVRTLFxuICAgIHNob3dTZWNvbmQgPSBmYWxzZSxcbiAgICByb3VuZGluZyA9IFwicm91bmRcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgcm91bmRGbiA9IHR5cGVvZiByb3VuZGluZyA9PT0gXCJudW1iZXJcIiA/IChuKSA9PiArbi50b0ZpeGVkKHJvdW5kaW5nKSA6IE1hdGhbcm91bmRpbmddO1xuICBjb25zdCBkaWZmID0gK25vdyAtICtmcm9tO1xuICBjb25zdCBhYnNEaWZmID0gTWF0aC5hYnMoZGlmZik7XG4gIGZ1bmN0aW9uIGdldFZhbHVlKGRpZmYyLCB1bml0KSB7XG4gICAgcmV0dXJuIHJvdW5kRm4oTWF0aC5hYnMoZGlmZjIpIC8gdW5pdC52YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0KGRpZmYyLCB1bml0KSB7XG4gICAgY29uc3QgdmFsID0gZ2V0VmFsdWUoZGlmZjIsIHVuaXQpO1xuICAgIGNvbnN0IHBhc3QgPSBkaWZmMiA+IDA7XG4gICAgY29uc3Qgc3RyID0gYXBwbHlGb3JtYXQodW5pdC5uYW1lLCB2YWwsIHBhc3QpO1xuICAgIHJldHVybiBhcHBseUZvcm1hdChwYXN0ID8gXCJwYXN0XCIgOiBcImZ1dHVyZVwiLCBzdHIsIHBhc3QpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5Rm9ybWF0KG5hbWUsIHZhbCwgaXNQYXN0KSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gbWVzc2FnZXNbbmFtZV07XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsLCBpc1Bhc3QpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucmVwbGFjZShcInswfVwiLCB2YWwudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKGFic0RpZmYgPCA2ZTQgJiYgIXNob3dTZWNvbmQpXG4gICAgcmV0dXJuIG1lc3NhZ2VzLmp1c3ROb3c7XG4gIGlmICh0eXBlb2YgbWF4ID09PSBcIm51bWJlclwiICYmIGFic0RpZmYgPiBtYXgpXG4gICAgcmV0dXJuIGZ1bGxEYXRlRm9ybWF0dGVyKG5ldyBEYXRlKGZyb20pKTtcbiAgaWYgKHR5cGVvZiBtYXggPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCB1bml0TWF4ID0gKF9hID0gdW5pdHMuZmluZCgoaSkgPT4gaS5uYW1lID09PSBtYXgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWF4O1xuICAgIGlmICh1bml0TWF4ICYmIGFic0RpZmYgPiB1bml0TWF4KVxuICAgICAgcmV0dXJuIGZ1bGxEYXRlRm9ybWF0dGVyKG5ldyBEYXRlKGZyb20pKTtcbiAgfVxuICBmb3IgKGNvbnN0IFtpZHgsIHVuaXRdIG9mIHVuaXRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IHZhbCA9IGdldFZhbHVlKGRpZmYsIHVuaXQpO1xuICAgIGlmICh2YWwgPD0gMCAmJiB1bml0c1tpZHggLSAxXSlcbiAgICAgIHJldHVybiBmb3JtYXQoZGlmZiwgdW5pdHNbaWR4IC0gMV0pO1xuICAgIGlmIChhYnNEaWZmIDwgdW5pdC5tYXgpXG4gICAgICByZXR1cm4gZm9ybWF0KGRpZmYsIHVuaXQpO1xuICB9XG4gIHJldHVybiBtZXNzYWdlcy5pbnZhbGlkO1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lb3V0UG9sbChmbiwgaW50ZXJ2YWwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBpbW1lZGlhdGVDYWxsYmFjayA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IHN0YXJ0IH0gPSB1c2VUaW1lb3V0Rm4obG9vcCwgaW50ZXJ2YWwsIHsgaW1tZWRpYXRlIH0pO1xuICBjb25zdCBpc0FjdGl2ZSA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBhc3luYyBmdW5jdGlvbiBsb29wKCkge1xuICAgIGlmICghaXNBY3RpdmUudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgZm4oKTtcbiAgICBzdGFydCgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBpZiAoIWlzQWN0aXZlLnZhbHVlKSB7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IHRydWU7XG4gICAgICBpZiAoaW1tZWRpYXRlQ2FsbGJhY2spXG4gICAgICAgIGZuKCk7XG4gICAgICBzdGFydCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpc0FjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpbW1lZGlhdGUgJiYgaXNDbGllbnQpXG4gICAgcmVzdW1lKCk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHBhdXNlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZSxcbiAgICBwYXVzZSxcbiAgICByZXN1bWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVGltZXN0YW1wKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHM6IGV4cG9zZUNvbnRyb2xzID0gZmFsc2UsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGludGVydmFsID0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICBjYWxsYmFja1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdHMgPSBzaGFsbG93UmVmKHRpbWVzdGFtcCgpICsgb2Zmc2V0KTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4gdHMudmFsdWUgPSB0aW1lc3RhbXAoKSArIG9mZnNldDtcbiAgY29uc3QgY2IgPSBjYWxsYmFjayA/ICgpID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgICBjYWxsYmFjayh0cy52YWx1ZSk7XG4gIH0gOiB1cGRhdGU7XG4gIGNvbnN0IGNvbnRyb2xzID0gaW50ZXJ2YWwgPT09IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIgPyB1c2VSYWZGbihjYiwgeyBpbW1lZGlhdGUgfSkgOiB1c2VJbnRlcnZhbEZuKGNiLCBpbnRlcnZhbCwgeyBpbW1lZGlhdGUgfSk7XG4gIGlmIChleHBvc2VDb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXA6IHRzLFxuICAgICAgLi4uY29udHJvbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cztcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VUaXRsZShuZXdUaXRsZSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50LFxuICAgIHJlc3RvcmVPblVubW91bnQgPSAodCkgPT4gdFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgb3JpZ2luYWxUaXRsZSA9IChfYSA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC50aXRsZSkgIT0gbnVsbCA/IF9hIDogXCJcIjtcbiAgY29uc3QgdGl0bGUgPSB0b1JlZigoX2IgPSBuZXdUaXRsZSAhPSBudWxsID8gbmV3VGl0bGUgOiBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQudGl0bGUpICE9IG51bGwgPyBfYiA6IG51bGwpO1xuICBjb25zdCBpc1JlYWRvbmx5ID0gISEobmV3VGl0bGUgJiYgdHlwZW9mIG5ld1RpdGxlID09PSBcImZ1bmN0aW9uXCIpO1xuICBmdW5jdGlvbiBmb3JtYXQodCkge1xuICAgIGlmICghKFwidGl0bGVUZW1wbGF0ZVwiIGluIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBvcHRpb25zLnRpdGxlVGVtcGxhdGUgfHwgXCIlc1wiO1xuICAgIHJldHVybiB0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHRlbXBsYXRlKHQpIDogdG9WYWx1ZSh0ZW1wbGF0ZSkucmVwbGFjZSgvJXMvZywgdCk7XG4gIH1cbiAgd2F0Y2goXG4gICAgdGl0bGUsXG4gICAgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSAmJiBkb2N1bWVudClcbiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSBmb3JtYXQobmV3VmFsdWUgIT0gbnVsbCA/IG5ld1ZhbHVlIDogXCJcIik7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIGlmIChvcHRpb25zLm9ic2VydmUgJiYgIW9wdGlvbnMudGl0bGVUZW1wbGF0ZSAmJiBkb2N1bWVudCAmJiAhaXNSZWFkb25seSkge1xuICAgIHVzZU11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICAoX2MgPSBkb2N1bWVudC5oZWFkKSA9PSBudWxsID8gdm9pZCAwIDogX2MucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQudGl0bGUgIT09IHRpdGxlLnZhbHVlKVxuICAgICAgICAgIHRpdGxlLnZhbHVlID0gZm9ybWF0KGRvY3VtZW50LnRpdGxlKTtcbiAgICAgIH0sXG4gICAgICB7IGNoaWxkTGlzdDogdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgaWYgKHJlc3RvcmVPblVubW91bnQpIHtcbiAgICAgIGNvbnN0IHJlc3RvcmVkVGl0bGUgPSByZXN0b3JlT25Vbm1vdW50KG9yaWdpbmFsVGl0bGUsIHRpdGxlLnZhbHVlIHx8IFwiXCIpO1xuICAgICAgaWYgKHJlc3RvcmVkVGl0bGUgIT0gbnVsbCAmJiBkb2N1bWVudClcbiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSByZXN0b3JlZFRpdGxlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aXRsZTtcbn1cblxuY29uc3QgX1RyYW5zaXRpb25QcmVzZXRzID0ge1xuICBlYXNlSW5TaW5lOiBbMC4xMiwgMCwgMC4zOSwgMF0sXG4gIGVhc2VPdXRTaW5lOiBbMC42MSwgMSwgMC44OCwgMV0sXG4gIGVhc2VJbk91dFNpbmU6IFswLjM3LCAwLCAwLjYzLCAxXSxcbiAgZWFzZUluUXVhZDogWzAuMTEsIDAsIDAuNSwgMF0sXG4gIGVhc2VPdXRRdWFkOiBbMC41LCAxLCAwLjg5LCAxXSxcbiAgZWFzZUluT3V0UXVhZDogWzAuNDUsIDAsIDAuNTUsIDFdLFxuICBlYXNlSW5DdWJpYzogWzAuMzIsIDAsIDAuNjcsIDBdLFxuICBlYXNlT3V0Q3ViaWM6IFswLjMzLCAxLCAwLjY4LCAxXSxcbiAgZWFzZUluT3V0Q3ViaWM6IFswLjY1LCAwLCAwLjM1LCAxXSxcbiAgZWFzZUluUXVhcnQ6IFswLjUsIDAsIDAuNzUsIDBdLFxuICBlYXNlT3V0UXVhcnQ6IFswLjI1LCAxLCAwLjUsIDFdLFxuICBlYXNlSW5PdXRRdWFydDogWzAuNzYsIDAsIDAuMjQsIDFdLFxuICBlYXNlSW5RdWludDogWzAuNjQsIDAsIDAuNzgsIDBdLFxuICBlYXNlT3V0UXVpbnQ6IFswLjIyLCAxLCAwLjM2LCAxXSxcbiAgZWFzZUluT3V0UXVpbnQ6IFswLjgzLCAwLCAwLjE3LCAxXSxcbiAgZWFzZUluRXhwbzogWzAuNywgMCwgMC44NCwgMF0sXG4gIGVhc2VPdXRFeHBvOiBbMC4xNiwgMSwgMC4zLCAxXSxcbiAgZWFzZUluT3V0RXhwbzogWzAuODcsIDAsIDAuMTMsIDFdLFxuICBlYXNlSW5DaXJjOiBbMC41NSwgMCwgMSwgMC40NV0sXG4gIGVhc2VPdXRDaXJjOiBbMCwgMC41NSwgMC40NSwgMV0sXG4gIGVhc2VJbk91dENpcmM6IFswLjg1LCAwLCAwLjE1LCAxXSxcbiAgZWFzZUluQmFjazogWzAuMzYsIDAsIDAuNjYsIC0wLjU2XSxcbiAgZWFzZU91dEJhY2s6IFswLjM0LCAxLjU2LCAwLjY0LCAxXSxcbiAgZWFzZUluT3V0QmFjazogWzAuNjgsIC0wLjYsIDAuMzIsIDEuNl1cbn07XG5jb25zdCBUcmFuc2l0aW9uUHJlc2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKHt9LCB7IGxpbmVhcjogaWRlbnRpdHkgfSwgX1RyYW5zaXRpb25QcmVzZXRzKTtcbmZ1bmN0aW9uIGNyZWF0ZUVhc2luZ0Z1bmN0aW9uKFtwMCwgcDEsIHAyLCBwM10pIHtcbiAgY29uc3QgYSA9IChhMSwgYTIpID0+IDEgLSAzICogYTIgKyAzICogYTE7XG4gIGNvbnN0IGIgPSAoYTEsIGEyKSA9PiAzICogYTIgLSA2ICogYTE7XG4gIGNvbnN0IGMgPSAoYTEpID0+IDMgKiBhMTtcbiAgY29uc3QgY2FsY0JlemllciA9ICh0LCBhMSwgYTIpID0+ICgoYShhMSwgYTIpICogdCArIGIoYTEsIGEyKSkgKiB0ICsgYyhhMSkpICogdDtcbiAgY29uc3QgZ2V0U2xvcGUgPSAodCwgYTEsIGEyKSA9PiAzICogYShhMSwgYTIpICogdCAqIHQgKyAyICogYihhMSwgYTIpICogdCArIGMoYTEpO1xuICBjb25zdCBnZXRUZm9yWCA9ICh4KSA9PiB7XG4gICAgbGV0IGFHdWVzc1QgPSB4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBjb25zdCBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBwMCwgcDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgcDAsIHAyKSAtIHg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfTtcbiAgcmV0dXJuICh4KSA9PiBwMCA9PT0gcDEgJiYgcDIgPT09IHAzID8geCA6IGNhbGNCZXppZXIoZ2V0VGZvclgoeCksIHAxLCBwMyk7XG59XG5mdW5jdGlvbiBsZXJwKGEsIGIsIGFscGhhKSB7XG4gIHJldHVybiBhICsgYWxwaGEgKiAoYiAtIGEpO1xufVxuZnVuY3Rpb24gdG9WZWModCkge1xuICByZXR1cm4gKHR5cGVvZiB0ID09PSBcIm51bWJlclwiID8gW3RdIDogdCkgfHwgW107XG59XG5mdW5jdGlvbiBleGVjdXRlVHJhbnNpdGlvbihzb3VyY2UsIGZyb20sIHRvLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZnJvbVZhbCA9IHRvVmFsdWUoZnJvbSk7XG4gIGNvbnN0IHRvVmFsID0gdG9WYWx1ZSh0byk7XG4gIGNvbnN0IHYxID0gdG9WZWMoZnJvbVZhbCk7XG4gIGNvbnN0IHYyID0gdG9WZWModG9WYWwpO1xuICBjb25zdCBkdXJhdGlvbiA9IChfYSA9IHRvVmFsdWUob3B0aW9ucy5kdXJhdGlvbikpICE9IG51bGwgPyBfYSA6IDFlMztcbiAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgZW5kQXQgPSBEYXRlLm5vdygpICsgZHVyYXRpb247XG4gIGNvbnN0IHRyYW5zID0gdHlwZW9mIG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy50cmFuc2l0aW9uIDogKF9iID0gdG9WYWx1ZShvcHRpb25zLnRyYW5zaXRpb24pKSAhPSBudWxsID8gX2IgOiBpZGVudGl0eTtcbiAgY29uc3QgZWFzZSA9IHR5cGVvZiB0cmFucyA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnMgOiBjcmVhdGVFYXNpbmdGdW5jdGlvbih0cmFucyk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHNvdXJjZS52YWx1ZSA9IGZyb21WYWw7XG4gICAgY29uc3QgdGljayA9ICgpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoKF9hMiA9IG9wdGlvbnMuYWJvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBhbHBoYSA9IGVhc2UoKG5vdyAtIHN0YXJ0ZWRBdCkgLyBkdXJhdGlvbik7XG4gICAgICBjb25zdCBhcnIgPSB0b1ZlYyhzb3VyY2UudmFsdWUpLm1hcCgobiwgaSkgPT4gbGVycCh2MVtpXSwgdjJbaV0sIGFscGhhKSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UudmFsdWUpKVxuICAgICAgICBzb3VyY2UudmFsdWUgPSBhcnIubWFwKChuLCBpKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMywgX2IyO1xuICAgICAgICAgIHJldHVybiBsZXJwKChfYTMgPSB2MVtpXSkgIT0gbnVsbCA/IF9hMyA6IDAsIChfYjIgPSB2MltpXSkgIT0gbnVsbCA/IF9iMiA6IDAsIGFscGhhKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlLnZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICBzb3VyY2UudmFsdWUgPSBhcnJbMF07XG4gICAgICBpZiAobm93IDwgZW5kQXQpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlLnZhbHVlID0gdG9WYWw7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRpY2soKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjdXJyZW50SWQgPSAwO1xuICBjb25zdCBzb3VyY2VWYWwgPSAoKSA9PiB7XG4gICAgY29uc3QgdiA9IHRvVmFsdWUoc291cmNlKTtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyB2IDogdi5tYXAodG9WYWx1ZSk7XG4gIH07XG4gIGNvbnN0IG91dHB1dFJlZiA9IHJlZihzb3VyY2VWYWwoKSk7XG4gIHdhdGNoKHNvdXJjZVZhbCwgYXN5bmMgKHRvKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodG9WYWx1ZShvcHRpb25zLmRpc2FibGVkKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpZCA9ICsrY3VycmVudElkO1xuICAgIGlmIChvcHRpb25zLmRlbGF5KVxuICAgICAgYXdhaXQgcHJvbWlzZVRpbWVvdXQodG9WYWx1ZShvcHRpb25zLmRlbGF5KSk7XG4gICAgaWYgKGlkICE9PSBjdXJyZW50SWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdG9WYWwgPSBBcnJheS5pc0FycmF5KHRvKSA/IHRvLm1hcCh0b1ZhbHVlKSA6IHRvVmFsdWUodG8pO1xuICAgIChfYSA9IG9wdGlvbnMub25TdGFydGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zKTtcbiAgICBhd2FpdCBleGVjdXRlVHJhbnNpdGlvbihvdXRwdXRSZWYsIG91dHB1dFJlZi52YWx1ZSwgdG9WYWwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gaWQgIT09IGN1cnJlbnRJZCB8fCAoKF9hMiA9IG9wdGlvbnMuYWJvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgKF9iID0gb3B0aW9ucy5vbkZpbmlzaGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zKTtcbiAgfSwgeyBkZWVwOiB0cnVlIH0pO1xuICB3YXRjaCgoKSA9PiB0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpLCAoZGlzYWJsZWQpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIGN1cnJlbnRJZCsrO1xuICAgICAgb3V0cHV0UmVmLnZhbHVlID0gc291cmNlVmFsKCk7XG4gICAgfVxuICB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIGN1cnJlbnRJZCsrO1xuICB9KTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUob3B0aW9ucy5kaXNhYmxlZCkgPyBzb3VyY2VWYWwoKSA6IG91dHB1dFJlZi52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVVybFNlYXJjaFBhcmFtcyhtb2RlID0gXCJoaXN0b3J5XCIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW5pdGlhbFZhbHVlID0ge30sXG4gICAgcmVtb3ZlTnVsbGlzaFZhbHVlcyA9IHRydWUsXG4gICAgcmVtb3ZlRmFsc3lWYWx1ZXMgPSBmYWxzZSxcbiAgICB3cml0ZTogZW5hYmxlV3JpdGUgPSB0cnVlLFxuICAgIHdyaXRlTW9kZSA9IFwicmVwbGFjZVwiLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgc3RyaW5naWZ5ID0gKHBhcmFtcykgPT4gcGFyYW1zLnRvU3RyaW5nKClcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93KVxuICAgIHJldHVybiByZWFjdGl2ZShpbml0aWFsVmFsdWUpO1xuICBjb25zdCBzdGF0ZSA9IHJlYWN0aXZlKHt9KTtcbiAgZnVuY3Rpb24gZ2V0UmF3UGFyYW1zKCkge1xuICAgIGlmIChtb2RlID09PSBcImhpc3RvcnlcIikge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiaGFzaFwiKSB7XG4gICAgICBjb25zdCBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2ggfHwgXCJcIjtcbiAgICAgIGNvbnN0IGluZGV4ID0gaGFzaC5pbmRleE9mKFwiP1wiKTtcbiAgICAgIHJldHVybiBpbmRleCA+IDAgPyBoYXNoLnNsaWNlKGluZGV4KSA6IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAod2luZG93LmxvY2F0aW9uLmhhc2ggfHwgXCJcIikucmVwbGFjZSgvXiMvLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29uc3RydWN0UXVlcnkocGFyYW1zKSB7XG4gICAgY29uc3Qgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnkocGFyYW1zKTtcbiAgICBpZiAobW9kZSA9PT0gXCJoaXN0b3J5XCIpXG4gICAgICByZXR1cm4gYCR7c3RyaW5naWZpZWQgPyBgPyR7c3RyaW5naWZpZWR9YCA6IFwiXCJ9JHt3aW5kb3cubG9jYXRpb24uaGFzaCB8fCBcIlwifWA7XG4gICAgaWYgKG1vZGUgPT09IFwiaGFzaC1wYXJhbXNcIilcbiAgICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8IFwiXCJ9JHtzdHJpbmdpZmllZCA/IGAjJHtzdHJpbmdpZmllZH1gIDogXCJcIn1gO1xuICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaCB8fCBcIiNcIjtcbiAgICBjb25zdCBpbmRleCA9IGhhc2guaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKGluZGV4ID4gMClcbiAgICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8IFwiXCJ9JHtoYXNoLnNsaWNlKDAsIGluZGV4KX0ke3N0cmluZ2lmaWVkID8gYD8ke3N0cmluZ2lmaWVkfWAgOiBcIlwifWA7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIn0ke2hhc2h9JHtzdHJpbmdpZmllZCA/IGA/JHtzdHJpbmdpZmllZH1gIDogXCJcIn1gO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoZ2V0UmF3UGFyYW1zKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHVudXNlZEtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHN0YXRlKSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGFyYW1zLmtleXMoKSkge1xuICAgICAgY29uc3QgcGFyYW1zRm9yS2V5ID0gcGFyYW1zLmdldEFsbChrZXkpO1xuICAgICAgc3RhdGVba2V5XSA9IHBhcmFtc0ZvcktleS5sZW5ndGggPiAxID8gcGFyYW1zRm9yS2V5IDogcGFyYW1zLmdldChrZXkpIHx8IFwiXCI7XG4gICAgICB1bnVzZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBBcnJheS5mcm9tKHVudXNlZEtleXMpLmZvckVhY2goKGtleSkgPT4gZGVsZXRlIHN0YXRlW2tleV0pO1xuICB9XG4gIGNvbnN0IHsgcGF1c2UsIHJlc3VtZSB9ID0gcGF1c2FibGVXYXRjaChcbiAgICBzdGF0ZSxcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFwiXCIpO1xuICAgICAgT2JqZWN0LmtleXMoc3RhdGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHN0YXRlW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hcEVudHJ5KSlcbiAgICAgICAgICBtYXBFbnRyeS5mb3JFYWNoKCh2YWx1ZSkgPT4gcGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlbW92ZU51bGxpc2hWYWx1ZXMgJiYgbWFwRW50cnkgPT0gbnVsbClcbiAgICAgICAgICBwYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2UgaWYgKHJlbW92ZUZhbHN5VmFsdWVzICYmICFtYXBFbnRyeSlcbiAgICAgICAgICBwYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwYXJhbXMuc2V0KGtleSwgbWFwRW50cnkpO1xuICAgICAgfSk7XG4gICAgICB3cml0ZShwYXJhbXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIHsgZGVlcDogdHJ1ZSB9XG4gICk7XG4gIGZ1bmN0aW9uIHdyaXRlKHBhcmFtcywgc2hvdWxkVXBkYXRlKSB7XG4gICAgcGF1c2UoKTtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKVxuICAgICAgdXBkYXRlU3RhdGUocGFyYW1zKTtcbiAgICBpZiAod3JpdGVNb2RlID09PSBcInJlcGxhY2VcIikge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5zdGF0ZSxcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnRpdGxlLFxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyBjb25zdHJ1Y3RRdWVyeShwYXJhbXMpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnN0YXRlLFxuICAgICAgICB3aW5kb3cuZG9jdW1lbnQudGl0bGUsXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIGNvbnN0cnVjdFF1ZXJ5KHBhcmFtcylcbiAgICAgICk7XG4gICAgfVxuICAgIHJlc3VtZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG9uQ2hhbmdlZCgpIHtcbiAgICBpZiAoIWVuYWJsZVdyaXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHdyaXRlKHJlYWQoKSwgdHJ1ZSk7XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInBvcHN0YXRlXCIsIG9uQ2hhbmdlZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgaWYgKG1vZGUgIT09IFwiaGlzdG9yeVwiKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImhhc2hjaGFuZ2VcIiwgb25DaGFuZ2VkLCBsaXN0ZW5lck9wdGlvbnMpO1xuICBjb25zdCBpbml0aWFsID0gcmVhZCgpO1xuICBpZiAoaW5pdGlhbC5rZXlzKCkubmV4dCgpLnZhbHVlKVxuICAgIHVwZGF0ZVN0YXRlKGluaXRpYWwpO1xuICBlbHNlXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwgaW5pdGlhbFZhbHVlKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VVc2VyTWVkaWEob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGVuYWJsZWQgPSBzaGFsbG93UmVmKChfYSA9IG9wdGlvbnMuZW5hYmxlZCkgIT0gbnVsbCA/IF9hIDogZmFsc2UpO1xuICBjb25zdCBhdXRvU3dpdGNoID0gc2hhbGxvd1JlZigoX2IgPSBvcHRpb25zLmF1dG9Td2l0Y2gpICE9IG51bGwgPyBfYiA6IHRydWUpO1xuICBjb25zdCBjb25zdHJhaW50cyA9IHJlZihvcHRpb25zLmNvbnN0cmFpbnRzKTtcbiAgY29uc3QgeyBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRVc2VyTWVkaWE7XG4gIH0pO1xuICBjb25zdCBzdHJlYW0gPSBzaGFsbG93UmVmKCk7XG4gIGZ1bmN0aW9uIGdldERldmljZU9wdGlvbnModHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInZpZGVvXCI6IHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnZhbHVlKVxuICAgICAgICAgIHJldHVybiBjb25zdHJhaW50cy52YWx1ZS52aWRlbyB8fCBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXVkaW9cIjoge1xuICAgICAgICBpZiAoY29uc3RyYWludHMudmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzLnZhbHVlLmF1ZGlvIHx8IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gX3N0YXJ0KCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgc3RyZWFtLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHN0cmVhbS52YWx1ZSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgIHZpZGVvOiBnZXREZXZpY2VPcHRpb25zKFwidmlkZW9cIiksXG4gICAgICBhdWRpbzogZ2V0RGV2aWNlT3B0aW9ucyhcImF1ZGlvXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbS52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBfc3RvcCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIChfYTIgPSBzdHJlYW0udmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdC5zdG9wKCkpO1xuICAgIHN0cmVhbS52YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIF9zdG9wKCk7XG4gICAgZW5hYmxlZC52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGF3YWl0IF9zdGFydCgpO1xuICAgIGlmIChzdHJlYW0udmFsdWUpXG4gICAgICBlbmFibGVkLnZhbHVlID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RyZWFtLnZhbHVlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgX3N0b3AoKTtcbiAgICByZXR1cm4gYXdhaXQgc3RhcnQoKTtcbiAgfVxuICB3YXRjaChcbiAgICBlbmFibGVkLFxuICAgICh2KSA9PiB7XG4gICAgICBpZiAodilcbiAgICAgICAgX3N0YXJ0KCk7XG4gICAgICBlbHNlIF9zdG9wKCk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHdhdGNoKFxuICAgIGNvbnN0cmFpbnRzLFxuICAgICgpID0+IHtcbiAgICAgIGlmIChhdXRvU3dpdGNoLnZhbHVlICYmIHN0cmVhbS52YWx1ZSlcbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgc3RvcCgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBzdHJlYW0sXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICByZXN0YXJ0LFxuICAgIGNvbnN0cmFpbnRzLFxuICAgIGVuYWJsZWQsXG4gICAgYXV0b1N3aXRjaFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VWTW9kZWwocHJvcHMsIGtleSwgZW1pdCwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCB7XG4gICAgY2xvbmUgPSBmYWxzZSxcbiAgICBwYXNzaXZlID0gZmFsc2UsXG4gICAgZXZlbnROYW1lLFxuICAgIGRlZXAgPSBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWUsXG4gICAgc2hvdWxkRW1pdFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgdm0gPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgX2VtaXQgPSBlbWl0IHx8ICh2bSA9PSBudWxsID8gdm9pZCAwIDogdm0uZW1pdCkgfHwgKChfYSA9IHZtID09IG51bGwgPyB2b2lkIDAgOiB2bS4kZW1pdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJpbmQodm0pKSB8fCAoKF9jID0gKF9iID0gdm0gPT0gbnVsbCA/IHZvaWQgMCA6IHZtLnByb3h5KSA9PSBudWxsID8gdm9pZCAwIDogX2IuJGVtaXQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5iaW5kKHZtID09IG51bGwgPyB2b2lkIDAgOiB2bS5wcm94eSkpO1xuICBsZXQgZXZlbnQgPSBldmVudE5hbWU7XG4gIGlmICgha2V5KSB7XG4gICAga2V5ID0gXCJtb2RlbFZhbHVlXCI7XG4gIH1cbiAgZXZlbnQgPSBldmVudCB8fCBgdXBkYXRlOiR7a2V5LnRvU3RyaW5nKCl9YDtcbiAgY29uc3QgY2xvbmVGbiA9ICh2YWwpID0+ICFjbG9uZSA/IHZhbCA6IHR5cGVvZiBjbG9uZSA9PT0gXCJmdW5jdGlvblwiID8gY2xvbmUodmFsKSA6IGNsb25lRm5KU09OKHZhbCk7XG4gIGNvbnN0IGdldFZhbHVlID0gKCkgPT4gaXNEZWYocHJvcHNba2V5XSkgPyBjbG9uZUZuKHByb3BzW2tleV0pIDogZGVmYXVsdFZhbHVlO1xuICBjb25zdCB0cmlnZ2VyRW1pdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICBpZiAoc2hvdWxkRW1pdCh2YWx1ZSkpXG4gICAgICAgIF9lbWl0KGV2ZW50LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9lbWl0KGV2ZW50LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBpZiAocGFzc2l2ZSkge1xuICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldFZhbHVlKCk7XG4gICAgY29uc3QgcHJveHkgPSByZWYoaW5pdGlhbFZhbHVlKTtcbiAgICBsZXQgaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gcHJvcHNba2V5XSxcbiAgICAgICh2KSA9PiB7XG4gICAgICAgIGlmICghaXNVcGRhdGluZykge1xuICAgICAgICAgIGlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHByb3h5LnZhbHVlID0gY2xvbmVGbih2KTtcbiAgICAgICAgICBuZXh0VGljaygoKSA9PiBpc1VwZGF0aW5nID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB3YXRjaChcbiAgICAgIHByb3h5LFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgaWYgKCFpc1VwZGF0aW5nICYmICh2ICE9PSBwcm9wc1trZXldIHx8IGRlZXApKVxuICAgICAgICAgIHRyaWdnZXJFbWl0KHYpO1xuICAgICAgfSxcbiAgICAgIHsgZGVlcCB9XG4gICAgKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkKHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKCk7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHRyaWdnZXJFbWl0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VWTW9kZWxzKHByb3BzLCBlbWl0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgcmV0W2tleV0gPSB1c2VWTW9kZWwoXG4gICAgICBwcm9wcyxcbiAgICAgIGtleSxcbiAgICAgIGVtaXQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1c2VWaWJyYXRlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBhdHRlcm4gPSBbXSxcbiAgICBpbnRlcnZhbCA9IDAsXG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvclxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcInZpYnJhdGVcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBwYXR0ZXJuUmVmID0gdG9SZWYocGF0dGVybik7XG4gIGxldCBpbnRlcnZhbENvbnRyb2xzO1xuICBjb25zdCB2aWJyYXRlID0gKHBhdHRlcm4yID0gcGF0dGVyblJlZi52YWx1ZSkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIG5hdmlnYXRvci52aWJyYXRlKHBhdHRlcm4yKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICBuYXZpZ2F0b3IudmlicmF0ZSgwKTtcbiAgICBpbnRlcnZhbENvbnRyb2xzID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcnZhbENvbnRyb2xzLnBhdXNlKCk7XG4gIH07XG4gIGlmIChpbnRlcnZhbCA+IDApIHtcbiAgICBpbnRlcnZhbENvbnRyb2xzID0gdXNlSW50ZXJ2YWxGbihcbiAgICAgIHZpYnJhdGUsXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIHtcbiAgICAgICAgaW1tZWRpYXRlOiBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlQ2FsbGJhY2s6IGZhbHNlXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHBhdHRlcm4sXG4gICAgaW50ZXJ2YWxDb250cm9scyxcbiAgICB2aWJyYXRlLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVmlydHVhbExpc3QobGlzdCwgb3B0aW9ucykge1xuICBjb25zdCB7IGNvbnRhaW5lclN0eWxlLCB3cmFwcGVyUHJvcHMsIHNjcm9sbFRvLCBjYWxjdWxhdGVSYW5nZSwgY3VycmVudExpc3QsIGNvbnRhaW5lclJlZiB9ID0gXCJpdGVtSGVpZ2h0XCIgaW4gb3B0aW9ucyA/IHVzZVZlcnRpY2FsVmlydHVhbExpc3Qob3B0aW9ucywgbGlzdCkgOiB1c2VIb3Jpem9udGFsVmlydHVhbExpc3Qob3B0aW9ucywgbGlzdCk7XG4gIHJldHVybiB7XG4gICAgbGlzdDogY3VycmVudExpc3QsXG4gICAgc2Nyb2xsVG8sXG4gICAgY29udGFpbmVyUHJvcHM6IHtcbiAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgb25TY3JvbGw6ICgpID0+IHtcbiAgICAgICAgY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZTogY29udGFpbmVyU3R5bGVcbiAgICB9LFxuICAgIHdyYXBwZXJQcm9wc1xuICB9O1xufVxuZnVuY3Rpb24gdXNlVmlydHVhbExpc3RSZXNvdXJjZXMobGlzdCkge1xuICBjb25zdCBjb250YWluZXJSZWYgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBzaXplID0gdXNlRWxlbWVudFNpemUoY29udGFpbmVyUmVmKTtcbiAgY29uc3QgY3VycmVudExpc3QgPSByZWYoW10pO1xuICBjb25zdCBzb3VyY2UgPSBzaGFsbG93UmVmKGxpc3QpO1xuICBjb25zdCBzdGF0ZSA9IHJlZih7IHN0YXJ0OiAwLCBlbmQ6IDEwIH0pO1xuICByZXR1cm4geyBzdGF0ZSwgc291cmNlLCBjdXJyZW50TGlzdCwgc2l6ZSwgY29udGFpbmVyUmVmIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHZXRWaWV3Q2FwYWNpdHkoc3RhdGUsIHNvdXJjZSwgaXRlbVNpemUpIHtcbiAgcmV0dXJuIChjb250YWluZXJTaXplKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtU2l6ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoY29udGFpbmVyU2l6ZSAvIGl0ZW1TaXplKTtcbiAgICBjb25zdCB7IHN0YXJ0ID0gMCB9ID0gc3RhdGUudmFsdWU7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGNhcGFjaXR5ID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzb3VyY2UudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpdGVtU2l6ZShpKTtcbiAgICAgIHN1bSArPSBzaXplO1xuICAgICAgY2FwYWNpdHkgPSBpO1xuICAgICAgaWYgKHN1bSA+IGNvbnRhaW5lclNpemUpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWNpdHkgLSBzdGFydDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdldE9mZnNldChzb3VyY2UsIGl0ZW1TaXplKSB7XG4gIHJldHVybiAoc2Nyb2xsRGlyZWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtU2l6ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHNjcm9sbERpcmVjdGlvbiAvIGl0ZW1TaXplKSArIDE7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpdGVtU2l6ZShpKTtcbiAgICAgIHN1bSArPSBzaXplO1xuICAgICAgaWYgKHN1bSA+PSBzY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgb2Zmc2V0ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsY3VsYXRlUmFuZ2UodHlwZSwgb3ZlcnNjYW4sIGdldE9mZnNldCwgZ2V0Vmlld0NhcGFjaXR5LCB7IGNvbnRhaW5lclJlZiwgc3RhdGUsIGN1cnJlbnRMaXN0LCBzb3VyY2UgfSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjb250YWluZXJSZWYudmFsdWU7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGdldE9mZnNldCh0eXBlID09PSBcInZlcnRpY2FsXCIgPyBlbGVtZW50LnNjcm9sbFRvcCA6IGVsZW1lbnQuc2Nyb2xsTGVmdCk7XG4gICAgICBjb25zdCB2aWV3Q2FwYWNpdHkgPSBnZXRWaWV3Q2FwYWNpdHkodHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gZWxlbWVudC5jbGllbnRIZWlnaHQgOiBlbGVtZW50LmNsaWVudFdpZHRoKTtcbiAgICAgIGNvbnN0IGZyb20gPSBvZmZzZXQgLSBvdmVyc2NhbjtcbiAgICAgIGNvbnN0IHRvID0gb2Zmc2V0ICsgdmlld0NhcGFjaXR5ICsgb3ZlcnNjYW47XG4gICAgICBzdGF0ZS52YWx1ZSA9IHtcbiAgICAgICAgc3RhcnQ6IGZyb20gPCAwID8gMCA6IGZyb20sXG4gICAgICAgIGVuZDogdG8gPiBzb3VyY2UudmFsdWUubGVuZ3RoID8gc291cmNlLnZhbHVlLmxlbmd0aCA6IHRvXG4gICAgICB9O1xuICAgICAgY3VycmVudExpc3QudmFsdWUgPSBzb3VyY2UudmFsdWUuc2xpY2Uoc3RhdGUudmFsdWUuc3RhcnQsIHN0YXRlLnZhbHVlLmVuZCkubWFwKChlbGUsIGluZGV4KSA9PiAoe1xuICAgICAgICBkYXRhOiBlbGUsXG4gICAgICAgIGluZGV4OiBpbmRleCArIHN0YXRlLnZhbHVlLnN0YXJ0XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlR2V0RGlzdGFuY2UoaXRlbVNpemUsIHNvdXJjZSkge1xuICByZXR1cm4gKGluZGV4KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtU2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgc2l6ZTIgPSBpbmRleCAqIGl0ZW1TaXplO1xuICAgICAgcmV0dXJuIHNpemUyO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gc291cmNlLnZhbHVlLnNsaWNlKDAsIGluZGV4KS5yZWR1Y2UoKHN1bSwgXywgaSkgPT4gc3VtICsgaXRlbVNpemUoaSksIDApO1xuICAgIHJldHVybiBzaXplO1xuICB9O1xufVxuZnVuY3Rpb24gdXNlV2F0Y2hGb3JTaXplcyhzaXplLCBsaXN0LCBjb250YWluZXJSZWYsIGNhbGN1bGF0ZVJhbmdlKSB7XG4gIHdhdGNoKFtzaXplLndpZHRoLCBzaXplLmhlaWdodCwgbGlzdCwgY29udGFpbmVyUmVmXSwgKCkgPT4ge1xuICAgIGNhbGN1bGF0ZVJhbmdlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRUb3RhbFNpemUoaXRlbVNpemUsIHNvdXJjZSkge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgaXRlbVNpemUgPT09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc291cmNlLnZhbHVlLmxlbmd0aCAqIGl0ZW1TaXplO1xuICAgIHJldHVybiBzb3VyY2UudmFsdWUucmVkdWNlKChzdW0sIF8sIGluZGV4KSA9PiBzdW0gKyBpdGVtU2l6ZShpbmRleCksIDApO1xuICB9KTtcbn1cbmNvbnN0IHNjcm9sbFRvRGljdGlvbmFyeUZvckVsZW1lbnRTY3JvbGxLZXkgPSB7XG4gIGhvcml6b250YWw6IFwic2Nyb2xsTGVmdFwiLFxuICB2ZXJ0aWNhbDogXCJzY3JvbGxUb3BcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVNjcm9sbFRvKHR5cGUsIGNhbGN1bGF0ZVJhbmdlLCBnZXREaXN0YW5jZSwgY29udGFpbmVyUmVmKSB7XG4gIHJldHVybiAoaW5kZXgpID0+IHtcbiAgICBpZiAoY29udGFpbmVyUmVmLnZhbHVlKSB7XG4gICAgICBjb250YWluZXJSZWYudmFsdWVbc2Nyb2xsVG9EaWN0aW9uYXJ5Rm9yRWxlbWVudFNjcm9sbEtleVt0eXBlXV0gPSBnZXREaXN0YW5jZShpbmRleCk7XG4gICAgICBjYWxjdWxhdGVSYW5nZSgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUhvcml6b250YWxWaXJ0dWFsTGlzdChvcHRpb25zLCBsaXN0KSB7XG4gIGNvbnN0IHJlc291cmNlcyA9IHVzZVZpcnR1YWxMaXN0UmVzb3VyY2VzKGxpc3QpO1xuICBjb25zdCB7IHN0YXRlLCBzb3VyY2UsIGN1cnJlbnRMaXN0LCBzaXplLCBjb250YWluZXJSZWYgfSA9IHJlc291cmNlcztcbiAgY29uc3QgY29udGFpbmVyU3R5bGUgPSB7IG92ZXJmbG93WDogXCJhdXRvXCIgfTtcbiAgY29uc3QgeyBpdGVtV2lkdGgsIG92ZXJzY2FuID0gNSB9ID0gb3B0aW9ucztcbiAgY29uc3QgZ2V0Vmlld0NhcGFjaXR5ID0gY3JlYXRlR2V0Vmlld0NhcGFjaXR5KHN0YXRlLCBzb3VyY2UsIGl0ZW1XaWR0aCk7XG4gIGNvbnN0IGdldE9mZnNldCA9IGNyZWF0ZUdldE9mZnNldChzb3VyY2UsIGl0ZW1XaWR0aCk7XG4gIGNvbnN0IGNhbGN1bGF0ZVJhbmdlID0gY3JlYXRlQ2FsY3VsYXRlUmFuZ2UoXCJob3Jpem9udGFsXCIsIG92ZXJzY2FuLCBnZXRPZmZzZXQsIGdldFZpZXdDYXBhY2l0eSwgcmVzb3VyY2VzKTtcbiAgY29uc3QgZ2V0RGlzdGFuY2VMZWZ0ID0gY3JlYXRlR2V0RGlzdGFuY2UoaXRlbVdpZHRoLCBzb3VyY2UpO1xuICBjb25zdCBvZmZzZXRMZWZ0ID0gY29tcHV0ZWQoKCkgPT4gZ2V0RGlzdGFuY2VMZWZ0KHN0YXRlLnZhbHVlLnN0YXJ0KSk7XG4gIGNvbnN0IHRvdGFsV2lkdGggPSBjcmVhdGVDb21wdXRlZFRvdGFsU2l6ZShpdGVtV2lkdGgsIHNvdXJjZSk7XG4gIHVzZVdhdGNoRm9yU2l6ZXMoc2l6ZSwgbGlzdCwgY29udGFpbmVyUmVmLCBjYWxjdWxhdGVSYW5nZSk7XG4gIGNvbnN0IHNjcm9sbFRvID0gY3JlYXRlU2Nyb2xsVG8oXCJob3Jpem9udGFsXCIsIGNhbGN1bGF0ZVJhbmdlLCBnZXREaXN0YW5jZUxlZnQsIGNvbnRhaW5lclJlZik7XG4gIGNvbnN0IHdyYXBwZXJQcm9wcyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgd2lkdGg6IGAke3RvdGFsV2lkdGgudmFsdWUgLSBvZmZzZXRMZWZ0LnZhbHVlfXB4YCxcbiAgICAgICAgbWFyZ2luTGVmdDogYCR7b2Zmc2V0TGVmdC52YWx1ZX1weGAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsVG8sXG4gICAgY2FsY3VsYXRlUmFuZ2UsXG4gICAgd3JhcHBlclByb3BzLFxuICAgIGNvbnRhaW5lclN0eWxlLFxuICAgIGN1cnJlbnRMaXN0LFxuICAgIGNvbnRhaW5lclJlZlxuICB9O1xufVxuZnVuY3Rpb24gdXNlVmVydGljYWxWaXJ0dWFsTGlzdChvcHRpb25zLCBsaXN0KSB7XG4gIGNvbnN0IHJlc291cmNlcyA9IHVzZVZpcnR1YWxMaXN0UmVzb3VyY2VzKGxpc3QpO1xuICBjb25zdCB7IHN0YXRlLCBzb3VyY2UsIGN1cnJlbnRMaXN0LCBzaXplLCBjb250YWluZXJSZWYgfSA9IHJlc291cmNlcztcbiAgY29uc3QgY29udGFpbmVyU3R5bGUgPSB7IG92ZXJmbG93WTogXCJhdXRvXCIgfTtcbiAgY29uc3QgeyBpdGVtSGVpZ2h0LCBvdmVyc2NhbiA9IDUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGdldFZpZXdDYXBhY2l0eSA9IGNyZWF0ZUdldFZpZXdDYXBhY2l0eShzdGF0ZSwgc291cmNlLCBpdGVtSGVpZ2h0KTtcbiAgY29uc3QgZ2V0T2Zmc2V0ID0gY3JlYXRlR2V0T2Zmc2V0KHNvdXJjZSwgaXRlbUhlaWdodCk7XG4gIGNvbnN0IGNhbGN1bGF0ZVJhbmdlID0gY3JlYXRlQ2FsY3VsYXRlUmFuZ2UoXCJ2ZXJ0aWNhbFwiLCBvdmVyc2NhbiwgZ2V0T2Zmc2V0LCBnZXRWaWV3Q2FwYWNpdHksIHJlc291cmNlcyk7XG4gIGNvbnN0IGdldERpc3RhbmNlVG9wID0gY3JlYXRlR2V0RGlzdGFuY2UoaXRlbUhlaWdodCwgc291cmNlKTtcbiAgY29uc3Qgb2Zmc2V0VG9wID0gY29tcHV0ZWQoKCkgPT4gZ2V0RGlzdGFuY2VUb3Aoc3RhdGUudmFsdWUuc3RhcnQpKTtcbiAgY29uc3QgdG90YWxIZWlnaHQgPSBjcmVhdGVDb21wdXRlZFRvdGFsU2l6ZShpdGVtSGVpZ2h0LCBzb3VyY2UpO1xuICB1c2VXYXRjaEZvclNpemVzKHNpemUsIGxpc3QsIGNvbnRhaW5lclJlZiwgY2FsY3VsYXRlUmFuZ2UpO1xuICBjb25zdCBzY3JvbGxUbyA9IGNyZWF0ZVNjcm9sbFRvKFwidmVydGljYWxcIiwgY2FsY3VsYXRlUmFuZ2UsIGdldERpc3RhbmNlVG9wLCBjb250YWluZXJSZWYpO1xuICBjb25zdCB3cmFwcGVyUHJvcHMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBgJHt0b3RhbEhlaWdodC52YWx1ZSAtIG9mZnNldFRvcC52YWx1ZX1weGAsXG4gICAgICAgIG1hcmdpblRvcDogYCR7b2Zmc2V0VG9wLnZhbHVlfXB4YFxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNhbGN1bGF0ZVJhbmdlLFxuICAgIHNjcm9sbFRvLFxuICAgIGNvbnRhaW5lclN0eWxlLFxuICAgIHdyYXBwZXJQcm9wcyxcbiAgICBjdXJyZW50TGlzdCxcbiAgICBjb250YWluZXJSZWZcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlV2FrZUxvY2sob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yLFxuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXF1ZXN0ZWRUeXBlID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHNlbnRpbmVsID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgZG9jdW1lbnRWaXNpYmlsaXR5ID0gdXNlRG9jdW1lbnRWaXNpYmlsaXR5KHsgZG9jdW1lbnQgfSk7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcIndha2VMb2NrXCIgaW4gbmF2aWdhdG9yKTtcbiAgY29uc3QgaXNBY3RpdmUgPSBjb21wdXRlZCgoKSA9PiAhIXNlbnRpbmVsLnZhbHVlICYmIGRvY3VtZW50VmlzaWJpbGl0eS52YWx1ZSA9PT0gXCJ2aXNpYmxlXCIpO1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICB1c2VFdmVudExpc3RlbmVyKHNlbnRpbmVsLCBcInJlbGVhc2VcIiwgKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJlcXVlc3RlZFR5cGUudmFsdWUgPSAoX2IgPSAoX2EgPSBzZW50aW5lbC52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUpICE9IG51bGwgPyBfYiA6IGZhbHNlO1xuICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB3aGVuZXZlcihcbiAgICAgICgpID0+IGRvY3VtZW50VmlzaWJpbGl0eS52YWx1ZSA9PT0gXCJ2aXNpYmxlXCIgJiYgKGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpID09PSBcInZpc2libGVcIiAmJiByZXF1ZXN0ZWRUeXBlLnZhbHVlLFxuICAgICAgKHR5cGUpID0+IHtcbiAgICAgICAgcmVxdWVzdGVkVHlwZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgICBmb3JjZVJlcXVlc3QodHlwZSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmb3JjZVJlcXVlc3QodHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBhd2FpdCAoKF9hID0gc2VudGluZWwudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWxlYXNlKCkpO1xuICAgIHNlbnRpbmVsLnZhbHVlID0gaXNTdXBwb3J0ZWQudmFsdWUgPyBhd2FpdCBuYXZpZ2F0b3Iud2FrZUxvY2sucmVxdWVzdCh0eXBlKSA6IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdCh0eXBlKSB7XG4gICAgaWYgKGRvY3VtZW50VmlzaWJpbGl0eS52YWx1ZSA9PT0gXCJ2aXNpYmxlXCIpXG4gICAgICBhd2FpdCBmb3JjZVJlcXVlc3QodHlwZSk7XG4gICAgZWxzZVxuICAgICAgcmVxdWVzdGVkVHlwZS52YWx1ZSA9IHR5cGU7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICByZXF1ZXN0ZWRUeXBlLnZhbHVlID0gZmFsc2U7XG4gICAgY29uc3QgcyA9IHNlbnRpbmVsLnZhbHVlO1xuICAgIHNlbnRpbmVsLnZhbHVlID0gbnVsbDtcbiAgICBhd2FpdCAocyA9PSBudWxsID8gdm9pZCAwIDogcy5yZWxlYXNlKCkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2VudGluZWwsXG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNBY3RpdmUsXG4gICAgcmVxdWVzdCxcbiAgICBmb3JjZVJlcXVlc3QsXG4gICAgcmVsZWFzZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VXZWJOb3RpZmljYXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIHJlcXVlc3RQZXJtaXNzaW9uczogX3JlcXVlc3RGb3JQZXJtaXNzaW9ucyA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRlZmF1bHRXZWJOb3RpZmljYXRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4ge1xuICAgIGlmICghd2luZG93IHx8ICEoXCJOb3RpZmljYXRpb25cIiBpbiB3aW5kb3cpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gXCJncmFudGVkXCIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgbm90aWZpY2F0aW9uMiA9IG5ldyBOb3RpZmljYXRpb24oXCJcIik7XG4gICAgICBub3RpZmljYXRpb24yLm9uc2hvdyA9ICgpID0+IHtcbiAgICAgICAgbm90aWZpY2F0aW9uMi5jbG9zZSgpO1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lID09PSBcIlR5cGVFcnJvclwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgY29uc3QgcGVybWlzc2lvbkdyYW50ZWQgPSBzaGFsbG93UmVmKGlzU3VwcG9ydGVkLnZhbHVlICYmIFwicGVybWlzc2lvblwiIGluIE5vdGlmaWNhdGlvbiAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gXCJncmFudGVkXCIpO1xuICBjb25zdCBub3RpZmljYXRpb24gPSByZWYobnVsbCk7XG4gIGNvbnN0IGVuc3VyZVBlcm1pc3Npb25zID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiAhPT0gXCJkZW5pZWRcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBcImdyYW50ZWRcIilcbiAgICAgICAgcGVybWlzc2lvbkdyYW50ZWQudmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGVybWlzc2lvbkdyYW50ZWQudmFsdWU7XG4gIH07XG4gIGNvbnN0IHsgb246IG9uQ2xpY2ssIHRyaWdnZXI6IGNsaWNrVHJpZ2dlciB9ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IHsgb246IG9uU2hvdywgdHJpZ2dlcjogc2hvd1RyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvbkVycm9yLCB0cmlnZ2VyOiBlcnJvclRyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvbkNsb3NlLCB0cmlnZ2VyOiBjbG9zZVRyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBzaG93ID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgIXBlcm1pc3Npb25HcmFudGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9wdGlvbnMyID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFdlYk5vdGlmaWNhdGlvbk9wdGlvbnMsIG92ZXJyaWRlcyk7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlID0gbmV3IE5vdGlmaWNhdGlvbihvcHRpb25zMi50aXRsZSB8fCBcIlwiLCBvcHRpb25zMik7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlLm9uY2xpY2sgPSBjbGlja1RyaWdnZXI7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlLm9uc2hvdyA9IHNob3dUcmlnZ2VyO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZS5vbmVycm9yID0gZXJyb3JUcmlnZ2VyO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZS5vbmNsb3NlID0gY2xvc2VUcmlnZ2VyO1xuICAgIHJldHVybiBub3RpZmljYXRpb24udmFsdWU7XG4gIH07XG4gIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgIGlmIChub3RpZmljYXRpb24udmFsdWUpXG4gICAgICBub3RpZmljYXRpb24udmFsdWUuY2xvc2UoKTtcbiAgICBub3RpZmljYXRpb24udmFsdWUgPSBudWxsO1xuICB9O1xuICBpZiAoX3JlcXVlc3RGb3JQZXJtaXNzaW9ucylcbiAgICB0cnlPbk1vdW50ZWQoZW5zdXJlUGVybWlzc2lvbnMpO1xuICB0cnlPblNjb3BlRGlzcG9zZShjbG9zZSk7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB3aW5kb3cpIHtcbiAgICBjb25zdCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInZpc2liaWxpdHljaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBub3RpZmljYXRpb24sXG4gICAgZW5zdXJlUGVybWlzc2lvbnMsXG4gICAgcGVybWlzc2lvbkdyYW50ZWQsXG4gICAgc2hvdyxcbiAgICBjbG9zZSxcbiAgICBvbkNsaWNrLFxuICAgIG9uU2hvdyxcbiAgICBvbkVycm9yLFxuICAgIG9uQ2xvc2VcbiAgfTtcbn1cblxuY29uc3QgREVGQVVMVF9QSU5HX01FU1NBR0UgPSBcInBpbmdcIjtcbmZ1bmN0aW9uIHJlc29sdmVOZXN0ZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpXG4gICAgcmV0dXJuIHt9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIHVzZVdlYlNvY2tldCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgb25Db25uZWN0ZWQsXG4gICAgb25EaXNjb25uZWN0ZWQsXG4gICAgb25FcnJvcixcbiAgICBvbk1lc3NhZ2UsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBhdXRvQ29ubmVjdCA9IHRydWUsXG4gICAgYXV0b0Nsb3NlID0gdHJ1ZSxcbiAgICBwcm90b2NvbHMgPSBbXVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZGF0YSA9IHJlZihudWxsKTtcbiAgY29uc3Qgc3RhdHVzID0gc2hhbGxvd1JlZihcIkNMT1NFRFwiKTtcbiAgY29uc3Qgd3NSZWYgPSByZWYoKTtcbiAgY29uc3QgdXJsUmVmID0gdG9SZWYodXJsKTtcbiAgbGV0IGhlYXJ0YmVhdFBhdXNlO1xuICBsZXQgaGVhcnRiZWF0UmVzdW1lO1xuICBsZXQgZXhwbGljaXRseUNsb3NlZCA9IGZhbHNlO1xuICBsZXQgcmV0cmllZCA9IDA7XG4gIGxldCBidWZmZXJlZERhdGEgPSBbXTtcbiAgbGV0IHJldHJ5VGltZW91dDtcbiAgbGV0IHBvbmdUaW1lb3V0V2FpdDtcbiAgY29uc3QgX3NlbmRCdWZmZXIgPSAoKSA9PiB7XG4gICAgaWYgKGJ1ZmZlcmVkRGF0YS5sZW5ndGggJiYgd3NSZWYudmFsdWUgJiYgc3RhdHVzLnZhbHVlID09PSBcIk9QRU5cIikge1xuICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVyZWREYXRhKVxuICAgICAgICB3c1JlZi52YWx1ZS5zZW5kKGJ1ZmZlcik7XG4gICAgICBidWZmZXJlZERhdGEgPSBbXTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlc2V0UmV0cnkgPSAoKSA9PiB7XG4gICAgaWYgKHJldHJ5VGltZW91dCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmV0cnlUaW1lb3V0KTtcbiAgICAgIHJldHJ5VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlc2V0SGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dChwb25nVGltZW91dFdhaXQpO1xuICAgIHBvbmdUaW1lb3V0V2FpdCA9IHZvaWQgMDtcbiAgfTtcbiAgY29uc3QgY2xvc2UgPSAoY29kZSA9IDFlMywgcmVhc29uKSA9PiB7XG4gICAgcmVzZXRSZXRyeSgpO1xuICAgIGlmICghaXNDbGllbnQgJiYgIWlzV29ya2VyIHx8ICF3c1JlZi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBleHBsaWNpdGx5Q2xvc2VkID0gdHJ1ZTtcbiAgICByZXNldEhlYXJ0YmVhdCgpO1xuICAgIGhlYXJ0YmVhdFBhdXNlID09IG51bGwgPyB2b2lkIDAgOiBoZWFydGJlYXRQYXVzZSgpO1xuICAgIHdzUmVmLnZhbHVlLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgd3NSZWYudmFsdWUgPSB2b2lkIDA7XG4gIH07XG4gIGNvbnN0IHNlbmQgPSAoZGF0YTIsIHVzZUJ1ZmZlciA9IHRydWUpID0+IHtcbiAgICBpZiAoIXdzUmVmLnZhbHVlIHx8IHN0YXR1cy52YWx1ZSAhPT0gXCJPUEVOXCIpIHtcbiAgICAgIGlmICh1c2VCdWZmZXIpXG4gICAgICAgIGJ1ZmZlcmVkRGF0YS5wdXNoKGRhdGEyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3NlbmRCdWZmZXIoKTtcbiAgICB3c1JlZi52YWx1ZS5zZW5kKGRhdGEyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgX2luaXQgPSAoKSA9PiB7XG4gICAgaWYgKGV4cGxpY2l0bHlDbG9zZWQgfHwgdHlwZW9mIHVybFJlZi52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQodXJsUmVmLnZhbHVlLCBwcm90b2NvbHMpO1xuICAgIHdzUmVmLnZhbHVlID0gd3M7XG4gICAgc3RhdHVzLnZhbHVlID0gXCJDT05ORUNUSU5HXCI7XG4gICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJPUEVOXCI7XG4gICAgICByZXRyaWVkID0gMDtcbiAgICAgIG9uQ29ubmVjdGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkNvbm5lY3RlZCh3cyk7XG4gICAgICBoZWFydGJlYXRSZXN1bWUgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYXJ0YmVhdFJlc3VtZSgpO1xuICAgICAgX3NlbmRCdWZmZXIoKTtcbiAgICB9O1xuICAgIHdzLm9uY2xvc2UgPSAoZXYpID0+IHtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiQ0xPU0VEXCI7XG4gICAgICByZXNldEhlYXJ0YmVhdCgpO1xuICAgICAgaGVhcnRiZWF0UGF1c2UgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYXJ0YmVhdFBhdXNlKCk7XG4gICAgICBvbkRpc2Nvbm5lY3RlZCA9PSBudWxsID8gdm9pZCAwIDogb25EaXNjb25uZWN0ZWQod3MsIGV2KTtcbiAgICAgIGlmICghZXhwbGljaXRseUNsb3NlZCAmJiBvcHRpb25zLmF1dG9SZWNvbm5lY3QgJiYgKHdzUmVmLnZhbHVlID09IG51bGwgfHwgd3MgPT09IHdzUmVmLnZhbHVlKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmV0cmllcyA9IC0xLFxuICAgICAgICAgIGRlbGF5ID0gMWUzLFxuICAgICAgICAgIG9uRmFpbGVkXG4gICAgICAgIH0gPSByZXNvbHZlTmVzdGVkT3B0aW9ucyhvcHRpb25zLmF1dG9SZWNvbm5lY3QpO1xuICAgICAgICBjb25zdCBjaGVja1JldGlyZXMgPSB0eXBlb2YgcmV0cmllcyA9PT0gXCJmdW5jdGlvblwiID8gcmV0cmllcyA6ICgpID0+IHR5cGVvZiByZXRyaWVzID09PSBcIm51bWJlclwiICYmIChyZXRyaWVzIDwgMCB8fCByZXRyaWVkIDwgcmV0cmllcyk7XG4gICAgICAgIGlmIChjaGVja1JldGlyZXMocmV0cmllZCkpIHtcbiAgICAgICAgICByZXRyaWVkICs9IDE7XG4gICAgICAgICAgcmV0cnlUaW1lb3V0ID0gc2V0VGltZW91dChfaW5pdCwgZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRmFpbGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkZhaWxlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3cy5vbmVycm9yID0gKGUpID0+IHtcbiAgICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3Iod3MsIGUpO1xuICAgIH07XG4gICAgd3Mub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLmhlYXJ0YmVhdCkge1xuICAgICAgICByZXNldEhlYXJ0YmVhdCgpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWVzc2FnZSA9IERFRkFVTFRfUElOR19NRVNTQUdFLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2VcbiAgICAgICAgfSA9IHJlc29sdmVOZXN0ZWRPcHRpb25zKG9wdGlvbnMuaGVhcnRiZWF0KTtcbiAgICAgICAgaWYgKGUuZGF0YSA9PT0gdG9WYWx1ZShyZXNwb25zZU1lc3NhZ2UpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGE7XG4gICAgICBvbk1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTWVzc2FnZSh3cywgZSk7XG4gICAgfTtcbiAgfTtcbiAgaWYgKG9wdGlvbnMuaGVhcnRiZWF0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZSA9IERFRkFVTFRfUElOR19NRVNTQUdFLFxuICAgICAgaW50ZXJ2YWwgPSAxZTMsXG4gICAgICBwb25nVGltZW91dCA9IDFlM1xuICAgIH0gPSByZXNvbHZlTmVzdGVkT3B0aW9ucyhvcHRpb25zLmhlYXJ0YmVhdCk7XG4gICAgY29uc3QgeyBwYXVzZSwgcmVzdW1lIH0gPSB1c2VJbnRlcnZhbEZuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzZW5kKHRvVmFsdWUobWVzc2FnZSksIGZhbHNlKTtcbiAgICAgICAgaWYgKHBvbmdUaW1lb3V0V2FpdCAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcG9uZ1RpbWVvdXRXYWl0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH0sIHBvbmdUaW1lb3V0KTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIHsgaW1tZWRpYXRlOiBmYWxzZSB9XG4gICAgKTtcbiAgICBoZWFydGJlYXRQYXVzZSA9IHBhdXNlO1xuICAgIGhlYXJ0YmVhdFJlc3VtZSA9IHJlc3VtZTtcbiAgfVxuICBpZiAoYXV0b0Nsb3NlKSB7XG4gICAgaWYgKGlzQ2xpZW50KVxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiBjbG9zZSgpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdHJ5T25TY29wZURpc3Bvc2UoY2xvc2UpO1xuICB9XG4gIGNvbnN0IG9wZW4gPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCAmJiAhaXNXb3JrZXIpXG4gICAgICByZXR1cm47XG4gICAgY2xvc2UoKTtcbiAgICBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgcmV0cmllZCA9IDA7XG4gICAgX2luaXQoKTtcbiAgfTtcbiAgaWYgKGltbWVkaWF0ZSlcbiAgICBvcGVuKCk7XG4gIGlmIChhdXRvQ29ubmVjdClcbiAgICB3YXRjaCh1cmxSZWYsIG9wZW4pO1xuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgc3RhdHVzLFxuICAgIGNsb3NlLFxuICAgIHNlbmQsXG4gICAgb3BlbixcbiAgICB3czogd3NSZWZcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlV2ViV29ya2VyKGFyZzAsIHdvcmtlck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgY29uc3QgZGF0YSA9IHJlZihudWxsKTtcbiAgY29uc3Qgd29ya2VyID0gc2hhbGxvd1JlZigpO1xuICBjb25zdCBwb3N0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIXdvcmtlci52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB3b3JrZXIudmFsdWUucG9zdE1lc3NhZ2UoLi4uYXJncyk7XG4gIH07XG4gIGNvbnN0IHRlcm1pbmF0ZSA9IGZ1bmN0aW9uIHRlcm1pbmF0ZTIoKSB7XG4gICAgaWYgKCF3b3JrZXIudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgd29ya2VyLnZhbHVlLnRlcm1pbmF0ZSgpO1xuICB9O1xuICBpZiAod2luZG93KSB7XG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSBcInN0cmluZ1wiKVxuICAgICAgd29ya2VyLnZhbHVlID0gbmV3IFdvcmtlcihhcmcwLCB3b3JrZXJPcHRpb25zKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgYXJnMCA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgd29ya2VyLnZhbHVlID0gYXJnMCgpO1xuICAgIGVsc2VcbiAgICAgIHdvcmtlci52YWx1ZSA9IGFyZzA7XG4gICAgd29ya2VyLnZhbHVlLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICBkYXRhLnZhbHVlID0gZS5kYXRhO1xuICAgIH07XG4gICAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgICAgaWYgKHdvcmtlci52YWx1ZSlcbiAgICAgICAgd29ya2VyLnZhbHVlLnRlcm1pbmF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBwb3N0LFxuICAgIHRlcm1pbmF0ZSxcbiAgICB3b3JrZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVwc1BhcnNlcihkZXBzLCBsb2NhbERlcHMpIHtcbiAgaWYgKGRlcHMubGVuZ3RoID09PSAwICYmIGxvY2FsRGVwcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IGRlcHNTdHJpbmcgPSBkZXBzLm1hcCgoZGVwKSA9PiBgJyR7ZGVwfSdgKS50b1N0cmluZygpO1xuICBjb25zdCBkZXBzRnVuY3Rpb25TdHJpbmcgPSBsb2NhbERlcHMuZmlsdGVyKChkZXApID0+IHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIikubWFwKChmbikgPT4ge1xuICAgIGNvbnN0IHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgaWYgKHN0ci50cmltKCkuc3RhcnRzV2l0aChcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lID0gZm4ubmFtZTtcbiAgICAgIHJldHVybiBgY29uc3QgJHtuYW1lfSA9ICR7c3RyfWA7XG4gICAgfVxuICB9KS5qb2luKFwiO1wiKTtcbiAgY29uc3QgaW1wb3J0U3RyaW5nID0gYGltcG9ydFNjcmlwdHMoJHtkZXBzU3RyaW5nfSk7YDtcbiAgcmV0dXJuIGAke2RlcHNTdHJpbmcudHJpbSgpID09PSBcIlwiID8gXCJcIiA6IGltcG9ydFN0cmluZ30gJHtkZXBzRnVuY3Rpb25TdHJpbmd9YDtcbn1cblxuZnVuY3Rpb24gam9iUnVubmVyKHVzZXJGdW5jKSB7XG4gIHJldHVybiAoZSkgPT4ge1xuICAgIGNvbnN0IHVzZXJGdW5jQXJncyA9IGUuZGF0YVswXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVzZXJGdW5jLmFwcGx5KHZvaWQgMCwgdXNlckZ1bmNBcmdzKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBwb3N0TWVzc2FnZShbXCJTVUNDRVNTXCIsIHJlc3VsdF0pO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgcG9zdE1lc3NhZ2UoW1wiRVJST1JcIiwgZXJyb3JdKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya2VyQmxvYlVybChmbiwgZGVwcywgbG9jYWxEZXBzKSB7XG4gIGNvbnN0IGJsb2JDb2RlID0gYCR7ZGVwc1BhcnNlcihkZXBzLCBsb2NhbERlcHMpfTsgb25tZXNzYWdlPSgke2pvYlJ1bm5lcn0pKCR7Zm59KWA7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYmxvYkNvZGVdLCB7IHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCIgfSk7XG4gIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIHVzZVdlYldvcmtlckZuKGZuLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGRlcGVuZGVuY2llcyA9IFtdLFxuICAgIGxvY2FsRGVwZW5kZW5jaWVzID0gW10sXG4gICAgdGltZW91dCxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB3b3JrZXIgPSByZWYoKTtcbiAgY29uc3Qgd29ya2VyU3RhdHVzID0gc2hhbGxvd1JlZihcIlBFTkRJTkdcIik7XG4gIGNvbnN0IHByb21pc2UgPSByZWYoe30pO1xuICBjb25zdCB0aW1lb3V0SWQgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IHdvcmtlclRlcm1pbmF0ZSA9IChzdGF0dXMgPSBcIlBFTkRJTkdcIikgPT4ge1xuICAgIGlmICh3b3JrZXIudmFsdWUgJiYgd29ya2VyLnZhbHVlLl91cmwgJiYgd2luZG93KSB7XG4gICAgICB3b3JrZXIudmFsdWUudGVybWluYXRlKCk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlci52YWx1ZS5fdXJsKTtcbiAgICAgIHByb21pc2UudmFsdWUgPSB7fTtcbiAgICAgIHdvcmtlci52YWx1ZSA9IHZvaWQgMDtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkLnZhbHVlKTtcbiAgICAgIHdvcmtlclN0YXR1cy52YWx1ZSA9IHN0YXR1cztcbiAgICB9XG4gIH07XG4gIHdvcmtlclRlcm1pbmF0ZSgpO1xuICB0cnlPblNjb3BlRGlzcG9zZSh3b3JrZXJUZXJtaW5hdGUpO1xuICBjb25zdCBnZW5lcmF0ZVdvcmtlciA9ICgpID0+IHtcbiAgICBjb25zdCBibG9iVXJsID0gY3JlYXRlV29ya2VyQmxvYlVybChmbiwgZGVwZW5kZW5jaWVzLCBsb2NhbERlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgbmV3V29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICBuZXdXb3JrZXIuX3VybCA9IGJsb2JVcmw7XG4gICAgbmV3V29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc29sdmUgPSAoKSA9PiB7XG4gICAgICB9LCByZWplY3QgPSAoKSA9PiB7XG4gICAgICB9IH0gPSBwcm9taXNlLnZhbHVlO1xuICAgICAgY29uc3QgW3N0YXR1cywgcmVzdWx0XSA9IGUuZGF0YTtcbiAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJTVUNDRVNTXCI6XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIHdvcmtlclRlcm1pbmF0ZShzdGF0dXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlamVjdChyZXN1bHQpO1xuICAgICAgICAgIHdvcmtlclRlcm1pbmF0ZShcIkVSUk9SXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgbmV3V29ya2VyLm9uZXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgeyByZWplY3QgPSAoKSA9PiB7XG4gICAgICB9IH0gPSBwcm9taXNlLnZhbHVlO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmVqZWN0KGUpO1xuICAgICAgd29ya2VyVGVybWluYXRlKFwiRVJST1JcIik7XG4gICAgfTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgdGltZW91dElkLnZhbHVlID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gd29ya2VyVGVybWluYXRlKFwiVElNRU9VVF9FWFBJUkVEXCIpLFxuICAgICAgICB0aW1lb3V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3V29ya2VyO1xuICB9O1xuICBjb25zdCBjYWxsV29ya2VyID0gKC4uLmZuQXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBwcm9taXNlLnZhbHVlID0ge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdFxuICAgIH07XG4gICAgKF9hID0gd29ya2VyLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UoW1suLi5mbkFyZ3NdXSk7XG4gICAgd29ya2VyU3RhdHVzLnZhbHVlID0gXCJSVU5OSU5HXCI7XG4gIH0pO1xuICBjb25zdCB3b3JrZXJGbiA9ICguLi5mbkFyZ3MpID0+IHtcbiAgICBpZiAod29ya2VyU3RhdHVzLnZhbHVlID09PSBcIlJVTk5JTkdcIikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJbdXNlV2ViV29ya2VyRm5dIFlvdSBjYW4gb25seSBydW4gb25lIGluc3RhbmNlIG9mIHRoZSB3b3JrZXIgYXQgYSB0aW1lLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgfVxuICAgIHdvcmtlci52YWx1ZSA9IGdlbmVyYXRlV29ya2VyKCk7XG4gICAgcmV0dXJuIGNhbGxXb3JrZXIoLi4uZm5BcmdzKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB3b3JrZXJGbixcbiAgICB3b3JrZXJTdGF0dXMsXG4gICAgd29ya2VyVGVybWluYXRlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVdpbmRvd0ZvY3VzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93KVxuICAgIHJldHVybiBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgZm9jdXNlZCA9IHNoYWxsb3dSZWYod2luZG93LmRvY3VtZW50Lmhhc0ZvY3VzKCkpO1xuICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiYmx1clwiLCAoKSA9PiB7XG4gICAgZm9jdXNlZC52YWx1ZSA9IGZhbHNlO1xuICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgZm9jdXNlZC52YWx1ZSA9IHRydWU7XG4gIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gIHJldHVybiBmb2N1c2VkO1xufVxuXG5mdW5jdGlvbiB1c2VXaW5kb3dTY3JvbGwob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHVzZVNjcm9sbCh3aW5kb3csIHJlc3QpO1xufVxuXG5mdW5jdGlvbiB1c2VXaW5kb3dTaXplKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBpbml0aWFsV2lkdGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgaW5pdGlhbEhlaWdodCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBsaXN0ZW5PcmllbnRhdGlvbiA9IHRydWUsXG4gICAgaW5jbHVkZVNjcm9sbGJhciA9IHRydWUsXG4gICAgdHlwZSA9IFwiaW5uZXJcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgd2lkdGggPSBzaGFsbG93UmVmKGluaXRpYWxXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IHNoYWxsb3dSZWYoaW5pdGlhbEhlaWdodCk7XG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICBpZiAod2luZG93KSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJvdXRlclwiKSB7XG4gICAgICAgIHdpZHRoLnZhbHVlID0gd2luZG93Lm91dGVyV2lkdGg7XG4gICAgICAgIGhlaWdodC52YWx1ZSA9IHdpbmRvdy5vdXRlckhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2aXN1YWxcIiAmJiB3aW5kb3cudmlzdWFsVmlld3BvcnQpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aDogdmlzdWFsVmlld3BvcnRXaWR0aCwgaGVpZ2h0OiB2aXN1YWxWaWV3cG9ydEhlaWdodCwgc2NhbGUgfSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbiAgICAgICAgd2lkdGgudmFsdWUgPSBNYXRoLnJvdW5kKHZpc3VhbFZpZXdwb3J0V2lkdGggKiBzY2FsZSk7XG4gICAgICAgIGhlaWdodC52YWx1ZSA9IE1hdGgucm91bmQodmlzdWFsVmlld3BvcnRIZWlnaHQgKiBzY2FsZSk7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVTY3JvbGxiYXIpIHtcbiAgICAgICAgd2lkdGgudmFsdWUgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgaGVpZ2h0LnZhbHVlID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGgudmFsdWUgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQudmFsdWUgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHVwZGF0ZSgpO1xuICB0cnlPbk1vdW50ZWQodXBkYXRlKTtcbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlLCBsaXN0ZW5lck9wdGlvbnMpO1xuICBpZiAod2luZG93ICYmIHR5cGUgPT09IFwidmlzdWFsXCIgJiYgd2luZG93LnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3cudmlzdWFsVmlld3BvcnQsIFwicmVzaXplXCIsIHVwZGF0ZSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICBpZiAobGlzdGVuT3JpZW50YXRpb24pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdXNlTWVkaWFRdWVyeShcIihvcmllbnRhdGlvbjogcG9ydHJhaXQpXCIpO1xuICAgIHdhdGNoKG1hdGNoZXMsICgpID0+IHVwZGF0ZSgpKTtcbiAgfVxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG59XG5cbmV4cG9ydCB7IERlZmF1bHRNYWdpY0tleXNBbGlhc01hcCwgU3RvcmFnZVNlcmlhbGl6ZXJzLCBUcmFuc2l0aW9uUHJlc2V0cywgY29tcHV0ZWRBc3luYyBhcyBhc3luY0NvbXB1dGVkLCBicmVha3BvaW50c0FudERlc2lnbiwgYnJlYWtwb2ludHNCb290c3RyYXBWNSwgYnJlYWtwb2ludHNFbGVtZW50LCBicmVha3BvaW50c01hc3RlckNzcywgYnJlYWtwb2ludHNQcmltZUZsZXgsIGJyZWFrcG9pbnRzUXVhc2FyLCBicmVha3BvaW50c1NlbWF0aWMsIGJyZWFrcG9pbnRzVGFpbHdpbmQsIGJyZWFrcG9pbnRzVnVldGlmeSwgYnJlYWtwb2ludHNWdWV0aWZ5VjIsIGJyZWFrcG9pbnRzVnVldGlmeVYzLCBjbG9uZUZuSlNPTiwgY29tcHV0ZWRBc3luYywgY29tcHV0ZWRJbmplY3QsIGNyZWF0ZUZldGNoLCBjcmVhdGVSZXVzYWJsZVRlbXBsYXRlLCBjcmVhdGVUZW1wbGF0ZVByb21pc2UsIGNyZWF0ZVVucmVmRm4sIGN1c3RvbVN0b3JhZ2VFdmVudE5hbWUsIGRlZmF1bHREb2N1bWVudCwgZGVmYXVsdExvY2F0aW9uLCBkZWZhdWx0TmF2aWdhdG9yLCBkZWZhdWx0V2luZG93LCBleGVjdXRlVHJhbnNpdGlvbiwgZm9ybWF0VGltZUFnbywgZ2V0U1NSSGFuZGxlciwgbWFwR2FtZXBhZFRvWGJveDM2MENvbnRyb2xsZXIsIG9uQ2xpY2tPdXRzaWRlLCBvbkVsZW1lbnRSZW1vdmFsLCBvbktleURvd24sIG9uS2V5UHJlc3NlZCwgb25LZXlTdHJva2UsIG9uS2V5VXAsIG9uTG9uZ1ByZXNzLCBvblN0YXJ0VHlwaW5nLCBwcm92aWRlU1NSV2lkdGgsIHNldFNTUkhhbmRsZXIsIHRlbXBsYXRlUmVmLCB1bnJlZkVsZW1lbnQsIHVzZUFjdGl2ZUVsZW1lbnQsIHVzZUFuaW1hdGUsIHVzZUFzeW5jUXVldWUsIHVzZUFzeW5jU3RhdGUsIHVzZUJhc2U2NCwgdXNlQmF0dGVyeSwgdXNlQmx1ZXRvb3RoLCB1c2VCcmVha3BvaW50cywgdXNlQnJvYWRjYXN0Q2hhbm5lbCwgdXNlQnJvd3NlckxvY2F0aW9uLCB1c2VDYWNoZWQsIHVzZUNsaXBib2FyZCwgdXNlQ2xpcGJvYXJkSXRlbXMsIHVzZUNsb25lZCwgdXNlQ29sb3JNb2RlLCB1c2VDb25maXJtRGlhbG9nLCB1c2VDb3VudGRvd24sIHVzZUNzc1ZhciwgdXNlQ3VycmVudEVsZW1lbnQsIHVzZUN5Y2xlTGlzdCwgdXNlRGFyaywgdXNlRGVib3VuY2VkUmVmSGlzdG9yeSwgdXNlRGV2aWNlTW90aW9uLCB1c2VEZXZpY2VPcmllbnRhdGlvbiwgdXNlRGV2aWNlUGl4ZWxSYXRpbywgdXNlRGV2aWNlc0xpc3QsIHVzZURpc3BsYXlNZWRpYSwgdXNlRG9jdW1lbnRWaXNpYmlsaXR5LCB1c2VEcmFnZ2FibGUsIHVzZURyb3Bab25lLCB1c2VFbGVtZW50Qm91bmRpbmcsIHVzZUVsZW1lbnRCeVBvaW50LCB1c2VFbGVtZW50SG92ZXIsIHVzZUVsZW1lbnRTaXplLCB1c2VFbGVtZW50VmlzaWJpbGl0eSwgdXNlRXZlbnRCdXMsIHVzZUV2ZW50TGlzdGVuZXIsIHVzZUV2ZW50U291cmNlLCB1c2VFeWVEcm9wcGVyLCB1c2VGYXZpY29uLCB1c2VGZXRjaCwgdXNlRmlsZURpYWxvZywgdXNlRmlsZVN5c3RlbUFjY2VzcywgdXNlRm9jdXMsIHVzZUZvY3VzV2l0aGluLCB1c2VGcHMsIHVzZUZ1bGxzY3JlZW4sIHVzZUdhbWVwYWQsIHVzZUdlb2xvY2F0aW9uLCB1c2VJZGxlLCB1c2VJbWFnZSwgdXNlSW5maW5pdGVTY3JvbGwsIHVzZUludGVyc2VjdGlvbk9ic2VydmVyLCB1c2VLZXlNb2RpZmllciwgdXNlTG9jYWxTdG9yYWdlLCB1c2VNYWdpY0tleXMsIHVzZU1hbnVhbFJlZkhpc3RvcnksIHVzZU1lZGlhQ29udHJvbHMsIHVzZU1lZGlhUXVlcnksIHVzZU1lbW9pemUsIHVzZU1lbW9yeSwgdXNlTW91bnRlZCwgdXNlTW91c2UsIHVzZU1vdXNlSW5FbGVtZW50LCB1c2VNb3VzZVByZXNzZWQsIHVzZU11dGF0aW9uT2JzZXJ2ZXIsIHVzZU5hdmlnYXRvckxhbmd1YWdlLCB1c2VOZXR3b3JrLCB1c2VOb3csIHVzZU9iamVjdFVybCwgdXNlT2Zmc2V0UGFnaW5hdGlvbiwgdXNlT25saW5lLCB1c2VQYWdlTGVhdmUsIHVzZVBhcmFsbGF4LCB1c2VQYXJlbnRFbGVtZW50LCB1c2VQZXJmb3JtYW5jZU9ic2VydmVyLCB1c2VQZXJtaXNzaW9uLCB1c2VQb2ludGVyLCB1c2VQb2ludGVyTG9jaywgdXNlUG9pbnRlclN3aXBlLCB1c2VQcmVmZXJyZWRDb2xvclNjaGVtZSwgdXNlUHJlZmVycmVkQ29udHJhc3QsIHVzZVByZWZlcnJlZERhcmssIHVzZVByZWZlcnJlZExhbmd1YWdlcywgdXNlUHJlZmVycmVkUmVkdWNlZE1vdGlvbiwgdXNlUHJlZmVycmVkUmVkdWNlZFRyYW5zcGFyZW5jeSwgdXNlUHJldmlvdXMsIHVzZVJhZkZuLCB1c2VSZWZIaXN0b3J5LCB1c2VSZXNpemVPYnNlcnZlciwgdXNlU1NSV2lkdGgsIHVzZVNjcmVlbk9yaWVudGF0aW9uLCB1c2VTY3JlZW5TYWZlQXJlYSwgdXNlU2NyaXB0VGFnLCB1c2VTY3JvbGwsIHVzZVNjcm9sbExvY2ssIHVzZVNlc3Npb25TdG9yYWdlLCB1c2VTaGFyZSwgdXNlU29ydGVkLCB1c2VTcGVlY2hSZWNvZ25pdGlvbiwgdXNlU3BlZWNoU3ludGhlc2lzLCB1c2VTdGVwcGVyLCB1c2VTdG9yYWdlLCB1c2VTdG9yYWdlQXN5bmMsIHVzZVN0eWxlVGFnLCB1c2VTdXBwb3J0ZWQsIHVzZVN3aXBlLCB1c2VUZW1wbGF0ZVJlZnNMaXN0LCB1c2VUZXh0RGlyZWN0aW9uLCB1c2VUZXh0U2VsZWN0aW9uLCB1c2VUZXh0YXJlYUF1dG9zaXplLCB1c2VUaHJvdHRsZWRSZWZIaXN0b3J5LCB1c2VUaW1lQWdvLCB1c2VUaW1lb3V0UG9sbCwgdXNlVGltZXN0YW1wLCB1c2VUaXRsZSwgdXNlVHJhbnNpdGlvbiwgdXNlVXJsU2VhcmNoUGFyYW1zLCB1c2VVc2VyTWVkaWEsIHVzZVZNb2RlbCwgdXNlVk1vZGVscywgdXNlVmlicmF0ZSwgdXNlVmlydHVhbExpc3QsIHVzZVdha2VMb2NrLCB1c2VXZWJOb3RpZmljYXRpb24sIHVzZVdlYlNvY2tldCwgdXNlV2ViV29ya2VyLCB1c2VXZWJXb3JrZXJGbiwgdXNlV2luZG93Rm9jdXMsIHVzZVdpbmRvd1Njcm9sbCwgdXNlV2luZG93U2l6ZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLE1BQU0sb0JBQW9CLFVBQVUsVUFBVSxTQUFTLGdCQUFn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LFVBQU0sU0FBUyxNQUFNLE9BQU8sQ0FBQztBQUFBLEVBQy9CO0FBQ0EsU0FBTyxFQUFFLE9BQU8sT0FBTztBQUN6QjtBQUVBLFNBQVMsMEJBQTBCLG9CQUFvQixtQkFBbUIsaUJBQWlCLGVBQWUsc0JBQXNCLHdCQUF3QixvQkFBb0Isc0JBQXNCLHNCQUFzQixtQkFBbUIsb0JBQW9CLHFCQUFxQixvQkFBb0Isc0JBQXNCLHNCQUFzQixhQUFhLGVBQWUsZ0JBQWdCLGFBQWEsd0JBQXdCLHVCQUF1QixlQUFlLHdCQUF3QixpQkFBaUIsaUJBQWlCLGtCQUFrQixlQUFlLG1CQUFtQixlQUFlLGVBQWUsK0JBQStCLGdCQUFnQixrQkFBa0IsV0FBVyxjQUFjLGFBQWEsU0FBUyxhQUFhLGVBQWUsaUJBQWlCLGVBQWUsYUFBYSxjQUFjLGtCQUFrQixZQUFZLGVBQWUsZUFBZSxXQUFXLFlBQVksY0FBYyxnQkFBZ0IscUJBQXFCLG9CQUFvQixXQUFXLGNBQWMsbUJBQW1CLFdBQVcsY0FBYyxrQkFBa0IsY0FBYyxXQUFXLG1CQUFtQixjQUFjLFNBQVMsd0JBQXdCLGlCQUFpQixzQkFBc0IscUJBQXFCLGdCQUFnQixpQkFBaUIsdUJBQXVCLGNBQWMsYUFBYSxvQkFBb0IsbUJBQW1CLGlCQUFpQixnQkFBZ0Isc0JBQXNCLGFBQWEsa0JBQWtCLGdCQUFnQixlQUFlLFlBQVksVUFBVSxlQUFlLHFCQUFxQixVQUFVLGdCQUFnQixRQUFRLGVBQWUsWUFBWSxnQkFBZ0IsU0FBUyxVQUFVLG1CQUFtQix5QkFBeUIsZ0JBQWdCLGlCQUFpQixjQUFjLHFCQUFxQixrQkFBa0IsZUFBZSxZQUFZLFdBQVcsWUFBWSxVQUFVLG1CQUFtQixpQkFBaUIscUJBQXFCLHNCQUFzQixZQUFZLFFBQVEsY0FBYyxxQkFBcUIsV0FBVyxjQUFjLGFBQWEsa0JBQWtCLHdCQUF3QixlQUFlLFlBQVksZ0JBQWdCLGlCQUFpQix5QkFBeUIsc0JBQXNCLGtCQUFrQix1QkFBdUIsMkJBQTJCLGlDQUFpQyxhQUFhLFVBQVUsZUFBZSxtQkFBbUIsYUFBYSxzQkFBc0IsbUJBQW1CLGNBQWMsV0FBVyxlQUFlLG1CQUFtQixVQUFVLFdBQVcsc0JBQXNCLG9CQUFvQixZQUFZLFlBQVksaUJBQWlCLGFBQWEsY0FBYyxVQUFVLHFCQUFxQixrQkFBa0Isa0JBQWtCLHFCQUFxQix3QkFBd0IsWUFBWSxnQkFBZ0IsY0FBYyxVQUFVLGVBQWUsb0JBQW9CLGNBQWMsV0FBVyxZQUFZLFlBQVksZ0JBQWdCLGFBQWEsb0JBQW9CLGNBQWMsY0FBYyxnQkFBZ0IsZ0JBQWdCLGlCQUFpQjsiLCJuYW1lcyI6WyJ3aW5kb3ciLCJkb2N1bWVudCIsInRpbWVzdGFtcCIsIm5hdmlnYXRvciIsImV2ZW50cyIsImdldFZhbHVlIiwicmVmIiwiZGVmYXVsdHMiLCJvblVwZGF0ZWQiLCJwcmV2ZW50RGVmYXVsdCIsImtleXMiLCJpc1JlYWRvbmx5Il0sInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswXX0=