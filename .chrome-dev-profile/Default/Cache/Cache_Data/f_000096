import { noop, makeDestructurable, camelize, isClient, toArray, watchImmediate, isObject, tryOnScopeDispose, isIOS, notNullish, tryOnMounted, objectOmit, promiseTimeout, until, injectLocal, provideLocal, pxValue, increaseWithUnit, objectEntries, createRef, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, useIntervalFn, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, bypassFilter, createFilterWrapper, toRefs, watchOnce, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, tryOnUnmounted, clamp, syncRef, objectPick, watchWithFilter, identity, isDef, whenever, isWorker } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/node_modules/@vueuse/shared/index.mjs?v=1214a853";
export * from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/reka-ui/node_modules/@vueuse/shared/index.mjs?v=1214a853";
import { isRef, shallowRef, ref, watchEffect, computed, inject, defineComponent, h, TransitionGroup, shallowReactive, Fragment, toValue, unref, getCurrentInstance, onMounted, watch, customRef, onUpdated, readonly, reactive, hasInjectionContext, toRaw, nextTick, markRaw, getCurrentScope, isReadonly, onBeforeUpdate } from "/_nuxt/@fs/D:/Bill24/b24managementportal/node_modules/vue/dist/vue.runtime.esm-bundler.js?v=1214a853";
function computedAsync(evaluationCallback, initialState, optionsOrRef) {
  let options;
  if (isRef(optionsOrRef)) {
    options = {
      evaluating: optionsOrRef
    };
  } else {
    options = optionsOrRef || {};
  }
  const {
    lazy = false,
    evaluating = void 0,
    shallow = true,
    onError = noop
  } = options;
  const started = shallowRef(!lazy);
  const current = shallow ? shallowRef(initialState) : ref(initialState);
  let counter = 0;
  watchEffect(async (onInvalidate) => {
    if (!started.value)
      return;
    counter++;
    const counterAtBeginning = counter;
    let hasFinished = false;
    if (evaluating) {
      Promise.resolve().then(() => {
        evaluating.value = true;
      });
    }
    try {
      const result = await evaluationCallback((cancelCallback) => {
        onInvalidate(() => {
          if (evaluating)
            evaluating.value = false;
          if (!hasFinished)
            cancelCallback();
        });
      });
      if (counterAtBeginning === counter)
        current.value = result;
    } catch (e) {
      onError(e);
    } finally {
      if (evaluating && counterAtBeginning === counter)
        evaluating.value = false;
      hasFinished = true;
    }
  });
  if (lazy) {
    return computed(() => {
      started.value = true;
      return current.value;
    });
  } else {
    return current;
  }
}
function computedInject(key, options, defaultSource, treatDefaultAsFactory) {
  let source = inject(key);
  if (defaultSource)
    source = inject(key, defaultSource);
  if (treatDefaultAsFactory)
    source = inject(key, defaultSource, treatDefaultAsFactory);
  if (typeof options === "function") {
    return computed((ctx) => options(source, ctx));
  } else {
    return computed({
      get: (ctx) => options.get(source, ctx),
      set: options.set
    });
  }
}
function createReusableTemplate(options = {}) {
  const {
    inheritAttrs = true
  } = options;
  const render = shallowRef();
  const define = /* @__PURE__ */ defineComponent({
    setup(_, { slots }) {
      return () => {
        render.value = slots.default;
      };
    }
  });
  const reuse = /* @__PURE__ */ defineComponent({
    inheritAttrs,
    props: options.props,
    setup(props, { attrs, slots }) {
      return () => {
        var _a;
        if (!render.value && true)
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, {
          ...options.props == null ? keysToCamelKebabCase(attrs) : props,
          $slots: slots
        });
        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;
      };
    }
  });
  return makeDestructurable(
    { define, reuse },
    [define, reuse]
  );
}
function keysToCamelKebabCase(obj) {
  const newObj = {};
  for (const key in obj)
    newObj[camelize(key)] = obj[key];
  return newObj;
}
function createTemplatePromise(options = {}) {
  let index = 0;
  const instances = ref([]);
  function create(...args) {
    const props = shallowReactive({
      key: index++,
      args,
      promise: void 0,
      resolve: () => {
      },
      reject: () => {
      },
      isResolving: false,
      options
    });
    instances.value.push(props);
    props.promise = new Promise((_resolve, _reject) => {
      props.resolve = (v) => {
        props.isResolving = true;
        return _resolve(v);
      };
      props.reject = _reject;
    }).finally(() => {
      props.promise = void 0;
      const index2 = instances.value.indexOf(props);
      if (index2 !== -1)
        instances.value.splice(index2, 1);
    });
    return props.promise;
  }
  function start(...args) {
    if (options.singleton && instances.value.length > 0)
      return instances.value[0].promise;
    return create(...args);
  }
  const component = /* @__PURE__ */ defineComponent((_, { slots }) => {
    const renderList = () => instances.value.map((props) => {
      var _a;
      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));
    });
    if (options.transition)
      return () => h(TransitionGroup, options.transition, renderList);
    return renderList;
  });
  component.start = start;
  return component;
}
function createUnrefFn(fn) {
  return function(...args) {
    return fn.apply(this, args.map((i) => toValue(i)));
  };
}
const defaultWindow = isClient ? window : void 0;
const defaultDocument = isClient ? window.document : void 0;
const defaultNavigator = isClient ? window.navigator : void 0;
const defaultLocation = isClient ? window.location : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test = toArray(toValue(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(cleanup);
  return stop;
}
let _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;
  if (!window2) {
    return controls ? { stop: noop, cancel: noop, trigger: noop } : noop;
  }
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    const listenerOptions = { passive: true };
    Array.from(window2.document.body.children).forEach((el) => useEventListener(el, "click", noop, listenerOptions));
    useEventListener(window2.document.documentElement, "click", noop, listenerOptions);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return toValue(ignore).some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  function hasMultipleRoots(target2) {
    const vm = toValue(target2);
    return vm && vm.$.subTree.shapeFlag === 16;
  }
  function checkMultipleRoots(target2, event) {
    const vm = toValue(target2);
    const children = vm.$.subTree && vm.$.subTree.children;
    if (children == null || !Array.isArray(children))
      return false;
    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
  }
  const listener = (event) => {
    const el = unrefElement(target);
    if (event.target == null)
      return;
    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))
      return;
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if ("detail" in event && event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  let isProcessingClick = false;
  const cleanup = [
    useEventListener(window2, "click", (event) => {
      if (!isProcessingClick) {
        isProcessingClick = true;
        setTimeout(() => {
          isProcessingClick = false;
        }, 0);
        listener(event);
      }
    }, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
          handler(event);
        }
      }, 0);
    }, { passive: true })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  if (controls) {
    return {
      stop,
      cancel: () => {
        shouldListen = false;
      },
      trigger: (event) => {
        shouldListen = true;
        listener(event);
        shouldListen = false;
      }
    };
  }
  return stop;
}
function useMounted() {
  const isMounted = shallowRef(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const value = toValue(target);
    const items = toArray(value).map(unrefElement).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function onElementRemoval(target, callback, options = {}) {
  const {
    window: window2 = defaultWindow,
    document: document2 = window2 == null ? void 0 : window2.document,
    flush = "sync"
  } = options;
  if (!window2 || !document2)
    return noop;
  let stopFn;
  const cleanupAndUpdate = (fn) => {
    stopFn == null ? void 0 : stopFn();
    stopFn = fn;
  };
  const stopWatch = watchEffect(() => {
    const el = unrefElement(target);
    if (el) {
      const { stop } = useMutationObserver(
        document2,
        (mutationsList) => {
          const targetRemoved = mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el));
          if (targetRemoved) {
            callback(mutationsList);
          }
        },
        {
          window: window2,
          childList: true,
          subtree: true
        }
      );
      cleanupAndUpdate(stop);
    }
  }, { flush });
  const stopHandle = () => {
    stopWatch();
    cleanupAndUpdate();
  };
  tryOnScopeDispose(stopHandle);
  return stopHandle;
}
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (e.repeat && toValue(dedupe))
      return;
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive);
}
function onKeyDown(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keydown" });
}
function onKeyPressed(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keypress" });
}
function onKeyUp(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keyup" });
}
const DEFAULT_DELAY = 500;
const DEFAULT_THRESHOLD = 10;
function onLongPress(target, handler, options) {
  var _a, _b;
  const elementRef = computed(() => unrefElement(target));
  let timeout;
  let posStart;
  let startTimestamp;
  let hasLongPressed = false;
  function clear() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    posStart = void 0;
    startTimestamp = void 0;
    hasLongPressed = false;
  }
  function onRelease(ev) {
    var _a2, _b2, _c;
    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];
    clear();
    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)
      return;
    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)
      return;
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    const dx = ev.x - _posStart.x;
    const dy = ev.y - _posStart.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);
  }
  function onDown(ev) {
    var _a2, _b2, _c, _d;
    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)
      return;
    clear();
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    posStart = {
      x: ev.x,
      y: ev.y
    };
    startTimestamp = ev.timeStamp;
    timeout = setTimeout(
      () => {
        hasLongPressed = true;
        handler(ev);
      },
      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY
    );
  }
  function onMove(ev) {
    var _a2, _b2, _c, _d;
    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)
      return;
    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)
      return;
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    const dx = ev.x - posStart.x;
    const dy = ev.y - posStart.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))
      clear();
  }
  const listenerOptions = {
    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,
    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once
  };
  const cleanup = [
    useEventListener(elementRef, "pointerdown", onDown, listenerOptions),
    useEventListener(elementRef, "pointermove", onMove, listenerOptions),
    useEventListener(elementRef, ["pointerup", "pointerleave"], onRelease, listenerOptions)
  ];
  const stop = () => cleanup.forEach((fn) => fn());
  return stop;
}
function isFocusedElementEditable() {
  const { activeElement, body } = document;
  if (!activeElement)
    return false;
  if (activeElement === body)
    return false;
  switch (activeElement.tagName) {
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return activeElement.hasAttribute("contenteditable");
}
function isTypedCharValid({
  keyCode,
  metaKey,
  ctrlKey,
  altKey
}) {
  if (metaKey || ctrlKey || altKey)
    return false;
  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)
    return true;
  if (keyCode >= 65 && keyCode <= 90)
    return true;
  return false;
}
function onStartTyping(callback, options = {}) {
  const { document: document2 = defaultDocument } = options;
  const keydown = (event) => {
    if (!isFocusedElementEditable() && isTypedCharValid(event)) {
      callback(event);
    }
  };
  if (document2)
    useEventListener(document2, "keydown", keydown, { passive: true });
}
function templateRef(key, initialValue = null) {
  const instance = getCurrentInstance();
  let _trigger = () => {
  };
  const element = customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        var _a, _b;
        track();
        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;
      },
      set() {
      }
    };
  });
  tryOnMounted(_trigger);
  onUpdated(_trigger);
  return element;
}
function useActiveElement(options = {}) {
  var _a;
  const {
    window: window2 = defaultWindow,
    deep = true,
    triggerOnRemoval = false
  } = options;
  const document2 = (_a = options.document) != null ? _a : window2 == null ? void 0 : window2.document;
  const getDeepActiveElement = () => {
    var _a2;
    let element = document2 == null ? void 0 : document2.activeElement;
    if (deep) {
      while (element == null ? void 0 : element.shadowRoot)
        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
    }
    return element;
  };
  const activeElement = shallowRef();
  const trigger = () => {
    activeElement.value = getDeepActiveElement();
  };
  if (window2) {
    const listenerOptions = {
      capture: true,
      passive: true
    };
    useEventListener(
      window2,
      "blur",
      (event) => {
        if (event.relatedTarget !== null)
          return;
        trigger();
      },
      listenerOptions
    );
    useEventListener(
      window2,
      "focus",
      trigger,
      listenerOptions
    );
  }
  if (triggerOnRemoval) {
    onElementRemoval(activeElement, trigger, { document: document2 });
  }
  trigger();
  return activeElement;
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow,
    once = false
  } = options;
  const isActive = shallowRef(false);
  const intervalLimit = computed(() => {
    return fpsLimit ? 1e3 / toValue(fpsLimit) : null;
  });
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit.value && delta < intervalLimit.value) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    if (once) {
      isActive.value = false;
      rafId = null;
      return;
    }
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
function useAnimate(target, keyframes, options) {
  let config;
  let animateOptions;
  if (isObject(options)) {
    config = options;
    animateOptions = objectOmit(options, ["window", "immediate", "commitStyles", "persist", "onReady", "onError"]);
  } else {
    config = { duration: options };
    animateOptions = options;
  }
  const {
    window: window2 = defaultWindow,
    immediate = true,
    commitStyles,
    persist,
    playbackRate: _playbackRate = 1,
    onReady,
    onError = (e) => {
      console.error(e);
    }
  } = config;
  const isSupported = useSupported(() => window2 && HTMLElement && "animate" in HTMLElement.prototype);
  const animate = shallowRef(void 0);
  const store = shallowReactive({
    startTime: null,
    currentTime: null,
    timeline: null,
    playbackRate: _playbackRate,
    pending: false,
    playState: immediate ? "idle" : "paused",
    replaceState: "active"
  });
  const pending = computed(() => store.pending);
  const playState = computed(() => store.playState);
  const replaceState = computed(() => store.replaceState);
  const startTime = computed({
    get() {
      return store.startTime;
    },
    set(value) {
      store.startTime = value;
      if (animate.value)
        animate.value.startTime = value;
    }
  });
  const currentTime = computed({
    get() {
      return store.currentTime;
    },
    set(value) {
      store.currentTime = value;
      if (animate.value) {
        animate.value.currentTime = value;
        syncResume();
      }
    }
  });
  const timeline = computed({
    get() {
      return store.timeline;
    },
    set(value) {
      store.timeline = value;
      if (animate.value)
        animate.value.timeline = value;
    }
  });
  const playbackRate = computed({
    get() {
      return store.playbackRate;
    },
    set(value) {
      store.playbackRate = value;
      if (animate.value)
        animate.value.playbackRate = value;
    }
  });
  const play = () => {
    if (animate.value) {
      try {
        animate.value.play();
        syncResume();
      } catch (e) {
        syncPause();
        onError(e);
      }
    } else {
      update();
    }
  };
  const pause = () => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.pause();
      syncPause();
    } catch (e) {
      onError(e);
    }
  };
  const reverse = () => {
    var _a;
    if (!animate.value)
      update();
    try {
      (_a = animate.value) == null ? void 0 : _a.reverse();
      syncResume();
    } catch (e) {
      syncPause();
      onError(e);
    }
  };
  const finish = () => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.finish();
      syncPause();
    } catch (e) {
      onError(e);
    }
  };
  const cancel = () => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.cancel();
      syncPause();
    } catch (e) {
      onError(e);
    }
  };
  watch(() => unrefElement(target), (el) => {
    if (el) {
      update();
    } else {
      animate.value = void 0;
    }
  });
  watch(() => keyframes, (value) => {
    if (animate.value) {
      update();
      const targetEl = unrefElement(target);
      if (targetEl) {
        animate.value.effect = new KeyframeEffect(
          targetEl,
          toValue(value),
          animateOptions
        );
      }
    }
  }, { deep: true });
  tryOnMounted(() => update(true), false);
  tryOnScopeDispose(cancel);
  function update(init) {
    const el = unrefElement(target);
    if (!isSupported.value || !el)
      return;
    if (!animate.value)
      animate.value = el.animate(toValue(keyframes), animateOptions);
    if (persist)
      animate.value.persist();
    if (_playbackRate !== 1)
      animate.value.playbackRate = _playbackRate;
    if (init && !immediate)
      animate.value.pause();
    else
      syncResume();
    onReady == null ? void 0 : onReady(animate.value);
  }
  const listenerOptions = { passive: true };
  useEventListener(animate, ["cancel", "finish", "remove"], syncPause, listenerOptions);
  useEventListener(animate, "finish", () => {
    var _a;
    if (commitStyles)
      (_a = animate.value) == null ? void 0 : _a.commitStyles();
  }, listenerOptions);
  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {
    if (!animate.value)
      return;
    store.pending = animate.value.pending;
    store.playState = animate.value.playState;
    store.replaceState = animate.value.replaceState;
    store.startTime = animate.value.startTime;
    store.currentTime = animate.value.currentTime;
    store.timeline = animate.value.timeline;
    store.playbackRate = animate.value.playbackRate;
  }, { immediate: false });
  function syncResume() {
    if (isSupported.value)
      resumeRef();
  }
  function syncPause() {
    if (isSupported.value && window2)
      window2.requestAnimationFrame(pauseRef);
  }
  return {
    isSupported,
    animate,
    // actions
    play,
    pause,
    reverse,
    finish,
    cancel,
    // state
    pending,
    playState,
    replaceState,
    startTime,
    currentTime,
    timeline,
    playbackRate
  };
}
function useAsyncQueue(tasks, options) {
  const {
    interrupt = true,
    onError = noop,
    onFinished = noop,
    signal
  } = options || {};
  const promiseState = {
    aborted: "aborted",
    fulfilled: "fulfilled",
    pending: "pending",
    rejected: "rejected"
  };
  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));
  const result = reactive(initialResult);
  const activeIndex = shallowRef(-1);
  if (!tasks || tasks.length === 0) {
    onFinished();
    return {
      activeIndex,
      result
    };
  }
  function updateResult(state, res) {
    activeIndex.value++;
    result[activeIndex.value].data = res;
    result[activeIndex.value].state = state;
  }
  tasks.reduce((prev, curr) => {
    return prev.then((prevRes) => {
      var _a;
      if (signal == null ? void 0 : signal.aborted) {
        updateResult(promiseState.aborted, new Error("aborted"));
        return;
      }
      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {
        onFinished();
        return;
      }
      const done = curr(prevRes).then((currentRes) => {
        updateResult(promiseState.fulfilled, currentRes);
        if (activeIndex.value === tasks.length - 1)
          onFinished();
        return currentRes;
      });
      if (!signal)
        return done;
      return Promise.race([done, whenAborted(signal)]);
    }).catch((e) => {
      if (signal == null ? void 0 : signal.aborted) {
        updateResult(promiseState.aborted, e);
        return e;
      }
      updateResult(promiseState.rejected, e);
      onError();
      return e;
    });
  }, Promise.resolve());
  return {
    activeIndex,
    result
  };
}
function whenAborted(signal) {
  return new Promise((resolve, reject) => {
    const error = new Error("aborted");
    if (signal.aborted)
      reject(error);
    else
      signal.addEventListener("abort", () => reject(error), { once: true });
  });
}
function useAsyncState(promise, initialState, options) {
  const {
    immediate = true,
    delay = 0,
    onError = noop,
    onSuccess = noop,
    resetOnExecute = true,
    shallow = true,
    throwError
  } = options != null ? options : {};
  const state = shallow ? shallowRef(initialState) : ref(initialState);
  const isReady = shallowRef(false);
  const isLoading = shallowRef(false);
  const error = shallowRef(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      state.value = initialState;
    error.value = void 0;
    isReady.value = false;
    isLoading.value = true;
    if (delay2 > 0)
      await promiseTimeout(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data = await _promise;
      state.value = data;
      isReady.value = true;
      onSuccess(data);
    } catch (e) {
      error.value = e;
      onError(e);
      if (throwError)
        throw e;
    } finally {
      isLoading.value = false;
    }
    return state.value;
  }
  if (immediate) {
    execute(delay);
  }
  const shell = {
    state,
    isReady,
    isLoading,
    error,
    execute
  };
  function waitUntilIsLoaded() {
    return new Promise((resolve, reject) => {
      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);
    });
  }
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilIsLoaded().then(onFulfilled, onRejected);
    }
  };
}
const defaults = {
  array: (v) => JSON.stringify(v),
  object: (v) => JSON.stringify(v),
  set: (v) => JSON.stringify(Array.from(v)),
  map: (v) => JSON.stringify(Object.fromEntries(v)),
  null: () => ""
};
function getDefaultSerialization(target) {
  if (!target)
    return defaults.null;
  if (target instanceof Map)
    return defaults.map;
  else if (target instanceof Set)
    return defaults.set;
  else if (Array.isArray(target))
    return defaults.array;
  else
    return defaults.object;
}
function useBase64(target, options) {
  const base64 = shallowRef("");
  const promise = shallowRef();
  function execute() {
    if (!isClient)
      return;
    promise.value = new Promise((resolve, reject) => {
      try {
        const _target = toValue(target);
        if (_target == null) {
          resolve("");
        } else if (typeof _target === "string") {
          resolve(blobToBase64(new Blob([_target], { type: "text/plain" })));
        } else if (_target instanceof Blob) {
          resolve(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
          }).catch(reject);
        } else if (typeof _target === "object") {
          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);
          const serialized = _serializeFn(_target);
          return resolve(blobToBase64(new Blob([serialized], { type: "application/json" })));
        } else {
          reject(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject(error);
      }
    });
    promise.value.then((res) => {
      base64.value = (options == null ? void 0 : options.dataUrl) === false ? res.replace(/^data:.*?;base64,/, "") : res;
    });
    return promise.value;
  }
  if (isRef(target) || typeof target === "function")
    watch(target, execute, { immediate: true });
  else
    execute();
  return {
    base64,
    promise,
    execute
  };
}
function imgLoaded(img) {
  return new Promise((resolve, reject) => {
    if (!img.complete) {
      img.onload = () => {
        resolve();
      };
      img.onerror = reject;
    } else {
      resolve();
    }
  });
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = (e) => {
      resolve(e.target.result);
    };
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
function useBattery(options = {}) {
  const { navigator: navigator2 = defaultNavigator } = options;
  const events2 = ["chargingchange", "chargingtimechange", "dischargingtimechange", "levelchange"];
  const isSupported = useSupported(() => navigator2 && "getBattery" in navigator2 && typeof navigator2.getBattery === "function");
  const charging = shallowRef(false);
  const chargingTime = shallowRef(0);
  const dischargingTime = shallowRef(0);
  const level = shallowRef(1);
  let battery;
  function updateBatteryInfo() {
    charging.value = this.charging;
    chargingTime.value = this.chargingTime || 0;
    dischargingTime.value = this.dischargingTime || 0;
    level.value = this.level;
  }
  if (isSupported.value) {
    navigator2.getBattery().then((_battery) => {
      battery = _battery;
      updateBatteryInfo.call(battery);
      useEventListener(battery, events2, updateBatteryInfo, { passive: true });
    });
  }
  return {
    isSupported,
    charging,
    chargingTime,
    dischargingTime,
    level
  };
}
function useBluetooth(options) {
  let {
    acceptAllDevices = false
  } = options || {};
  const {
    filters = void 0,
    optionalServices = void 0,
    navigator: navigator2 = defaultNavigator
  } = options || {};
  const isSupported = useSupported(() => navigator2 && "bluetooth" in navigator2);
  const device = shallowRef();
  const error = shallowRef(null);
  watch(device, () => {
    connectToBluetoothGATTServer();
  });
  async function requestDevice() {
    if (!isSupported.value)
      return;
    error.value = null;
    if (filters && filters.length > 0)
      acceptAllDevices = false;
    try {
      device.value = await (navigator2 == null ? void 0 : navigator2.bluetooth.requestDevice({
        acceptAllDevices,
        filters,
        optionalServices
      }));
    } catch (err) {
      error.value = err;
    }
  }
  const server = shallowRef();
  const isConnected = shallowRef(false);
  function reset() {
    isConnected.value = false;
    device.value = void 0;
    server.value = void 0;
  }
  async function connectToBluetoothGATTServer() {
    error.value = null;
    if (device.value && device.value.gatt) {
      useEventListener(device, "gattserverdisconnected", reset, { passive: true });
      try {
        server.value = await device.value.gatt.connect();
        isConnected.value = server.value.connected;
      } catch (err) {
        error.value = err;
      }
    }
  }
  tryOnMounted(() => {
    var _a;
    if (device.value)
      (_a = device.value.gatt) == null ? void 0 : _a.connect();
  });
  tryOnScopeDispose(() => {
    var _a;
    if (device.value)
      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();
  });
  return {
    isSupported,
    isConnected: readonly(isConnected),
    // Device:
    device,
    requestDevice,
    // Server:
    server,
    // Errors:
    error
  };
}
const ssrWidthSymbol = Symbol("vueuse-ssr-width");
function useSSRWidth() {
  const ssrWidth = hasInjectionContext() ? injectLocal(ssrWidthSymbol, null) : null;
  return typeof ssrWidth === "number" ? ssrWidth : void 0;
}
function provideSSRWidth(width, app) {
  if (app !== void 0) {
    app.provide(ssrWidthSymbol, width);
  } else {
    provideLocal(ssrWidthSymbol, width);
  }
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow, ssrWidth = useSSRWidth() } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  const ssrSupport = shallowRef(typeof ssrWidth === "number");
  const mediaQuery = shallowRef();
  const matches = shallowRef(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  watchEffect(() => {
    if (ssrSupport.value) {
      ssrSupport.value = !isSupported.value;
      const queryStrings = toValue(query).split(",");
      matches.value = queryStrings.some((queryString) => {
        const not = queryString.includes("not all");
        const minWidth = queryString.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        const maxWidth = queryString.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let res = Boolean(minWidth || maxWidth);
        if (minWidth && res) {
          res = ssrWidth >= pxValue(minWidth[1]);
        }
        if (maxWidth && res) {
          res = ssrWidth <= pxValue(maxWidth[1]);
        }
        return not ? !res : res;
      });
      return;
    }
    if (!isSupported.value)
      return;
    mediaQuery.value = window2.matchMedia(toValue(query));
    matches.value = mediaQuery.value.matches;
  });
  useEventListener(mediaQuery, "change", handler, { passive: true });
  return computed(() => matches.value);
}
const breakpointsTailwind = {
  "sm": 640,
  "md": 768,
  "lg": 1024,
  "xl": 1280,
  "2xl": 1536
};
const breakpointsBootstrapV5 = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
const breakpointsVuetifyV2 = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1264,
  xl: 1904
};
const breakpointsVuetifyV3 = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1280,
  xl: 1920,
  xxl: 2560
};
const breakpointsVuetify = breakpointsVuetifyV2;
const breakpointsAntDesign = {
  xs: 480,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1600
};
const breakpointsQuasar = {
  xs: 0,
  sm: 600,
  md: 1024,
  lg: 1440,
  xl: 1920
};
const breakpointsSematic = {
  mobileS: 320,
  mobileM: 375,
  mobileL: 425,
  tablet: 768,
  laptop: 1024,
  laptopL: 1440,
  desktop4K: 2560
};
const breakpointsMasterCss = {
  "3xs": 360,
  "2xs": 480,
  "xs": 600,
  "sm": 768,
  "md": 1024,
  "lg": 1280,
  "xl": 1440,
  "2xl": 1600,
  "3xl": 1920,
  "4xl": 2560
};
const breakpointsPrimeFlex = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
const breakpointsElement = {
  xs: 0,
  sm: 768,
  md: 992,
  lg: 1200,
  xl: 1920
};
function useBreakpoints(breakpoints, options = {}) {
  function getValue2(k, delta) {
    let v = toValue(breakpoints[toValue(k)]);
    if (delta != null)
      v = increaseWithUnit(v, delta);
    if (typeof v === "number")
      v = `${v}px`;
    return v;
  }
  const { window: window2 = defaultWindow, strategy = "min-width", ssrWidth = useSSRWidth() } = options;
  const ssrSupport = typeof ssrWidth === "number";
  const mounted = ssrSupport ? shallowRef(false) : { value: true };
  if (ssrSupport) {
    tryOnMounted(() => mounted.value = !!window2);
  }
  function match(query, size) {
    if (!mounted.value && ssrSupport) {
      return query === "min" ? ssrWidth >= pxValue(size) : ssrWidth <= pxValue(size);
    }
    if (!window2)
      return false;
    return window2.matchMedia(`(${query}-width: ${size})`).matches;
  }
  const greaterOrEqual = (k) => {
    return useMediaQuery(() => `(min-width: ${getValue2(k)})`, options);
  };
  const smallerOrEqual = (k) => {
    return useMediaQuery(() => `(max-width: ${getValue2(k)})`, options);
  };
  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      get: () => strategy === "min-width" ? greaterOrEqual(k) : smallerOrEqual(k),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  function current() {
    const points = Object.keys(breakpoints).map((k) => [k, shortcutMethods[k], pxValue(getValue2(k))]).sort((a, b) => a[2] - b[2]);
    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));
  }
  return Object.assign(shortcutMethods, {
    greaterOrEqual,
    smallerOrEqual,
    greater(k) {
      return useMediaQuery(() => `(min-width: ${getValue2(k, 0.1)})`, options);
    },
    smaller(k) {
      return useMediaQuery(() => `(max-width: ${getValue2(k, -0.1)})`, options);
    },
    between(a, b) {
      return useMediaQuery(() => `(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`, options);
    },
    isGreater(k) {
      return match("min", getValue2(k, 0.1));
    },
    isGreaterOrEqual(k) {
      return match("min", getValue2(k));
    },
    isSmaller(k) {
      return match("max", getValue2(k, -0.1));
    },
    isSmallerOrEqual(k) {
      return match("max", getValue2(k));
    },
    isInBetween(a, b) {
      return match("min", getValue2(a)) && match("max", getValue2(b, -0.1));
    },
    current,
    active() {
      const bps = current();
      return computed(() => bps.value.length === 0 ? "" : bps.value.at(strategy === "min-width" ? -1 : 0));
    }
  });
}
function useBroadcastChannel(options) {
  const {
    name,
    window: window2 = defaultWindow
  } = options;
  const isSupported = useSupported(() => window2 && "BroadcastChannel" in window2);
  const isClosed = shallowRef(false);
  const channel = ref();
  const data = ref();
  const error = shallowRef(null);
  const post = (data2) => {
    if (channel.value)
      channel.value.postMessage(data2);
  };
  const close = () => {
    if (channel.value)
      channel.value.close();
    isClosed.value = true;
  };
  if (isSupported.value) {
    tryOnMounted(() => {
      error.value = null;
      channel.value = new BroadcastChannel(name);
      const listenerOptions = {
        passive: true
      };
      useEventListener(channel, "message", (e) => {
        data.value = e.data;
      }, listenerOptions);
      useEventListener(channel, "messageerror", (e) => {
        error.value = e;
      }, listenerOptions);
      useEventListener(channel, "close", () => {
        isClosed.value = true;
      }, listenerOptions);
    });
  }
  tryOnScopeDispose(() => {
    close();
  });
  return {
    isSupported,
    channel,
    data,
    post,
    close,
    error,
    isClosed
  };
}
const WRITABLE_PROPERTIES = [
  "hash",
  "host",
  "hostname",
  "href",
  "pathname",
  "port",
  "protocol",
  "search"
];
function useBrowserLocation(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const refs = Object.fromEntries(
    WRITABLE_PROPERTIES.map((key) => [key, ref()])
  );
  for (const [key, ref2] of objectEntries(refs)) {
    watch(ref2, (value) => {
      if (!(window2 == null ? void 0 : window2.location) || window2.location[key] === value)
        return;
      window2.location[key] = value;
    });
  }
  const buildState = (trigger) => {
    var _a;
    const { state: state2, length } = (window2 == null ? void 0 : window2.history) || {};
    const { origin } = (window2 == null ? void 0 : window2.location) || {};
    for (const key of WRITABLE_PROPERTIES)
      refs[key].value = (_a = window2 == null ? void 0 : window2.location) == null ? void 0 : _a[key];
    return reactive({
      trigger,
      state: state2,
      length,
      origin,
      ...refs
    });
  };
  const state = ref(buildState("load"));
  if (window2) {
    const listenerOptions = { passive: true };
    useEventListener(window2, "popstate", () => state.value = buildState("popstate"), listenerOptions);
    useEventListener(window2, "hashchange", () => state.value = buildState("hashchange"), listenerOptions);
  }
  return state;
}
function useCached(refValue, comparator = (a, b) => a === b, options) {
  const { deepRefs = true, ...watchOptions } = options || {};
  const cachedValue = createRef(refValue.value, deepRefs);
  watch(() => refValue.value, (value) => {
    if (!comparator(value, cachedValue.value))
      cachedValue.value = value;
  }, watchOptions);
  return cachedValue;
}
function usePermission(permissionDesc, options = {}) {
  const {
    controls = false,
    navigator: navigator2 = defaultNavigator
  } = options;
  const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
  const permissionStatus = shallowRef();
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const state = shallowRef();
  const update = () => {
    var _a, _b;
    state.value = (_b = (_a = permissionStatus.value) == null ? void 0 : _a.state) != null ? _b : "prompt";
  };
  useEventListener(permissionStatus, "change", update, { passive: true });
  const query = createSingletonPromise(async () => {
    if (!isSupported.value)
      return;
    if (!permissionStatus.value) {
      try {
        permissionStatus.value = await navigator2.permissions.query(desc);
      } catch (e) {
        permissionStatus.value = void 0;
      } finally {
        update();
      }
    }
    if (controls)
      return toRaw(permissionStatus.value);
  });
  query();
  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  } else {
    return state;
  }
}
function useClipboard(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500,
    legacy = false
  } = options;
  const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
  const permissionRead = usePermission("clipboard-read");
  const permissionWrite = usePermission("clipboard-write");
  const isSupported = computed(() => isClipboardApiSupported.value || legacy);
  const text = shallowRef("");
  const copied = shallowRef(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });
  async function updateText() {
    let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionRead.value));
    if (!useLegacy) {
      try {
        text.value = await navigator2.clipboard.readText();
      } catch (e) {
        useLegacy = true;
      }
    }
    if (useLegacy) {
      text.value = legacyRead();
    }
  }
  if (isSupported.value && read)
    useEventListener(["copy", "cut"], updateText, { passive: true });
  async function copy(value = toValue(source)) {
    if (isSupported.value && value != null) {
      let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionWrite.value));
      if (!useLegacy) {
        try {
          await navigator2.clipboard.writeText(value);
        } catch (e) {
          useLegacy = true;
        }
      }
      if (useLegacy)
        legacyCopy(value);
      text.value = value;
      copied.value = true;
      timeout.start();
    }
  }
  function legacyCopy(value) {
    const ta = document.createElement("textarea");
    ta.value = value != null ? value : "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  function legacyRead() {
    var _a, _b, _c;
    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
  }
  function isAllowed(status) {
    return status === "granted" || status === "prompt";
  }
  return {
    isSupported,
    text,
    copied,
    copy
  };
}
function useClipboardItems(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500
  } = options;
  const isSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
  const content = ref([]);
  const copied = shallowRef(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });
  function updateContent() {
    if (isSupported.value) {
      navigator2.clipboard.read().then((items) => {
        content.value = items;
      });
    }
  }
  if (isSupported.value && read)
    useEventListener(["copy", "cut"], updateContent, { passive: true });
  async function copy(value = toValue(source)) {
    if (isSupported.value && value != null) {
      await navigator2.clipboard.write(value);
      content.value = value;
      copied.value = true;
      timeout.start();
    }
  }
  return {
    isSupported,
    content,
    copied,
    copy
  };
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
function useCloned(source, options = {}) {
  const cloned = ref({});
  const isModified = shallowRef(false);
  let _lastSync = false;
  const {
    manual,
    clone = cloneFnJSON,
    // watch options
    deep = true,
    immediate = true
  } = options;
  watch(cloned, () => {
    if (_lastSync) {
      _lastSync = false;
      return;
    }
    isModified.value = true;
  }, {
    deep: true,
    flush: "sync"
  });
  function sync() {
    _lastSync = true;
    isModified.value = false;
    cloned.value = clone(toValue(source));
  }
  if (!manual && (isRef(source) || typeof source === "function")) {
    watch(source, sync, {
      ...options,
      deep,
      immediate
    });
  } else {
    sync();
  }
  return { cloned, isModified, sync };
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function setSSRHandler(key, fn) {
  handlers[key] = fn;
}
function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => Number.parseFloat(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    },
    initOnMounted
  } = options;
  const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
  const keyComputed = computed(() => toValue(key));
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data;
  const rawInit = toValue(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(
    data,
    () => write(data.value),
    { flush, deep, eventFilter }
  );
  watch(keyComputed, () => update(), { flush });
  if (window2 && listenToStorageChanges) {
    tryOnMounted(() => {
      if (storage instanceof Storage)
        useEventListener(window2, "storage", update, { passive: true });
      else
        useEventListener(window2, customStorageEventName, updateFromCustomEvent);
      if (initOnMounted)
        update();
    });
  }
  if (!initOnMounted)
    update();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2) {
      const payload = {
        key: keyComputed.value,
        oldValue,
        newValue,
        storageArea: storage
      };
      window2.dispatchEvent(storage instanceof Storage ? new StorageEvent("storage", payload) : new CustomEvent(customStorageEventName, {
        detail: payload
      }));
    }
  }
  function write(v) {
    try {
      const oldValue = storage.getItem(keyComputed.value);
      if (v == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(keyComputed.value);
      } else {
        const serialized = serializer.write(v);
        if (oldValue !== serialized) {
          storage.setItem(keyComputed.value, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(keyComputed.value);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage.setItem(keyComputed.value, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value, rawInit);
      else if (type === "object" && !Array.isArray(value))
        return { ...rawInit, ...value };
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== keyComputed.value)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
        data.value = read(event);
    } catch (e) {
      onError(e);
    } finally {
      if (event)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  return data;
}
const CSS_DISABLE_TRANS = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function useColorMode(options = {}) {
  const {
    selector = "html",
    attribute = "class",
    initialValue = "auto",
    window: window2 = defaultWindow,
    storage,
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef,
    emitAuto,
    disableTransition = true
  } = options;
  const modes = {
    auto: "",
    light: "light",
    dark: "dark",
    ...options.modes || {}
  };
  const preferredDark = usePreferredDark({ window: window2 });
  const system = computed(() => preferredDark.value ? "dark" : "light");
  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
  const state = computed(() => store.value === "auto" ? system.value : store.value);
  const updateHTMLAttrs = getSSRHandler(
    "updateHTMLAttrs",
    (selector2, attribute2, value) => {
      const el = typeof selector2 === "string" ? window2 == null ? void 0 : window2.document.querySelector(selector2) : unrefElement(selector2);
      if (!el)
        return;
      const classesToAdd = /* @__PURE__ */ new Set();
      const classesToRemove = /* @__PURE__ */ new Set();
      let attributeToChange = null;
      if (attribute2 === "class") {
        const current = value.split(/\s/g);
        Object.values(modes).flatMap((i) => (i || "").split(/\s/g)).filter(Boolean).forEach((v) => {
          if (current.includes(v))
            classesToAdd.add(v);
          else
            classesToRemove.add(v);
        });
      } else {
        attributeToChange = { key: attribute2, value };
      }
      if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)
        return;
      let style;
      if (disableTransition) {
        style = window2.document.createElement("style");
        style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));
        window2.document.head.appendChild(style);
      }
      for (const c of classesToAdd) {
        el.classList.add(c);
      }
      for (const c of classesToRemove) {
        el.classList.remove(c);
      }
      if (attributeToChange) {
        el.setAttribute(attributeToChange.key, attributeToChange.value);
      }
      if (disableTransition) {
        window2.getComputedStyle(style).opacity;
        document.head.removeChild(style);
      }
    }
  );
  function defaultOnChanged(mode) {
    var _a;
    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);
  }
  function onChanged(mode) {
    if (options.onChanged)
      options.onChanged(mode, defaultOnChanged);
    else
      defaultOnChanged(mode);
  }
  watch(state, onChanged, { flush: "post", immediate: true });
  tryOnMounted(() => onChanged(state.value));
  const auto = computed({
    get() {
      return emitAuto ? store.value : state.value;
    },
    set(v) {
      store.value = v;
    }
  });
  return Object.assign(auto, { store, system, state });
}
function useConfirmDialog(revealed = shallowRef(false)) {
  const confirmHook = createEventHook();
  const cancelHook = createEventHook();
  const revealHook = createEventHook();
  let _resolve = noop;
  const reveal = (data) => {
    revealHook.trigger(data);
    revealed.value = true;
    return new Promise((resolve) => {
      _resolve = resolve;
    });
  };
  const confirm = (data) => {
    revealed.value = false;
    confirmHook.trigger(data);
    _resolve({ data, isCanceled: false });
  };
  const cancel = (data) => {
    revealed.value = false;
    cancelHook.trigger(data);
    _resolve({ data, isCanceled: true });
  };
  return {
    isRevealed: computed(() => revealed.value),
    reveal,
    confirm,
    cancel,
    onReveal: revealHook.on,
    onConfirm: confirmHook.on,
    onCancel: cancelHook.on
  };
}
function useCountdown(initialCountdown, options) {
  var _a, _b;
  const remaining = shallowRef(toValue(initialCountdown));
  const intervalController = useIntervalFn(() => {
    var _a2, _b2;
    const value = remaining.value - 1;
    remaining.value = value < 0 ? 0 : value;
    (_a2 = options == null ? void 0 : options.onTick) == null ? void 0 : _a2.call(options);
    if (remaining.value <= 0) {
      intervalController.pause();
      (_b2 = options == null ? void 0 : options.onComplete) == null ? void 0 : _b2.call(options);
    }
  }, (_a = options == null ? void 0 : options.interval) != null ? _a : 1e3, { immediate: (_b = options == null ? void 0 : options.immediate) != null ? _b : false });
  const reset = (countdown) => {
    var _a2;
    remaining.value = (_a2 = toValue(countdown)) != null ? _a2 : toValue(initialCountdown);
  };
  const stop = () => {
    intervalController.pause();
    reset();
  };
  const resume = () => {
    if (!intervalController.isActive.value) {
      if (remaining.value > 0) {
        intervalController.resume();
      }
    }
  };
  const start = (countdown) => {
    reset(countdown);
    intervalController.resume();
  };
  return {
    remaining,
    reset,
    stop,
    start,
    pause: intervalController.pause,
    resume,
    isActive: intervalController.isActive
  };
}
function useCssVar(prop, target, options = {}) {
  const { window: window2 = defaultWindow, initialValue, observe = false } = options;
  const variable = shallowRef(initialValue);
  const elRef = computed(() => {
    var _a;
    return unrefElement(target) || ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
  });
  function updateCssVar() {
    var _a;
    const key = toValue(prop);
    const el = toValue(elRef);
    if (el && window2 && key) {
      const value = (_a = window2.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();
      variable.value = value || variable.value || initialValue;
    }
  }
  if (observe) {
    useMutationObserver(elRef, updateCssVar, {
      attributeFilter: ["style", "class"],
      window: window2
    });
  }
  watch(
    [elRef, () => toValue(prop)],
    (_, old) => {
      if (old[0] && old[1])
        old[0].style.removeProperty(old[1]);
      updateCssVar();
    },
    { immediate: true }
  );
  watch(
    [variable, elRef],
    ([val, el]) => {
      const raw_prop = toValue(prop);
      if ((el == null ? void 0 : el.style) && raw_prop) {
        if (val == null)
          el.style.removeProperty(raw_prop);
        else
          el.style.setProperty(raw_prop, val);
      }
    },
    { immediate: true }
  );
  return variable;
}
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance();
  const currentElement = computedWithControl(
    () => null,
    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el
  );
  onUpdated(currentElement.trigger);
  onMounted(currentElement.trigger);
  return currentElement;
}
function useCycleList(list, options) {
  const state = shallowRef(getInitialValue());
  const listRef = toRef(list);
  const index = computed({
    get() {
      var _a;
      const targetList = listRef.value;
      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);
      if (index2 < 0)
        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;
      return index2;
    },
    set(v) {
      set(v);
    }
  });
  function set(i) {
    const targetList = listRef.value;
    const length = targetList.length;
    const index2 = (i % length + length) % length;
    const value = targetList[index2];
    state.value = value;
    return value;
  }
  function shift(delta = 1) {
    return set(index.value + delta);
  }
  function next(n = 1) {
    return shift(n);
  }
  function prev(n = 1) {
    return shift(-n);
  }
  function getInitialValue() {
    var _a, _b;
    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;
  }
  watch(listRef, () => set(index.value));
  return {
    state,
    index,
    next,
    prev,
    go: set
  };
}
function useDark(options = {}) {
  const {
    valueDark = "dark",
    valueLight = ""
  } = options;
  const mode = useColorMode({
    ...options,
    onChanged: (mode2, defaultHandler) => {
      var _a;
      if (options.onChanged)
        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === "dark", defaultHandler, mode2);
      else
        defaultHandler(mode2);
    },
    modes: {
      dark: valueDark,
      light: valueLight
    }
  });
  const system = computed(() => mode.system.value);
  const isDark = computed({
    get() {
      return mode.value === "dark";
    },
    set(v) {
      const modeVal = v ? "dark" : "light";
      if (system.value === modeVal)
        mode.value = "auto";
      else
        mode.value = modeVal;
    }
  });
  return isDark;
}
function fnBypass(v) {
  return v;
}
function fnSetSource(source, value) {
  return source.value = value;
}
function defaultDump(clone) {
  return clone ? typeof clone === "function" ? clone : cloneFnJSON : fnBypass;
}
function defaultParse(clone) {
  return clone ? typeof clone === "function" ? clone : cloneFnJSON : fnBypass;
}
function useManualRefHistory(source, options = {}) {
  const {
    clone = false,
    dump = defaultDump(clone),
    parse = defaultParse(clone),
    setSource = fnSetSource
  } = options;
  function _createHistoryRecord() {
    return markRaw({
      snapshot: dump(source.value),
      timestamp: timestamp()
    });
  }
  const last = ref(_createHistoryRecord());
  const undoStack = ref([]);
  const redoStack = ref([]);
  const _setSource = (record) => {
    setSource(source, parse(record.snapshot));
    last.value = record;
  };
  const commit = () => {
    undoStack.value.unshift(last.value);
    last.value = _createHistoryRecord();
    if (options.capacity && undoStack.value.length > options.capacity)
      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);
    if (redoStack.value.length)
      redoStack.value.splice(0, redoStack.value.length);
  };
  const clear = () => {
    undoStack.value.splice(0, undoStack.value.length);
    redoStack.value.splice(0, redoStack.value.length);
  };
  const undo = () => {
    const state = undoStack.value.shift();
    if (state) {
      redoStack.value.unshift(last.value);
      _setSource(state);
    }
  };
  const redo = () => {
    const state = redoStack.value.shift();
    if (state) {
      undoStack.value.unshift(last.value);
      _setSource(state);
    }
  };
  const reset = () => {
    _setSource(last.value);
  };
  const history = computed(() => [last.value, ...undoStack.value]);
  const canUndo = computed(() => undoStack.value.length > 0);
  const canRedo = computed(() => redoStack.value.length > 0);
  return {
    source,
    undoStack,
    redoStack,
    last,
    history,
    canUndo,
    canRedo,
    clear,
    commit,
    reset,
    undo,
    redo
  };
}
function useRefHistory(source, options = {}) {
  const {
    deep = false,
    flush = "pre",
    eventFilter
  } = options;
  const {
    eventFilter: composedFilter,
    pause,
    resume: resumeTracking,
    isActive: isTracking
  } = pausableFilter(eventFilter);
  const {
    ignoreUpdates,
    ignorePrevAsyncUpdates,
    stop
  } = watchIgnorable(
    source,
    commit,
    { deep, flush, eventFilter: composedFilter }
  );
  function setSource(source2, value) {
    ignorePrevAsyncUpdates();
    ignoreUpdates(() => {
      source2.value = value;
    });
  }
  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });
  const { clear, commit: manualCommit } = manualHistory;
  function commit() {
    ignorePrevAsyncUpdates();
    manualCommit();
  }
  function resume(commitNow) {
    resumeTracking();
    if (commitNow)
      commit();
  }
  function batch(fn) {
    let canceled = false;
    const cancel = () => canceled = true;
    ignoreUpdates(() => {
      fn(cancel);
    });
    if (!canceled)
      commit();
  }
  function dispose() {
    stop();
    clear();
  }
  return {
    ...manualHistory,
    isTracking,
    pause,
    resume,
    commit,
    batch,
    dispose
  };
}
function useDebouncedRefHistory(source, options = {}) {
  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;
  const history = useRefHistory(source, { ...options, eventFilter: filter });
  return {
    ...history
  };
}
function useDeviceMotion(options = {}) {
  const {
    window: window2 = defaultWindow,
    requestPermissions = false,
    eventFilter = bypassFilter
  } = options;
  const isSupported = useSupported(() => typeof DeviceMotionEvent !== "undefined");
  const requirePermissions = useSupported(() => isSupported.value && "requestPermission" in DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === "function");
  const permissionGranted = shallowRef(false);
  const acceleration = ref({ x: null, y: null, z: null });
  const rotationRate = ref({ alpha: null, beta: null, gamma: null });
  const interval = shallowRef(0);
  const accelerationIncludingGravity = ref({
    x: null,
    y: null,
    z: null
  });
  function init() {
    if (window2) {
      const onDeviceMotion = createFilterWrapper(
        eventFilter,
        (event) => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i;
          acceleration.value = {
            x: ((_a = event.acceleration) == null ? void 0 : _a.x) || null,
            y: ((_b = event.acceleration) == null ? void 0 : _b.y) || null,
            z: ((_c = event.acceleration) == null ? void 0 : _c.z) || null
          };
          accelerationIncludingGravity.value = {
            x: ((_d = event.accelerationIncludingGravity) == null ? void 0 : _d.x) || null,
            y: ((_e = event.accelerationIncludingGravity) == null ? void 0 : _e.y) || null,
            z: ((_f = event.accelerationIncludingGravity) == null ? void 0 : _f.z) || null
          };
          rotationRate.value = {
            alpha: ((_g = event.rotationRate) == null ? void 0 : _g.alpha) || null,
            beta: ((_h = event.rotationRate) == null ? void 0 : _h.beta) || null,
            gamma: ((_i = event.rotationRate) == null ? void 0 : _i.gamma) || null
          };
          interval.value = event.interval;
        }
      );
      useEventListener(window2, "devicemotion", onDeviceMotion, { passive: true });
    }
  }
  const ensurePermissions = async () => {
    if (!requirePermissions.value)
      permissionGranted.value = true;
    if (permissionGranted.value)
      return;
    if (requirePermissions.value) {
      const requestPermission = DeviceMotionEvent.requestPermission;
      try {
        const response = await requestPermission();
        if (response === "granted") {
          permissionGranted.value = true;
          init();
        }
      } catch (error) {
        console.error(error);
      }
    }
  };
  if (isSupported.value) {
    if (requestPermissions && requirePermissions.value) {
      ensurePermissions().then(() => init());
    } else {
      init();
    }
  }
  return {
    acceleration,
    accelerationIncludingGravity,
    rotationRate,
    interval,
    isSupported,
    requirePermissions,
    ensurePermissions,
    permissionGranted
  };
}
function useDeviceOrientation(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "DeviceOrientationEvent" in window2);
  const isAbsolute = shallowRef(false);
  const alpha = shallowRef(null);
  const beta = shallowRef(null);
  const gamma = shallowRef(null);
  if (window2 && isSupported.value) {
    useEventListener(window2, "deviceorientation", (event) => {
      isAbsolute.value = event.absolute;
      alpha.value = event.alpha;
      beta.value = event.beta;
      gamma.value = event.gamma;
    }, { passive: true });
  }
  return {
    isSupported,
    isAbsolute,
    alpha,
    beta,
    gamma
  };
}
function useDevicePixelRatio(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const pixelRatio = shallowRef(1);
  const query = useMediaQuery(() => `(resolution: ${pixelRatio.value}dppx)`, options);
  let stop = noop;
  if (window2) {
    stop = watchImmediate(query, () => pixelRatio.value = window2.devicePixelRatio);
  }
  return {
    pixelRatio: readonly(pixelRatio),
    stop
  };
}
function useDevicesList(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    requestPermissions = false,
    constraints = { audio: true, video: true },
    onUpdated: onUpdated2
  } = options;
  const devices = ref([]);
  const videoInputs = computed(() => devices.value.filter((i) => i.kind === "videoinput"));
  const audioInputs = computed(() => devices.value.filter((i) => i.kind === "audioinput"));
  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === "audiooutput"));
  const isSupported = useSupported(() => navigator2 && navigator2.mediaDevices && navigator2.mediaDevices.enumerateDevices);
  const permissionGranted = shallowRef(false);
  let stream;
  async function update() {
    if (!isSupported.value)
      return;
    devices.value = await navigator2.mediaDevices.enumerateDevices();
    onUpdated2 == null ? void 0 : onUpdated2(devices.value);
    if (stream) {
      stream.getTracks().forEach((t) => t.stop());
      stream = null;
    }
  }
  async function ensurePermissions() {
    const deviceName = constraints.video ? "camera" : "microphone";
    if (!isSupported.value)
      return false;
    if (permissionGranted.value)
      return true;
    const { state, query } = usePermission(deviceName, { controls: true });
    await query();
    if (state.value !== "granted") {
      let granted = true;
      try {
        stream = await navigator2.mediaDevices.getUserMedia(constraints);
      } catch (e) {
        stream = null;
        granted = false;
      }
      update();
      permissionGranted.value = granted;
    } else {
      permissionGranted.value = true;
    }
    return permissionGranted.value;
  }
  if (isSupported.value) {
    if (requestPermissions)
      ensurePermissions();
    useEventListener(navigator2.mediaDevices, "devicechange", update, { passive: true });
    update();
  }
  return {
    devices,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported
  };
}
function useDisplayMedia(options = {}) {
  var _a;
  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);
  const video = options.video;
  const audio = options.audio;
  const { navigator: navigator2 = defaultNavigator } = options;
  const isSupported = useSupported(() => {
    var _a2;
    return (_a2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;
  });
  const constraint = { audio, video };
  const stream = shallowRef();
  async function _start() {
    var _a2;
    if (!isSupported.value || stream.value)
      return;
    stream.value = await navigator2.mediaDevices.getDisplayMedia(constraint);
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => useEventListener(t, "ended", stop, { passive: true }));
    return stream.value;
  }
  async function _stop() {
    var _a2;
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());
    stream.value = void 0;
  }
  function stop() {
    _stop();
    enabled.value = false;
  }
  async function start() {
    await _start();
    if (stream.value)
      enabled.value = true;
    return stream.value;
  }
  watch(
    enabled,
    (v) => {
      if (v)
        _start();
      else
        _stop();
    },
    { immediate: true }
  );
  return {
    isSupported,
    stream,
    start,
    stop,
    enabled
  };
}
function useDocumentVisibility(options = {}) {
  const { document: document2 = defaultDocument } = options;
  if (!document2)
    return shallowRef("visible");
  const visibility = shallowRef(document2.visibilityState);
  useEventListener(document2, "visibilitychange", () => {
    visibility.value = document2.visibilityState;
  }, { passive: true });
  return visibility;
}
function useDraggable(target, options = {}) {
  var _a;
  const {
    pointerTypes,
    preventDefault: preventDefault2,
    stopPropagation,
    exact,
    onMove,
    onEnd,
    onStart,
    initialValue,
    axis = "both",
    draggingElement = defaultWindow,
    containerElement,
    handle: draggingHandle = target,
    buttons = [0]
  } = options;
  const position = ref(
    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }
  );
  const pressedDelta = ref();
  const filterEvent = (e) => {
    if (pointerTypes)
      return pointerTypes.includes(e.pointerType);
    return true;
  };
  const handleEvent = (e) => {
    if (toValue(preventDefault2))
      e.preventDefault();
    if (toValue(stopPropagation))
      e.stopPropagation();
  };
  const start = (e) => {
    var _a2;
    if (!toValue(buttons).includes(e.button))
      return;
    if (toValue(options.disabled) || !filterEvent(e))
      return;
    if (toValue(exact) && e.target !== toValue(target))
      return;
    const container = toValue(containerElement);
    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);
    const targetRect = toValue(target).getBoundingClientRect();
    const pos = {
      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),
      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)
    };
    if ((onStart == null ? void 0 : onStart(pos, e)) === false)
      return;
    pressedDelta.value = pos;
    handleEvent(e);
  };
  const move = (e) => {
    if (toValue(options.disabled) || !filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    const container = toValue(containerElement);
    const targetRect = toValue(target).getBoundingClientRect();
    let { x, y } = position.value;
    if (axis === "x" || axis === "both") {
      x = e.clientX - pressedDelta.value.x;
      if (container)
        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);
    }
    if (axis === "y" || axis === "both") {
      y = e.clientY - pressedDelta.value.y;
      if (container)
        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);
    }
    position.value = {
      x,
      y
    };
    onMove == null ? void 0 : onMove(position.value, e);
    handleEvent(e);
  };
  const end = (e) => {
    if (toValue(options.disabled) || !filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    pressedDelta.value = void 0;
    onEnd == null ? void 0 : onEnd(position.value, e);
    handleEvent(e);
  };
  if (isClient) {
    const config = () => {
      var _a2;
      return {
        capture: (_a2 = options.capture) != null ? _a2 : true,
        passive: !toValue(preventDefault2)
      };
    };
    useEventListener(draggingHandle, "pointerdown", start, config);
    useEventListener(draggingElement, "pointermove", move, config);
    useEventListener(draggingElement, "pointerup", end, config);
  }
  return {
    ...toRefs(position),
    position,
    isDragging: computed(() => !!pressedDelta.value),
    style: computed(
      () => `left:${position.value.x}px;top:${position.value.y}px;`
    )
  };
}
function useDropZone(target, options = {}) {
  var _a, _b;
  const isOverDropZone = shallowRef(false);
  const files = shallowRef(null);
  let counter = 0;
  let isValid = true;
  if (isClient) {
    const _options = typeof options === "function" ? { onDrop: options } : options;
    const multiple = (_a = _options.multiple) != null ? _a : true;
    const preventDefaultForUnhandled = (_b = _options.preventDefaultForUnhandled) != null ? _b : false;
    const getFiles = (event) => {
      var _a2, _b2;
      const list = Array.from((_b2 = (_a2 = event.dataTransfer) == null ? void 0 : _a2.files) != null ? _b2 : []);
      return list.length === 0 ? null : multiple ? list : [list[0]];
    };
    const checkDataTypes = (types) => {
      const dataTypes = unref(_options.dataTypes);
      if (typeof dataTypes === "function")
        return dataTypes(types);
      if (!(dataTypes == null ? void 0 : dataTypes.length))
        return true;
      if (types.length === 0)
        return false;
      return types.every(
        (type) => dataTypes.some((allowedType) => type.includes(allowedType))
      );
    };
    const checkValidity = (items) => {
      const types = Array.from(items != null ? items : []).map((item) => item.type);
      const dataTypesValid = checkDataTypes(types);
      const multipleFilesValid = multiple || items.length <= 1;
      return dataTypesValid && multipleFilesValid;
    };
    const isSafari = () => /^(?:(?!chrome|android).)*safari/i.test(navigator.userAgent) && !("chrome" in window);
    const handleDragEvent = (event, eventType) => {
      var _a2, _b2, _c, _d, _e, _f;
      const dataTransferItemList = (_a2 = event.dataTransfer) == null ? void 0 : _a2.items;
      isValid = (_b2 = dataTransferItemList && checkValidity(dataTransferItemList)) != null ? _b2 : false;
      if (preventDefaultForUnhandled) {
        event.preventDefault();
      }
      if (!isSafari() && !isValid) {
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = "none";
        }
        return;
      }
      event.preventDefault();
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = "copy";
      }
      const currentFiles = getFiles(event);
      switch (eventType) {
        case "enter":
          counter += 1;
          isOverDropZone.value = true;
          (_c = _options.onEnter) == null ? void 0 : _c.call(_options, null, event);
          break;
        case "over":
          (_d = _options.onOver) == null ? void 0 : _d.call(_options, null, event);
          break;
        case "leave":
          counter -= 1;
          if (counter === 0)
            isOverDropZone.value = false;
          (_e = _options.onLeave) == null ? void 0 : _e.call(_options, null, event);
          break;
        case "drop":
          counter = 0;
          isOverDropZone.value = false;
          if (isValid) {
            files.value = currentFiles;
            (_f = _options.onDrop) == null ? void 0 : _f.call(_options, currentFiles, event);
          }
          break;
      }
    };
    useEventListener(target, "dragenter", (event) => handleDragEvent(event, "enter"));
    useEventListener(target, "dragover", (event) => handleDragEvent(event, "over"));
    useEventListener(target, "dragleave", (event) => handleDragEvent(event, "leave"));
    useEventListener(target, "drop", (event) => handleDragEvent(event, "drop"));
  }
  return {
    files,
    isOverDropZone
  };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const _targets = toValue(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true,
    updateTiming = "sync"
  } = options;
  const height = shallowRef(0);
  const bottom = shallowRef(0);
  const left = shallowRef(0);
  const right = shallowRef(0);
  const top = shallowRef(0);
  const width = shallowRef(0);
  const x = shallowRef(0);
  const y = shallowRef(0);
  function recalculate() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }
  function update() {
    if (updateTiming === "sync")
      recalculate();
    else if (updateTiming === "next-frame")
      requestAnimationFrame(() => recalculate());
  }
  useResizeObserver(target, update);
  watch(() => unrefElement(target), (ele) => !ele && update());
  useMutationObserver(target, update, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementByPoint(options) {
  const {
    x,
    y,
    document: document2 = defaultDocument,
    multiple,
    interval = "requestAnimationFrame",
    immediate = true
  } = options;
  const isSupported = useSupported(() => {
    if (toValue(multiple))
      return document2 && "elementsFromPoint" in document2;
    return document2 && "elementFromPoint" in document2;
  });
  const element = shallowRef(null);
  const cb = () => {
    var _a, _b;
    element.value = toValue(multiple) ? (_a = document2 == null ? void 0 : document2.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document2 == null ? void 0 : document2.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;
  };
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  return {
    isSupported,
    element,
    ...controls
  };
}
function useElementHover(el, options = {}) {
  const {
    delayEnter = 0,
    delayLeave = 0,
    triggerOnRemoval = false,
    window: window2 = defaultWindow
  } = options;
  const isHovered = shallowRef(false);
  let timer;
  const toggle = (entering) => {
    const delay = entering ? delayEnter : delayLeave;
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
    if (delay)
      timer = setTimeout(() => isHovered.value = entering, delay);
    else
      isHovered.value = entering;
  };
  if (!window2)
    return isHovered;
  useEventListener(el, "mouseenter", () => toggle(true), { passive: true });
  useEventListener(el, "mouseleave", () => toggle(false), { passive: true });
  if (triggerOnRemoval) {
    onElementRemoval(
      computed(() => unrefElement(el)),
      () => toggle(false)
    );
  }
  return isHovered;
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = shallowRef(initialSize.width);
  const height = shallowRef(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = toArray(boxSize);
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement(target);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch(
    () => unrefElement(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useIntersectionObserver(target, callback, options = {}) {
  const {
    root,
    rootMargin = "0px",
    threshold = 0,
    window: window2 = defaultWindow,
    immediate = true
  } = options;
  const isSupported = useSupported(() => window2 && "IntersectionObserver" in window2);
  const targets = computed(() => {
    const _target = toValue(target);
    return toArray(_target).map(unrefElement).filter(notNullish);
  });
  let cleanup = noop;
  const isActive = shallowRef(immediate);
  const stopWatch = isSupported.value ? watch(
    () => [targets.value, unrefElement(root), isActive.value],
    ([targets2, root2]) => {
      cleanup();
      if (!isActive.value)
        return;
      if (!targets2.length)
        return;
      const observer = new IntersectionObserver(
        callback,
        {
          root: unrefElement(root2),
          rootMargin,
          threshold
        }
      );
      targets2.forEach((el) => el && observer.observe(el));
      cleanup = () => {
        observer.disconnect();
        cleanup = noop;
      };
    },
    { immediate, flush: "post" }
  ) : noop;
  const stop = () => {
    cleanup();
    stopWatch();
    isActive.value = false;
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    isActive,
    pause() {
      cleanup();
      isActive.value = false;
    },
    resume() {
      isActive.value = true;
    },
    stop
  };
}
function useElementVisibility(element, options = {}) {
  const {
    window: window2 = defaultWindow,
    scrollTarget,
    threshold = 0,
    rootMargin,
    once = false
  } = options;
  const elementIsVisible = shallowRef(false);
  const { stop } = useIntersectionObserver(
    element,
    (intersectionObserverEntries) => {
      let isIntersecting = elementIsVisible.value;
      let latestTime = 0;
      for (const entry of intersectionObserverEntries) {
        if (entry.time >= latestTime) {
          latestTime = entry.time;
          isIntersecting = entry.isIntersecting;
        }
      }
      elementIsVisible.value = isIntersecting;
      if (once) {
        watchOnce(elementIsVisible, () => {
          stop();
        });
      }
    },
    {
      root: scrollTarget,
      window: window2,
      threshold,
      rootMargin: toValue(rootMargin)
    }
  );
  return elementIsVisible;
}
const events = /* @__PURE__ */ new Map();
function useEventBus(key) {
  const scope = getCurrentScope();
  function on(listener) {
    var _a;
    const listeners = events.get(key) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    events.set(key, listeners);
    const _off = () => off(listener);
    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);
    return _off;
  }
  function once(listener) {
    function _listener(...args) {
      off(_listener);
      listener(...args);
    }
    return on(_listener);
  }
  function off(listener) {
    const listeners = events.get(key);
    if (!listeners)
      return;
    listeners.delete(listener);
    if (!listeners.size)
      reset();
  }
  function reset() {
    events.delete(key);
  }
  function emit(event, payload) {
    var _a;
    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));
  }
  return { on, once, off, emit, reset };
}
function resolveNestedOptions$1(options) {
  if (options === true)
    return {};
  return options;
}
function useEventSource(url, events2 = [], options = {}) {
  const event = shallowRef(null);
  const data = shallowRef(null);
  const status = shallowRef("CONNECTING");
  const eventSource = ref(null);
  const error = shallowRef(null);
  const urlRef = toRef(url);
  const lastEventId = shallowRef(null);
  let explicitlyClosed = false;
  let retried = 0;
  const {
    withCredentials = false,
    immediate = true,
    autoConnect = true,
    autoReconnect
  } = options;
  const close = () => {
    if (isClient && eventSource.value) {
      eventSource.value.close();
      eventSource.value = null;
      status.value = "CLOSED";
      explicitlyClosed = true;
    }
  };
  const _init = () => {
    if (explicitlyClosed || typeof urlRef.value === "undefined")
      return;
    const es = new EventSource(urlRef.value, { withCredentials });
    status.value = "CONNECTING";
    eventSource.value = es;
    es.onopen = () => {
      status.value = "OPEN";
      error.value = null;
    };
    es.onerror = (e) => {
      status.value = "CLOSED";
      error.value = e;
      if (es.readyState === 2 && !explicitlyClosed && autoReconnect) {
        es.close();
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions$1(autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    es.onmessage = (e) => {
      event.value = null;
      data.value = e.data;
      lastEventId.value = e.lastEventId;
    };
    for (const event_name of events2) {
      useEventListener(es, event_name, (e) => {
        event.value = event_name;
        data.value = e.data || null;
      }, { passive: true });
    }
  };
  const open = () => {
    if (!isClient)
      return;
    close();
    explicitlyClosed = false;
    retried = 0;
    _init();
  };
  if (immediate)
    open();
  if (autoConnect)
    watch(urlRef, open);
  tryOnScopeDispose(close);
  return {
    eventSource,
    event,
    data,
    status,
    error,
    open,
    close,
    lastEventId
  };
}
function useEyeDropper(options = {}) {
  const { initialValue = "" } = options;
  const isSupported = useSupported(() => typeof window !== "undefined" && "EyeDropper" in window);
  const sRGBHex = shallowRef(initialValue);
  async function open(openOptions) {
    if (!isSupported.value)
      return;
    const eyeDropper = new window.EyeDropper();
    const result = await eyeDropper.open(openOptions);
    sRGBHex.value = result.sRGBHex;
    return result;
  }
  return { isSupported, sRGBHex, open };
}
function useFavicon(newIcon = null, options = {}) {
  const {
    baseUrl = "",
    rel = "icon",
    document: document2 = defaultDocument
  } = options;
  const favicon = toRef(newIcon);
  const applyIcon = (icon) => {
    const elements = document2 == null ? void 0 : document2.head.querySelectorAll(`link[rel*="${rel}"]`);
    if (!elements || elements.length === 0) {
      const link = document2 == null ? void 0 : document2.createElement("link");
      if (link) {
        link.rel = rel;
        link.href = `${baseUrl}${icon}`;
        link.type = `image/${icon.split(".").pop()}`;
        document2 == null ? void 0 : document2.head.append(link);
      }
      return;
    }
    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);
  };
  watch(
    favicon,
    (i, o) => {
      if (typeof i === "string" && i !== o)
        applyIcon(i);
    },
    { immediate: true }
  );
  return favicon;
}
const payloadMapping = {
  json: "application/json",
  text: "text/plain"
};
function isFetchOptions(obj) {
  return obj && containsProp(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch", "updateDataOnError");
}
const reAbsolute = /^(?:[a-z][a-z\d+\-.]*:)?\/\//i;
function isAbsoluteURL(url) {
  return reAbsolute.test(url);
}
function headersToObject(headers) {
  if (typeof Headers !== "undefined" && headers instanceof Headers)
    return Object.fromEntries(headers.entries());
  return headers;
}
function combineCallbacks(combination, ...callbacks) {
  if (combination === "overwrite") {
    return async (ctx) => {
      let callback;
      for (let i = callbacks.length - 1; i >= 0; i--) {
        if (callbacks[i] != null) {
          callback = callbacks[i];
          break;
        }
      }
      if (callback)
        return { ...ctx, ...await callback(ctx) };
      return ctx;
    };
  } else {
    return async (ctx) => {
      for (const callback of callbacks) {
        if (callback)
          ctx = { ...ctx, ...await callback(ctx) };
      }
      return ctx;
    };
  }
}
function createFetch(config = {}) {
  const _combination = config.combination || "chain";
  const _options = config.options || {};
  const _fetchOptions = config.fetchOptions || {};
  function useFactoryFetch(url, ...args) {
    const computedUrl = computed(() => {
      const baseUrl = toValue(config.baseUrl);
      const targetUrl = toValue(url);
      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;
    });
    let options = _options;
    let fetchOptions = _fetchOptions;
    if (args.length > 0) {
      if (isFetchOptions(args[0])) {
        options = {
          ...options,
          ...args[0],
          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),
          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),
          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)
        };
      } else {
        fetchOptions = {
          ...fetchOptions,
          ...args[0],
          headers: {
            ...headersToObject(fetchOptions.headers) || {},
            ...headersToObject(args[0].headers) || {}
          }
        };
      }
    }
    if (args.length > 1 && isFetchOptions(args[1])) {
      options = {
        ...options,
        ...args[1],
        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),
        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),
        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)
      };
    }
    return useFetch(computedUrl, fetchOptions, options);
  }
  return useFactoryFetch;
}
function useFetch(url, ...args) {
  var _a;
  const supportsAbort = typeof AbortController === "function";
  let fetchOptions = {};
  let options = {
    immediate: true,
    refetch: false,
    timeout: 0,
    updateDataOnError: false
  };
  const config = {
    method: "GET",
    type: "text",
    payload: void 0
  };
  if (args.length > 0) {
    if (isFetchOptions(args[0]))
      options = { ...options, ...args[0] };
    else
      fetchOptions = args[0];
  }
  if (args.length > 1) {
    if (isFetchOptions(args[1]))
      options = { ...options, ...args[1] };
  }
  const {
    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,
    initialData,
    timeout
  } = options;
  const responseEvent = createEventHook();
  const errorEvent = createEventHook();
  const finallyEvent = createEventHook();
  const isFinished = shallowRef(false);
  const isFetching = shallowRef(false);
  const aborted = shallowRef(false);
  const statusCode = shallowRef(null);
  const response = shallowRef(null);
  const error = shallowRef(null);
  const data = shallowRef(initialData || null);
  const canAbort = computed(() => supportsAbort && isFetching.value);
  let controller;
  let timer;
  const abort = () => {
    if (supportsAbort) {
      controller == null ? void 0 : controller.abort();
      controller = new AbortController();
      controller.signal.onabort = () => aborted.value = true;
      fetchOptions = {
        ...fetchOptions,
        signal: controller.signal
      };
    }
  };
  const loading = (isLoading) => {
    isFetching.value = isLoading;
    isFinished.value = !isLoading;
  };
  if (timeout)
    timer = useTimeoutFn(abort, timeout, { immediate: false });
  let executeCounter = 0;
  const execute = async (throwOnFailed = false) => {
    var _a2, _b;
    abort();
    loading(true);
    error.value = null;
    statusCode.value = null;
    aborted.value = false;
    executeCounter += 1;
    const currentExecuteCounter = executeCounter;
    const defaultFetchOptions = {
      method: config.method,
      headers: {}
    };
    const payload = toValue(config.payload);
    if (payload) {
      const headers = headersToObject(defaultFetchOptions.headers);
      const proto = Object.getPrototypeOf(payload);
      if (!config.payloadType && payload && (proto === Object.prototype || Array.isArray(proto)) && !(payload instanceof FormData))
        config.payloadType = "json";
      if (config.payloadType)
        headers["Content-Type"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;
      defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(payload) : payload;
    }
    let isCanceled = false;
    const context = {
      url: toValue(url),
      options: {
        ...defaultFetchOptions,
        ...fetchOptions
      },
      cancel: () => {
        isCanceled = true;
      }
    };
    if (options.beforeFetch)
      Object.assign(context, await options.beforeFetch(context));
    if (isCanceled || !fetch) {
      loading(false);
      return Promise.resolve(null);
    }
    let responseData = null;
    if (timer)
      timer.start();
    return fetch(
      context.url,
      {
        ...defaultFetchOptions,
        ...context.options,
        headers: {
          ...headersToObject(defaultFetchOptions.headers),
          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)
        }
      }
    ).then(async (fetchResponse) => {
      response.value = fetchResponse;
      statusCode.value = fetchResponse.status;
      responseData = await fetchResponse.clone()[config.type]();
      if (!fetchResponse.ok) {
        data.value = initialData || null;
        throw new Error(fetchResponse.statusText);
      }
      if (options.afterFetch) {
        ({ data: responseData } = await options.afterFetch({
          data: responseData,
          response: fetchResponse,
          context,
          execute
        }));
      }
      data.value = responseData;
      responseEvent.trigger(fetchResponse);
      return fetchResponse;
    }).catch(async (fetchError) => {
      let errorData = fetchError.message || fetchError.name;
      if (options.onFetchError) {
        ({ error: errorData, data: responseData } = await options.onFetchError({
          data: responseData,
          error: fetchError,
          response: response.value,
          context,
          execute
        }));
      }
      error.value = errorData;
      if (options.updateDataOnError)
        data.value = responseData;
      errorEvent.trigger(fetchError);
      if (throwOnFailed)
        throw fetchError;
      return null;
    }).finally(() => {
      if (currentExecuteCounter === executeCounter)
        loading(false);
      if (timer)
        timer.stop();
      finallyEvent.trigger(null);
    });
  };
  const refetch = toRef(options.refetch);
  watch(
    [
      refetch,
      toRef(url)
    ],
    ([refetch2]) => refetch2 && execute(),
    { deep: true }
  );
  const shell = {
    isFinished: readonly(isFinished),
    isFetching: readonly(isFetching),
    statusCode,
    response,
    error,
    data,
    canAbort,
    aborted,
    abort,
    execute,
    onFetchResponse: responseEvent.on,
    onFetchError: errorEvent.on,
    onFetchFinally: finallyEvent.on,
    // method
    get: setMethod("GET"),
    put: setMethod("PUT"),
    post: setMethod("POST"),
    delete: setMethod("DELETE"),
    patch: setMethod("PATCH"),
    head: setMethod("HEAD"),
    options: setMethod("OPTIONS"),
    // type
    json: setType("json"),
    text: setType("text"),
    blob: setType("blob"),
    arrayBuffer: setType("arrayBuffer"),
    formData: setType("formData")
  };
  function setMethod(method) {
    return (payload, payloadType) => {
      if (!isFetching.value) {
        config.method = method;
        config.payload = payload;
        config.payloadType = payloadType;
        if (isRef(config.payload)) {
          watch(
            [
              refetch,
              toRef(config.payload)
            ],
            ([refetch2]) => refetch2 && execute(),
            { deep: true }
          );
        }
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  function waitUntilFinished() {
    return new Promise((resolve, reject) => {
      until(isFinished).toBe(true).then(() => resolve(shell)).catch(reject);
    });
  }
  function setType(type) {
    return () => {
      if (!isFetching.value) {
        config.type = type;
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  if (options.immediate)
    Promise.resolve().then(() => execute());
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilFinished().then(onFulfilled, onRejected);
    }
  };
}
function joinPaths(start, end) {
  if (!start.endsWith("/") && !end.startsWith("/")) {
    return `${start}/${end}`;
  }
  if (start.endsWith("/") && end.startsWith("/")) {
    return `${start.slice(0, -1)}${end}`;
  }
  return `${start}${end}`;
}
const DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*",
  reset: false,
  directory: false
};
function prepareInitialFiles(files) {
  if (!files)
    return null;
  if (files instanceof FileList)
    return files;
  const dt = new DataTransfer();
  for (const file of files) {
    dt.items.add(file);
  }
  return dt.files;
}
function useFileDialog(options = {}) {
  const {
    document: document2 = defaultDocument
  } = options;
  const files = ref(prepareInitialFiles(options.initialFiles));
  const { on: onChange, trigger: changeTrigger } = createEventHook();
  const { on: onCancel, trigger: cancelTrigger } = createEventHook();
  let input;
  if (document2) {
    input = document2.createElement("input");
    input.type = "file";
    input.onchange = (event) => {
      const result = event.target;
      files.value = result.files;
      changeTrigger(files.value);
    };
    input.oncancel = () => {
      cancelTrigger();
    };
  }
  const reset = () => {
    files.value = null;
    if (input && input.value) {
      input.value = "";
      changeTrigger(null);
    }
  };
  const open = (localOptions) => {
    if (!input)
      return;
    const _options = {
      ...DEFAULT_OPTIONS,
      ...options,
      ...localOptions
    };
    input.multiple = _options.multiple;
    input.accept = _options.accept;
    input.webkitdirectory = _options.directory;
    if (hasOwn(_options, "capture"))
      input.capture = _options.capture;
    if (_options.reset)
      reset();
    input.click();
  };
  return {
    files: readonly(files),
    open,
    reset,
    onCancel,
    onChange
  };
}
function useFileSystemAccess(options = {}) {
  const {
    window: _window = defaultWindow,
    dataType = "Text"
  } = options;
  const window2 = _window;
  const isSupported = useSupported(() => window2 && "showSaveFilePicker" in window2 && "showOpenFilePicker" in window2);
  const fileHandle = shallowRef();
  const data = shallowRef();
  const file = shallowRef();
  const fileName = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : "";
  });
  const fileMIME = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : "";
  });
  const fileSize = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;
  });
  const fileLastModified = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;
  });
  async function open(_options = {}) {
    if (!isSupported.value)
      return;
    const [handle] = await window2.showOpenFilePicker({ ...toValue(options), ..._options });
    fileHandle.value = handle;
    await updateData();
  }
  async function create(_options = {}) {
    if (!isSupported.value)
      return;
    fileHandle.value = await window2.showSaveFilePicker({ ...options, ..._options });
    data.value = void 0;
    await updateData();
  }
  async function save(_options = {}) {
    if (!isSupported.value)
      return;
    if (!fileHandle.value)
      return saveAs(_options);
    if (data.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data.value);
      await writableStream.close();
    }
    await updateFile();
  }
  async function saveAs(_options = {}) {
    if (!isSupported.value)
      return;
    fileHandle.value = await window2.showSaveFilePicker({ ...options, ..._options });
    if (data.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data.value);
      await writableStream.close();
    }
    await updateFile();
  }
  async function updateFile() {
    var _a;
    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());
  }
  async function updateData() {
    var _a, _b;
    await updateFile();
    const type = toValue(dataType);
    if (type === "Text")
      data.value = await ((_a = file.value) == null ? void 0 : _a.text());
    else if (type === "ArrayBuffer")
      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());
    else if (type === "Blob")
      data.value = file.value;
  }
  watch(() => toValue(dataType), updateData);
  return {
    isSupported,
    data,
    file,
    fileName,
    fileMIME,
    fileSize,
    fileLastModified,
    open,
    create,
    save,
    saveAs,
    updateData
  };
}
function useFocus(target, options = {}) {
  const { initialValue = false, focusVisible = false, preventScroll = false } = options;
  const innerFocused = shallowRef(false);
  const targetElement = computed(() => unrefElement(target));
  const listenerOptions = { passive: true };
  useEventListener(targetElement, "focus", (event) => {
    var _a, _b;
    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, ":focus-visible")))
      innerFocused.value = true;
  }, listenerOptions);
  useEventListener(targetElement, "blur", () => innerFocused.value = false, listenerOptions);
  const focused = computed({
    get: () => innerFocused.value,
    set(value) {
      var _a, _b;
      if (!value && innerFocused.value)
        (_a = targetElement.value) == null ? void 0 : _a.blur();
      else if (value && !innerFocused.value)
        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });
    }
  });
  watch(
    targetElement,
    () => {
      focused.value = initialValue;
    },
    { immediate: true, flush: "post" }
  );
  return { focused };
}
const EVENT_FOCUS_IN = "focusin";
const EVENT_FOCUS_OUT = "focusout";
const PSEUDO_CLASS_FOCUS_WITHIN = ":focus-within";
function useFocusWithin(target, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const targetElement = computed(() => unrefElement(target));
  const _focused = shallowRef(false);
  const focused = computed(() => _focused.value);
  const activeElement = useActiveElement(options);
  if (!window2 || !activeElement.value) {
    return { focused };
  }
  const listenerOptions = { passive: true };
  useEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);
  useEventListener(targetElement, EVENT_FOCUS_OUT, () => {
    var _a, _b, _c;
    return _focused.value = (_c = (_b = (_a = targetElement.value) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, PSEUDO_CLASS_FOCUS_WITHIN)) != null ? _c : false;
  }, listenerOptions);
  return { focused };
}
function useFps(options) {
  var _a;
  const fps = shallowRef(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
const eventHandlers = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function useFullscreen(target, options = {}) {
  const {
    document: document2 = defaultDocument,
    autoExit = false
  } = options;
  const targetRef = computed(() => {
    var _a;
    return (_a = unrefElement(target)) != null ? _a : document2 == null ? void 0 : document2.documentElement;
  });
  const isFullscreen = shallowRef(false);
  const requestMethod = computed(() => {
    return [
      "requestFullscreen",
      "webkitRequestFullscreen",
      "webkitEnterFullscreen",
      "webkitEnterFullScreen",
      "webkitRequestFullScreen",
      "mozRequestFullScreen",
      "msRequestFullscreen"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const exitMethod = computed(() => {
    return [
      "exitFullscreen",
      "webkitExitFullscreen",
      "webkitExitFullScreen",
      "webkitCancelFullScreen",
      "mozCancelFullScreen",
      "msExitFullscreen"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const fullscreenEnabled = computed(() => {
    return [
      "fullScreen",
      "webkitIsFullScreen",
      "webkitDisplayingFullscreen",
      "mozFullScreen",
      "msFullscreenElement"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const fullscreenElementMethod = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((m) => document2 && m in document2);
  const isSupported = useSupported(() => targetRef.value && document2 && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);
  const isCurrentElementFullScreen = () => {
    if (fullscreenElementMethod)
      return (document2 == null ? void 0 : document2[fullscreenElementMethod]) === targetRef.value;
    return false;
  };
  const isElementFullScreen = () => {
    if (fullscreenEnabled.value) {
      if (document2 && document2[fullscreenEnabled.value] != null) {
        return document2[fullscreenEnabled.value];
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {
          return Boolean(target2[fullscreenEnabled.value]);
        }
      }
    }
    return false;
  };
  async function exit() {
    if (!isSupported.value || !isFullscreen.value)
      return;
    if (exitMethod.value) {
      if ((document2 == null ? void 0 : document2[exitMethod.value]) != null) {
        await document2[exitMethod.value]();
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)
          await target2[exitMethod.value]();
      }
    }
    isFullscreen.value = false;
  }
  async function enter() {
    if (!isSupported.value || isFullscreen.value)
      return;
    if (isElementFullScreen())
      await exit();
    const target2 = targetRef.value;
    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {
      await target2[requestMethod.value]();
      isFullscreen.value = true;
    }
  }
  async function toggle() {
    await (isFullscreen.value ? exit() : enter());
  }
  const handlerCallback = () => {
    const isElementFullScreenValue = isElementFullScreen();
    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())
      isFullscreen.value = isElementFullScreenValue;
  };
  const listenerOptions = { capture: false, passive: true };
  useEventListener(document2, eventHandlers, handlerCallback, listenerOptions);
  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, listenerOptions);
  if (autoExit)
    tryOnScopeDispose(exit);
  return {
    isSupported,
    isFullscreen,
    enter,
    exit,
    toggle
  };
}
function mapGamepadToXbox360Controller(gamepad) {
  return computed(() => {
    if (gamepad.value) {
      return {
        buttons: {
          a: gamepad.value.buttons[0],
          b: gamepad.value.buttons[1],
          x: gamepad.value.buttons[2],
          y: gamepad.value.buttons[3]
        },
        bumper: {
          left: gamepad.value.buttons[4],
          right: gamepad.value.buttons[5]
        },
        triggers: {
          left: gamepad.value.buttons[6],
          right: gamepad.value.buttons[7]
        },
        stick: {
          left: {
            horizontal: gamepad.value.axes[0],
            vertical: gamepad.value.axes[1],
            button: gamepad.value.buttons[10]
          },
          right: {
            horizontal: gamepad.value.axes[2],
            vertical: gamepad.value.axes[3],
            button: gamepad.value.buttons[11]
          }
        },
        dpad: {
          up: gamepad.value.buttons[12],
          down: gamepad.value.buttons[13],
          left: gamepad.value.buttons[14],
          right: gamepad.value.buttons[15]
        },
        back: gamepad.value.buttons[8],
        start: gamepad.value.buttons[9]
      };
    }
    return null;
  });
}
function useGamepad(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator
  } = options;
  const isSupported = useSupported(() => navigator2 && "getGamepads" in navigator2);
  const gamepads = ref([]);
  const onConnectedHook = createEventHook();
  const onDisconnectedHook = createEventHook();
  const stateFromGamepad = (gamepad) => {
    const hapticActuators = [];
    const vibrationActuator = "vibrationActuator" in gamepad ? gamepad.vibrationActuator : null;
    if (vibrationActuator)
      hapticActuators.push(vibrationActuator);
    if (gamepad.hapticActuators)
      hapticActuators.push(...gamepad.hapticActuators);
    return {
      id: gamepad.id,
      index: gamepad.index,
      connected: gamepad.connected,
      mapping: gamepad.mapping,
      timestamp: gamepad.timestamp,
      vibrationActuator: gamepad.vibrationActuator,
      hapticActuators,
      axes: gamepad.axes.map((axes) => axes),
      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))
    };
  };
  const updateGamepadState = () => {
    const _gamepads = (navigator2 == null ? void 0 : navigator2.getGamepads()) || [];
    for (const gamepad of _gamepads) {
      if (gamepad && gamepads.value[gamepad.index])
        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);
    }
  };
  const { isActive, pause, resume } = useRafFn(updateGamepadState);
  const onGamepadConnected = (gamepad) => {
    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {
      gamepads.value.push(stateFromGamepad(gamepad));
      onConnectedHook.trigger(gamepad.index);
    }
    resume();
  };
  const onGamepadDisconnected = (gamepad) => {
    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);
    onDisconnectedHook.trigger(gamepad.index);
  };
  const listenerOptions = { passive: true };
  useEventListener("gamepadconnected", (e) => onGamepadConnected(e.gamepad), listenerOptions);
  useEventListener("gamepaddisconnected", (e) => onGamepadDisconnected(e.gamepad), listenerOptions);
  tryOnMounted(() => {
    const _gamepads = (navigator2 == null ? void 0 : navigator2.getGamepads()) || [];
    for (const gamepad of _gamepads) {
      if (gamepad && gamepads.value[gamepad.index])
        onGamepadConnected(gamepad);
    }
  });
  pause();
  return {
    isSupported,
    onConnected: onConnectedHook.on,
    onDisconnected: onDisconnectedHook.on,
    gamepads,
    pause,
    resume,
    isActive
  };
}
function useGeolocation(options = {}) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3,
    navigator: navigator2 = defaultNavigator,
    immediate = true
  } = options;
  const isSupported = useSupported(() => navigator2 && "geolocation" in navigator2);
  const locatedAt = shallowRef(null);
  const error = shallowRef(null);
  const coords = ref({
    accuracy: 0,
    latitude: Number.POSITIVE_INFINITY,
    longitude: Number.POSITIVE_INFINITY,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    speed: null
  });
  function updatePosition(position) {
    locatedAt.value = position.timestamp;
    coords.value = position.coords;
    error.value = null;
  }
  let watcher;
  function resume() {
    if (isSupported.value) {
      watcher = navigator2.geolocation.watchPosition(
        updatePosition,
        (err) => error.value = err,
        {
          enableHighAccuracy,
          maximumAge,
          timeout
        }
      );
    }
  }
  if (immediate)
    resume();
  function pause() {
    if (watcher && navigator2)
      navigator2.geolocation.clearWatch(watcher);
  }
  tryOnScopeDispose(() => {
    pause();
  });
  return {
    isSupported,
    coords,
    locatedAt,
    error,
    resume,
    pause
  };
}
const defaultEvents$1 = ["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"];
const oneMinute = 6e4;
function useIdle(timeout = oneMinute, options = {}) {
  const {
    initialState = false,
    listenForVisibilityChange = true,
    events: events2 = defaultEvents$1,
    window: window2 = defaultWindow,
    eventFilter = throttleFilter(50)
  } = options;
  const idle = shallowRef(initialState);
  const lastActive = shallowRef(timestamp());
  let timer;
  const reset = () => {
    idle.value = false;
    clearTimeout(timer);
    timer = setTimeout(() => idle.value = true, timeout);
  };
  const onEvent = createFilterWrapper(
    eventFilter,
    () => {
      lastActive.value = timestamp();
      reset();
    }
  );
  if (window2) {
    const document2 = window2.document;
    const listenerOptions = { passive: true };
    for (const event of events2)
      useEventListener(window2, event, onEvent, listenerOptions);
    if (listenForVisibilityChange) {
      useEventListener(document2, "visibilitychange", () => {
        if (!document2.hidden)
          onEvent();
      }, listenerOptions);
    }
    reset();
  }
  return {
    idle,
    lastActive,
    reset
  };
}
async function loadImage(options) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy, width, height, decoding, fetchPriority, ismap, usemap } = options;
    img.src = src;
    if (srcset != null)
      img.srcset = srcset;
    if (sizes != null)
      img.sizes = sizes;
    if (clazz != null)
      img.className = clazz;
    if (loading != null)
      img.loading = loading;
    if (crossorigin != null)
      img.crossOrigin = crossorigin;
    if (referrerPolicy != null)
      img.referrerPolicy = referrerPolicy;
    if (width != null)
      img.width = width;
    if (height != null)
      img.height = height;
    if (decoding != null)
      img.decoding = decoding;
    if (fetchPriority != null)
      img.fetchPriority = fetchPriority;
    if (ismap != null)
      img.isMap = ismap;
    if (usemap != null)
      img.useMap = usemap;
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}
function useImage(options, asyncStateOptions = {}) {
  const state = useAsyncState(
    () => loadImage(toValue(options)),
    void 0,
    {
      resetOnExecute: true,
      ...asyncStateOptions
    }
  );
  watch(
    () => toValue(options),
    () => state.execute(asyncStateOptions.delay),
    { deep: true }
  );
  return state;
}
function resolveElement(el) {
  if (typeof Window !== "undefined" && el instanceof Window)
    return el.document.documentElement;
  if (typeof Document !== "undefined" && el instanceof Document)
    return el.documentElement;
  return el;
}
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(element, options = {}) {
  const {
    throttle = 0,
    idle = 200,
    onStop = noop,
    onScroll = noop,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions = {
      capture: false,
      passive: true
    },
    behavior = "auto",
    window: window2 = defaultWindow,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const internalX = shallowRef(0);
  const internalY = shallowRef(0);
  const x = computed({
    get() {
      return internalX.value;
    },
    set(x2) {
      scrollTo(x2, void 0);
    }
  });
  const y = computed({
    get() {
      return internalY.value;
    },
    set(y2) {
      scrollTo(void 0, y2);
    }
  });
  function scrollTo(_x, _y) {
    var _a, _b, _c, _d;
    if (!window2)
      return;
    const _element = toValue(element);
    if (!_element)
      return;
    (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
      top: (_a = toValue(_y)) != null ? _a : y.value,
      left: (_b = toValue(_x)) != null ? _b : x.value,
      behavior: toValue(behavior)
    });
    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
    if (x != null)
      internalX.value = scrollContainer.scrollLeft;
    if (y != null)
      internalY.value = scrollContainer.scrollTop;
  }
  const isScrolling = shallowRef(false);
  const arrivedState = reactive({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const directions = reactive({
    left: false,
    right: false,
    top: false,
    bottom: false
  });
  const onScrollEnd = (e) => {
    if (!isScrolling.value)
      return;
    isScrolling.value = false;
    directions.left = false;
    directions.right = false;
    directions.top = false;
    directions.bottom = false;
    onStop(e);
  };
  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);
  const setArrivedState = (target) => {
    var _a;
    if (!window2)
      return;
    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);
    const { display, flexDirection, direction } = getComputedStyle(el);
    const directionMultipler = direction === "rtl" ? -1 : 1;
    const scrollLeft = el.scrollLeft;
    directions.left = scrollLeft < internalX.value;
    directions.right = scrollLeft > internalX.value;
    const left = Math.abs(scrollLeft * directionMultipler) <= (offset.left || 0);
    const right = Math.abs(scrollLeft * directionMultipler) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "row-reverse") {
      arrivedState.left = right;
      arrivedState.right = left;
    } else {
      arrivedState.left = left;
      arrivedState.right = right;
    }
    internalX.value = scrollLeft;
    let scrollTop = el.scrollTop;
    if (target === window2.document && !scrollTop)
      scrollTop = window2.document.body.scrollTop;
    directions.top = scrollTop < internalY.value;
    directions.bottom = scrollTop > internalY.value;
    const top = Math.abs(scrollTop) <= (offset.top || 0);
    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "column-reverse") {
      arrivedState.top = bottom;
      arrivedState.bottom = top;
    } else {
      arrivedState.top = top;
      arrivedState.bottom = bottom;
    }
    internalY.value = scrollTop;
  };
  const onScrollHandler = (e) => {
    var _a;
    if (!window2)
      return;
    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;
    setArrivedState(eventTarget);
    isScrolling.value = true;
    onScrollEndDebounced(e);
    onScroll(e);
  };
  useEventListener(
    element,
    "scroll",
    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,
    eventListenerOptions
  );
  tryOnMounted(() => {
    try {
      const _element = toValue(element);
      if (!_element)
        return;
      setArrivedState(_element);
    } catch (e) {
      onError(e);
    }
  });
  useEventListener(
    element,
    "scrollend",
    onScrollEnd,
    eventListenerOptions
  );
  return {
    x,
    y,
    isScrolling,
    arrivedState,
    directions,
    measure() {
      const _element = toValue(element);
      if (window2 && _element)
        setArrivedState(_element);
    }
  };
}
function useInfiniteScroll(element, onLoadMore, options = {}) {
  var _a;
  const {
    direction = "bottom",
    interval = 100,
    canLoadMore = () => true
  } = options;
  const state = reactive(useScroll(
    element,
    {
      ...options,
      offset: {
        [direction]: (_a = options.distance) != null ? _a : 0,
        ...options.offset
      }
    }
  ));
  const promise = ref();
  const isLoading = computed(() => !!promise.value);
  const observedElement = computed(() => {
    return resolveElement(toValue(element));
  });
  const isElementVisible = useElementVisibility(observedElement);
  function checkAndLoad() {
    state.measure();
    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))
      return;
    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;
    const isNarrower = direction === "bottom" || direction === "top" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;
    if (state.arrivedState[direction] || isNarrower) {
      if (!promise.value) {
        promise.value = Promise.all([
          onLoadMore(state),
          new Promise((resolve) => setTimeout(resolve, interval))
        ]).finally(() => {
          promise.value = null;
          nextTick(() => checkAndLoad());
        });
      }
    }
  }
  const stop = watch(
    () => [state.arrivedState[direction], isElementVisible.value],
    checkAndLoad,
    { immediate: true }
  );
  tryOnUnmounted(stop);
  return {
    isLoading,
    reset() {
      nextTick(() => checkAndLoad());
    }
  };
}
const defaultEvents = ["mousedown", "mouseup", "keydown", "keyup"];
function useKeyModifier(modifier, options = {}) {
  const {
    events: events2 = defaultEvents,
    document: document2 = defaultDocument,
    initial = null
  } = options;
  const state = shallowRef(initial);
  if (document2) {
    events2.forEach((listenerEvent) => {
      useEventListener(document2, listenerEvent, (evt) => {
        if (typeof evt.getModifierState === "function")
          state.value = evt.getModifierState(modifier);
      }, { passive: true });
    });
  }
  return state;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
const DefaultMagicKeysAliasMap = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
function useMagicKeys(options = {}) {
  const {
    reactive: useReactive = false,
    target = defaultWindow,
    aliasMap = DefaultMagicKeysAliasMap,
    passive = true,
    onEventFired = noop
  } = options;
  const current = reactive(/* @__PURE__ */ new Set());
  const obj = {
    toJSON() {
      return {};
    },
    current
  };
  const refs = useReactive ? reactive(obj) : obj;
  const metaDeps = /* @__PURE__ */ new Set();
  const usedKeys = /* @__PURE__ */ new Set();
  function setRefs(key, value) {
    if (key in refs) {
      if (useReactive)
        refs[key] = value;
      else
        refs[key].value = value;
    }
  }
  function reset() {
    current.clear();
    for (const key of usedKeys)
      setRefs(key, false);
  }
  function updateRefs(e, value) {
    var _a, _b;
    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();
    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();
    const values = [code, key].filter(Boolean);
    if (key) {
      if (value)
        current.add(key);
      else
        current.delete(key);
    }
    for (const key2 of values) {
      usedKeys.add(key2);
      setRefs(key2, value);
    }
    if (key === "meta" && !value) {
      metaDeps.forEach((key2) => {
        current.delete(key2);
        setRefs(key2, false);
      });
      metaDeps.clear();
    } else if (typeof e.getModifierState === "function" && e.getModifierState("Meta") && value) {
      [...current, ...values].forEach((key2) => metaDeps.add(key2));
    }
  }
  useEventListener(target, "keydown", (e) => {
    updateRefs(e, true);
    return onEventFired(e);
  }, { passive });
  useEventListener(target, "keyup", (e) => {
    updateRefs(e, false);
    return onEventFired(e);
  }, { passive });
  useEventListener("blur", reset, { passive });
  useEventListener("focus", reset, { passive });
  const proxy = new Proxy(
    refs,
    {
      get(target2, prop, rec) {
        if (typeof prop !== "string")
          return Reflect.get(target2, prop, rec);
        prop = prop.toLowerCase();
        if (prop in aliasMap)
          prop = aliasMap[prop];
        if (!(prop in refs)) {
          if (/[+_-]/.test(prop)) {
            const keys2 = prop.split(/[+_-]/g).map((i) => i.trim());
            refs[prop] = computed(() => keys2.map((key) => toValue(proxy[key])).every(Boolean));
          } else {
            refs[prop] = shallowRef(false);
          }
        }
        const r = Reflect.get(target2, prop, rec);
        return useReactive ? toValue(r) : r;
      }
    }
  );
  return proxy;
}
function usingElRef(source, cb) {
  if (toValue(source))
    cb(toValue(source));
}
function timeRangeToArray(timeRanges) {
  let ranges = [];
  for (let i = 0; i < timeRanges.length; ++i)
    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];
  return ranges;
}
function tracksToArray(tracks) {
  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));
}
const defaultOptions = {
  src: "",
  tracks: []
};
function useMediaControls(target, options = {}) {
  target = toRef(target);
  options = {
    ...defaultOptions,
    ...options
  };
  const {
    document: document2 = defaultDocument
  } = options;
  const listenerOptions = { passive: true };
  const currentTime = shallowRef(0);
  const duration = shallowRef(0);
  const seeking = shallowRef(false);
  const volume = shallowRef(1);
  const waiting = shallowRef(false);
  const ended = shallowRef(false);
  const playing = shallowRef(false);
  const rate = shallowRef(1);
  const stalled = shallowRef(false);
  const buffered = ref([]);
  const tracks = ref([]);
  const selectedTrack = shallowRef(-1);
  const isPictureInPicture = shallowRef(false);
  const muted = shallowRef(false);
  const supportsPictureInPicture = document2 && "pictureInPictureEnabled" in document2;
  const sourceErrorEvent = createEventHook();
  const playbackErrorEvent = createEventHook();
  const disableTrack = (track) => {
    usingElRef(target, (el) => {
      if (track) {
        const id = typeof track === "number" ? track : track.id;
        el.textTracks[id].mode = "disabled";
      } else {
        for (let i = 0; i < el.textTracks.length; ++i)
          el.textTracks[i].mode = "disabled";
      }
      selectedTrack.value = -1;
    });
  };
  const enableTrack = (track, disableTracks = true) => {
    usingElRef(target, (el) => {
      const id = typeof track === "number" ? track : track.id;
      if (disableTracks)
        disableTrack();
      el.textTracks[id].mode = "showing";
      selectedTrack.value = id;
    });
  };
  const togglePictureInPicture = () => {
    return new Promise((resolve, reject) => {
      usingElRef(target, async (el) => {
        if (supportsPictureInPicture) {
          if (!isPictureInPicture.value) {
            el.requestPictureInPicture().then(resolve).catch(reject);
          } else {
            document2.exitPictureInPicture().then(resolve).catch(reject);
          }
        }
      });
    });
  };
  watchEffect(() => {
    if (!document2)
      return;
    const el = toValue(target);
    if (!el)
      return;
    const src = toValue(options.src);
    let sources = [];
    if (!src)
      return;
    if (typeof src === "string")
      sources = [{ src }];
    else if (Array.isArray(src))
      sources = src;
    else if (isObject(src))
      sources = [src];
    el.querySelectorAll("source").forEach((e) => {
      e.remove();
    });
    sources.forEach(({ src: src2, type, media }) => {
      const source = document2.createElement("source");
      source.setAttribute("src", src2);
      source.setAttribute("type", type || "");
      source.setAttribute("media", media || "");
      useEventListener(source, "error", sourceErrorEvent.trigger, listenerOptions);
      el.appendChild(source);
    });
    el.load();
  });
  watch([target, volume], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.volume = volume.value;
  });
  watch([target, muted], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.muted = muted.value;
  });
  watch([target, rate], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.playbackRate = rate.value;
  });
  watchEffect(() => {
    if (!document2)
      return;
    const textTracks = toValue(options.tracks);
    const el = toValue(target);
    if (!textTracks || !textTracks.length || !el)
      return;
    el.querySelectorAll("track").forEach((e) => e.remove());
    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {
      const track = document2.createElement("track");
      track.default = isDefault || false;
      track.kind = kind;
      track.label = label;
      track.src = src;
      track.srclang = srcLang;
      if (track.default)
        selectedTrack.value = i;
      el.appendChild(track);
    });
  });
  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {
    const el = toValue(target);
    if (!el)
      return;
    el.currentTime = time;
  });
  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {
    const el = toValue(target);
    if (!el)
      return;
    if (isPlaying) {
      el.play().catch((e) => {
        playbackErrorEvent.trigger(e);
        throw e;
      });
    } else {
      el.pause();
    }
  });
  useEventListener(
    target,
    "timeupdate",
    () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime),
    listenerOptions
  );
  useEventListener(
    target,
    "durationchange",
    () => duration.value = toValue(target).duration,
    listenerOptions
  );
  useEventListener(
    target,
    "progress",
    () => buffered.value = timeRangeToArray(toValue(target).buffered),
    listenerOptions
  );
  useEventListener(
    target,
    "seeking",
    () => seeking.value = true,
    listenerOptions
  );
  useEventListener(
    target,
    "seeked",
    () => seeking.value = false,
    listenerOptions
  );
  useEventListener(
    target,
    ["waiting", "loadstart"],
    () => {
      waiting.value = true;
      ignorePlayingUpdates(() => playing.value = false);
    },
    listenerOptions
  );
  useEventListener(
    target,
    "loadeddata",
    () => waiting.value = false,
    listenerOptions
  );
  useEventListener(
    target,
    "playing",
    () => {
      waiting.value = false;
      ended.value = false;
      ignorePlayingUpdates(() => playing.value = true);
    },
    listenerOptions
  );
  useEventListener(
    target,
    "ratechange",
    () => rate.value = toValue(target).playbackRate,
    listenerOptions
  );
  useEventListener(
    target,
    "stalled",
    () => stalled.value = true,
    listenerOptions
  );
  useEventListener(
    target,
    "ended",
    () => ended.value = true,
    listenerOptions
  );
  useEventListener(
    target,
    "pause",
    () => ignorePlayingUpdates(() => playing.value = false),
    listenerOptions
  );
  useEventListener(
    target,
    "play",
    () => ignorePlayingUpdates(() => playing.value = true),
    listenerOptions
  );
  useEventListener(
    target,
    "enterpictureinpicture",
    () => isPictureInPicture.value = true,
    listenerOptions
  );
  useEventListener(
    target,
    "leavepictureinpicture",
    () => isPictureInPicture.value = false,
    listenerOptions
  );
  useEventListener(
    target,
    "volumechange",
    () => {
      const el = toValue(target);
      if (!el)
        return;
      volume.value = el.volume;
      muted.value = el.muted;
    },
    listenerOptions
  );
  const listeners = [];
  const stop = watch([target], () => {
    const el = toValue(target);
    if (!el)
      return;
    stop();
    listeners[0] = useEventListener(el.textTracks, "addtrack", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);
    listeners[1] = useEventListener(el.textTracks, "removetrack", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);
    listeners[2] = useEventListener(el.textTracks, "change", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);
  });
  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));
  return {
    currentTime,
    duration,
    waiting,
    seeking,
    ended,
    stalled,
    buffered,
    playing,
    rate,
    // Volume
    volume,
    muted,
    // Tracks
    tracks,
    selectedTrack,
    enableTrack,
    disableTrack,
    // Picture in Picture
    supportsPictureInPicture,
    togglePictureInPicture,
    isPictureInPicture,
    // Events
    onSourceError: sourceErrorEvent.on,
    onPlaybackError: playbackErrorEvent.on
  };
}
function useMemoize(resolver, options) {
  const initCache = () => {
    if (options == null ? void 0 : options.cache)
      return shallowReactive(options.cache);
    return shallowReactive(/* @__PURE__ */ new Map());
  };
  const cache = initCache();
  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);
  const _loadData = (key, ...args) => {
    cache.set(key, resolver(...args));
    return cache.get(key);
  };
  const loadData = (...args) => _loadData(generateKey(...args), ...args);
  const deleteData = (...args) => {
    cache.delete(generateKey(...args));
  };
  const clearData = () => {
    cache.clear();
  };
  const memoized = (...args) => {
    const key = generateKey(...args);
    if (cache.has(key))
      return cache.get(key);
    return _loadData(key, ...args);
  };
  memoized.load = loadData;
  memoized.delete = deleteData;
  memoized.clear = clearData;
  memoized.generateKey = generateKey;
  memoized.cache = cache;
  return memoized;
}
function useMemory(options = {}) {
  const memory = ref();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported.value) {
    const { interval = 1e3 } = options;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });
  }
  return { isSupported, memory };
}
const UseMouseBuiltinExtractors = {
  page: (event) => [event.pageX, event.pageY],
  client: (event) => [event.clientX, event.clientY],
  screen: (event) => [event.screenX, event.screenY],
  movement: (event) => event instanceof MouseEvent ? [event.movementX, event.movementY] : null
};
function useMouse(options = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow,
    target = window2,
    scroll = true,
    eventFilter
  } = options;
  let _prevMouseEvent = null;
  let _prevScrollX = 0;
  let _prevScrollY = 0;
  const x = shallowRef(initialValue.x);
  const y = shallowRef(initialValue.y);
  const sourceType = shallowRef(null);
  const extractor = typeof type === "function" ? type : UseMouseBuiltinExtractors[type];
  const mouseHandler = (event) => {
    const result = extractor(event);
    _prevMouseEvent = event;
    if (result) {
      [x.value, y.value] = result;
      sourceType.value = "mouse";
    }
    if (window2) {
      _prevScrollX = window2.scrollX;
      _prevScrollY = window2.scrollY;
    }
  };
  const touchHandler = (event) => {
    if (event.touches.length > 0) {
      const result = extractor(event.touches[0]);
      if (result) {
        [x.value, y.value] = result;
        sourceType.value = "touch";
      }
    }
  };
  const scrollHandler = () => {
    if (!_prevMouseEvent || !window2)
      return;
    const pos = extractor(_prevMouseEvent);
    if (_prevMouseEvent instanceof MouseEvent && pos) {
      x.value = pos[0] + window2.scrollX - _prevScrollX;
      y.value = pos[1] + window2.scrollY - _prevScrollY;
    }
  };
  const reset = () => {
    x.value = initialValue.x;
    y.value = initialValue.y;
  };
  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);
  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);
  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["mousemove", "dragover"], mouseHandlerWrapper, listenerOptions);
    if (touch && type !== "movement") {
      useEventListener(target, ["touchstart", "touchmove"], touchHandlerWrapper, listenerOptions);
      if (resetOnTouchEnds)
        useEventListener(target, "touchend", reset, listenerOptions);
    }
    if (scroll && type === "page")
      useEventListener(window2, "scroll", scrollHandlerWrapper, listenerOptions);
  }
  return {
    x,
    y,
    sourceType
  };
}
function useMouseInElement(target, options = {}) {
  const {
    handleOutside = true,
    window: window2 = defaultWindow
  } = options;
  const type = options.type || "page";
  const { x, y, sourceType } = useMouse(options);
  const targetRef = shallowRef(target != null ? target : window2 == null ? void 0 : window2.document.body);
  const elementX = shallowRef(0);
  const elementY = shallowRef(0);
  const elementPositionX = shallowRef(0);
  const elementPositionY = shallowRef(0);
  const elementHeight = shallowRef(0);
  const elementWidth = shallowRef(0);
  const isOutside = shallowRef(true);
  let stop = () => {
  };
  if (window2) {
    stop = watch(
      [targetRef, x, y],
      () => {
        const el = unrefElement(targetRef);
        if (!el || !(el instanceof Element))
          return;
        const {
          left,
          top,
          width,
          height
        } = el.getBoundingClientRect();
        elementPositionX.value = left + (type === "page" ? window2.pageXOffset : 0);
        elementPositionY.value = top + (type === "page" ? window2.pageYOffset : 0);
        elementHeight.value = height;
        elementWidth.value = width;
        const elX = x.value - elementPositionX.value;
        const elY = y.value - elementPositionY.value;
        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
        if (handleOutside || !isOutside.value) {
          elementX.value = elX;
          elementY.value = elY;
        }
      },
      { immediate: true }
    );
    useEventListener(
      document,
      "mouseleave",
      () => isOutside.value = true,
      { passive: true }
    );
  }
  return {
    x,
    y,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop
  };
}
function useMousePressed(options = {}) {
  const {
    touch = true,
    drag = true,
    capture = false,
    initialValue = false,
    window: window2 = defaultWindow
  } = options;
  const pressed = shallowRef(initialValue);
  const sourceType = shallowRef(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = (srcType) => (event) => {
    var _a;
    pressed.value = true;
    sourceType.value = srcType;
    (_a = options.onPressed) == null ? void 0 : _a.call(options, event);
  };
  const onReleased = (event) => {
    var _a;
    pressed.value = false;
    sourceType.value = null;
    (_a = options.onReleased) == null ? void 0 : _a.call(options, event);
  };
  const target = computed(() => unrefElement(options.target) || window2);
  const listenerOptions = { passive: true, capture };
  useEventListener(target, "mousedown", onPressed("mouse"), listenerOptions);
  useEventListener(window2, "mouseleave", onReleased, listenerOptions);
  useEventListener(window2, "mouseup", onReleased, listenerOptions);
  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), listenerOptions);
    useEventListener(window2, "drop", onReleased, listenerOptions);
    useEventListener(window2, "dragend", onReleased, listenerOptions);
  }
  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), listenerOptions);
    useEventListener(window2, "touchend", onReleased, listenerOptions);
    useEventListener(window2, "touchcancel", onReleased, listenerOptions);
  }
  return {
    pressed,
    sourceType
  };
}
function useNavigatorLanguage(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator2 && "language" in navigator2);
  const language = shallowRef(navigator2 == null ? void 0 : navigator2.language);
  useEventListener(window2, "languagechange", () => {
    if (navigator2)
      language.value = navigator2.language;
  }, { passive: true });
  return {
    isSupported,
    language
  };
}
function useNetwork(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator2 && "connection" in navigator2);
  const isOnline = shallowRef(true);
  const saveData = shallowRef(false);
  const offlineAt = shallowRef(void 0);
  const onlineAt = shallowRef(void 0);
  const downlink = shallowRef(void 0);
  const downlinkMax = shallowRef(void 0);
  const rtt = shallowRef(void 0);
  const effectiveType = shallowRef(void 0);
  const type = shallowRef("unknown");
  const connection = isSupported.value && navigator2.connection;
  function updateNetworkInformation() {
    if (!navigator2)
      return;
    isOnline.value = navigator2.onLine;
    offlineAt.value = isOnline.value ? void 0 : Date.now();
    onlineAt.value = isOnline.value ? Date.now() : void 0;
    if (connection) {
      downlink.value = connection.downlink;
      downlinkMax.value = connection.downlinkMax;
      effectiveType.value = connection.effectiveType;
      rtt.value = connection.rtt;
      saveData.value = connection.saveData;
      type.value = connection.type;
    }
  }
  const listenerOptions = { passive: true };
  if (window2) {
    useEventListener(window2, "offline", () => {
      isOnline.value = false;
      offlineAt.value = Date.now();
    }, listenerOptions);
    useEventListener(window2, "online", () => {
      isOnline.value = true;
      onlineAt.value = Date.now();
    }, listenerOptions);
  }
  if (connection)
    useEventListener(connection, "change", updateNetworkInformation, listenerOptions);
  updateNetworkInformation();
  return {
    isSupported,
    isOnline: readonly(isOnline),
    saveData: readonly(saveData),
    offlineAt: readonly(offlineAt),
    onlineAt: readonly(onlineAt),
    downlink: readonly(downlink),
    downlinkMax: readonly(downlinkMax),
    effectiveType: readonly(effectiveType),
    rtt: readonly(rtt),
    type: readonly(type)
  };
}
function useNow(options = {}) {
  const {
    controls: exposeControls = false,
    interval = "requestAnimationFrame"
  } = options;
  const now = ref(/* @__PURE__ */ new Date());
  const update = () => now.value = /* @__PURE__ */ new Date();
  const controls = interval === "requestAnimationFrame" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });
  if (exposeControls) {
    return {
      now,
      ...controls
    };
  } else {
    return now;
  }
}
function useObjectUrl(object) {
  const url = shallowRef();
  const release = () => {
    if (url.value)
      URL.revokeObjectURL(url.value);
    url.value = void 0;
  };
  watch(
    () => toValue(object),
    (newObject) => {
      release();
      if (newObject)
        url.value = URL.createObjectURL(newObject);
    },
    { immediate: true }
  );
  tryOnScopeDispose(release);
  return readonly(url);
}
function useClamp(value, min, max) {
  if (typeof value === "function" || isReadonly(value))
    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));
  const _value = ref(value);
  return computed({
    get() {
      return _value.value = clamp(_value.value, toValue(min), toValue(max));
    },
    set(value2) {
      _value.value = clamp(value2, toValue(min), toValue(max));
    }
  });
}
function useOffsetPagination(options) {
  const {
    total = Number.POSITIVE_INFINITY,
    pageSize = 10,
    page = 1,
    onPageChange = noop,
    onPageSizeChange = noop,
    onPageCountChange = noop
  } = options;
  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);
  const pageCount = computed(() => Math.max(
    1,
    Math.ceil(toValue(total) / toValue(currentPageSize))
  ));
  const currentPage = useClamp(page, 1, pageCount);
  const isFirstPage = computed(() => currentPage.value === 1);
  const isLastPage = computed(() => currentPage.value === pageCount.value);
  if (isRef(page)) {
    syncRef(page, currentPage, {
      direction: isReadonly(page) ? "ltr" : "both"
    });
  }
  if (isRef(pageSize)) {
    syncRef(pageSize, currentPageSize, {
      direction: isReadonly(pageSize) ? "ltr" : "both"
    });
  }
  function prev() {
    currentPage.value--;
  }
  function next() {
    currentPage.value++;
  }
  const returnValue = {
    currentPage,
    currentPageSize,
    pageCount,
    isFirstPage,
    isLastPage,
    prev,
    next
  };
  watch(currentPage, () => {
    onPageChange(reactive(returnValue));
  });
  watch(currentPageSize, () => {
    onPageSizeChange(reactive(returnValue));
  });
  watch(pageCount, () => {
    onPageCountChange(reactive(returnValue));
  });
  return returnValue;
}
function useOnline(options = {}) {
  const { isOnline } = useNetwork(options);
  return isOnline;
}
function usePageLeave(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isLeft = shallowRef(false);
  const handler = (event) => {
    if (!window2)
      return;
    event = event || window2.event;
    const from = event.relatedTarget || event.toElement;
    isLeft.value = !from;
  };
  if (window2) {
    const listenerOptions = { passive: true };
    useEventListener(window2, "mouseout", handler, listenerOptions);
    useEventListener(window2.document, "mouseleave", handler, listenerOptions);
    useEventListener(window2.document, "mouseenter", handler, listenerOptions);
  }
  return isLeft;
}
function useScreenOrientation(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const isSupported = useSupported(() => window2 && "screen" in window2 && "orientation" in window2.screen);
  const screenOrientation = isSupported.value ? window2.screen.orientation : {};
  const orientation = ref(screenOrientation.type);
  const angle = shallowRef(screenOrientation.angle || 0);
  if (isSupported.value) {
    useEventListener(window2, "orientationchange", () => {
      orientation.value = screenOrientation.type;
      angle.value = screenOrientation.angle;
    }, { passive: true });
  }
  const lockOrientation = (type) => {
    if (isSupported.value && typeof screenOrientation.lock === "function")
      return screenOrientation.lock(type);
    return Promise.reject(new Error("Not supported"));
  };
  const unlockOrientation = () => {
    if (isSupported.value && typeof screenOrientation.unlock === "function")
      screenOrientation.unlock();
  };
  return {
    isSupported,
    orientation,
    angle,
    lockOrientation,
    unlockOrientation
  };
}
function useParallax(target, options = {}) {
  const {
    deviceOrientationTiltAdjust = (i) => i,
    deviceOrientationRollAdjust = (i) => i,
    mouseTiltAdjust = (i) => i,
    mouseRollAdjust = (i) => i,
    window: window2 = defaultWindow
  } = options;
  const orientation = reactive(useDeviceOrientation({ window: window2 }));
  const screenOrientation = reactive(useScreenOrientation({ window: window2 }));
  const {
    elementX: x,
    elementY: y,
    elementWidth: width,
    elementHeight: height
  } = useMouseInElement(target, { handleOutside: false, window: window2 });
  const source = computed(() => {
    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {
      return "deviceOrientation";
    }
    return "mouse";
  });
  const roll = computed(() => {
    if (source.value === "deviceOrientation") {
      let value;
      switch (screenOrientation.orientation) {
        case "landscape-primary":
          value = orientation.gamma / 90;
          break;
        case "landscape-secondary":
          value = -orientation.gamma / 90;
          break;
        case "portrait-primary":
          value = -orientation.beta / 90;
          break;
        case "portrait-secondary":
          value = orientation.beta / 90;
          break;
        default:
          value = -orientation.beta / 90;
      }
      return deviceOrientationRollAdjust(value);
    } else {
      const value = -(y.value - height.value / 2) / height.value;
      return mouseRollAdjust(value);
    }
  });
  const tilt = computed(() => {
    if (source.value === "deviceOrientation") {
      let value;
      switch (screenOrientation.orientation) {
        case "landscape-primary":
          value = orientation.beta / 90;
          break;
        case "landscape-secondary":
          value = -orientation.beta / 90;
          break;
        case "portrait-primary":
          value = orientation.gamma / 90;
          break;
        case "portrait-secondary":
          value = -orientation.gamma / 90;
          break;
        default:
          value = orientation.gamma / 90;
      }
      return deviceOrientationTiltAdjust(value);
    } else {
      const value = (x.value - width.value / 2) / width.value;
      return mouseTiltAdjust(value);
    }
  });
  return { roll, tilt, source };
}
function useParentElement(element = useCurrentElement()) {
  const parentElement = shallowRef();
  const update = () => {
    const el = unrefElement(element);
    if (el)
      parentElement.value = el.parentElement;
  };
  tryOnMounted(update);
  watch(() => toValue(element), update);
  return parentElement;
}
function usePerformanceObserver(options, callback) {
  const {
    window: window2 = defaultWindow,
    immediate = true,
    ...performanceOptions
  } = options;
  const isSupported = useSupported(() => window2 && "PerformanceObserver" in window2);
  let observer;
  const stop = () => {
    observer == null ? void 0 : observer.disconnect();
  };
  const start = () => {
    if (isSupported.value) {
      stop();
      observer = new PerformanceObserver(callback);
      observer.observe(performanceOptions);
    }
  };
  tryOnScopeDispose(stop);
  if (immediate)
    start();
  return {
    isSupported,
    start,
    stop
  };
}
const defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
const keys = /* @__PURE__ */ Object.keys(defaultState);
function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = shallowRef(false);
  const state = ref(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler = (event) => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    state.value = objectPick(event, keys, false);
  };
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs(state),
    isInside
  };
}
function usePointerLock(target, options = {}) {
  const { document: document2 = defaultDocument } = options;
  const isSupported = useSupported(() => document2 && "pointerLockElement" in document2);
  const element = shallowRef();
  const triggerElement = shallowRef();
  let targetElement;
  if (isSupported.value) {
    const listenerOptions = { passive: true };
    useEventListener(document2, "pointerlockchange", () => {
      var _a;
      const currentElement = (_a = document2.pointerLockElement) != null ? _a : element.value;
      if (targetElement && currentElement === targetElement) {
        element.value = document2.pointerLockElement;
        if (!element.value)
          targetElement = triggerElement.value = null;
      }
    }, listenerOptions);
    useEventListener(document2, "pointerlockerror", () => {
      var _a;
      const currentElement = (_a = document2.pointerLockElement) != null ? _a : element.value;
      if (targetElement && currentElement === targetElement) {
        const action = document2.pointerLockElement ? "release" : "acquire";
        throw new Error(`Failed to ${action} pointer lock.`);
      }
    }, listenerOptions);
  }
  async function lock(e) {
    var _a;
    if (!isSupported.value)
      throw new Error("Pointer Lock API is not supported by your browser.");
    triggerElement.value = e instanceof Event ? e.currentTarget : null;
    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);
    if (!targetElement)
      throw new Error("Target element undefined.");
    targetElement.requestPointerLock();
    return await until(element).toBe(targetElement);
  }
  async function unlock() {
    if (!element.value)
      return false;
    document2.exitPointerLock();
    await until(element).toBeNull();
    return true;
  }
  return {
    isSupported,
    element,
    triggerElement,
    lock,
    unlock
  };
}
function usePointerSwipe(target, options = {}) {
  const targetRef = toRef(target);
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    disableTextSelect = false
  } = options;
  const posStart = reactive({ x: 0, y: 0 });
  const updatePosStart = (x, y) => {
    posStart.x = x;
    posStart.y = y;
  };
  const posEnd = reactive({ x: 0, y: 0 });
  const updatePosEnd = (x, y) => {
    posEnd.x = x;
    posEnd.y = y;
  };
  const distanceX = computed(() => posStart.x - posEnd.x);
  const distanceY = computed(() => posStart.y - posEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);
  const isSwiping = shallowRef(false);
  const isPointerDown = shallowRef(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(distanceX.value) > abs(distanceY.value)) {
      return distanceX.value > 0 ? "left" : "right";
    } else {
      return distanceY.value > 0 ? "up" : "down";
    }
  });
  const eventIsAllowed = (e) => {
    var _a, _b, _c;
    const isReleasingButton = e.buttons === 0;
    const isPrimaryButton = e.buttons === 1;
    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;
  };
  const listenerOptions = { passive: true };
  const stops = [
    useEventListener(target, "pointerdown", (e) => {
      if (!eventIsAllowed(e))
        return;
      isPointerDown.value = true;
      const eventTarget = e.target;
      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);
      const { clientX: x, clientY: y } = e;
      updatePosStart(x, y);
      updatePosEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions),
    useEventListener(target, "pointermove", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (!isPointerDown.value)
        return;
      const { clientX: x, clientY: y } = e;
      updatePosEnd(x, y);
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions),
    useEventListener(target, "pointerup", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (isSwiping.value)
        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
      isPointerDown.value = false;
      isSwiping.value = false;
    }, listenerOptions)
  ];
  tryOnMounted(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "none");
    if (disableTextSelect) {
      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty("-webkit-user-select", "none");
      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty("-ms-user-select", "none");
      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty("user-select", "none");
    }
  });
  const stop = () => stops.forEach((s) => s());
  return {
    isSwiping: readonly(isSwiping),
    direction: readonly(direction),
    posStart: readonly(posStart),
    posEnd: readonly(posEnd),
    distanceX,
    distanceY,
    stop
  };
}
function usePreferredColorScheme(options) {
  const isLight = useMediaQuery("(prefers-color-scheme: light)", options);
  const isDark = useMediaQuery("(prefers-color-scheme: dark)", options);
  return computed(() => {
    if (isDark.value)
      return "dark";
    if (isLight.value)
      return "light";
    return "no-preference";
  });
}
function usePreferredContrast(options) {
  const isMore = useMediaQuery("(prefers-contrast: more)", options);
  const isLess = useMediaQuery("(prefers-contrast: less)", options);
  const isCustom = useMediaQuery("(prefers-contrast: custom)", options);
  return computed(() => {
    if (isMore.value)
      return "more";
    if (isLess.value)
      return "less";
    if (isCustom.value)
      return "custom";
    return "no-preference";
  });
}
function usePreferredLanguages(options = {}) {
  const { window: window2 = defaultWindow } = options;
  if (!window2)
    return ref(["en"]);
  const navigator2 = window2.navigator;
  const value = ref(navigator2.languages);
  useEventListener(window2, "languagechange", () => {
    value.value = navigator2.languages;
  }, { passive: true });
  return value;
}
function usePreferredReducedMotion(options) {
  const isReduced = useMediaQuery("(prefers-reduced-motion: reduce)", options);
  return computed(() => {
    if (isReduced.value)
      return "reduce";
    return "no-preference";
  });
}
function usePreferredReducedTransparency(options) {
  const isReduced = useMediaQuery("(prefers-reduced-transparency: reduce)", options);
  return computed(() => {
    if (isReduced.value)
      return "reduce";
    return "no-preference";
  });
}
function usePrevious(value, initialValue) {
  const previous = shallowRef(initialValue);
  watch(
    toRef(value),
    (_, oldValue) => {
      previous.value = oldValue;
    },
    { flush: "sync" }
  );
  return readonly(previous);
}
const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";
function useScreenSafeArea() {
  const top = shallowRef("");
  const right = shallowRef("");
  const bottom = shallowRef("");
  const left = shallowRef("");
  if (isClient) {
    const topCssVar = useCssVar(topVarName);
    const rightCssVar = useCssVar(rightVarName);
    const bottomCssVar = useCssVar(bottomVarName);
    const leftCssVar = useCssVar(leftVarName);
    topCssVar.value = "env(safe-area-inset-top, 0px)";
    rightCssVar.value = "env(safe-area-inset-right, 0px)";
    bottomCssVar.value = "env(safe-area-inset-bottom, 0px)";
    leftCssVar.value = "env(safe-area-inset-left, 0px)";
    update();
    useEventListener("resize", useDebounceFn(update), { passive: true });
  }
  function update() {
    top.value = getValue(topVarName);
    right.value = getValue(rightVarName);
    bottom.value = getValue(bottomVarName);
    left.value = getValue(leftVarName);
  }
  return {
    top,
    right,
    bottom,
    left,
    update
  };
}
function getValue(position) {
  return getComputedStyle(document.documentElement).getPropertyValue(position);
}
function useScriptTag(src, onLoaded = noop, options = {}) {
  const {
    immediate = true,
    manual = false,
    type = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document: document2 = defaultDocument,
    attrs = {}
  } = options;
  const scriptTag = shallowRef(null);
  let _promise = null;
  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      scriptTag.value = el2;
      resolve(el2);
      return el2;
    };
    if (!document2) {
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (!el) {
      el = document2.createElement("script");
      el.type = type;
      el.async = async;
      el.src = toValue(src);
      if (defer)
        el.defer = defer;
      if (crossOrigin)
        el.crossOrigin = crossOrigin;
      if (noModule)
        el.noModule = noModule;
      if (referrerPolicy)
        el.referrerPolicy = referrerPolicy;
      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    const listenerOptions = {
      passive: true
    };
    useEventListener(el, "error", (event) => reject(event), listenerOptions);
    useEventListener(el, "abort", (event) => reject(event), listenerOptions);
    useEventListener(el, "load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    }, listenerOptions);
    if (shouldAppend)
      el = document2.head.appendChild(el);
    if (!waitForScriptLoad)
      resolveWithElement(el);
  });
  const load = (waitForScriptLoad = true) => {
    if (!_promise)
      _promise = loadScript(waitForScriptLoad);
    return _promise;
  };
  const unload = () => {
    if (!document2)
      return;
    _promise = null;
    if (scriptTag.value)
      scriptTag.value = null;
    const el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (el)
      document2.head.removeChild(el);
  };
  if (immediate && !manual)
    tryOnMounted(load);
  if (!manual)
    tryOnUnmounted(unload);
  return { scriptTag, load, unload };
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault)
    e.preventDefault();
  return false;
}
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element, initialState = false) {
  const isLocked = shallowRef(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow = "";
  watch(toRef(element), (el) => {
    const target = resolveElement(toValue(el));
    if (target) {
      const ele = target;
      if (!elInitialOverflow.get(ele))
        elInitialOverflow.set(ele, ele.style.overflow);
      if (ele.style.overflow !== "hidden")
        initialOverflow = ele.style.overflow;
      if (ele.style.overflow === "hidden")
        return isLocked.value = true;
      if (isLocked.value)
        return ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const lock = () => {
    const el = resolveElement(toValue(element));
    if (!el || isLocked.value)
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        el,
        "touchmove",
        (e) => {
          preventDefault(e);
        },
        { passive: false }
      );
    }
    el.style.overflow = "hidden";
    isLocked.value = true;
  };
  const unlock = () => {
    const el = resolveElement(toValue(element));
    if (!el || !isLocked.value)
      return;
    if (isIOS)
      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
    el.style.overflow = initialOverflow;
    elInitialOverflow.delete(el);
    isLocked.value = false;
  };
  tryOnScopeDispose(unlock);
  return computed({
    get() {
      return isLocked.value;
    },
    set(v) {
      if (v)
        lock();
      else unlock();
    }
  });
}
function useSessionStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.sessionStorage, options);
}
function useShare(shareOptions = {}, options = {}) {
  const { navigator: navigator2 = defaultNavigator } = options;
  const _navigator = navigator2;
  const isSupported = useSupported(() => _navigator && "canShare" in _navigator);
  const share = async (overrideOptions = {}) => {
    if (isSupported.value) {
      const data = {
        ...toValue(shareOptions),
        ...toValue(overrideOptions)
      };
      let granted = true;
      if (data.files && _navigator.canShare)
        granted = _navigator.canShare({ files: data.files });
      if (granted)
        return _navigator.share(data);
    }
  };
  return {
    isSupported,
    share
  };
}
const defaultSortFn = (source, compareFn) => source.sort(compareFn);
const defaultCompare = (a, b) => a - b;
function useSorted(...args) {
  var _a, _b, _c, _d;
  const [source] = args;
  let compareFn = defaultCompare;
  let options = {};
  if (args.length === 2) {
    if (typeof args[1] === "object") {
      options = args[1];
      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;
    } else {
      compareFn = (_b = args[1]) != null ? _b : defaultCompare;
    }
  } else if (args.length > 2) {
    compareFn = (_c = args[1]) != null ? _c : defaultCompare;
    options = (_d = args[2]) != null ? _d : {};
  }
  const {
    dirty = false,
    sortFn = defaultSortFn
  } = options;
  if (!dirty)
    return computed(() => sortFn([...toValue(source)], compareFn));
  watchEffect(() => {
    const result = sortFn(toValue(source), compareFn);
    if (isRef(source))
      source.value = result;
    else
      source.splice(0, source.length, ...result);
  });
  return source;
}
function useSpeechRecognition(options = {}) {
  const {
    interimResults = true,
    continuous = true,
    maxAlternatives = 1,
    window: window2 = defaultWindow
  } = options;
  const lang = toRef(options.lang || "en-US");
  const isListening = shallowRef(false);
  const isFinal = shallowRef(false);
  const result = shallowRef("");
  const error = shallowRef(void 0);
  let recognition;
  const start = () => {
    isListening.value = true;
  };
  const stop = () => {
    isListening.value = false;
  };
  const toggle = (value = !isListening.value) => {
    if (value) {
      start();
    } else {
      stop();
    }
  };
  const SpeechRecognition = window2 && (window2.SpeechRecognition || window2.webkitSpeechRecognition);
  const isSupported = useSupported(() => SpeechRecognition);
  if (isSupported.value) {
    recognition = new SpeechRecognition();
    recognition.continuous = continuous;
    recognition.interimResults = interimResults;
    recognition.lang = toValue(lang);
    recognition.maxAlternatives = maxAlternatives;
    recognition.onstart = () => {
      isListening.value = true;
      isFinal.value = false;
    };
    watch(lang, (lang2) => {
      if (recognition && !isListening.value)
        recognition.lang = lang2;
    });
    recognition.onresult = (event) => {
      const currentResult = event.results[event.resultIndex];
      const { transcript } = currentResult[0];
      isFinal.value = currentResult.isFinal;
      result.value = transcript;
      error.value = void 0;
    };
    recognition.onerror = (event) => {
      error.value = event;
    };
    recognition.onend = () => {
      isListening.value = false;
      recognition.lang = toValue(lang);
    };
    watch(isListening, (newValue, oldValue) => {
      if (newValue === oldValue)
        return;
      if (newValue)
        recognition.start();
      else
        recognition.stop();
    });
  }
  tryOnScopeDispose(() => {
    stop();
  });
  return {
    isSupported,
    isListening,
    isFinal,
    recognition,
    result,
    error,
    toggle,
    start,
    stop
  };
}
function useSpeechSynthesis(text, options = {}) {
  const {
    pitch = 1,
    rate = 1,
    volume = 1,
    window: window2 = defaultWindow
  } = options;
  const synth = window2 && window2.speechSynthesis;
  const isSupported = useSupported(() => synth);
  const isPlaying = shallowRef(false);
  const status = shallowRef("init");
  const spokenText = toRef(text || "");
  const lang = toRef(options.lang || "en-US");
  const error = shallowRef(void 0);
  const toggle = (value = !isPlaying.value) => {
    isPlaying.value = value;
  };
  const bindEventsForUtterance = (utterance2) => {
    utterance2.lang = toValue(lang);
    utterance2.voice = toValue(options.voice) || null;
    utterance2.pitch = toValue(pitch);
    utterance2.rate = toValue(rate);
    utterance2.volume = volume;
    utterance2.onstart = () => {
      isPlaying.value = true;
      status.value = "play";
    };
    utterance2.onpause = () => {
      isPlaying.value = false;
      status.value = "pause";
    };
    utterance2.onresume = () => {
      isPlaying.value = true;
      status.value = "play";
    };
    utterance2.onend = () => {
      isPlaying.value = false;
      status.value = "end";
    };
    utterance2.onerror = (event) => {
      error.value = event;
    };
  };
  const utterance = computed(() => {
    isPlaying.value = false;
    status.value = "init";
    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
    bindEventsForUtterance(newUtterance);
    return newUtterance;
  });
  const speak = () => {
    synth.cancel();
    if (utterance)
      synth.speak(utterance.value);
  };
  const stop = () => {
    synth.cancel();
    isPlaying.value = false;
  };
  if (isSupported.value) {
    bindEventsForUtterance(utterance.value);
    watch(lang, (lang2) => {
      if (utterance.value && !isPlaying.value)
        utterance.value.lang = lang2;
    });
    if (options.voice) {
      watch(options.voice, () => {
        synth.cancel();
      });
    }
    watch(isPlaying, () => {
      if (isPlaying.value)
        synth.resume();
      else
        synth.pause();
    });
  }
  tryOnScopeDispose(() => {
    isPlaying.value = false;
  });
  return {
    isSupported,
    isPlaying,
    status,
    utterance,
    error,
    stop,
    toggle,
    speak
  };
}
function useStepper(steps, initialStep) {
  const stepsRef = ref(steps);
  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));
  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));
  const current = computed(() => at(index.value));
  const isFirst = computed(() => index.value === 0);
  const isLast = computed(() => index.value === stepNames.value.length - 1);
  const next = computed(() => stepNames.value[index.value + 1]);
  const previous = computed(() => stepNames.value[index.value - 1]);
  function at(index2) {
    if (Array.isArray(stepsRef.value))
      return stepsRef.value[index2];
    return stepsRef.value[stepNames.value[index2]];
  }
  function get(step) {
    if (!stepNames.value.includes(step))
      return;
    return at(stepNames.value.indexOf(step));
  }
  function goTo(step) {
    if (stepNames.value.includes(step))
      index.value = stepNames.value.indexOf(step);
  }
  function goToNext() {
    if (isLast.value)
      return;
    index.value++;
  }
  function goToPrevious() {
    if (isFirst.value)
      return;
    index.value--;
  }
  function goBackTo(step) {
    if (isAfter(step))
      goTo(step);
  }
  function isNext(step) {
    return stepNames.value.indexOf(step) === index.value + 1;
  }
  function isPrevious(step) {
    return stepNames.value.indexOf(step) === index.value - 1;
  }
  function isCurrent(step) {
    return stepNames.value.indexOf(step) === index.value;
  }
  function isBefore(step) {
    return index.value < stepNames.value.indexOf(step);
  }
  function isAfter(step) {
    return index.value > stepNames.value.indexOf(step);
  }
  return {
    steps: stepsRef,
    stepNames,
    index,
    current,
    next,
    previous,
    isFirst,
    isLast,
    at,
    get,
    goTo,
    goToNext,
    goToPrevious,
    goBackTo,
    isNext,
    isPrevious,
    isCurrent,
    isBefore,
    isAfter
  };
}
function useStorageAsync(key, initialValue, storage, options = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const rawInit = toValue(initialValue);
  const type = guessSerializerType(rawInit);
  const data = (shallow ? shallowRef : ref)(toValue(initialValue));
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorageAsync", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  async function read(event) {
    if (!storage || event && event.key !== key)
      return;
    try {
      const rawValue = event ? event.newValue : await storage.getItem(key);
      if (rawValue == null) {
        data.value = rawInit;
        if (writeDefaults && rawInit !== null)
          await storage.setItem(key, await serializer.write(rawInit));
      } else if (mergeDefaults) {
        const value = await serializer.read(rawValue);
        if (typeof mergeDefaults === "function")
          data.value = mergeDefaults(value, rawInit);
        else if (type === "object" && !Array.isArray(value))
          data.value = { ...rawInit, ...value };
        else data.value = value;
      } else {
        data.value = await serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    }
  }
  read();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e) => Promise.resolve().then(() => read(e)), { passive: true });
  if (storage) {
    watchWithFilter(
      data,
      async () => {
        try {
          if (data.value == null)
            await storage.removeItem(key);
          else
            await storage.setItem(key, await serializer.write(data.value));
        } catch (e) {
          onError(e);
        }
      },
      {
        flush,
        deep,
        eventFilter
      }
    );
  }
  return data;
}
let _id = 0;
function useStyleTag(css, options = {}) {
  const isLoaded = shallowRef(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id = `vueuse_styletag_${++_id}`
  } = options;
  const cssRef = shallowRef(css);
  let stop = () => {
  };
  const load = () => {
    if (!document2)
      return;
    const el = document2.getElementById(id) || document2.createElement("style");
    if (!el.isConnected) {
      el.id = id;
      if (options.media)
        el.media = options.media;
      document2.head.appendChild(el);
    }
    if (isLoaded.value)
      return;
    stop = watch(
      cssRef,
      (value) => {
        el.textContent = value;
      },
      { immediate: true }
    );
    isLoaded.value = true;
  };
  const unload = () => {
    if (!document2 || !isLoaded.value)
      return;
    stop();
    document2.head.removeChild(document2.getElementById(id));
    isLoaded.value = false;
  };
  if (immediate && !manual)
    tryOnMounted(load);
  if (!manual)
    tryOnScopeDispose(unload);
  return {
    id,
    css: cssRef,
    unload,
    load,
    isLoaded: readonly(isLoaded)
  };
}
function useSwipe(target, options = {}) {
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    passive = true
  } = options;
  const coordsStart = reactive({ x: 0, y: 0 });
  const coordsEnd = reactive({ x: 0, y: 0 });
  const diffX = computed(() => coordsStart.x - coordsEnd.x);
  const diffY = computed(() => coordsStart.y - coordsEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);
  const isSwiping = shallowRef(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(diffX.value) > abs(diffY.value)) {
      return diffX.value > 0 ? "left" : "right";
    } else {
      return diffY.value > 0 ? "up" : "down";
    }
  });
  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];
  const updateCoordsStart = (x, y) => {
    coordsStart.x = x;
    coordsStart.y = y;
  };
  const updateCoordsEnd = (x, y) => {
    coordsEnd.x = x;
    coordsEnd.y = y;
  };
  const listenerOptions = { passive, capture: !passive };
  const onTouchEnd = (e) => {
    if (isSwiping.value)
      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
    isSwiping.value = false;
  };
  const stops = [
    useEventListener(target, "touchstart", (e) => {
      if (e.touches.length !== 1)
        return;
      const [x, y] = getTouchEventCoords(e);
      updateCoordsStart(x, y);
      updateCoordsEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions),
    useEventListener(target, "touchmove", (e) => {
      if (e.touches.length !== 1)
        return;
      const [x, y] = getTouchEventCoords(e);
      updateCoordsEnd(x, y);
      if (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value))
        e.preventDefault();
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions),
    useEventListener(target, ["touchend", "touchcancel"], onTouchEnd, listenerOptions)
  ];
  const stop = () => stops.forEach((s) => s());
  return {
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop,
    // TODO: Remove in the next major version
    isPassiveEventSupported: true
  };
}
function useTemplateRefsList() {
  const refs = ref([]);
  refs.value.set = (el) => {
    if (el)
      refs.value.push(el);
  };
  onBeforeUpdate(() => {
    refs.value.length = 0;
  });
  return refs;
}
function useTextDirection(options = {}) {
  const {
    document: document2 = defaultDocument,
    selector = "html",
    observe = false,
    initialValue = "ltr"
  } = options;
  function getValue2() {
    var _a, _b;
    return (_b = (_a = document2 == null ? void 0 : document2.querySelector(selector)) == null ? void 0 : _a.getAttribute("dir")) != null ? _b : initialValue;
  }
  const dir = ref(getValue2());
  tryOnMounted(() => dir.value = getValue2());
  if (observe && document2) {
    useMutationObserver(
      document2.querySelector(selector),
      () => dir.value = getValue2(),
      { attributes: true }
    );
  }
  return computed({
    get() {
      return dir.value;
    },
    set(v) {
      var _a, _b;
      dir.value = v;
      if (!document2)
        return;
      if (dir.value)
        (_a = document2.querySelector(selector)) == null ? void 0 : _a.setAttribute("dir", dir.value);
      else
        (_b = document2.querySelector(selector)) == null ? void 0 : _b.removeAttribute("dir");
    }
  });
}
function getRangesFromSelection(selection) {
  var _a;
  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;
  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));
}
function useTextSelection(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const selection = ref(null);
  const text = computed(() => {
    var _a, _b;
    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : "";
  });
  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);
  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));
  function onSelectionChange() {
    selection.value = null;
    if (window2)
      selection.value = window2.getSelection();
  }
  if (window2)
    useEventListener(window2.document, "selectionchange", onSelectionChange, { passive: true });
  return {
    text,
    rects,
    ranges,
    selection
  };
}
function tryRequestAnimationFrame(window2 = defaultWindow, fn) {
  if (window2 && typeof window2.requestAnimationFrame === "function") {
    window2.requestAnimationFrame(fn);
  } else {
    fn();
  }
}
function useTextareaAutosize(options = {}) {
  var _a, _b;
  const { window: window2 = defaultWindow } = options;
  const textarea = toRef(options == null ? void 0 : options.element);
  const input = toRef((_a = options == null ? void 0 : options.input) != null ? _a : "");
  const styleProp = (_b = options == null ? void 0 : options.styleProp) != null ? _b : "height";
  const textareaScrollHeight = shallowRef(1);
  const textareaOldWidth = shallowRef(0);
  function triggerResize() {
    var _a2;
    if (!textarea.value)
      return;
    let height = "";
    textarea.value.style[styleProp] = "1px";
    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;
    const _styleTarget = toValue(options == null ? void 0 : options.styleTarget);
    if (_styleTarget)
      _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;
    else
      height = `${textareaScrollHeight.value}px`;
    textarea.value.style[styleProp] = height;
  }
  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });
  watch(textareaScrollHeight, () => {
    var _a2;
    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);
  });
  useResizeObserver(textarea, ([{ contentRect }]) => {
    if (textareaOldWidth.value === contentRect.width)
      return;
    tryRequestAnimationFrame(window2, () => {
      textareaOldWidth.value = contentRect.width;
      triggerResize();
    });
  });
  if (options == null ? void 0 : options.watch)
    watch(options.watch, triggerResize, { immediate: true, deep: true });
  return {
    textarea,
    input,
    triggerResize
  };
}
function useThrottledRefHistory(source, options = {}) {
  const { throttle = 200, trailing = true } = options;
  const filter = throttleFilter(throttle, trailing);
  const history = useRefHistory(source, { ...options, eventFilter: filter });
  return {
    ...history
  };
}
const DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: (n) => n.match(/\d/) ? `${n} ago` : n,
  future: (n) => n.match(/\d/) ? `in ${n}` : n,
  month: (n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`,
  year: (n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`,
  day: (n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`,
  week: (n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`,
  hour: (n) => `${n} hour${n > 1 ? "s" : ""}`,
  minute: (n) => `${n} minute${n > 1 ? "s" : ""}`,
  second: (n) => `${n} second${n > 1 ? "s" : ""}`,
  invalid: ""
};
function DEFAULT_FORMATTER(date) {
  return date.toISOString().slice(0, 10);
}
function useTimeAgo(time, options = {}) {
  const {
    controls: exposeControls = false,
    updateInterval = 3e4
  } = options;
  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });
  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));
  if (exposeControls) {
    return {
      timeAgo,
      ...controls
    };
  } else {
    return timeAgo;
  }
}
function formatTimeAgo(from, options = {}, now = Date.now()) {
  var _a;
  const {
    max,
    messages = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER,
    units = DEFAULT_UNITS,
    showSecond = false,
    rounding = "round"
  } = options;
  const roundFn = typeof rounding === "number" ? (n) => +n.toFixed(rounding) : Math[rounding];
  const diff = +now - +from;
  const absDiff = Math.abs(diff);
  function getValue2(diff2, unit) {
    return roundFn(Math.abs(diff2) / unit.value);
  }
  function format(diff2, unit) {
    const val = getValue2(diff2, unit);
    const past = diff2 > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }
  function applyFormat(name, val, isPast) {
    const formatter = messages[name];
    if (typeof formatter === "function")
      return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }
  if (absDiff < 6e4 && !showSecond)
    return messages.justNow;
  if (typeof max === "number" && absDiff > max)
    return fullDateFormatter(new Date(from));
  if (typeof max === "string") {
    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;
    if (unitMax && absDiff > unitMax)
      return fullDateFormatter(new Date(from));
  }
  for (const [idx, unit] of units.entries()) {
    const val = getValue2(diff, unit);
    if (val <= 0 && units[idx - 1])
      return format(diff, units[idx - 1]);
    if (absDiff < unit.max)
      return format(diff, unit);
  }
  return messages.invalid;
}
function useTimeoutPoll(fn, interval, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  const { start } = useTimeoutFn(loop, interval, { immediate });
  const isActive = shallowRef(false);
  async function loop() {
    if (!isActive.value)
      return;
    await fn();
    start();
  }
  function resume() {
    if (!isActive.value) {
      isActive.value = true;
      if (immediateCallback)
        fn();
      start();
    }
  }
  function pause() {
    isActive.value = false;
  }
  if (immediate && isClient)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useTimestamp(options = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval = "requestAnimationFrame",
    callback
  } = options;
  const ts = shallowRef(timestamp() + offset);
  const update = () => ts.value = timestamp() + offset;
  const cb = callback ? () => {
    update();
    callback(ts.value);
  } : update;
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  if (exposeControls) {
    return {
      timestamp: ts,
      ...controls
    };
  } else {
    return ts;
  }
}
function useTitle(newTitle = null, options = {}) {
  var _a, _b, _c;
  const {
    document: document2 = defaultDocument,
    restoreOnUnmount = (t) => t
  } = options;
  const originalTitle = (_a = document2 == null ? void 0 : document2.title) != null ? _a : "";
  const title = toRef((_b = newTitle != null ? newTitle : document2 == null ? void 0 : document2.title) != null ? _b : null);
  const isReadonly2 = !!(newTitle && typeof newTitle === "function");
  function format(t) {
    if (!("titleTemplate" in options))
      return t;
    const template = options.titleTemplate || "%s";
    return typeof template === "function" ? template(t) : toValue(template).replace(/%s/g, t);
  }
  watch(
    title,
    (newValue, oldValue) => {
      if (newValue !== oldValue && document2)
        document2.title = format(newValue != null ? newValue : "");
    },
    { immediate: true }
  );
  if (options.observe && !options.titleTemplate && document2 && !isReadonly2) {
    useMutationObserver(
      (_c = document2.head) == null ? void 0 : _c.querySelector("title"),
      () => {
        if (document2 && document2.title !== title.value)
          title.value = format(document2.title);
      },
      { childList: true }
    );
  }
  tryOnScopeDispose(() => {
    if (restoreOnUnmount) {
      const restoredTitle = restoreOnUnmount(originalTitle, title.value || "");
      if (restoredTitle != null && document2)
        document2.title = restoredTitle;
    }
  });
  return title;
}
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
const TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);
function createEasingFunction([p0, p1, p2, p3]) {
  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;
  const b = (a1, a2) => 3 * a2 - 6 * a1;
  const c = (a1) => 3 * a1;
  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
  const getTforX = (x) => {
    let aGuessT = x;
    for (let i = 0; i < 4; ++i) {
      const currentSlope = getSlope(aGuessT, p0, p2);
      if (currentSlope === 0)
        return aGuessT;
      const currentX = calcBezier(aGuessT, p0, p2) - x;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);
}
function lerp(a, b, alpha) {
  return a + alpha * (b - a);
}
function toVec(t) {
  return (typeof t === "number" ? [t] : t) || [];
}
function executeTransition(source, from, to, options = {}) {
  var _a, _b;
  const fromVal = toValue(from);
  const toVal = toValue(to);
  const v1 = toVec(fromVal);
  const v2 = toVec(toVal);
  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;
  const startedAt = Date.now();
  const endAt = Date.now() + duration;
  const trans = typeof options.transition === "function" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;
  const ease = typeof trans === "function" ? trans : createEasingFunction(trans);
  return new Promise((resolve) => {
    source.value = fromVal;
    const tick = () => {
      var _a2;
      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {
        resolve();
        return;
      }
      const now = Date.now();
      const alpha = ease((now - startedAt) / duration);
      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));
      if (Array.isArray(source.value))
        source.value = arr.map((n, i) => {
          var _a3, _b2;
          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);
        });
      else if (typeof source.value === "number")
        source.value = arr[0];
      if (now < endAt) {
        requestAnimationFrame(tick);
      } else {
        source.value = toVal;
        resolve();
      }
    };
    tick();
  });
}
function useTransition(source, options = {}) {
  let currentId = 0;
  const sourceVal = () => {
    const v = toValue(source);
    return typeof v === "number" ? v : v.map(toValue);
  };
  const outputRef = ref(sourceVal());
  watch(sourceVal, async (to) => {
    var _a, _b;
    if (toValue(options.disabled))
      return;
    const id = ++currentId;
    if (options.delay)
      await promiseTimeout(toValue(options.delay));
    if (id !== currentId)
      return;
    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);
    (_a = options.onStarted) == null ? void 0 : _a.call(options);
    await executeTransition(outputRef, outputRef.value, toVal, {
      ...options,
      abort: () => {
        var _a2;
        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));
      }
    });
    (_b = options.onFinished) == null ? void 0 : _b.call(options);
  }, { deep: true });
  watch(() => toValue(options.disabled), (disabled) => {
    if (disabled) {
      currentId++;
      outputRef.value = sourceVal();
    }
  });
  tryOnScopeDispose(() => {
    currentId++;
  });
  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);
}
function useUrlSearchParams(mode = "history", options = {}) {
  const {
    initialValue = {},
    removeNullishValues = true,
    removeFalsyValues = false,
    write: enableWrite = true,
    writeMode = "replace",
    window: window2 = defaultWindow
  } = options;
  if (!window2)
    return reactive(initialValue);
  const state = reactive({});
  function getRawParams() {
    if (mode === "history") {
      return window2.location.search || "";
    } else if (mode === "hash") {
      const hash = window2.location.hash || "";
      const index = hash.indexOf("?");
      return index > 0 ? hash.slice(index) : "";
    } else {
      return (window2.location.hash || "").replace(/^#/, "");
    }
  }
  function constructQuery(params) {
    const stringified = params.toString();
    if (mode === "history")
      return `${stringified ? `?${stringified}` : ""}${window2.location.hash || ""}`;
    if (mode === "hash-params")
      return `${window2.location.search || ""}${stringified ? `#${stringified}` : ""}`;
    const hash = window2.location.hash || "#";
    const index = hash.indexOf("?");
    if (index > 0)
      return `${window2.location.search || ""}${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
    return `${window2.location.search || ""}${hash}${stringified ? `?${stringified}` : ""}`;
  }
  function read() {
    return new URLSearchParams(getRawParams());
  }
  function updateState(params) {
    const unusedKeys = new Set(Object.keys(state));
    for (const key of params.keys()) {
      const paramsForKey = params.getAll(key);
      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || "";
      unusedKeys.delete(key);
    }
    Array.from(unusedKeys).forEach((key) => delete state[key]);
  }
  const { pause, resume } = pausableWatch(
    state,
    () => {
      const params = new URLSearchParams("");
      Object.keys(state).forEach((key) => {
        const mapEntry = state[key];
        if (Array.isArray(mapEntry))
          mapEntry.forEach((value) => params.append(key, value));
        else if (removeNullishValues && mapEntry == null)
          params.delete(key);
        else if (removeFalsyValues && !mapEntry)
          params.delete(key);
        else
          params.set(key, mapEntry);
      });
      write(params, false);
    },
    { deep: true }
  );
  function write(params, shouldUpdate) {
    pause();
    if (shouldUpdate)
      updateState(params);
    if (writeMode === "replace") {
      window2.history.replaceState(
        window2.history.state,
        window2.document.title,
        window2.location.pathname + constructQuery(params)
      );
    } else {
      window2.history.pushState(
        window2.history.state,
        window2.document.title,
        window2.location.pathname + constructQuery(params)
      );
    }
    resume();
  }
  function onChanged() {
    if (!enableWrite)
      return;
    write(read(), true);
  }
  const listenerOptions = { passive: true };
  useEventListener(window2, "popstate", onChanged, listenerOptions);
  if (mode !== "history")
    useEventListener(window2, "hashchange", onChanged, listenerOptions);
  const initial = read();
  if (initial.keys().next().value)
    updateState(initial);
  else
    Object.assign(state, initialValue);
  return state;
}
function useUserMedia(options = {}) {
  var _a, _b;
  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);
  const autoSwitch = shallowRef((_b = options.autoSwitch) != null ? _b : true);
  const constraints = ref(options.constraints);
  const { navigator: navigator2 = defaultNavigator } = options;
  const isSupported = useSupported(() => {
    var _a2;
    return (_a2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _a2.getUserMedia;
  });
  const stream = shallowRef();
  function getDeviceOptions(type) {
    switch (type) {
      case "video": {
        if (constraints.value)
          return constraints.value.video || false;
        break;
      }
      case "audio": {
        if (constraints.value)
          return constraints.value.audio || false;
        break;
      }
    }
  }
  async function _start() {
    if (!isSupported.value || stream.value)
      return;
    stream.value = await navigator2.mediaDevices.getUserMedia({
      video: getDeviceOptions("video"),
      audio: getDeviceOptions("audio")
    });
    return stream.value;
  }
  function _stop() {
    var _a2;
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());
    stream.value = void 0;
  }
  function stop() {
    _stop();
    enabled.value = false;
  }
  async function start() {
    await _start();
    if (stream.value)
      enabled.value = true;
    return stream.value;
  }
  async function restart() {
    _stop();
    return await start();
  }
  watch(
    enabled,
    (v) => {
      if (v)
        _start();
      else _stop();
    },
    { immediate: true }
  );
  watch(
    constraints,
    () => {
      if (autoSwitch.value && stream.value)
        restart();
    },
    { immediate: true }
  );
  tryOnScopeDispose(() => {
    stop();
  });
  return {
    isSupported,
    stream,
    start,
    stop,
    restart,
    constraints,
    enabled,
    autoSwitch
  };
}
function useVModel(props, key, emit, options = {}) {
  var _a, _b, _c;
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  if (!key) {
    key = "modelValue";
  }
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
  const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v) => {
        if (!isUpdating && (v !== props[key] || deep))
          triggerEmit(v);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}
function useVModels(props, emit, options = {}) {
  const ret = {};
  for (const key in props) {
    ret[key] = useVModel(
      props,
      key,
      emit,
      options
    );
  }
  return ret;
}
function useVibrate(options) {
  const {
    pattern = [],
    interval = 0,
    navigator: navigator2 = defaultNavigator
  } = options || {};
  const isSupported = useSupported(() => typeof navigator2 !== "undefined" && "vibrate" in navigator2);
  const patternRef = toRef(pattern);
  let intervalControls;
  const vibrate = (pattern2 = patternRef.value) => {
    if (isSupported.value)
      navigator2.vibrate(pattern2);
  };
  const stop = () => {
    if (isSupported.value)
      navigator2.vibrate(0);
    intervalControls == null ? void 0 : intervalControls.pause();
  };
  if (interval > 0) {
    intervalControls = useIntervalFn(
      vibrate,
      interval,
      {
        immediate: false,
        immediateCallback: false
      }
    );
  }
  return {
    isSupported,
    pattern,
    intervalControls,
    vibrate,
    stop
  };
}
function useVirtualList(list, options) {
  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = "itemHeight" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);
  return {
    list: currentList,
    scrollTo,
    containerProps: {
      ref: containerRef,
      onScroll: () => {
        calculateRange();
      },
      style: containerStyle
    },
    wrapperProps
  };
}
function useVirtualListResources(list) {
  const containerRef = shallowRef(null);
  const size = useElementSize(containerRef);
  const currentList = ref([]);
  const source = shallowRef(list);
  const state = ref({ start: 0, end: 10 });
  return { state, source, currentList, size, containerRef };
}
function createGetViewCapacity(state, source, itemSize) {
  return (containerSize) => {
    if (typeof itemSize === "number")
      return Math.ceil(containerSize / itemSize);
    const { start = 0 } = state.value;
    let sum = 0;
    let capacity = 0;
    for (let i = start; i < source.value.length; i++) {
      const size = itemSize(i);
      sum += size;
      capacity = i;
      if (sum > containerSize)
        break;
    }
    return capacity - start;
  };
}
function createGetOffset(source, itemSize) {
  return (scrollDirection) => {
    if (typeof itemSize === "number")
      return Math.floor(scrollDirection / itemSize) + 1;
    let sum = 0;
    let offset = 0;
    for (let i = 0; i < source.value.length; i++) {
      const size = itemSize(i);
      sum += size;
      if (sum >= scrollDirection) {
        offset = i;
        break;
      }
    }
    return offset + 1;
  };
}
function createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {
  return () => {
    const element = containerRef.value;
    if (element) {
      const offset = getOffset(type === "vertical" ? element.scrollTop : element.scrollLeft);
      const viewCapacity = getViewCapacity(type === "vertical" ? element.clientHeight : element.clientWidth);
      const from = offset - overscan;
      const to = offset + viewCapacity + overscan;
      state.value = {
        start: from < 0 ? 0 : from,
        end: to > source.value.length ? source.value.length : to
      };
      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({
        data: ele,
        index: index + state.value.start
      }));
    }
  };
}
function createGetDistance(itemSize, source) {
  return (index) => {
    if (typeof itemSize === "number") {
      const size2 = index * itemSize;
      return size2;
    }
    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);
    return size;
  };
}
function useWatchForSizes(size, list, containerRef, calculateRange) {
  watch([size.width, size.height, list, containerRef], () => {
    calculateRange();
  });
}
function createComputedTotalSize(itemSize, source) {
  return computed(() => {
    if (typeof itemSize === "number")
      return source.value.length * itemSize;
    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);
  });
}
const scrollToDictionaryForElementScrollKey = {
  horizontal: "scrollLeft",
  vertical: "scrollTop"
};
function createScrollTo(type, calculateRange, getDistance, containerRef) {
  return (index) => {
    if (containerRef.value) {
      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);
      calculateRange();
    }
  };
}
function useHorizontalVirtualList(options, list) {
  const resources = useVirtualListResources(list);
  const { state, source, currentList, size, containerRef } = resources;
  const containerStyle = { overflowX: "auto" };
  const { itemWidth, overscan = 5 } = options;
  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);
  const getOffset = createGetOffset(source, itemWidth);
  const calculateRange = createCalculateRange("horizontal", overscan, getOffset, getViewCapacity, resources);
  const getDistanceLeft = createGetDistance(itemWidth, source);
  const offsetLeft = computed(() => getDistanceLeft(state.value.start));
  const totalWidth = createComputedTotalSize(itemWidth, source);
  useWatchForSizes(size, list, containerRef, calculateRange);
  const scrollTo = createScrollTo("horizontal", calculateRange, getDistanceLeft, containerRef);
  const wrapperProps = computed(() => {
    return {
      style: {
        height: "100%",
        width: `${totalWidth.value - offsetLeft.value}px`,
        marginLeft: `${offsetLeft.value}px`,
        display: "flex"
      }
    };
  });
  return {
    scrollTo,
    calculateRange,
    wrapperProps,
    containerStyle,
    currentList,
    containerRef
  };
}
function useVerticalVirtualList(options, list) {
  const resources = useVirtualListResources(list);
  const { state, source, currentList, size, containerRef } = resources;
  const containerStyle = { overflowY: "auto" };
  const { itemHeight, overscan = 5 } = options;
  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);
  const getOffset = createGetOffset(source, itemHeight);
  const calculateRange = createCalculateRange("vertical", overscan, getOffset, getViewCapacity, resources);
  const getDistanceTop = createGetDistance(itemHeight, source);
  const offsetTop = computed(() => getDistanceTop(state.value.start));
  const totalHeight = createComputedTotalSize(itemHeight, source);
  useWatchForSizes(size, list, containerRef, calculateRange);
  const scrollTo = createScrollTo("vertical", calculateRange, getDistanceTop, containerRef);
  const wrapperProps = computed(() => {
    return {
      style: {
        width: "100%",
        height: `${totalHeight.value - offsetTop.value}px`,
        marginTop: `${offsetTop.value}px`
      }
    };
  });
  return {
    calculateRange,
    scrollTo,
    containerStyle,
    wrapperProps,
    currentList,
    containerRef
  };
}
function useWakeLock(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    document: document2 = defaultDocument
  } = options;
  const requestedType = shallowRef(false);
  const sentinel = shallowRef(null);
  const documentVisibility = useDocumentVisibility({ document: document2 });
  const isSupported = useSupported(() => navigator2 && "wakeLock" in navigator2);
  const isActive = computed(() => !!sentinel.value && documentVisibility.value === "visible");
  if (isSupported.value) {
    useEventListener(sentinel, "release", () => {
      var _a, _b;
      requestedType.value = (_b = (_a = sentinel.value) == null ? void 0 : _a.type) != null ? _b : false;
    }, { passive: true });
    whenever(
      () => documentVisibility.value === "visible" && (document2 == null ? void 0 : document2.visibilityState) === "visible" && requestedType.value,
      (type) => {
        requestedType.value = false;
        forceRequest(type);
      }
    );
  }
  async function forceRequest(type) {
    var _a;
    await ((_a = sentinel.value) == null ? void 0 : _a.release());
    sentinel.value = isSupported.value ? await navigator2.wakeLock.request(type) : null;
  }
  async function request(type) {
    if (documentVisibility.value === "visible")
      await forceRequest(type);
    else
      requestedType.value = type;
  }
  async function release() {
    requestedType.value = false;
    const s = sentinel.value;
    sentinel.value = null;
    await (s == null ? void 0 : s.release());
  }
  return {
    sentinel,
    isSupported,
    isActive,
    request,
    forceRequest,
    release
  };
}
function useWebNotification(options = {}) {
  const {
    window: window2 = defaultWindow,
    requestPermissions: _requestForPermissions = true
  } = options;
  const defaultWebNotificationOptions = options;
  const isSupported = useSupported(() => {
    if (!window2 || !("Notification" in window2))
      return false;
    if (Notification.permission === "granted")
      return true;
    try {
      const notification2 = new Notification("");
      notification2.onshow = () => {
        notification2.close();
      };
    } catch (e) {
      if (e.name === "TypeError")
        return false;
    }
    return true;
  });
  const permissionGranted = shallowRef(isSupported.value && "permission" in Notification && Notification.permission === "granted");
  const notification = ref(null);
  const ensurePermissions = async () => {
    if (!isSupported.value)
      return;
    if (!permissionGranted.value && Notification.permission !== "denied") {
      const result = await Notification.requestPermission();
      if (result === "granted")
        permissionGranted.value = true;
    }
    return permissionGranted.value;
  };
  const { on: onClick, trigger: clickTrigger } = createEventHook();
  const { on: onShow, trigger: showTrigger } = createEventHook();
  const { on: onError, trigger: errorTrigger } = createEventHook();
  const { on: onClose, trigger: closeTrigger } = createEventHook();
  const show = async (overrides) => {
    if (!isSupported.value || !permissionGranted.value)
      return;
    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);
    notification.value = new Notification(options2.title || "", options2);
    notification.value.onclick = clickTrigger;
    notification.value.onshow = showTrigger;
    notification.value.onerror = errorTrigger;
    notification.value.onclose = closeTrigger;
    return notification.value;
  };
  const close = () => {
    if (notification.value)
      notification.value.close();
    notification.value = null;
  };
  if (_requestForPermissions)
    tryOnMounted(ensurePermissions);
  tryOnScopeDispose(close);
  if (isSupported.value && window2) {
    const document2 = window2.document;
    useEventListener(document2, "visibilitychange", (e) => {
      e.preventDefault();
      if (document2.visibilityState === "visible") {
        close();
      }
    });
  }
  return {
    isSupported,
    notification,
    ensurePermissions,
    permissionGranted,
    show,
    close,
    onClick,
    onShow,
    onError,
    onClose
  };
}
const DEFAULT_PING_MESSAGE = "ping";
function resolveNestedOptions(options) {
  if (options === true)
    return {};
  return options;
}
function useWebSocket(url, options = {}) {
  const {
    onConnected,
    onDisconnected,
    onError,
    onMessage,
    immediate = true,
    autoConnect = true,
    autoClose = true,
    protocols = []
  } = options;
  const data = ref(null);
  const status = shallowRef("CLOSED");
  const wsRef = ref();
  const urlRef = toRef(url);
  let heartbeatPause;
  let heartbeatResume;
  let explicitlyClosed = false;
  let retried = 0;
  let bufferedData = [];
  let retryTimeout;
  let pongTimeoutWait;
  const _sendBuffer = () => {
    if (bufferedData.length && wsRef.value && status.value === "OPEN") {
      for (const buffer of bufferedData)
        wsRef.value.send(buffer);
      bufferedData = [];
    }
  };
  const resetRetry = () => {
    if (retryTimeout != null) {
      clearTimeout(retryTimeout);
      retryTimeout = void 0;
    }
  };
  const resetHeartbeat = () => {
    clearTimeout(pongTimeoutWait);
    pongTimeoutWait = void 0;
  };
  const close = (code = 1e3, reason) => {
    resetRetry();
    if (!isClient && !isWorker || !wsRef.value)
      return;
    explicitlyClosed = true;
    resetHeartbeat();
    heartbeatPause == null ? void 0 : heartbeatPause();
    wsRef.value.close(code, reason);
    wsRef.value = void 0;
  };
  const send = (data2, useBuffer = true) => {
    if (!wsRef.value || status.value !== "OPEN") {
      if (useBuffer)
        bufferedData.push(data2);
      return false;
    }
    _sendBuffer();
    wsRef.value.send(data2);
    return true;
  };
  const _init = () => {
    if (explicitlyClosed || typeof urlRef.value === "undefined")
      return;
    const ws = new WebSocket(urlRef.value, protocols);
    wsRef.value = ws;
    status.value = "CONNECTING";
    ws.onopen = () => {
      status.value = "OPEN";
      retried = 0;
      onConnected == null ? void 0 : onConnected(ws);
      heartbeatResume == null ? void 0 : heartbeatResume();
      _sendBuffer();
    };
    ws.onclose = (ev) => {
      status.value = "CLOSED";
      resetHeartbeat();
      heartbeatPause == null ? void 0 : heartbeatPause();
      onDisconnected == null ? void 0 : onDisconnected(ws, ev);
      if (!explicitlyClosed && options.autoReconnect && (wsRef.value == null || ws === wsRef.value)) {
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions(options.autoReconnect);
        const checkRetires = typeof retries === "function" ? retries : () => typeof retries === "number" && (retries < 0 || retried < retries);
        if (checkRetires(retried)) {
          retried += 1;
          retryTimeout = setTimeout(_init, delay);
        } else {
          onFailed == null ? void 0 : onFailed();
        }
      }
    };
    ws.onerror = (e) => {
      onError == null ? void 0 : onError(ws, e);
    };
    ws.onmessage = (e) => {
      if (options.heartbeat) {
        resetHeartbeat();
        const {
          message = DEFAULT_PING_MESSAGE,
          responseMessage = message
        } = resolveNestedOptions(options.heartbeat);
        if (e.data === toValue(responseMessage))
          return;
      }
      data.value = e.data;
      onMessage == null ? void 0 : onMessage(ws, e);
    };
  };
  if (options.heartbeat) {
    const {
      message = DEFAULT_PING_MESSAGE,
      interval = 1e3,
      pongTimeout = 1e3
    } = resolveNestedOptions(options.heartbeat);
    const { pause, resume } = useIntervalFn(
      () => {
        send(toValue(message), false);
        if (pongTimeoutWait != null)
          return;
        pongTimeoutWait = setTimeout(() => {
          close();
          explicitlyClosed = false;
        }, pongTimeout);
      },
      interval,
      { immediate: false }
    );
    heartbeatPause = pause;
    heartbeatResume = resume;
  }
  if (autoClose) {
    if (isClient)
      useEventListener("beforeunload", () => close(), { passive: true });
    tryOnScopeDispose(close);
  }
  const open = () => {
    if (!isClient && !isWorker)
      return;
    close();
    explicitlyClosed = false;
    retried = 0;
    _init();
  };
  if (immediate)
    open();
  if (autoConnect)
    watch(urlRef, open);
  return {
    data,
    status,
    close,
    send,
    open,
    ws: wsRef
  };
}
function useWebWorker(arg0, workerOptions, options) {
  const {
    window: window2 = defaultWindow
  } = options != null ? options : {};
  const data = ref(null);
  const worker = shallowRef();
  const post = (...args) => {
    if (!worker.value)
      return;
    worker.value.postMessage(...args);
  };
  const terminate = function terminate2() {
    if (!worker.value)
      return;
    worker.value.terminate();
  };
  if (window2) {
    if (typeof arg0 === "string")
      worker.value = new Worker(arg0, workerOptions);
    else if (typeof arg0 === "function")
      worker.value = arg0();
    else
      worker.value = arg0;
    worker.value.onmessage = (e) => {
      data.value = e.data;
    };
    tryOnScopeDispose(() => {
      if (worker.value)
        worker.value.terminate();
    });
  }
  return {
    data,
    post,
    terminate,
    worker
  };
}
function depsParser(deps, localDeps) {
  if (deps.length === 0 && localDeps.length === 0)
    return "";
  const depsString = deps.map((dep) => `'${dep}'`).toString();
  const depsFunctionString = localDeps.filter((dep) => typeof dep === "function").map((fn) => {
    const str = fn.toString();
    if (str.trim().startsWith("function")) {
      return str;
    } else {
      const name = fn.name;
      return `const ${name} = ${str}`;
    }
  }).join(";");
  const importString = `importScripts(${depsString});`;
  return `${depsString.trim() === "" ? "" : importString} ${depsFunctionString}`;
}
function jobRunner(userFunc) {
  return (e) => {
    const userFuncArgs = e.data[0];
    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {
      postMessage(["SUCCESS", result]);
    }).catch((error) => {
      postMessage(["ERROR", error]);
    });
  };
}
function createWorkerBlobUrl(fn, deps, localDeps) {
  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;
  const blob = new Blob([blobCode], { type: "text/javascript" });
  const url = URL.createObjectURL(blob);
  return url;
}
function useWebWorkerFn(fn, options = {}) {
  const {
    dependencies = [],
    localDependencies = [],
    timeout,
    window: window2 = defaultWindow
  } = options;
  const worker = ref();
  const workerStatus = shallowRef("PENDING");
  const promise = ref({});
  const timeoutId = shallowRef();
  const workerTerminate = (status = "PENDING") => {
    if (worker.value && worker.value._url && window2) {
      worker.value.terminate();
      URL.revokeObjectURL(worker.value._url);
      promise.value = {};
      worker.value = void 0;
      window2.clearTimeout(timeoutId.value);
      workerStatus.value = status;
    }
  };
  workerTerminate();
  tryOnScopeDispose(workerTerminate);
  const generateWorker = () => {
    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;
    newWorker.onmessage = (e) => {
      const { resolve = () => {
      }, reject = () => {
      } } = promise.value;
      const [status, result] = e.data;
      switch (status) {
        case "SUCCESS":
          resolve(result);
          workerTerminate(status);
          break;
        default:
          reject(result);
          workerTerminate("ERROR");
          break;
      }
    };
    newWorker.onerror = (e) => {
      const { reject = () => {
      } } = promise.value;
      e.preventDefault();
      reject(e);
      workerTerminate("ERROR");
    };
    if (timeout) {
      timeoutId.value = setTimeout(
        () => workerTerminate("TIMEOUT_EXPIRED"),
        timeout
      );
    }
    return newWorker;
  };
  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {
    var _a;
    promise.value = {
      resolve,
      reject
    };
    (_a = worker.value) == null ? void 0 : _a.postMessage([[...fnArgs]]);
    workerStatus.value = "RUNNING";
  });
  const workerFn = (...fnArgs) => {
    if (workerStatus.value === "RUNNING") {
      console.error(
        "[useWebWorkerFn] You can only run one instance of the worker at a time."
      );
      return Promise.reject();
    }
    worker.value = generateWorker();
    return callWorker(...fnArgs);
  };
  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
}
function useWindowFocus(options = {}) {
  const { window: window2 = defaultWindow } = options;
  if (!window2)
    return shallowRef(false);
  const focused = shallowRef(window2.document.hasFocus());
  const listenerOptions = { passive: true };
  useEventListener(window2, "blur", () => {
    focused.value = false;
  }, listenerOptions);
  useEventListener(window2, "focus", () => {
    focused.value = true;
  }, listenerOptions);
  return focused;
}
function useWindowScroll(options = {}) {
  const { window: window2 = defaultWindow, ...rest } = options;
  return useScroll(window2, rest);
}
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true,
    type = "inner"
  } = options;
  const width = shallowRef(initialWidth);
  const height = shallowRef(initialHeight);
  const update = () => {
    if (window2) {
      if (type === "outer") {
        width.value = window2.outerWidth;
        height.value = window2.outerHeight;
      } else if (type === "visual" && window2.visualViewport) {
        const { width: visualViewportWidth, height: visualViewportHeight, scale } = window2.visualViewport;
        width.value = Math.round(visualViewportWidth * scale);
        height.value = Math.round(visualViewportHeight * scale);
      } else if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  const listenerOptions = { passive: true };
  useEventListener("resize", update, listenerOptions);
  if (window2 && type === "visual" && window2.visualViewport) {
    useEventListener(window2.visualViewport, "resize", update, listenerOptions);
  }
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch(matches, () => update());
  }
  return { width, height };
}
export { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsElement, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onElementRemoval, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, provideSSRWidth, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCountdown, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePreferredReducedTransparency, usePrevious, useRafFn, useRefHistory, useResizeObserver, useSSRWidth, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4Lm1qcz92PTEyMTRhODUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5vb3AsIG1ha2VEZXN0cnVjdHVyYWJsZSwgY2FtZWxpemUsIGlzQ2xpZW50LCB0b0FycmF5LCB3YXRjaEltbWVkaWF0ZSwgaXNPYmplY3QsIHRyeU9uU2NvcGVEaXNwb3NlLCBpc0lPUywgbm90TnVsbGlzaCwgdHJ5T25Nb3VudGVkLCBvYmplY3RPbWl0LCBwcm9taXNlVGltZW91dCwgdW50aWwsIGluamVjdExvY2FsLCBwcm92aWRlTG9jYWwsIHB4VmFsdWUsIGluY3JlYXNlV2l0aFVuaXQsIG9iamVjdEVudHJpZXMsIGNyZWF0ZVJlZiwgY3JlYXRlU2luZ2xldG9uUHJvbWlzZSwgdXNlVGltZW91dEZuLCBwYXVzYWJsZVdhdGNoLCB0b1JlZiwgY3JlYXRlRXZlbnRIb29rLCB1c2VJbnRlcnZhbEZuLCBjb21wdXRlZFdpdGhDb250cm9sLCB0aW1lc3RhbXAsIHBhdXNhYmxlRmlsdGVyLCB3YXRjaElnbm9yYWJsZSwgZGVib3VuY2VGaWx0ZXIsIGJ5cGFzc0ZpbHRlciwgY3JlYXRlRmlsdGVyV3JhcHBlciwgdG9SZWZzLCB3YXRjaE9uY2UsIGNvbnRhaW5zUHJvcCwgaGFzT3duLCB0aHJvdHRsZUZpbHRlciwgdXNlRGVib3VuY2VGbiwgdXNlVGhyb3R0bGVGbiwgdHJ5T25Vbm1vdW50ZWQsIGNsYW1wLCBzeW5jUmVmLCBvYmplY3RQaWNrLCB3YXRjaFdpdGhGaWx0ZXIsIGlkZW50aXR5LCBpc0RlZiwgd2hlbmV2ZXIsIGlzV29ya2VyIH0gZnJvbSAnQHZ1ZXVzZS9zaGFyZWQnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZXVzZS9zaGFyZWQnO1xuaW1wb3J0IHsgaXNSZWYsIHNoYWxsb3dSZWYsIHJlZiwgd2F0Y2hFZmZlY3QsIGNvbXB1dGVkLCBpbmplY3QsIGRlZmluZUNvbXBvbmVudCwgaCwgVHJhbnNpdGlvbkdyb3VwLCBzaGFsbG93UmVhY3RpdmUsIEZyYWdtZW50LCB0b1ZhbHVlLCB1bnJlZiwgZ2V0Q3VycmVudEluc3RhbmNlLCBvbk1vdW50ZWQsIHdhdGNoLCBjdXN0b21SZWYsIG9uVXBkYXRlZCwgcmVhZG9ubHksIHJlYWN0aXZlLCBoYXNJbmplY3Rpb25Db250ZXh0LCB0b1JhdywgbmV4dFRpY2ssIG1hcmtSYXcsIGdldEN1cnJlbnRTY29wZSwgaXNSZWFkb25seSwgb25CZWZvcmVVcGRhdGUgfSBmcm9tICd2dWUnO1xuXG5mdW5jdGlvbiBjb21wdXRlZEFzeW5jKGV2YWx1YXRpb25DYWxsYmFjaywgaW5pdGlhbFN0YXRlLCBvcHRpb25zT3JSZWYpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChpc1JlZihvcHRpb25zT3JSZWYpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGV2YWx1YXRpbmc6IG9wdGlvbnNPclJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNPclJlZiB8fCB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgbGF6eSA9IGZhbHNlLFxuICAgIGV2YWx1YXRpbmcgPSB2b2lkIDAsXG4gICAgc2hhbGxvdyA9IHRydWUsXG4gICAgb25FcnJvciA9IG5vb3BcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHN0YXJ0ZWQgPSBzaGFsbG93UmVmKCFsYXp5KTtcbiAgY29uc3QgY3VycmVudCA9IHNoYWxsb3cgPyBzaGFsbG93UmVmKGluaXRpYWxTdGF0ZSkgOiByZWYoaW5pdGlhbFN0YXRlKTtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICB3YXRjaEVmZmVjdChhc3luYyAob25JbnZhbGlkYXRlKSA9PiB7XG4gICAgaWYgKCFzdGFydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvdW50ZXIrKztcbiAgICBjb25zdCBjb3VudGVyQXRCZWdpbm5pbmcgPSBjb3VudGVyO1xuICAgIGxldCBoYXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIGlmIChldmFsdWF0aW5nKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgZXZhbHVhdGluZy52YWx1ZSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2YWx1YXRpb25DYWxsYmFjaygoY2FuY2VsQ2FsbGJhY2spID0+IHtcbiAgICAgICAgb25JbnZhbGlkYXRlKCgpID0+IHtcbiAgICAgICAgICBpZiAoZXZhbHVhdGluZylcbiAgICAgICAgICAgIGV2YWx1YXRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIWhhc0ZpbmlzaGVkKVxuICAgICAgICAgICAgY2FuY2VsQ2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChjb3VudGVyQXRCZWdpbm5pbmcgPT09IGNvdW50ZXIpXG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGV2YWx1YXRpbmcgJiYgY291bnRlckF0QmVnaW5uaW5nID09PSBjb3VudGVyKVxuICAgICAgICBldmFsdWF0aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICBoYXNGaW5pc2hlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKGxhenkpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgc3RhcnRlZC52YWx1ZSA9IHRydWU7XG4gICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlZEluamVjdChrZXksIG9wdGlvbnMsIGRlZmF1bHRTb3VyY2UsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSkge1xuICBsZXQgc291cmNlID0gaW5qZWN0KGtleSk7XG4gIGlmIChkZWZhdWx0U291cmNlKVxuICAgIHNvdXJjZSA9IGluamVjdChrZXksIGRlZmF1bHRTb3VyY2UpO1xuICBpZiAodHJlYXREZWZhdWx0QXNGYWN0b3J5KVxuICAgIHNvdXJjZSA9IGluamVjdChrZXksIGRlZmF1bHRTb3VyY2UsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkKChjdHgpID0+IG9wdGlvbnMoc291cmNlLCBjdHgpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoe1xuICAgICAgZ2V0OiAoY3R4KSA9PiBvcHRpb25zLmdldChzb3VyY2UsIGN0eCksXG4gICAgICBzZXQ6IG9wdGlvbnMuc2V0XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmV1c2FibGVUZW1wbGF0ZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGluaGVyaXRBdHRycyA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlbmRlciA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgZGVmaW5lID0gLypAX19QVVJFX18qLyBkZWZpbmVDb21wb25lbnQoe1xuICAgIHNldHVwKF8sIHsgc2xvdHMgfSkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVuZGVyLnZhbHVlID0gc2xvdHMuZGVmYXVsdDtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcmV1c2UgPSAvKkBfX1BVUkVfXyovIGRlZmluZUNvbXBvbmVudCh7XG4gICAgaW5oZXJpdEF0dHJzLFxuICAgIHByb3BzOiBvcHRpb25zLnByb3BzLFxuICAgIHNldHVwKHByb3BzLCB7IGF0dHJzLCBzbG90cyB9KSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcmVuZGVyLnZhbHVlICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbVnVlVXNlXSBGYWlsZWQgdG8gZmluZCB0aGUgZGVmaW5pdGlvbiBvZiByZXVzYWJsZSB0ZW1wbGF0ZVwiKTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSAoX2EgPSByZW5kZXIudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHJlbmRlciwge1xuICAgICAgICAgIC4uLm9wdGlvbnMucHJvcHMgPT0gbnVsbCA/IGtleXNUb0NhbWVsS2ViYWJDYXNlKGF0dHJzKSA6IHByb3BzLFxuICAgICAgICAgICRzbG90czogc2xvdHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbmhlcml0QXR0cnMgJiYgKHZub2RlID09IG51bGwgPyB2b2lkIDAgOiB2bm9kZS5sZW5ndGgpID09PSAxID8gdm5vZGVbMF0gOiB2bm9kZTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1ha2VEZXN0cnVjdHVyYWJsZShcbiAgICB7IGRlZmluZSwgcmV1c2UgfSxcbiAgICBbZGVmaW5lLCByZXVzZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGtleXNUb0NhbWVsS2ViYWJDYXNlKG9iaikge1xuICBjb25zdCBuZXdPYmogPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKVxuICAgIG5ld09ialtjYW1lbGl6ZShrZXkpXSA9IG9ialtrZXldO1xuICByZXR1cm4gbmV3T2JqO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZVByb21pc2Uob3B0aW9ucyA9IHt9KSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IGluc3RhbmNlcyA9IHJlZihbXSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBzaGFsbG93UmVhY3RpdmUoe1xuICAgICAga2V5OiBpbmRleCsrLFxuICAgICAgYXJncyxcbiAgICAgIHByb21pc2U6IHZvaWQgMCxcbiAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICByZWplY3Q6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBpc1Jlc29sdmluZzogZmFsc2UsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgaW5zdGFuY2VzLnZhbHVlLnB1c2gocHJvcHMpO1xuICAgIHByb3BzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgIHByb3BzLnJlc29sdmUgPSAodikgPT4ge1xuICAgICAgICBwcm9wcy5pc1Jlc29sdmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBfcmVzb2x2ZSh2KTtcbiAgICAgIH07XG4gICAgICBwcm9wcy5yZWplY3QgPSBfcmVqZWN0O1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgcHJvcHMucHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGluZGV4MiA9IGluc3RhbmNlcy52YWx1ZS5pbmRleE9mKHByb3BzKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKVxuICAgICAgICBpbnN0YW5jZXMudmFsdWUuc3BsaWNlKGluZGV4MiwgMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3BzLnByb21pc2U7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoLi4uYXJncykge1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbiAmJiBpbnN0YW5jZXMudmFsdWUubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBpbnN0YW5jZXMudmFsdWVbMF0ucHJvbWlzZTtcbiAgICByZXR1cm4gY3JlYXRlKC4uLmFyZ3MpO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudCA9IC8qQF9fUFVSRV9fKi8gZGVmaW5lQ29tcG9uZW50KChfLCB7IHNsb3RzIH0pID0+IHtcbiAgICBjb25zdCByZW5kZXJMaXN0ID0gKCkgPT4gaW5zdGFuY2VzLnZhbHVlLm1hcCgocHJvcHMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBoKEZyYWdtZW50LCB7IGtleTogcHJvcHMua2V5IH0sIChfYSA9IHNsb3RzLmRlZmF1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHNsb3RzLCBwcm9wcykpO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pXG4gICAgICByZXR1cm4gKCkgPT4gaChUcmFuc2l0aW9uR3JvdXAsIG9wdGlvbnMudHJhbnNpdGlvbiwgcmVuZGVyTGlzdCk7XG4gICAgcmV0dXJuIHJlbmRlckxpc3Q7XG4gIH0pO1xuICBjb21wb25lbnQuc3RhcnQgPSBzdGFydDtcbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5yZWZGbihmbikge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzLm1hcCgoaSkgPT4gdG9WYWx1ZShpKSkpO1xuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0V2luZG93ID0gaXNDbGllbnQgPyB3aW5kb3cgOiB2b2lkIDA7XG5jb25zdCBkZWZhdWx0RG9jdW1lbnQgPSBpc0NsaWVudCA/IHdpbmRvdy5kb2N1bWVudCA6IHZvaWQgMDtcbmNvbnN0IGRlZmF1bHROYXZpZ2F0b3IgPSBpc0NsaWVudCA/IHdpbmRvdy5uYXZpZ2F0b3IgOiB2b2lkIDA7XG5jb25zdCBkZWZhdWx0TG9jYXRpb24gPSBpc0NsaWVudCA/IHdpbmRvdy5sb2NhdGlvbiA6IHZvaWQgMDtcblxuZnVuY3Rpb24gdW5yZWZFbGVtZW50KGVsUmVmKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcGxhaW4gPSB0b1ZhbHVlKGVsUmVmKTtcbiAgcmV0dXJuIChfYSA9IHBsYWluID09IG51bGwgPyB2b2lkIDAgOiBwbGFpbi4kZWwpICE9IG51bGwgPyBfYSA6IHBsYWluO1xufVxuXG5mdW5jdGlvbiB1c2VFdmVudExpc3RlbmVyKC4uLmFyZ3MpIHtcbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBjbGVhbnVwcy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgY2xlYW51cHMubGVuZ3RoID0gMDtcbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXIgPSAoZWwsIGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9ucykgPT4ge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBmaXJzdFBhcmFtVGFyZ2V0cyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCB0ZXN0ID0gdG9BcnJheSh0b1ZhbHVlKGFyZ3NbMF0pKS5maWx0ZXIoKGUpID0+IGUgIT0gbnVsbCk7XG4gICAgcmV0dXJuIHRlc3QuZXZlcnkoKGUpID0+IHR5cGVvZiBlICE9PSBcInN0cmluZ1wiKSA/IHRlc3QgOiB2b2lkIDA7XG4gIH0pO1xuICBjb25zdCBzdG9wV2F0Y2ggPSB3YXRjaEltbWVkaWF0ZShcbiAgICAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgKF9iID0gKF9hID0gZmlyc3RQYXJhbVRhcmdldHMudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IHVucmVmRWxlbWVudChlKSkpICE9IG51bGwgPyBfYiA6IFtkZWZhdWx0V2luZG93XS5maWx0ZXIoKGUpID0+IGUgIT0gbnVsbCksXG4gICAgICAgIHRvQXJyYXkodG9WYWx1ZShmaXJzdFBhcmFtVGFyZ2V0cy52YWx1ZSA/IGFyZ3NbMV0gOiBhcmdzWzBdKSksXG4gICAgICAgIHRvQXJyYXkodW5yZWYoZmlyc3RQYXJhbVRhcmdldHMudmFsdWUgPyBhcmdzWzJdIDogYXJnc1sxXSkpLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVHlwZVNjcmlwdCBnZXRzIHRoZSBjb3JyZWN0IHR5cGVzLCBidXQgc29tZWhvdyBzdGlsbCBjb21wbGFpbnNcbiAgICAgICAgdG9WYWx1ZShmaXJzdFBhcmFtVGFyZ2V0cy52YWx1ZSA/IGFyZ3NbM10gOiBhcmdzWzJdKVxuICAgICAgXTtcbiAgICB9LFxuICAgIChbcmF3X3RhcmdldHMsIHJhd19ldmVudHMsIHJhd19saXN0ZW5lcnMsIHJhd19vcHRpb25zXSkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgaWYgKCEocmF3X3RhcmdldHMgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd190YXJnZXRzLmxlbmd0aCkgfHwgIShyYXdfZXZlbnRzID09IG51bGwgPyB2b2lkIDAgOiByYXdfZXZlbnRzLmxlbmd0aCkgfHwgIShyYXdfbGlzdGVuZXJzID09IG51bGwgPyB2b2lkIDAgOiByYXdfbGlzdGVuZXJzLmxlbmd0aCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG9wdGlvbnNDbG9uZSA9IGlzT2JqZWN0KHJhd19vcHRpb25zKSA/IHsgLi4ucmF3X29wdGlvbnMgfSA6IHJhd19vcHRpb25zO1xuICAgICAgY2xlYW51cHMucHVzaChcbiAgICAgICAgLi4ucmF3X3RhcmdldHMuZmxhdE1hcChcbiAgICAgICAgICAoZWwpID0+IHJhd19ldmVudHMuZmxhdE1hcChcbiAgICAgICAgICAgIChldmVudCkgPT4gcmF3X2xpc3RlbmVycy5tYXAoKGxpc3RlbmVyKSA9PiByZWdpc3RlcihlbCwgZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zQ2xvbmUpKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHsgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBzdG9wV2F0Y2goKTtcbiAgICBjbGVhbnVwKCk7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKGNsZWFudXApO1xuICByZXR1cm4gc3RvcDtcbn1cblxubGV0IF9pT1NXb3JrYXJvdW5kID0gZmFsc2U7XG5mdW5jdGlvbiBvbkNsaWNrT3V0c2lkZSh0YXJnZXQsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIGlnbm9yZSA9IFtdLCBjYXB0dXJlID0gdHJ1ZSwgZGV0ZWN0SWZyYW1lID0gZmFsc2UsIGNvbnRyb2xzID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuIGNvbnRyb2xzID8geyBzdG9wOiBub29wLCBjYW5jZWw6IG5vb3AsIHRyaWdnZXI6IG5vb3AgfSA6IG5vb3A7XG4gIH1cbiAgaWYgKGlzSU9TICYmICFfaU9TV29ya2Fyb3VuZCkge1xuICAgIF9pT1NXb3JrYXJvdW5kID0gdHJ1ZTtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICBBcnJheS5mcm9tKHdpbmRvdy5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChlbCkgPT4gdXNlRXZlbnRMaXN0ZW5lcihlbCwgXCJjbGlja1wiLCBub29wLCBsaXN0ZW5lck9wdGlvbnMpKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIFwiY2xpY2tcIiwgbm9vcCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICBsZXQgc2hvdWxkTGlzdGVuID0gdHJ1ZTtcbiAgY29uc3Qgc2hvdWxkSWdub3JlID0gKGV2ZW50KSA9PiB7XG4gICAgcmV0dXJuIHRvVmFsdWUoaWdub3JlKS5zb21lKCh0YXJnZXQyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldDIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0MikpLnNvbWUoKGVsKSA9PiBlbCA9PT0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGVsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQyKTtcbiAgICAgICAgcmV0dXJuIGVsICYmIChldmVudC50YXJnZXQgPT09IGVsIHx8IGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGVsKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGhhc011bHRpcGxlUm9vdHModGFyZ2V0Mikge1xuICAgIGNvbnN0IHZtID0gdG9WYWx1ZSh0YXJnZXQyKTtcbiAgICByZXR1cm4gdm0gJiYgdm0uJC5zdWJUcmVlLnNoYXBlRmxhZyA9PT0gMTY7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tNdWx0aXBsZVJvb3RzKHRhcmdldDIsIGV2ZW50KSB7XG4gICAgY29uc3Qgdm0gPSB0b1ZhbHVlKHRhcmdldDIpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdm0uJC5zdWJUcmVlICYmIHZtLiQuc3ViVHJlZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNoaWxkcmVuLnNvbWUoKGNoaWxkKSA9PiBjaGlsZC5lbCA9PT0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGNoaWxkLmVsKSk7XG4gIH1cbiAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgIGlmIChldmVudC50YXJnZXQgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIShlbCBpbnN0YW5jZW9mIEVsZW1lbnQpICYmIGhhc011bHRpcGxlUm9vdHModGFyZ2V0KSAmJiBjaGVja011bHRpcGxlUm9vdHModGFyZ2V0LCBldmVudCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFlbCB8fCBlbCA9PT0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGVsKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoXCJkZXRhaWxcIiBpbiBldmVudCAmJiBldmVudC5kZXRhaWwgPT09IDApXG4gICAgICBzaG91bGRMaXN0ZW4gPSAhc2hvdWxkSWdub3JlKGV2ZW50KTtcbiAgICBpZiAoIXNob3VsZExpc3Rlbikge1xuICAgICAgc2hvdWxkTGlzdGVuID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlcihldmVudCk7XG4gIH07XG4gIGxldCBpc1Byb2Nlc3NpbmdDbGljayA9IGZhbHNlO1xuICBjb25zdCBjbGVhbnVwID0gW1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImNsaWNrXCIsIChldmVudCkgPT4ge1xuICAgICAgaWYgKCFpc1Byb2Nlc3NpbmdDbGljaykge1xuICAgICAgICBpc1Byb2Nlc3NpbmdDbGljayA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlzUHJvY2Vzc2luZ0NsaWNrID0gZmFsc2U7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9XG4gICAgfSwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJkb3duXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgICAgc2hvdWxkTGlzdGVuID0gIXNob3VsZElnbm9yZShlKSAmJiAhIShlbCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlbCkpO1xuICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KSxcbiAgICBkZXRlY3RJZnJhbWUgJiYgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiYmx1clwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgICAgIGlmICgoKF9hID0gd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS50YWdOYW1lKSA9PT0gXCJJRlJBTUVcIiAmJiAhKGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5jb250YWlucyh3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpKSB7XG4gICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KVxuICBdLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IGNsZWFudXAuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICBpZiAoY29udHJvbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcCxcbiAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICBzaG91bGRMaXN0ZW4gPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyOiAoZXZlbnQpID0+IHtcbiAgICAgICAgc2hvdWxkTGlzdGVuID0gdHJ1ZTtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICBzaG91bGRMaXN0ZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBzdG9wO1xufVxuXG5mdW5jdGlvbiB1c2VNb3VudGVkKCkge1xuICBjb25zdCBpc01vdW50ZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgb25Nb3VudGVkKCgpID0+IHtcbiAgICAgIGlzTW91bnRlZC52YWx1ZSA9IHRydWU7XG4gICAgfSwgaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpc01vdW50ZWQ7XG59XG5cbmZ1bmN0aW9uIHVzZVN1cHBvcnRlZChjYWxsYmFjaykge1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VNb3VudGVkKCk7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgaXNNb3VudGVkLnZhbHVlO1xuICAgIHJldHVybiBCb29sZWFuKGNhbGxiYWNrKCkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcih0YXJnZXQsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCAuLi5tdXRhdGlvbk9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gIGxldCBvYnNlcnZlcjtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwiTXV0YXRpb25PYnNlcnZlclwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBvYnNlcnZlciA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRhcmdldHMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgY29uc3QgaXRlbXMgPSB0b0FycmF5KHZhbHVlKS5tYXAodW5yZWZFbGVtZW50KS5maWx0ZXIobm90TnVsbGlzaCk7XG4gICAgcmV0dXJuIG5ldyBTZXQoaXRlbXMpO1xuICB9KTtcbiAgY29uc3Qgc3RvcFdhdGNoID0gd2F0Y2goXG4gICAgKCkgPT4gdGFyZ2V0cy52YWx1ZSxcbiAgICAodGFyZ2V0czIpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB0YXJnZXRzMi5zaXplKSB7XG4gICAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgICAgICB0YXJnZXRzMi5mb3JFYWNoKChlbCkgPT4gb2JzZXJ2ZXIub2JzZXJ2ZShlbCwgbXV0YXRpb25PcHRpb25zKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSwgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbiAgY29uc3QgdGFrZVJlY29yZHMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIHN0b3BXYXRjaCgpO1xuICAgIGNsZWFudXAoKTtcbiAgfTtcbiAgdHJ5T25TY29wZURpc3Bvc2Uoc3RvcCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RvcCxcbiAgICB0YWtlUmVjb3Jkc1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkVsZW1lbnRSZW1vdmFsKHRhcmdldCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBkb2N1bWVudCA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50LFxuICAgIGZsdXNoID0gXCJzeW5jXCJcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93IHx8ICFkb2N1bWVudClcbiAgICByZXR1cm4gbm9vcDtcbiAgbGV0IHN0b3BGbjtcbiAgY29uc3QgY2xlYW51cEFuZFVwZGF0ZSA9IChmbikgPT4ge1xuICAgIHN0b3BGbiA9PSBudWxsID8gdm9pZCAwIDogc3RvcEZuKCk7XG4gICAgc3RvcEZuID0gZm47XG4gIH07XG4gIGNvbnN0IHN0b3BXYXRjaCA9IHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgIGlmIChlbCkge1xuICAgICAgY29uc3QgeyBzdG9wIH0gPSB1c2VNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgKG11dGF0aW9uc0xpc3QpID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRSZW1vdmVkID0gbXV0YXRpb25zTGlzdC5tYXAoKG11dGF0aW9uKSA9PiBbLi4ubXV0YXRpb24ucmVtb3ZlZE5vZGVzXSkuZmxhdCgpLnNvbWUoKG5vZGUpID0+IG5vZGUgPT09IGVsIHx8IG5vZGUuY29udGFpbnMoZWwpKTtcbiAgICAgICAgICBpZiAodGFyZ2V0UmVtb3ZlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobXV0YXRpb25zTGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgd2luZG93LFxuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjbGVhbnVwQW5kVXBkYXRlKHN0b3ApO1xuICAgIH1cbiAgfSwgeyBmbHVzaCB9KTtcbiAgY29uc3Qgc3RvcEhhbmRsZSA9ICgpID0+IHtcbiAgICBzdG9wV2F0Y2goKTtcbiAgICBjbGVhbnVwQW5kVXBkYXRlKCk7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHN0b3BIYW5kbGUpO1xuICByZXR1cm4gc3RvcEhhbmRsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5UHJlZGljYXRlKGtleUZpbHRlcikge1xuICBpZiAodHlwZW9mIGtleUZpbHRlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBrZXlGaWx0ZXI7XG4gIGVsc2UgaWYgKHR5cGVvZiBrZXlGaWx0ZXIgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIChldmVudCkgPT4gZXZlbnQua2V5ID09PSBrZXlGaWx0ZXI7XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoa2V5RmlsdGVyKSlcbiAgICByZXR1cm4gKGV2ZW50KSA9PiBrZXlGaWx0ZXIuaW5jbHVkZXMoZXZlbnQua2V5KTtcbiAgcmV0dXJuICgpID0+IHRydWU7XG59XG5mdW5jdGlvbiBvbktleVN0cm9rZSguLi5hcmdzKSB7XG4gIGxldCBrZXk7XG4gIGxldCBoYW5kbGVyO1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICBrZXkgPSBhcmdzWzBdO1xuICAgIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgIG9wdGlvbnMgPSBhcmdzWzJdO1xuICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBrZXkgPSB0cnVlO1xuICAgICAgaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICBvcHRpb25zID0gYXJnc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gYXJnc1swXTtcbiAgICAgIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBrZXkgPSB0cnVlO1xuICAgIGhhbmRsZXIgPSBhcmdzWzBdO1xuICB9XG4gIGNvbnN0IHtcbiAgICB0YXJnZXQgPSBkZWZhdWx0V2luZG93LFxuICAgIGV2ZW50TmFtZSA9IFwia2V5ZG93blwiLFxuICAgIHBhc3NpdmUgPSBmYWxzZSxcbiAgICBkZWR1cGUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJlZGljYXRlID0gY3JlYXRlS2V5UHJlZGljYXRlKGtleSk7XG4gIGNvbnN0IGxpc3RlbmVyID0gKGUpID0+IHtcbiAgICBpZiAoZS5yZXBlYXQgJiYgdG9WYWx1ZShkZWR1cGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChwcmVkaWNhdGUoZSkpXG4gICAgICBoYW5kbGVyKGUpO1xuICB9O1xuICByZXR1cm4gdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHBhc3NpdmUpO1xufVxuZnVuY3Rpb24gb25LZXlEb3duKGtleSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBvbktleVN0cm9rZShrZXksIGhhbmRsZXIsIHsgLi4ub3B0aW9ucywgZXZlbnROYW1lOiBcImtleWRvd25cIiB9KTtcbn1cbmZ1bmN0aW9uIG9uS2V5UHJlc3NlZChrZXksIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gb25LZXlTdHJva2Uoa2V5LCBoYW5kbGVyLCB7IC4uLm9wdGlvbnMsIGV2ZW50TmFtZTogXCJrZXlwcmVzc1wiIH0pO1xufVxuZnVuY3Rpb24gb25LZXlVcChrZXksIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gb25LZXlTdHJva2Uoa2V5LCBoYW5kbGVyLCB7IC4uLm9wdGlvbnMsIGV2ZW50TmFtZTogXCJrZXl1cFwiIH0pO1xufVxuXG5jb25zdCBERUZBVUxUX0RFTEFZID0gNTAwO1xuY29uc3QgREVGQVVMVF9USFJFU0hPTEQgPSAxMDtcbmZ1bmN0aW9uIG9uTG9uZ1ByZXNzKHRhcmdldCwgaGFuZGxlciwgb3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBlbGVtZW50UmVmID0gY29tcHV0ZWQoKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCkpO1xuICBsZXQgdGltZW91dDtcbiAgbGV0IHBvc1N0YXJ0O1xuICBsZXQgc3RhcnRUaW1lc3RhbXA7XG4gIGxldCBoYXNMb25nUHJlc3NlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcG9zU3RhcnQgPSB2b2lkIDA7XG4gICAgc3RhcnRUaW1lc3RhbXAgPSB2b2lkIDA7XG4gICAgaGFzTG9uZ1ByZXNzZWQgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBvblJlbGVhc2UoZXYpIHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jO1xuICAgIGNvbnN0IFtfc3RhcnRUaW1lc3RhbXAsIF9wb3NTdGFydCwgX2hhc0xvbmdQcmVzc2VkXSA9IFtzdGFydFRpbWVzdGFtcCwgcG9zU3RhcnQsIGhhc0xvbmdQcmVzc2VkXTtcbiAgICBjbGVhcigpO1xuICAgIGlmICghKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25Nb3VzZVVwKSB8fCAhX3Bvc1N0YXJ0IHx8ICFfc3RhcnRUaW1lc3RhbXApXG4gICAgICByZXR1cm47XG4gICAgaWYgKCgoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2VsZikgJiYgZXYudGFyZ2V0ICE9PSBlbGVtZW50UmVmLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICgoX2IyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYjIucHJldmVudClcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKChfYyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RvcClcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IGR4ID0gZXYueCAtIF9wb3NTdGFydC54O1xuICAgIGNvbnN0IGR5ID0gZXYueSAtIF9wb3NTdGFydC55O1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBvcHRpb25zLm9uTW91c2VVcChldi50aW1lU3RhbXAgLSBfc3RhcnRUaW1lc3RhbXAsIGRpc3RhbmNlLCBfaGFzTG9uZ1ByZXNzZWQpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRG93bihldikge1xuICAgIHZhciBfYTIsIF9iMiwgX2MsIF9kO1xuICAgIGlmICgoKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNlbGYpICYmIGV2LnRhcmdldCAhPT0gZWxlbWVudFJlZi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBjbGVhcigpO1xuICAgIGlmICgoX2IyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYjIucHJldmVudClcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKChfYyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RvcClcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHBvc1N0YXJ0ID0ge1xuICAgICAgeDogZXYueCxcbiAgICAgIHk6IGV2LnlcbiAgICB9O1xuICAgIHN0YXJ0VGltZXN0YW1wID0gZXYudGltZVN0YW1wO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4ge1xuICAgICAgICBoYXNMb25nUHJlc3NlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgfSxcbiAgICAgIChfZCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVsYXkpICE9IG51bGwgPyBfZCA6IERFRkFVTFRfREVMQVlcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIG9uTW92ZShldikge1xuICAgIHZhciBfYTIsIF9iMiwgX2MsIF9kO1xuICAgIGlmICgoKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNlbGYpICYmIGV2LnRhcmdldCAhPT0gZWxlbWVudFJlZi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXBvc1N0YXJ0IHx8IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc3RhbmNlVGhyZXNob2xkKSA9PT0gZmFsc2UpXG4gICAgICByZXR1cm47XG4gICAgaWYgKChfYjIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5wcmV2ZW50KVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdG9wKVxuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3QgZHggPSBldi54IC0gcG9zU3RhcnQueDtcbiAgICBjb25zdCBkeSA9IGV2LnkgLSBwb3NTdGFydC55O1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBpZiAoZGlzdGFuY2UgPj0gKChfZCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzdGFuY2VUaHJlc2hvbGQpICE9IG51bGwgPyBfZCA6IERFRkFVTFRfVEhSRVNIT0xEKSlcbiAgICAgIGNsZWFyKCk7XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0ge1xuICAgIGNhcHR1cmU6IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FwdHVyZSxcbiAgICBvbmNlOiAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9uY2VcbiAgfTtcbiAgY29uc3QgY2xlYW51cCA9IFtcbiAgICB1c2VFdmVudExpc3RlbmVyKGVsZW1lbnRSZWYsIFwicG9pbnRlcmRvd25cIiwgb25Eb3duLCBsaXN0ZW5lck9wdGlvbnMpLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIoZWxlbWVudFJlZiwgXCJwb2ludGVybW92ZVwiLCBvbk1vdmUsIGxpc3RlbmVyT3B0aW9ucyksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihlbGVtZW50UmVmLCBbXCJwb2ludGVydXBcIiwgXCJwb2ludGVybGVhdmVcIl0sIG9uUmVsZWFzZSwgbGlzdGVuZXJPcHRpb25zKVxuICBdO1xuICBjb25zdCBzdG9wID0gKCkgPT4gY2xlYW51cC5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIHJldHVybiBzdG9wO1xufVxuXG5mdW5jdGlvbiBpc0ZvY3VzZWRFbGVtZW50RWRpdGFibGUoKSB7XG4gIGNvbnN0IHsgYWN0aXZlRWxlbWVudCwgYm9keSB9ID0gZG9jdW1lbnQ7XG4gIGlmICghYWN0aXZlRWxlbWVudClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhY3RpdmVFbGVtZW50ID09PSBib2R5KVxuICAgIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChhY3RpdmVFbGVtZW50LnRhZ05hbWUpIHtcbiAgICBjYXNlIFwiSU5QVVRcIjpcbiAgICBjYXNlIFwiVEVYVEFSRUFcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50Lmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZWRDaGFyVmFsaWQoe1xuICBrZXlDb2RlLFxuICBtZXRhS2V5LFxuICBjdHJsS2V5LFxuICBhbHRLZXlcbn0pIHtcbiAgaWYgKG1ldGFLZXkgfHwgY3RybEtleSB8fCBhbHRLZXkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoa2V5Q29kZSA+PSA0OCAmJiBrZXlDb2RlIDw9IDU3IHx8IGtleUNvZGUgPj0gOTYgJiYga2V5Q29kZSA8PSAxMDUpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChrZXlDb2RlID49IDY1ICYmIGtleUNvZGUgPD0gOTApXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uU3RhcnRUeXBpbmcoY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGRvY3VtZW50OiBkb2N1bWVudDIgPSBkZWZhdWx0RG9jdW1lbnQgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGtleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIWlzRm9jdXNlZEVsZW1lbnRFZGl0YWJsZSgpICYmIGlzVHlwZWRDaGFyVmFsaWQoZXZlbnQpKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9O1xuICBpZiAoZG9jdW1lbnQyKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQyLCBcImtleWRvd25cIiwga2V5ZG93biwgeyBwYXNzaXZlOiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZVJlZihrZXksIGluaXRpYWxWYWx1ZSA9IG51bGwpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgbGV0IF90cmlnZ2VyID0gKCkgPT4ge1xuICB9O1xuICBjb25zdCBlbGVtZW50ID0gY3VzdG9tUmVmKCh0cmFjaywgdHJpZ2dlcikgPT4ge1xuICAgIF90cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cmFjaygpO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnByb3h5KSA9PSBudWxsID8gdm9pZCAwIDogX2EuJHJlZnNba2V5XSkgIT0gbnVsbCA/IF9iIDogaW5pdGlhbFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgdHJ5T25Nb3VudGVkKF90cmlnZ2VyKTtcbiAgb25VcGRhdGVkKF90cmlnZ2VyKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZUFjdGl2ZUVsZW1lbnQob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgZGVlcCA9IHRydWUsXG4gICAgdHJpZ2dlck9uUmVtb3ZhbCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBkb2N1bWVudCA9IChfYSA9IG9wdGlvbnMuZG9jdW1lbnQpICE9IG51bGwgPyBfYSA6IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50O1xuICBjb25zdCBnZXREZWVwQWN0aXZlRWxlbWVudCA9ICgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIHdoaWxlIChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsZW1lbnQgPSAoX2EyID0gZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5zaGFkb3dSb290KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9O1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gc2hhbGxvd1JlZigpO1xuICBjb25zdCB0cmlnZ2VyID0gKCkgPT4ge1xuICAgIGFjdGl2ZUVsZW1lbnQudmFsdWUgPSBnZXREZWVwQWN0aXZlRWxlbWVudCgpO1xuICB9O1xuICBpZiAod2luZG93KSB7XG4gICAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICB3aW5kb3csXG4gICAgICBcImJsdXJcIixcbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCAhPT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH0sXG4gICAgICBsaXN0ZW5lck9wdGlvbnNcbiAgICApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICB3aW5kb3csXG4gICAgICBcImZvY3VzXCIsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgfVxuICBpZiAodHJpZ2dlck9uUmVtb3ZhbCkge1xuICAgIG9uRWxlbWVudFJlbW92YWwoYWN0aXZlRWxlbWVudCwgdHJpZ2dlciwgeyBkb2N1bWVudCB9KTtcbiAgfVxuICB0cmlnZ2VyKCk7XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1c2VSYWZGbihmbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGZwc0xpbWl0ID0gdm9pZCAwLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgb25jZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc0FjdGl2ZSA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBpbnRlcnZhbExpbWl0ID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiBmcHNMaW1pdCA/IDFlMyAvIHRvVmFsdWUoZnBzTGltaXQpIDogbnVsbDtcbiAgfSk7XG4gIGxldCBwcmV2aW91c0ZyYW1lVGltZXN0YW1wID0gMDtcbiAgbGV0IHJhZklkID0gbnVsbDtcbiAgZnVuY3Rpb24gbG9vcCh0aW1lc3RhbXApIHtcbiAgICBpZiAoIWlzQWN0aXZlLnZhbHVlIHx8ICF3aW5kb3cpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwcmV2aW91c0ZyYW1lVGltZXN0YW1wKVxuICAgICAgcHJldmlvdXNGcmFtZVRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICBjb25zdCBkZWx0YSA9IHRpbWVzdGFtcCAtIHByZXZpb3VzRnJhbWVUaW1lc3RhbXA7XG4gICAgaWYgKGludGVydmFsTGltaXQudmFsdWUgJiYgZGVsdGEgPCBpbnRlcnZhbExpbWl0LnZhbHVlKSB7XG4gICAgICByYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZXZpb3VzRnJhbWVUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgZm4oeyBkZWx0YSwgdGltZXN0YW1wIH0pO1xuICAgIGlmIChvbmNlKSB7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgcmFmSWQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIGlmICghaXNBY3RpdmUudmFsdWUgJiYgd2luZG93KSB7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IHRydWU7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZXN0YW1wID0gMDtcbiAgICAgIHJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgICBpZiAocmFmSWQgIT0gbnVsbCAmJiB3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICByYWZJZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgcmVzdW1lKCk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHBhdXNlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZTogcmVhZG9ubHkoaXNBY3RpdmUpLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VBbmltYXRlKHRhcmdldCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gIGxldCBjb25maWc7XG4gIGxldCBhbmltYXRlT3B0aW9ucztcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgY29uZmlnID0gb3B0aW9ucztcbiAgICBhbmltYXRlT3B0aW9ucyA9IG9iamVjdE9taXQob3B0aW9ucywgW1wid2luZG93XCIsIFwiaW1tZWRpYXRlXCIsIFwiY29tbWl0U3R5bGVzXCIsIFwicGVyc2lzdFwiLCBcIm9uUmVhZHlcIiwgXCJvbkVycm9yXCJdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG4gICAgYW5pbWF0ZU9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgY29tbWl0U3R5bGVzLFxuICAgIHBlcnNpc3QsXG4gICAgcGxheWJhY2tSYXRlOiBfcGxheWJhY2tSYXRlID0gMSxcbiAgICBvblJlYWR5LFxuICAgIG9uRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBIVE1MRWxlbWVudCAmJiBcImFuaW1hdGVcIiBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuICBjb25zdCBhbmltYXRlID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCBzdG9yZSA9IHNoYWxsb3dSZWFjdGl2ZSh7XG4gICAgc3RhcnRUaW1lOiBudWxsLFxuICAgIGN1cnJlbnRUaW1lOiBudWxsLFxuICAgIHRpbWVsaW5lOiBudWxsLFxuICAgIHBsYXliYWNrUmF0ZTogX3BsYXliYWNrUmF0ZSxcbiAgICBwZW5kaW5nOiBmYWxzZSxcbiAgICBwbGF5U3RhdGU6IGltbWVkaWF0ZSA/IFwiaWRsZVwiIDogXCJwYXVzZWRcIixcbiAgICByZXBsYWNlU3RhdGU6IFwiYWN0aXZlXCJcbiAgfSk7XG4gIGNvbnN0IHBlbmRpbmcgPSBjb21wdXRlZCgoKSA9PiBzdG9yZS5wZW5kaW5nKTtcbiAgY29uc3QgcGxheVN0YXRlID0gY29tcHV0ZWQoKCkgPT4gc3RvcmUucGxheVN0YXRlKTtcbiAgY29uc3QgcmVwbGFjZVN0YXRlID0gY29tcHV0ZWQoKCkgPT4gc3RvcmUucmVwbGFjZVN0YXRlKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzdG9yZS5zdGFydFRpbWU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHN0b3JlLnN0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgaWYgKGFuaW1hdGUudmFsdWUpXG4gICAgICAgIGFuaW1hdGUudmFsdWUuc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRUaW1lO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBzdG9yZS5jdXJyZW50VGltZSA9IHZhbHVlO1xuICAgICAgaWYgKGFuaW1hdGUudmFsdWUpIHtcbiAgICAgICAgYW5pbWF0ZS52YWx1ZS5jdXJyZW50VGltZSA9IHZhbHVlO1xuICAgICAgICBzeW5jUmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3QgdGltZWxpbmUgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHN0b3JlLnRpbWVsaW5lO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBzdG9yZS50aW1lbGluZSA9IHZhbHVlO1xuICAgICAgaWYgKGFuaW1hdGUudmFsdWUpXG4gICAgICAgIGFuaW1hdGUudmFsdWUudGltZWxpbmUgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBwbGF5YmFja1JhdGUgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHN0b3JlLnBsYXliYWNrUmF0ZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc3RvcmUucGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgICBpZiAoYW5pbWF0ZS52YWx1ZSlcbiAgICAgICAgYW5pbWF0ZS52YWx1ZS5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBwbGF5ID0gKCkgPT4ge1xuICAgIGlmIChhbmltYXRlLnZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhbmltYXRlLnZhbHVlLnBsYXkoKTtcbiAgICAgICAgc3luY1Jlc3VtZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzeW5jUGF1c2UoKTtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXVzZSA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgIChfYSA9IGFuaW1hdGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wYXVzZSgpO1xuICAgICAgc3luY1BhdXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJldmVyc2UgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghYW5pbWF0ZS52YWx1ZSlcbiAgICAgIHVwZGF0ZSgpO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmV2ZXJzZSgpO1xuICAgICAgc3luY1Jlc3VtZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN5bmNQYXVzZSgpO1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGZpbmlzaCA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgIChfYSA9IGFuaW1hdGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5pc2goKTtcbiAgICAgIHN5bmNQYXVzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FuY2VsKCk7XG4gICAgICBzeW5jUGF1c2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfTtcbiAgd2F0Y2goKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCksIChlbCkgPT4ge1xuICAgIGlmIChlbCkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1hdGUudmFsdWUgPSB2b2lkIDA7XG4gICAgfVxuICB9KTtcbiAgd2F0Y2goKCkgPT4ga2V5ZnJhbWVzLCAodmFsdWUpID0+IHtcbiAgICBpZiAoYW5pbWF0ZS52YWx1ZSkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgICBjb25zdCB0YXJnZXRFbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgICAgaWYgKHRhcmdldEVsKSB7XG4gICAgICAgIGFuaW1hdGUudmFsdWUuZWZmZWN0ID0gbmV3IEtleWZyYW1lRWZmZWN0KFxuICAgICAgICAgIHRhcmdldEVsLFxuICAgICAgICAgIHRvVmFsdWUodmFsdWUpLFxuICAgICAgICAgIGFuaW1hdGVPcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7IGRlZXA6IHRydWUgfSk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB1cGRhdGUodHJ1ZSksIGZhbHNlKTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoY2FuY2VsKTtcbiAgZnVuY3Rpb24gdXBkYXRlKGluaXQpIHtcbiAgICBjb25zdCBlbCA9IHVucmVmRWxlbWVudCh0YXJnZXQpO1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghYW5pbWF0ZS52YWx1ZSlcbiAgICAgIGFuaW1hdGUudmFsdWUgPSBlbC5hbmltYXRlKHRvVmFsdWUoa2V5ZnJhbWVzKSwgYW5pbWF0ZU9wdGlvbnMpO1xuICAgIGlmIChwZXJzaXN0KVxuICAgICAgYW5pbWF0ZS52YWx1ZS5wZXJzaXN0KCk7XG4gICAgaWYgKF9wbGF5YmFja1JhdGUgIT09IDEpXG4gICAgICBhbmltYXRlLnZhbHVlLnBsYXliYWNrUmF0ZSA9IF9wbGF5YmFja1JhdGU7XG4gICAgaWYgKGluaXQgJiYgIWltbWVkaWF0ZSlcbiAgICAgIGFuaW1hdGUudmFsdWUucGF1c2UoKTtcbiAgICBlbHNlXG4gICAgICBzeW5jUmVzdW1lKCk7XG4gICAgb25SZWFkeSA9PSBudWxsID8gdm9pZCAwIDogb25SZWFkeShhbmltYXRlLnZhbHVlKTtcbiAgfVxuICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihhbmltYXRlLCBbXCJjYW5jZWxcIiwgXCJmaW5pc2hcIiwgXCJyZW1vdmVcIl0sIHN5bmNQYXVzZSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihhbmltYXRlLCBcImZpbmlzaFwiLCAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChjb21taXRTdHlsZXMpXG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29tbWl0U3R5bGVzKCk7XG4gIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gIGNvbnN0IHsgcmVzdW1lOiByZXN1bWVSZWYsIHBhdXNlOiBwYXVzZVJlZiB9ID0gdXNlUmFmRm4oKCkgPT4ge1xuICAgIGlmICghYW5pbWF0ZS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBzdG9yZS5wZW5kaW5nID0gYW5pbWF0ZS52YWx1ZS5wZW5kaW5nO1xuICAgIHN0b3JlLnBsYXlTdGF0ZSA9IGFuaW1hdGUudmFsdWUucGxheVN0YXRlO1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSA9IGFuaW1hdGUudmFsdWUucmVwbGFjZVN0YXRlO1xuICAgIHN0b3JlLnN0YXJ0VGltZSA9IGFuaW1hdGUudmFsdWUuc3RhcnRUaW1lO1xuICAgIHN0b3JlLmN1cnJlbnRUaW1lID0gYW5pbWF0ZS52YWx1ZS5jdXJyZW50VGltZTtcbiAgICBzdG9yZS50aW1lbGluZSA9IGFuaW1hdGUudmFsdWUudGltZWxpbmU7XG4gICAgc3RvcmUucGxheWJhY2tSYXRlID0gYW5pbWF0ZS52YWx1ZS5wbGF5YmFja1JhdGU7XG4gIH0sIHsgaW1tZWRpYXRlOiBmYWxzZSB9KTtcbiAgZnVuY3Rpb24gc3luY1Jlc3VtZSgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXN1bWVSZWYoKTtcbiAgfVxuICBmdW5jdGlvbiBzeW5jUGF1c2UoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHdpbmRvdylcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGF1c2VSZWYpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgYW5pbWF0ZSxcbiAgICAvLyBhY3Rpb25zXG4gICAgcGxheSxcbiAgICBwYXVzZSxcbiAgICByZXZlcnNlLFxuICAgIGZpbmlzaCxcbiAgICBjYW5jZWwsXG4gICAgLy8gc3RhdGVcbiAgICBwZW5kaW5nLFxuICAgIHBsYXlTdGF0ZSxcbiAgICByZXBsYWNlU3RhdGUsXG4gICAgc3RhcnRUaW1lLFxuICAgIGN1cnJlbnRUaW1lLFxuICAgIHRpbWVsaW5lLFxuICAgIHBsYXliYWNrUmF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VBc3luY1F1ZXVlKHRhc2tzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcnJ1cHQgPSB0cnVlLFxuICAgIG9uRXJyb3IgPSBub29wLFxuICAgIG9uRmluaXNoZWQgPSBub29wLFxuICAgIHNpZ25hbFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcHJvbWlzZVN0YXRlID0ge1xuICAgIGFib3J0ZWQ6IFwiYWJvcnRlZFwiLFxuICAgIGZ1bGZpbGxlZDogXCJmdWxmaWxsZWRcIixcbiAgICBwZW5kaW5nOiBcInBlbmRpbmdcIixcbiAgICByZWplY3RlZDogXCJyZWplY3RlZFwiXG4gIH07XG4gIGNvbnN0IGluaXRpYWxSZXN1bHQgPSBBcnJheS5mcm9tKEFycmF5LmZyb20oeyBsZW5ndGg6IHRhc2tzLmxlbmd0aCB9KSwgKCkgPT4gKHsgc3RhdGU6IHByb21pc2VTdGF0ZS5wZW5kaW5nLCBkYXRhOiBudWxsIH0pKTtcbiAgY29uc3QgcmVzdWx0ID0gcmVhY3RpdmUoaW5pdGlhbFJlc3VsdCk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gc2hhbGxvd1JlZigtMSk7XG4gIGlmICghdGFza3MgfHwgdGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgb25GaW5pc2hlZCgpO1xuICAgIHJldHVybiB7XG4gICAgICBhY3RpdmVJbmRleCxcbiAgICAgIHJlc3VsdFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUmVzdWx0KHN0YXRlLCByZXMpIHtcbiAgICBhY3RpdmVJbmRleC52YWx1ZSsrO1xuICAgIHJlc3VsdFthY3RpdmVJbmRleC52YWx1ZV0uZGF0YSA9IHJlcztcbiAgICByZXN1bHRbYWN0aXZlSW5kZXgudmFsdWVdLnN0YXRlID0gc3RhdGU7XG4gIH1cbiAgdGFza3MucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XG4gICAgcmV0dXJuIHByZXYudGhlbigocHJldlJlcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdXBkYXRlUmVzdWx0KHByb21pc2VTdGF0ZS5hYm9ydGVkLCBuZXcgRXJyb3IoXCJhYm9ydGVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCgoX2EgPSByZXN1bHRbYWN0aXZlSW5kZXgudmFsdWVdKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RhdGUpID09PSBwcm9taXNlU3RhdGUucmVqZWN0ZWQgJiYgaW50ZXJydXB0KSB7XG4gICAgICAgIG9uRmluaXNoZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZG9uZSA9IGN1cnIocHJldlJlcykudGhlbigoY3VycmVudFJlcykgPT4ge1xuICAgICAgICB1cGRhdGVSZXN1bHQocHJvbWlzZVN0YXRlLmZ1bGZpbGxlZCwgY3VycmVudFJlcyk7XG4gICAgICAgIGlmIChhY3RpdmVJbmRleC52YWx1ZSA9PT0gdGFza3MubGVuZ3RoIC0gMSlcbiAgICAgICAgICBvbkZpbmlzaGVkKCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmVzO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXNpZ25hbClcbiAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtkb25lLCB3aGVuQWJvcnRlZChzaWduYWwpXSk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIGlmIChzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHVwZGF0ZVJlc3VsdChwcm9taXNlU3RhdGUuYWJvcnRlZCwgZSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdXBkYXRlUmVzdWx0KHByb21pc2VTdGF0ZS5yZWplY3RlZCwgZSk7XG4gICAgICBvbkVycm9yKCk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICByZXR1cm4ge1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIHJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gd2hlbkFib3J0ZWQoc2lnbmFsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJhYm9ydGVkXCIpO1xuICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgZWxzZVxuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiByZWplY3QoZXJyb3IpLCB7IG9uY2U6IHRydWUgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VBc3luY1N0YXRlKHByb21pc2UsIGluaXRpYWxTdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBkZWxheSA9IDAsXG4gICAgb25FcnJvciA9IG5vb3AsXG4gICAgb25TdWNjZXNzID0gbm9vcCxcbiAgICByZXNldE9uRXhlY3V0ZSA9IHRydWUsXG4gICAgc2hhbGxvdyA9IHRydWUsXG4gICAgdGhyb3dFcnJvclxuICB9ID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICBjb25zdCBzdGF0ZSA9IHNoYWxsb3cgPyBzaGFsbG93UmVmKGluaXRpYWxTdGF0ZSkgOiByZWYoaW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgaXNSZWFkeSA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBpc0xvYWRpbmcgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKHZvaWQgMCk7XG4gIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGUoZGVsYXkyID0gMCwgLi4uYXJncykge1xuICAgIGlmIChyZXNldE9uRXhlY3V0ZSlcbiAgICAgIHN0YXRlLnZhbHVlID0gaW5pdGlhbFN0YXRlO1xuICAgIGVycm9yLnZhbHVlID0gdm9pZCAwO1xuICAgIGlzUmVhZHkudmFsdWUgPSBmYWxzZTtcbiAgICBpc0xvYWRpbmcudmFsdWUgPSB0cnVlO1xuICAgIGlmIChkZWxheTIgPiAwKVxuICAgICAgYXdhaXQgcHJvbWlzZVRpbWVvdXQoZGVsYXkyKTtcbiAgICBjb25zdCBfcHJvbWlzZSA9IHR5cGVvZiBwcm9taXNlID09PSBcImZ1bmN0aW9uXCIgPyBwcm9taXNlKC4uLmFyZ3MpIDogcHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9wcm9taXNlO1xuICAgICAgc3RhdGUudmFsdWUgPSBkYXRhO1xuICAgICAgaXNSZWFkeS52YWx1ZSA9IHRydWU7XG4gICAgICBvblN1Y2Nlc3MoZGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IudmFsdWUgPSBlO1xuICAgICAgb25FcnJvcihlKTtcbiAgICAgIGlmICh0aHJvd0Vycm9yKVxuICAgICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0xvYWRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnZhbHVlO1xuICB9XG4gIGlmIChpbW1lZGlhdGUpIHtcbiAgICBleGVjdXRlKGRlbGF5KTtcbiAgfVxuICBjb25zdCBzaGVsbCA9IHtcbiAgICBzdGF0ZSxcbiAgICBpc1JlYWR5LFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBleGVjdXRlXG4gIH07XG4gIGZ1bmN0aW9uIHdhaXRVbnRpbElzTG9hZGVkKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1bnRpbChpc0xvYWRpbmcpLnRvQmUoZmFsc2UpLnRoZW4oKCkgPT4gcmVzb2x2ZShzaGVsbCkpLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zaGVsbCxcbiAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gd2FpdFVudGlsSXNMb2FkZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhcnJheTogKHYpID0+IEpTT04uc3RyaW5naWZ5KHYpLFxuICBvYmplY3Q6ICh2KSA9PiBKU09OLnN0cmluZ2lmeSh2KSxcbiAgc2V0OiAodikgPT4gSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbSh2KSksXG4gIG1hcDogKHYpID0+IEpTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyh2KSksXG4gIG51bGw6ICgpID0+IFwiXCJcbn07XG5mdW5jdGlvbiBnZXREZWZhdWx0U2VyaWFsaXphdGlvbih0YXJnZXQpIHtcbiAgaWYgKCF0YXJnZXQpXG4gICAgcmV0dXJuIGRlZmF1bHRzLm51bGw7XG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApXG4gICAgcmV0dXJuIGRlZmF1bHRzLm1hcDtcbiAgZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU2V0KVxuICAgIHJldHVybiBkZWZhdWx0cy5zZXQ7XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSlcbiAgICByZXR1cm4gZGVmYXVsdHMuYXJyYXk7XG4gIGVsc2VcbiAgICByZXR1cm4gZGVmYXVsdHMub2JqZWN0O1xufVxuXG5mdW5jdGlvbiB1c2VCYXNlNjQodGFyZ2V0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGJhc2U2NCA9IHNoYWxsb3dSZWYoXCJcIik7XG4gIGNvbnN0IHByb21pc2UgPSBzaGFsbG93UmVmKCk7XG4gIGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgaWYgKCFpc0NsaWVudClcbiAgICAgIHJldHVybjtcbiAgICBwcm9taXNlLnZhbHVlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgX3RhcmdldCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICAgICAgaWYgKF90YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgIHJlc29sdmUoXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXNvbHZlKGJsb2JUb0Jhc2U2NChuZXcgQmxvYihbX3RhcmdldF0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGFyZ2V0IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgIHJlc29sdmUoYmxvYlRvQmFzZTY0KF90YXJnZXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGFyZ2V0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXNvbHZlKHdpbmRvdy5idG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoX3RhcmdldCkpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RhcmdldCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgcmVzb2x2ZShfdGFyZ2V0LnRvRGF0YVVSTChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnR5cGUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucXVhbGl0eSkpO1xuICAgICAgICB9IGVsc2UgaWYgKF90YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgaW1nID0gX3RhcmdldC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgaW1nTG9hZGVkKGltZykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICByZXNvbHZlKGNhbnZhcy50b0RhdGFVUkwob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50eXBlLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1YWxpdHkpKTtcbiAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGFyZ2V0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgY29uc3QgX3NlcmlhbGl6ZUZuID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VyaWFsaXplcikgfHwgZ2V0RGVmYXVsdFNlcmlhbGl6YXRpb24oX3RhcmdldCk7XG4gICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IF9zZXJpYWxpemVGbihfdGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShibG9iVG9CYXNlNjQobmV3IEJsb2IoW3NlcmlhbGl6ZWRdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiIH0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInRhcmdldCBpcyB1bnN1cHBvcnRlZCB0eXBlc1wiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvbWlzZS52YWx1ZS50aGVuKChyZXMpID0+IHtcbiAgICAgIGJhc2U2NC52YWx1ZSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGFVcmwpID09PSBmYWxzZSA/IHJlcy5yZXBsYWNlKC9eZGF0YTouKj87YmFzZTY0LC8sIFwiXCIpIDogcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICB9XG4gIGlmIChpc1JlZih0YXJnZXQpIHx8IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIilcbiAgICB3YXRjaCh0YXJnZXQsIGV4ZWN1dGUsIHsgaW1tZWRpYXRlOiB0cnVlIH0pO1xuICBlbHNlXG4gICAgZXhlY3V0ZSgpO1xuICByZXR1cm4ge1xuICAgIGJhc2U2NCxcbiAgICBwcm9taXNlLFxuICAgIGV4ZWN1dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGltZ0xvYWRlZChpbWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoIWltZy5jb21wbGV0ZSkge1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIGltZy5vbmVycm9yID0gcmVqZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJsb2JUb0Jhc2U2NChibG9iKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgfTtcbiAgICBmci5vbmVycm9yID0gcmVqZWN0O1xuICAgIGZyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VCYXR0ZXJ5KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGV2ZW50cyA9IFtcImNoYXJnaW5nY2hhbmdlXCIsIFwiY2hhcmdpbmd0aW1lY2hhbmdlXCIsIFwiZGlzY2hhcmdpbmd0aW1lY2hhbmdlXCIsIFwibGV2ZWxjaGFuZ2VcIl07XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImdldEJhdHRlcnlcIiBpbiBuYXZpZ2F0b3IgJiYgdHlwZW9mIG5hdmlnYXRvci5nZXRCYXR0ZXJ5ID09PSBcImZ1bmN0aW9uXCIpO1xuICBjb25zdCBjaGFyZ2luZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBjaGFyZ2luZ1RpbWUgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBkaXNjaGFyZ2luZ1RpbWUgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBsZXZlbCA9IHNoYWxsb3dSZWYoMSk7XG4gIGxldCBiYXR0ZXJ5O1xuICBmdW5jdGlvbiB1cGRhdGVCYXR0ZXJ5SW5mbygpIHtcbiAgICBjaGFyZ2luZy52YWx1ZSA9IHRoaXMuY2hhcmdpbmc7XG4gICAgY2hhcmdpbmdUaW1lLnZhbHVlID0gdGhpcy5jaGFyZ2luZ1RpbWUgfHwgMDtcbiAgICBkaXNjaGFyZ2luZ1RpbWUudmFsdWUgPSB0aGlzLmRpc2NoYXJnaW5nVGltZSB8fCAwO1xuICAgIGxldmVsLnZhbHVlID0gdGhpcy5sZXZlbDtcbiAgfVxuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICBuYXZpZ2F0b3IuZ2V0QmF0dGVyeSgpLnRoZW4oKF9iYXR0ZXJ5KSA9PiB7XG4gICAgICBiYXR0ZXJ5ID0gX2JhdHRlcnk7XG4gICAgICB1cGRhdGVCYXR0ZXJ5SW5mby5jYWxsKGJhdHRlcnkpO1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihiYXR0ZXJ5LCBldmVudHMsIHVwZGF0ZUJhdHRlcnlJbmZvLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBjaGFyZ2luZyxcbiAgICBjaGFyZ2luZ1RpbWUsXG4gICAgZGlzY2hhcmdpbmdUaW1lLFxuICAgIGxldmVsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUJsdWV0b290aChvcHRpb25zKSB7XG4gIGxldCB7XG4gICAgYWNjZXB0QWxsRGV2aWNlcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB7XG4gICAgZmlsdGVycyA9IHZvaWQgMCxcbiAgICBvcHRpb25hbFNlcnZpY2VzID0gdm9pZCAwLFxuICAgIG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3JcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImJsdWV0b290aFwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGRldmljZSA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKG51bGwpO1xuICB3YXRjaChkZXZpY2UsICgpID0+IHtcbiAgICBjb25uZWN0VG9CbHVldG9vdGhHQVRUU2VydmVyKCk7XG4gIH0pO1xuICBhc3luYyBmdW5jdGlvbiByZXF1ZXN0RGV2aWNlKCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoID4gMClcbiAgICAgIGFjY2VwdEFsbERldmljZXMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZGV2aWNlLnZhbHVlID0gYXdhaXQgKG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLmJsdWV0b290aC5yZXF1ZXN0RGV2aWNlKHtcbiAgICAgICAgYWNjZXB0QWxsRGV2aWNlcyxcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgb3B0aW9uYWxTZXJ2aWNlc1xuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlcnZlciA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgaXNDb25uZWN0ZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaXNDb25uZWN0ZWQudmFsdWUgPSBmYWxzZTtcbiAgICBkZXZpY2UudmFsdWUgPSB2b2lkIDA7XG4gICAgc2VydmVyLnZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RUb0JsdWV0b290aEdBVFRTZXJ2ZXIoKSB7XG4gICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgIGlmIChkZXZpY2UudmFsdWUgJiYgZGV2aWNlLnZhbHVlLmdhdHQpIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoZGV2aWNlLCBcImdhdHRzZXJ2ZXJkaXNjb25uZWN0ZWRcIiwgcmVzZXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlcnZlci52YWx1ZSA9IGF3YWl0IGRldmljZS52YWx1ZS5nYXR0LmNvbm5lY3QoKTtcbiAgICAgICAgaXNDb25uZWN0ZWQudmFsdWUgPSBzZXJ2ZXIudmFsdWUuY29ubmVjdGVkO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZGV2aWNlLnZhbHVlKVxuICAgICAgKF9hID0gZGV2aWNlLnZhbHVlLmdhdHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb25uZWN0KCk7XG4gIH0pO1xuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChkZXZpY2UudmFsdWUpXG4gICAgICAoX2EgPSBkZXZpY2UudmFsdWUuZ2F0dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNDb25uZWN0ZWQ6IHJlYWRvbmx5KGlzQ29ubmVjdGVkKSxcbiAgICAvLyBEZXZpY2U6XG4gICAgZGV2aWNlLFxuICAgIHJlcXVlc3REZXZpY2UsXG4gICAgLy8gU2VydmVyOlxuICAgIHNlcnZlcixcbiAgICAvLyBFcnJvcnM6XG4gICAgZXJyb3JcbiAgfTtcbn1cblxuY29uc3Qgc3NyV2lkdGhTeW1ib2wgPSBTeW1ib2woXCJ2dWV1c2Utc3NyLXdpZHRoXCIpO1xuZnVuY3Rpb24gdXNlU1NSV2lkdGgoKSB7XG4gIGNvbnN0IHNzcldpZHRoID0gaGFzSW5qZWN0aW9uQ29udGV4dCgpID8gaW5qZWN0TG9jYWwoc3NyV2lkdGhTeW1ib2wsIG51bGwpIDogbnVsbDtcbiAgcmV0dXJuIHR5cGVvZiBzc3JXaWR0aCA9PT0gXCJudW1iZXJcIiA/IHNzcldpZHRoIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gcHJvdmlkZVNTUldpZHRoKHdpZHRoLCBhcHApIHtcbiAgaWYgKGFwcCAhPT0gdm9pZCAwKSB7XG4gICAgYXBwLnByb3ZpZGUoc3NyV2lkdGhTeW1ib2wsIHdpZHRoKTtcbiAgfSBlbHNlIHtcbiAgICBwcm92aWRlTG9jYWwoc3NyV2lkdGhTeW1ib2wsIHdpZHRoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VNZWRpYVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCBzc3JXaWR0aCA9IHVzZVNTUldpZHRoKCkgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIm1hdGNoTWVkaWFcIiBpbiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5tYXRjaE1lZGlhID09PSBcImZ1bmN0aW9uXCIpO1xuICBjb25zdCBzc3JTdXBwb3J0ID0gc2hhbGxvd1JlZih0eXBlb2Ygc3NyV2lkdGggPT09IFwibnVtYmVyXCIpO1xuICBjb25zdCBtZWRpYVF1ZXJ5ID0gc2hhbGxvd1JlZigpO1xuICBjb25zdCBtYXRjaGVzID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBtYXRjaGVzLnZhbHVlID0gZXZlbnQubWF0Y2hlcztcbiAgfTtcbiAgd2F0Y2hFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzc3JTdXBwb3J0LnZhbHVlKSB7XG4gICAgICBzc3JTdXBwb3J0LnZhbHVlID0gIWlzU3VwcG9ydGVkLnZhbHVlO1xuICAgICAgY29uc3QgcXVlcnlTdHJpbmdzID0gdG9WYWx1ZShxdWVyeSkuc3BsaXQoXCIsXCIpO1xuICAgICAgbWF0Y2hlcy52YWx1ZSA9IHF1ZXJ5U3RyaW5ncy5zb21lKChxdWVyeVN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBub3QgPSBxdWVyeVN0cmluZy5pbmNsdWRlcyhcIm5vdCBhbGxcIik7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gcXVlcnlTdHJpbmcubWF0Y2goL1xcKFxccyptaW4td2lkdGg6XFxzKigtP1xcZCsoPzpcXC5cXGQqKT9bYS16XStcXHMqKVxcKS8pO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHF1ZXJ5U3RyaW5nLm1hdGNoKC9cXChcXHMqbWF4LXdpZHRoOlxccyooLT9cXGQrKD86XFwuXFxkKik/W2Etel0rXFxzKilcXCkvKTtcbiAgICAgICAgbGV0IHJlcyA9IEJvb2xlYW4obWluV2lkdGggfHwgbWF4V2lkdGgpO1xuICAgICAgICBpZiAobWluV2lkdGggJiYgcmVzKSB7XG4gICAgICAgICAgcmVzID0gc3NyV2lkdGggPj0gcHhWYWx1ZShtaW5XaWR0aFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFdpZHRoICYmIHJlcykge1xuICAgICAgICAgIHJlcyA9IHNzcldpZHRoIDw9IHB4VmFsdWUobWF4V2lkdGhbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3QgPyAhcmVzIDogcmVzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgbWVkaWFRdWVyeS52YWx1ZSA9IHdpbmRvdy5tYXRjaE1lZGlhKHRvVmFsdWUocXVlcnkpKTtcbiAgICBtYXRjaGVzLnZhbHVlID0gbWVkaWFRdWVyeS52YWx1ZS5tYXRjaGVzO1xuICB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihtZWRpYVF1ZXJ5LCBcImNoYW5nZVwiLCBoYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiBtYXRjaGVzLnZhbHVlKTtcbn1cblxuY29uc3QgYnJlYWtwb2ludHNUYWlsd2luZCA9IHtcbiAgXCJzbVwiOiA2NDAsXG4gIFwibWRcIjogNzY4LFxuICBcImxnXCI6IDEwMjQsXG4gIFwieGxcIjogMTI4MCxcbiAgXCIyeGxcIjogMTUzNlxufTtcbmNvbnN0IGJyZWFrcG9pbnRzQm9vdHN0cmFwVjUgPSB7XG4gIHhzOiAwLFxuICBzbTogNTc2LFxuICBtZDogNzY4LFxuICBsZzogOTkyLFxuICB4bDogMTIwMCxcbiAgeHhsOiAxNDAwXG59O1xuY29uc3QgYnJlYWtwb2ludHNWdWV0aWZ5VjIgPSB7XG4gIHhzOiAwLFxuICBzbTogNjAwLFxuICBtZDogOTYwLFxuICBsZzogMTI2NCxcbiAgeGw6IDE5MDRcbn07XG5jb25zdCBicmVha3BvaW50c1Z1ZXRpZnlWMyA9IHtcbiAgeHM6IDAsXG4gIHNtOiA2MDAsXG4gIG1kOiA5NjAsXG4gIGxnOiAxMjgwLFxuICB4bDogMTkyMCxcbiAgeHhsOiAyNTYwXG59O1xuY29uc3QgYnJlYWtwb2ludHNWdWV0aWZ5ID0gYnJlYWtwb2ludHNWdWV0aWZ5VjI7XG5jb25zdCBicmVha3BvaW50c0FudERlc2lnbiA9IHtcbiAgeHM6IDQ4MCxcbiAgc206IDU3NixcbiAgbWQ6IDc2OCxcbiAgbGc6IDk5MixcbiAgeGw6IDEyMDAsXG4gIHh4bDogMTYwMFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzUXVhc2FyID0ge1xuICB4czogMCxcbiAgc206IDYwMCxcbiAgbWQ6IDEwMjQsXG4gIGxnOiAxNDQwLFxuICB4bDogMTkyMFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzU2VtYXRpYyA9IHtcbiAgbW9iaWxlUzogMzIwLFxuICBtb2JpbGVNOiAzNzUsXG4gIG1vYmlsZUw6IDQyNSxcbiAgdGFibGV0OiA3NjgsXG4gIGxhcHRvcDogMTAyNCxcbiAgbGFwdG9wTDogMTQ0MCxcbiAgZGVza3RvcDRLOiAyNTYwXG59O1xuY29uc3QgYnJlYWtwb2ludHNNYXN0ZXJDc3MgPSB7XG4gIFwiM3hzXCI6IDM2MCxcbiAgXCIyeHNcIjogNDgwLFxuICBcInhzXCI6IDYwMCxcbiAgXCJzbVwiOiA3NjgsXG4gIFwibWRcIjogMTAyNCxcbiAgXCJsZ1wiOiAxMjgwLFxuICBcInhsXCI6IDE0NDAsXG4gIFwiMnhsXCI6IDE2MDAsXG4gIFwiM3hsXCI6IDE5MjAsXG4gIFwiNHhsXCI6IDI1NjBcbn07XG5jb25zdCBicmVha3BvaW50c1ByaW1lRmxleCA9IHtcbiAgc206IDU3NixcbiAgbWQ6IDc2OCxcbiAgbGc6IDk5MixcbiAgeGw6IDEyMDBcbn07XG5jb25zdCBicmVha3BvaW50c0VsZW1lbnQgPSB7XG4gIHhzOiAwLFxuICBzbTogNzY4LFxuICBtZDogOTkyLFxuICBsZzogMTIwMCxcbiAgeGw6IDE5MjBcbn07XG5cbmZ1bmN0aW9uIHVzZUJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzLCBvcHRpb25zID0ge30pIHtcbiAgZnVuY3Rpb24gZ2V0VmFsdWUoaywgZGVsdGEpIHtcbiAgICBsZXQgdiA9IHRvVmFsdWUoYnJlYWtwb2ludHNbdG9WYWx1ZShrKV0pO1xuICAgIGlmIChkZWx0YSAhPSBudWxsKVxuICAgICAgdiA9IGluY3JlYXNlV2l0aFVuaXQodiwgZGVsdGEpO1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIilcbiAgICAgIHYgPSBgJHt2fXB4YDtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIHN0cmF0ZWd5ID0gXCJtaW4td2lkdGhcIiwgc3NyV2lkdGggPSB1c2VTU1JXaWR0aCgpIH0gPSBvcHRpb25zO1xuICBjb25zdCBzc3JTdXBwb3J0ID0gdHlwZW9mIHNzcldpZHRoID09PSBcIm51bWJlclwiO1xuICBjb25zdCBtb3VudGVkID0gc3NyU3VwcG9ydCA/IHNoYWxsb3dSZWYoZmFsc2UpIDogeyB2YWx1ZTogdHJ1ZSB9O1xuICBpZiAoc3NyU3VwcG9ydCkge1xuICAgIHRyeU9uTW91bnRlZCgoKSA9PiBtb3VudGVkLnZhbHVlID0gISF3aW5kb3cpO1xuICB9XG4gIGZ1bmN0aW9uIG1hdGNoKHF1ZXJ5LCBzaXplKSB7XG4gICAgaWYgKCFtb3VudGVkLnZhbHVlICYmIHNzclN1cHBvcnQpIHtcbiAgICAgIHJldHVybiBxdWVyeSA9PT0gXCJtaW5cIiA/IHNzcldpZHRoID49IHB4VmFsdWUoc2l6ZSkgOiBzc3JXaWR0aCA8PSBweFZhbHVlKHNpemUpO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdylcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEoYCgke3F1ZXJ5fS13aWR0aDogJHtzaXplfSlgKS5tYXRjaGVzO1xuICB9XG4gIGNvbnN0IGdyZWF0ZXJPckVxdWFsID0gKGspID0+IHtcbiAgICByZXR1cm4gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKG1pbi13aWR0aDogJHtnZXRWYWx1ZShrKX0pYCwgb3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IHNtYWxsZXJPckVxdWFsID0gKGspID0+IHtcbiAgICByZXR1cm4gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKG1heC13aWR0aDogJHtnZXRWYWx1ZShrKX0pYCwgb3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IHNob3J0Y3V0TWV0aG9kcyA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5yZWR1Y2UoKHNob3J0Y3V0cywgaykgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaG9ydGN1dHMsIGssIHtcbiAgICAgIGdldDogKCkgPT4gc3RyYXRlZ3kgPT09IFwibWluLXdpZHRoXCIgPyBncmVhdGVyT3JFcXVhbChrKSA6IHNtYWxsZXJPckVxdWFsKGspLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBzaG9ydGN1dHM7XG4gIH0sIHt9KTtcbiAgZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICBjb25zdCBwb2ludHMgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cykubWFwKChrKSA9PiBbaywgc2hvcnRjdXRNZXRob2RzW2tdLCBweFZhbHVlKGdldFZhbHVlKGspKV0pLnNvcnQoKGEsIGIpID0+IGFbMl0gLSBiWzJdKTtcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gcG9pbnRzLmZpbHRlcigoWywgdl0pID0+IHYudmFsdWUpLm1hcCgoW2tdKSA9PiBrKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2hvcnRjdXRNZXRob2RzLCB7XG4gICAgZ3JlYXRlck9yRXF1YWwsXG4gICAgc21hbGxlck9yRXF1YWwsXG4gICAgZ3JlYXRlcihrKSB7XG4gICAgICByZXR1cm4gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKG1pbi13aWR0aDogJHtnZXRWYWx1ZShrLCAwLjEpfSlgLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIHNtYWxsZXIoaykge1xuICAgICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtYXgtd2lkdGg6ICR7Z2V0VmFsdWUoaywgLTAuMSl9KWAsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYmV0d2VlbihhLCBiKSB7XG4gICAgICByZXR1cm4gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKG1pbi13aWR0aDogJHtnZXRWYWx1ZShhKX0pIGFuZCAobWF4LXdpZHRoOiAke2dldFZhbHVlKGIsIC0wLjEpfSlgLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGlzR3JlYXRlcihrKSB7XG4gICAgICByZXR1cm4gbWF0Y2goXCJtaW5cIiwgZ2V0VmFsdWUoaywgMC4xKSk7XG4gICAgfSxcbiAgICBpc0dyZWF0ZXJPckVxdWFsKGspIHtcbiAgICAgIHJldHVybiBtYXRjaChcIm1pblwiLCBnZXRWYWx1ZShrKSk7XG4gICAgfSxcbiAgICBpc1NtYWxsZXIoaykge1xuICAgICAgcmV0dXJuIG1hdGNoKFwibWF4XCIsIGdldFZhbHVlKGssIC0wLjEpKTtcbiAgICB9LFxuICAgIGlzU21hbGxlck9yRXF1YWwoaykge1xuICAgICAgcmV0dXJuIG1hdGNoKFwibWF4XCIsIGdldFZhbHVlKGspKTtcbiAgICB9LFxuICAgIGlzSW5CZXR3ZWVuKGEsIGIpIHtcbiAgICAgIHJldHVybiBtYXRjaChcIm1pblwiLCBnZXRWYWx1ZShhKSkgJiYgbWF0Y2goXCJtYXhcIiwgZ2V0VmFsdWUoYiwgLTAuMSkpO1xuICAgIH0sXG4gICAgY3VycmVudCxcbiAgICBhY3RpdmUoKSB7XG4gICAgICBjb25zdCBicHMgPSBjdXJyZW50KCk7XG4gICAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gYnBzLnZhbHVlLmxlbmd0aCA9PT0gMCA/IFwiXCIgOiBicHMudmFsdWUuYXQoc3RyYXRlZ3kgPT09IFwibWluLXdpZHRoXCIgPyAtMSA6IDApKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VCcm9hZGNhc3RDaGFubmVsKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5hbWUsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwiQnJvYWRjYXN0Q2hhbm5lbFwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IGlzQ2xvc2VkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGNoYW5uZWwgPSByZWYoKTtcbiAgY29uc3QgZGF0YSA9IHJlZigpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IHBvc3QgPSAoZGF0YTIpID0+IHtcbiAgICBpZiAoY2hhbm5lbC52YWx1ZSlcbiAgICAgIGNoYW5uZWwudmFsdWUucG9zdE1lc3NhZ2UoZGF0YTIpO1xuICB9O1xuICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICBpZiAoY2hhbm5lbC52YWx1ZSlcbiAgICAgIGNoYW5uZWwudmFsdWUuY2xvc2UoKTtcbiAgICBpc0Nsb3NlZC52YWx1ZSA9IHRydWU7XG4gIH07XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgICBlcnJvci52YWx1ZSA9IG51bGw7XG4gICAgICBjaGFubmVsLnZhbHVlID0gbmV3IEJyb2FkY2FzdENoYW5uZWwobmFtZSk7XG4gICAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH07XG4gICAgICB1c2VFdmVudExpc3RlbmVyKGNoYW5uZWwsIFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgICAgICBkYXRhLnZhbHVlID0gZS5kYXRhO1xuICAgICAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoY2hhbm5lbCwgXCJtZXNzYWdlZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlO1xuICAgICAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoY2hhbm5lbCwgXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGlzQ2xvc2VkLnZhbHVlID0gdHJ1ZTtcbiAgICAgIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIGNsb3NlKCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGNoYW5uZWwsXG4gICAgZGF0YSxcbiAgICBwb3N0LFxuICAgIGNsb3NlLFxuICAgIGVycm9yLFxuICAgIGlzQ2xvc2VkXG4gIH07XG59XG5cbmNvbnN0IFdSSVRBQkxFX1BST1BFUlRJRVMgPSBbXG4gIFwiaGFzaFwiLFxuICBcImhvc3RcIixcbiAgXCJob3N0bmFtZVwiLFxuICBcImhyZWZcIixcbiAgXCJwYXRobmFtZVwiLFxuICBcInBvcnRcIixcbiAgXCJwcm90b2NvbFwiLFxuICBcInNlYXJjaFwiXG5dO1xuZnVuY3Rpb24gdXNlQnJvd3NlckxvY2F0aW9uKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZnMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgV1JJVEFCTEVfUFJPUEVSVElFUy5tYXAoKGtleSkgPT4gW2tleSwgcmVmKCldKVxuICApO1xuICBmb3IgKGNvbnN0IFtrZXksIHJlZl0gb2Ygb2JqZWN0RW50cmllcyhyZWZzKSkge1xuICAgIHdhdGNoKHJlZiwgKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoISh3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhdGlvbikgfHwgd2luZG93LmxvY2F0aW9uW2tleV0gPT09IHZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgICB3aW5kb3cubG9jYXRpb25ba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJ1aWxkU3RhdGUgPSAodHJpZ2dlcikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHN0YXRlOiBzdGF0ZTIsIGxlbmd0aCB9ID0gKHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Lmhpc3RvcnkpIHx8IHt9O1xuICAgIGNvbnN0IHsgb3JpZ2luIH0gPSAod2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pIHx8IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFdSSVRBQkxFX1BST1BFUlRJRVMpXG4gICAgICByZWZzW2tleV0udmFsdWUgPSAoX2EgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2tleV07XG4gICAgcmV0dXJuIHJlYWN0aXZlKHtcbiAgICAgIHRyaWdnZXIsXG4gICAgICBzdGF0ZTogc3RhdGUyLFxuICAgICAgbGVuZ3RoLFxuICAgICAgb3JpZ2luLFxuICAgICAgLi4ucmVmc1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBzdGF0ZSA9IHJlZihidWlsZFN0YXRlKFwibG9hZFwiKSk7XG4gIGlmICh3aW5kb3cpIHtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJwb3BzdGF0ZVwiLCAoKSA9PiBzdGF0ZS52YWx1ZSA9IGJ1aWxkU3RhdGUoXCJwb3BzdGF0ZVwiKSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJoYXNoY2hhbmdlXCIsICgpID0+IHN0YXRlLnZhbHVlID0gYnVpbGRTdGF0ZShcImhhc2hjaGFuZ2VcIiksIGxpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VDYWNoZWQocmVmVmFsdWUsIGNvbXBhcmF0b3IgPSAoYSwgYikgPT4gYSA9PT0gYiwgb3B0aW9ucykge1xuICBjb25zdCB7IGRlZXBSZWZzID0gdHJ1ZSwgLi4ud2F0Y2hPcHRpb25zIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZWRWYWx1ZSA9IGNyZWF0ZVJlZihyZWZWYWx1ZS52YWx1ZSwgZGVlcFJlZnMpO1xuICB3YXRjaCgoKSA9PiByZWZWYWx1ZS52YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFjb21wYXJhdG9yKHZhbHVlLCBjYWNoZWRWYWx1ZS52YWx1ZSkpXG4gICAgICBjYWNoZWRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICB9LCB3YXRjaE9wdGlvbnMpO1xuICByZXR1cm4gY2FjaGVkVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVBlcm1pc3Npb24ocGVybWlzc2lvbkRlc2MsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHMgPSBmYWxzZSxcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJwZXJtaXNzaW9uc1wiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IHBlcm1pc3Npb25TdGF0dXMgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IGRlc2MgPSB0eXBlb2YgcGVybWlzc2lvbkRlc2MgPT09IFwic3RyaW5nXCIgPyB7IG5hbWU6IHBlcm1pc3Npb25EZXNjIH0gOiBwZXJtaXNzaW9uRGVzYztcbiAgY29uc3Qgc3RhdGUgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHN0YXRlLnZhbHVlID0gKF9iID0gKF9hID0gcGVybWlzc2lvblN0YXR1cy52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0YXRlKSAhPSBudWxsID8gX2IgOiBcInByb21wdFwiO1xuICB9O1xuICB1c2VFdmVudExpc3RlbmVyKHBlcm1pc3Npb25TdGF0dXMsIFwiY2hhbmdlXCIsIHVwZGF0ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICBjb25zdCBxdWVyeSA9IGNyZWF0ZVNpbmdsZXRvblByb21pc2UoYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwZXJtaXNzaW9uU3RhdHVzLnZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwZXJtaXNzaW9uU3RhdHVzLnZhbHVlID0gYXdhaXQgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KGRlc2MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwZXJtaXNzaW9uU3RhdHVzLnZhbHVlID0gdm9pZCAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250cm9scylcbiAgICAgIHJldHVybiB0b1JhdyhwZXJtaXNzaW9uU3RhdHVzLnZhbHVlKTtcbiAgfSk7XG4gIHF1ZXJ5KCk7XG4gIGlmIChjb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZSxcbiAgICAgIGlzU3VwcG9ydGVkLFxuICAgICAgcXVlcnlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDbGlwYm9hcmQob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yLFxuICAgIHJlYWQgPSBmYWxzZSxcbiAgICBzb3VyY2UsXG4gICAgY29waWVkRHVyaW5nID0gMTUwMCxcbiAgICBsZWdhY3kgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNDbGlwYm9hcmRBcGlTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwiY2xpcGJvYXJkXCIgaW4gbmF2aWdhdG9yKTtcbiAgY29uc3QgcGVybWlzc2lvblJlYWQgPSB1c2VQZXJtaXNzaW9uKFwiY2xpcGJvYXJkLXJlYWRcIik7XG4gIGNvbnN0IHBlcm1pc3Npb25Xcml0ZSA9IHVzZVBlcm1pc3Npb24oXCJjbGlwYm9hcmQtd3JpdGVcIik7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gY29tcHV0ZWQoKCkgPT4gaXNDbGlwYm9hcmRBcGlTdXBwb3J0ZWQudmFsdWUgfHwgbGVnYWN5KTtcbiAgY29uc3QgdGV4dCA9IHNoYWxsb3dSZWYoXCJcIik7XG4gIGNvbnN0IGNvcGllZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCB0aW1lb3V0ID0gdXNlVGltZW91dEZuKCgpID0+IGNvcGllZC52YWx1ZSA9IGZhbHNlLCBjb3BpZWREdXJpbmcsIHsgaW1tZWRpYXRlOiBmYWxzZSB9KTtcbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVGV4dCgpIHtcbiAgICBsZXQgdXNlTGVnYWN5ID0gIShpc0NsaXBib2FyZEFwaVN1cHBvcnRlZC52YWx1ZSAmJiBpc0FsbG93ZWQocGVybWlzc2lvblJlYWQudmFsdWUpKTtcbiAgICBpZiAoIXVzZUxlZ2FjeSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGV4dC52YWx1ZSA9IGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdXNlTGVnYWN5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZUxlZ2FjeSkge1xuICAgICAgdGV4dC52YWx1ZSA9IGxlZ2FjeVJlYWQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHJlYWQpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihbXCJjb3B5XCIsIFwiY3V0XCJdLCB1cGRhdGVUZXh0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIGFzeW5jIGZ1bmN0aW9uIGNvcHkodmFsdWUgPSB0b1ZhbHVlKHNvdXJjZSkpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgbGV0IHVzZUxlZ2FjeSA9ICEoaXNDbGlwYm9hcmRBcGlTdXBwb3J0ZWQudmFsdWUgJiYgaXNBbGxvd2VkKHBlcm1pc3Npb25Xcml0ZS52YWx1ZSkpO1xuICAgICAgaWYgKCF1c2VMZWdhY3kpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB1c2VMZWdhY3kgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXNlTGVnYWN5KVxuICAgICAgICBsZWdhY3lDb3B5KHZhbHVlKTtcbiAgICAgIHRleHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGNvcGllZC52YWx1ZSA9IHRydWU7XG4gICAgICB0aW1lb3V0LnN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxlZ2FjeUNvcHkodmFsdWUpIHtcbiAgICBjb25zdCB0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICB0YS52YWx1ZSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwiXCI7XG4gICAgdGEuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgdGEuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGEpO1xuICAgIHRhLnNlbGVjdCgpO1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKTtcbiAgICB0YS5yZW1vdmUoKTtcbiAgfVxuICBmdW5jdGlvbiBsZWdhY3lSZWFkKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChkb2N1bWVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpKSAhPSBudWxsID8gX2MgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWxsb3dlZChzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID09PSBcImdyYW50ZWRcIiB8fCBzdGF0dXMgPT09IFwicHJvbXB0XCI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICB0ZXh0LFxuICAgIGNvcGllZCxcbiAgICBjb3B5XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUNsaXBib2FyZEl0ZW1zKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICByZWFkID0gZmFsc2UsXG4gICAgc291cmNlLFxuICAgIGNvcGllZER1cmluZyA9IDE1MDBcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImNsaXBib2FyZFwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGNvbnRlbnQgPSByZWYoW10pO1xuICBjb25zdCBjb3BpZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgdGltZW91dCA9IHVzZVRpbWVvdXRGbigoKSA9PiBjb3BpZWQudmFsdWUgPSBmYWxzZSwgY29waWVkRHVyaW5nLCB7IGltbWVkaWF0ZTogZmFsc2UgfSk7XG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnQoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLnJlYWQoKS50aGVuKChpdGVtcykgPT4ge1xuICAgICAgICBjb250ZW50LnZhbHVlID0gaXRlbXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHJlYWQpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihbXCJjb3B5XCIsIFwiY3V0XCJdLCB1cGRhdGVDb250ZW50LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIGFzeW5jIGZ1bmN0aW9uIGNvcHkodmFsdWUgPSB0b1ZhbHVlKHNvdXJjZSkpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZSh2YWx1ZSk7XG4gICAgICBjb250ZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICBjb3BpZWQudmFsdWUgPSB0cnVlO1xuICAgICAgdGltZW91dC5zdGFydCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGNvbnRlbnQsXG4gICAgY29waWVkLFxuICAgIGNvcHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xvbmVGbkpTT04oc291cmNlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNvdXJjZSkpO1xufVxuZnVuY3Rpb24gdXNlQ2xvbmVkKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGNsb25lZCA9IHJlZih7fSk7XG4gIGNvbnN0IGlzTW9kaWZpZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgbGV0IF9sYXN0U3luYyA9IGZhbHNlO1xuICBjb25zdCB7XG4gICAgbWFudWFsLFxuICAgIGNsb25lID0gY2xvbmVGbkpTT04sXG4gICAgLy8gd2F0Y2ggb3B0aW9uc1xuICAgIGRlZXAgPSB0cnVlLFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIHdhdGNoKGNsb25lZCwgKCkgPT4ge1xuICAgIGlmIChfbGFzdFN5bmMpIHtcbiAgICAgIF9sYXN0U3luYyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc01vZGlmaWVkLnZhbHVlID0gdHJ1ZTtcbiAgfSwge1xuICAgIGRlZXA6IHRydWUsXG4gICAgZmx1c2g6IFwic3luY1wiXG4gIH0pO1xuICBmdW5jdGlvbiBzeW5jKCkge1xuICAgIF9sYXN0U3luYyA9IHRydWU7XG4gICAgaXNNb2RpZmllZC52YWx1ZSA9IGZhbHNlO1xuICAgIGNsb25lZC52YWx1ZSA9IGNsb25lKHRvVmFsdWUoc291cmNlKSk7XG4gIH1cbiAgaWYgKCFtYW51YWwgJiYgKGlzUmVmKHNvdXJjZSkgfHwgdHlwZW9mIHNvdXJjZSA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHdhdGNoKHNvdXJjZSwgc3luYywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGRlZXAsXG4gICAgICBpbW1lZGlhdGVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzeW5jKCk7XG4gIH1cbiAgcmV0dXJuIHsgY2xvbmVkLCBpc01vZGlmaWVkLCBzeW5jIH07XG59XG5cbmNvbnN0IF9nbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHt9O1xuY29uc3QgZ2xvYmFsS2V5ID0gXCJfX3Z1ZXVzZV9zc3JfaGFuZGxlcnNfX1wiO1xuY29uc3QgaGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZ2V0SGFuZGxlcnMoKTtcbmZ1bmN0aW9uIGdldEhhbmRsZXJzKCkge1xuICBpZiAoIShnbG9iYWxLZXkgaW4gX2dsb2JhbCkpXG4gICAgX2dsb2JhbFtnbG9iYWxLZXldID0gX2dsb2JhbFtnbG9iYWxLZXldIHx8IHt9O1xuICByZXR1cm4gX2dsb2JhbFtnbG9iYWxLZXldO1xufVxuZnVuY3Rpb24gZ2V0U1NSSGFuZGxlcihrZXksIGZhbGxiYWNrKSB7XG4gIHJldHVybiBoYW5kbGVyc1trZXldIHx8IGZhbGxiYWNrO1xufVxuZnVuY3Rpb24gc2V0U1NSSGFuZGxlcihrZXksIGZuKSB7XG4gIGhhbmRsZXJzW2tleV0gPSBmbjtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmVycmVkRGFyayhvcHRpb25zKSB7XG4gIHJldHVybiB1c2VNZWRpYVF1ZXJ5KFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZ3Vlc3NTZXJpYWxpemVyVHlwZShyYXdJbml0KSB7XG4gIHJldHVybiByYXdJbml0ID09IG51bGwgPyBcImFueVwiIDogcmF3SW5pdCBpbnN0YW5jZW9mIFNldCA/IFwic2V0XCIgOiByYXdJbml0IGluc3RhbmNlb2YgTWFwID8gXCJtYXBcIiA6IHJhd0luaXQgaW5zdGFuY2VvZiBEYXRlID8gXCJkYXRlXCIgOiB0eXBlb2YgcmF3SW5pdCA9PT0gXCJib29sZWFuXCIgPyBcImJvb2xlYW5cIiA6IHR5cGVvZiByYXdJbml0ID09PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IHR5cGVvZiByYXdJbml0ID09PSBcIm9iamVjdFwiID8gXCJvYmplY3RcIiA6ICFOdW1iZXIuaXNOYU4ocmF3SW5pdCkgPyBcIm51bWJlclwiIDogXCJhbnlcIjtcbn1cblxuY29uc3QgU3RvcmFnZVNlcmlhbGl6ZXJzID0ge1xuICBib29sZWFuOiB7XG4gICAgcmVhZDogKHYpID0+IHYgPT09IFwidHJ1ZVwiLFxuICAgIHdyaXRlOiAodikgPT4gU3RyaW5nKHYpXG4gIH0sXG4gIG9iamVjdDoge1xuICAgIHJlYWQ6ICh2KSA9PiBKU09OLnBhcnNlKHYpLFxuICAgIHdyaXRlOiAodikgPT4gSlNPTi5zdHJpbmdpZnkodilcbiAgfSxcbiAgbnVtYmVyOiB7XG4gICAgcmVhZDogKHYpID0+IE51bWJlci5wYXJzZUZsb2F0KHYpLFxuICAgIHdyaXRlOiAodikgPT4gU3RyaW5nKHYpXG4gIH0sXG4gIGFueToge1xuICAgIHJlYWQ6ICh2KSA9PiB2LFxuICAgIHdyaXRlOiAodikgPT4gU3RyaW5nKHYpXG4gIH0sXG4gIHN0cmluZzoge1xuICAgIHJlYWQ6ICh2KSA9PiB2LFxuICAgIHdyaXRlOiAodikgPT4gU3RyaW5nKHYpXG4gIH0sXG4gIG1hcDoge1xuICAgIHJlYWQ6ICh2KSA9PiBuZXcgTWFwKEpTT04ucGFyc2UodikpLFxuICAgIHdyaXRlOiAodikgPT4gSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbSh2LmVudHJpZXMoKSkpXG4gIH0sXG4gIHNldDoge1xuICAgIHJlYWQ6ICh2KSA9PiBuZXcgU2V0KEpTT04ucGFyc2UodikpLFxuICAgIHdyaXRlOiAodikgPT4gSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbSh2KSlcbiAgfSxcbiAgZGF0ZToge1xuICAgIHJlYWQ6ICh2KSA9PiBuZXcgRGF0ZSh2KSxcbiAgICB3cml0ZTogKHYpID0+IHYudG9JU09TdHJpbmcoKVxuICB9XG59O1xuY29uc3QgY3VzdG9tU3RvcmFnZUV2ZW50TmFtZSA9IFwidnVldXNlLXN0b3JhZ2VcIjtcbmZ1bmN0aW9uIHVzZVN0b3JhZ2Uoa2V5LCBkZWZhdWx0cywgc3RvcmFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3Qge1xuICAgIGZsdXNoID0gXCJwcmVcIixcbiAgICBkZWVwID0gdHJ1ZSxcbiAgICBsaXN0ZW5Ub1N0b3JhZ2VDaGFuZ2VzID0gdHJ1ZSxcbiAgICB3cml0ZURlZmF1bHRzID0gdHJ1ZSxcbiAgICBtZXJnZURlZmF1bHRzID0gZmFsc2UsXG4gICAgc2hhbGxvdyxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGV2ZW50RmlsdGVyLFxuICAgIG9uRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9LFxuICAgIGluaXRPbk1vdW50ZWRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRhdGEgPSAoc2hhbGxvdyA/IHNoYWxsb3dSZWYgOiByZWYpKHR5cGVvZiBkZWZhdWx0cyA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdHMoKSA6IGRlZmF1bHRzKTtcbiAgY29uc3Qga2V5Q29tcHV0ZWQgPSBjb21wdXRlZCgoKSA9PiB0b1ZhbHVlKGtleSkpO1xuICBpZiAoIXN0b3JhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgc3RvcmFnZSA9IGdldFNTUkhhbmRsZXIoXCJnZXREZWZhdWx0U3RvcmFnZVwiLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gZGVmYXVsdFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5sb2NhbFN0b3JhZ2U7XG4gICAgICB9KSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlmICghc3RvcmFnZSlcbiAgICByZXR1cm4gZGF0YTtcbiAgY29uc3QgcmF3SW5pdCA9IHRvVmFsdWUoZGVmYXVsdHMpO1xuICBjb25zdCB0eXBlID0gZ3Vlc3NTZXJpYWxpemVyVHlwZShyYXdJbml0KTtcbiAgY29uc3Qgc2VyaWFsaXplciA9IChfYSA9IG9wdGlvbnMuc2VyaWFsaXplcikgIT0gbnVsbCA/IF9hIDogU3RvcmFnZVNlcmlhbGl6ZXJzW3R5cGVdO1xuICBjb25zdCB7IHBhdXNlOiBwYXVzZVdhdGNoLCByZXN1bWU6IHJlc3VtZVdhdGNoIH0gPSBwYXVzYWJsZVdhdGNoKFxuICAgIGRhdGEsXG4gICAgKCkgPT4gd3JpdGUoZGF0YS52YWx1ZSksXG4gICAgeyBmbHVzaCwgZGVlcCwgZXZlbnRGaWx0ZXIgfVxuICApO1xuICB3YXRjaChrZXlDb21wdXRlZCwgKCkgPT4gdXBkYXRlKCksIHsgZmx1c2ggfSk7XG4gIGlmICh3aW5kb3cgJiYgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcykge1xuICAgIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgICBpZiAoc3RvcmFnZSBpbnN0YW5jZW9mIFN0b3JhZ2UpXG4gICAgICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInN0b3JhZ2VcIiwgdXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBjdXN0b21TdG9yYWdlRXZlbnROYW1lLCB1cGRhdGVGcm9tQ3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKGluaXRPbk1vdW50ZWQpXG4gICAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIGlmICghaW5pdE9uTW91bnRlZClcbiAgICB1cGRhdGUoKTtcbiAgZnVuY3Rpb24gZGlzcGF0Y2hXcml0ZUV2ZW50KG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIGtleToga2V5Q29tcHV0ZWQudmFsdWUsXG4gICAgICAgIG9sZFZhbHVlLFxuICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgc3RvcmFnZUFyZWE6IHN0b3JhZ2VcbiAgICAgIH07XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChzdG9yYWdlIGluc3RhbmNlb2YgU3RvcmFnZSA/IG5ldyBTdG9yYWdlRXZlbnQoXCJzdG9yYWdlXCIsIHBheWxvYWQpIDogbmV3IEN1c3RvbUV2ZW50KGN1c3RvbVN0b3JhZ2VFdmVudE5hbWUsIHtcbiAgICAgICAgZGV0YWlsOiBwYXlsb2FkXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdyaXRlKHYpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdG9yYWdlLmdldEl0ZW0oa2V5Q29tcHV0ZWQudmFsdWUpO1xuICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICBkaXNwYXRjaFdyaXRlRXZlbnQob2xkVmFsdWUsIG51bGwpO1xuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5Q29tcHV0ZWQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZXIud3JpdGUodik7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gc2VyaWFsaXplZCkge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlDb21wdXRlZC52YWx1ZSwgc2VyaWFsaXplZCk7XG4gICAgICAgICAgZGlzcGF0Y2hXcml0ZUV2ZW50KG9sZFZhbHVlLCBzZXJpYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICBjb25zdCByYXdWYWx1ZSA9IGV2ZW50ID8gZXZlbnQubmV3VmFsdWUgOiBzdG9yYWdlLmdldEl0ZW0oa2V5Q29tcHV0ZWQudmFsdWUpO1xuICAgIGlmIChyYXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAod3JpdGVEZWZhdWx0cyAmJiByYXdJbml0ICE9IG51bGwpXG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlDb21wdXRlZC52YWx1ZSwgc2VyaWFsaXplci53cml0ZShyYXdJbml0KSk7XG4gICAgICByZXR1cm4gcmF3SW5pdDtcbiAgICB9IGVsc2UgaWYgKCFldmVudCAmJiBtZXJnZURlZmF1bHRzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNlcmlhbGl6ZXIucmVhZChyYXdWYWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIG1lcmdlRGVmYXVsdHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHModmFsdWUsIHJhd0luaXQpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB7IC4uLnJhd0luaXQsIC4uLnZhbHVlIH07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmF3VmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIucmVhZChyYXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIGlmIChldmVudCAmJiBldmVudC5zdG9yYWdlQXJlYSAhPT0gc3RvcmFnZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQua2V5ID09IG51bGwpIHtcbiAgICAgIGRhdGEudmFsdWUgPSByYXdJbml0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQua2V5ICE9PSBrZXlDb21wdXRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBwYXVzZVdhdGNoKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgoZXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50Lm5ld1ZhbHVlKSAhPT0gc2VyaWFsaXplci53cml0ZShkYXRhLnZhbHVlKSlcbiAgICAgICAgZGF0YS52YWx1ZSA9IHJlYWQoZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChldmVudClcbiAgICAgICAgbmV4dFRpY2socmVzdW1lV2F0Y2gpO1xuICAgICAgZWxzZVxuICAgICAgICByZXN1bWVXYXRjaCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVGcm9tQ3VzdG9tRXZlbnQoZXZlbnQpIHtcbiAgICB1cGRhdGUoZXZlbnQuZGV0YWlsKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuY29uc3QgQ1NTX0RJU0FCTEVfVFJBTlMgPSBcIiosKjo6YmVmb3JlLCo6OmFmdGVyey13ZWJraXQtdHJhbnNpdGlvbjpub25lIWltcG9ydGFudDstbW96LXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW8tdHJhbnNpdGlvbjpub25lIWltcG9ydGFudDstbXMtdHJhbnNpdGlvbjpub25lIWltcG9ydGFudDt0cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50fVwiO1xuZnVuY3Rpb24gdXNlQ29sb3JNb2RlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc2VsZWN0b3IgPSBcImh0bWxcIixcbiAgICBhdHRyaWJ1dGUgPSBcImNsYXNzXCIsXG4gICAgaW5pdGlhbFZhbHVlID0gXCJhdXRvXCIsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBzdG9yYWdlLFxuICAgIHN0b3JhZ2VLZXkgPSBcInZ1ZXVzZS1jb2xvci1zY2hlbWVcIixcbiAgICBsaXN0ZW5Ub1N0b3JhZ2VDaGFuZ2VzID0gdHJ1ZSxcbiAgICBzdG9yYWdlUmVmLFxuICAgIGVtaXRBdXRvLFxuICAgIGRpc2FibGVUcmFuc2l0aW9uID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbW9kZXMgPSB7XG4gICAgYXV0bzogXCJcIixcbiAgICBsaWdodDogXCJsaWdodFwiLFxuICAgIGRhcms6IFwiZGFya1wiLFxuICAgIC4uLm9wdGlvbnMubW9kZXMgfHwge31cbiAgfTtcbiAgY29uc3QgcHJlZmVycmVkRGFyayA9IHVzZVByZWZlcnJlZERhcmsoeyB3aW5kb3cgfSk7XG4gIGNvbnN0IHN5c3RlbSA9IGNvbXB1dGVkKCgpID0+IHByZWZlcnJlZERhcmsudmFsdWUgPyBcImRhcmtcIiA6IFwibGlnaHRcIik7XG4gIGNvbnN0IHN0b3JlID0gc3RvcmFnZVJlZiB8fCAoc3RvcmFnZUtleSA9PSBudWxsID8gdG9SZWYoaW5pdGlhbFZhbHVlKSA6IHVzZVN0b3JhZ2Uoc3RvcmFnZUtleSwgaW5pdGlhbFZhbHVlLCBzdG9yYWdlLCB7IHdpbmRvdywgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcyB9KSk7XG4gIGNvbnN0IHN0YXRlID0gY29tcHV0ZWQoKCkgPT4gc3RvcmUudmFsdWUgPT09IFwiYXV0b1wiID8gc3lzdGVtLnZhbHVlIDogc3RvcmUudmFsdWUpO1xuICBjb25zdCB1cGRhdGVIVE1MQXR0cnMgPSBnZXRTU1JIYW5kbGVyKFxuICAgIFwidXBkYXRlSFRNTEF0dHJzXCIsXG4gICAgKHNlbGVjdG9yMiwgYXR0cmlidXRlMiwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gdHlwZW9mIHNlbGVjdG9yMiA9PT0gXCJzdHJpbmdcIiA/IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IyKSA6IHVucmVmRWxlbWVudChzZWxlY3RvcjIpO1xuICAgICAgaWYgKCFlbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY2xhc3Nlc1RvQWRkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBsZXQgYXR0cmlidXRlVG9DaGFuZ2UgPSBudWxsO1xuICAgICAgaWYgKGF0dHJpYnV0ZTIgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdmFsdWUuc3BsaXQoL1xccy9nKTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhtb2RlcykuZmxhdE1hcCgoaSkgPT4gKGkgfHwgXCJcIikuc3BsaXQoL1xccy9nKSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICBpZiAoY3VycmVudC5pbmNsdWRlcyh2KSlcbiAgICAgICAgICAgIGNsYXNzZXNUb0FkZC5hZGQodik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLmFkZCh2KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVUb0NoYW5nZSA9IHsga2V5OiBhdHRyaWJ1dGUyLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgICAgaWYgKGNsYXNzZXNUb0FkZC5zaXplID09PSAwICYmIGNsYXNzZXNUb1JlbW92ZS5zaXplID09PSAwICYmIGF0dHJpYnV0ZVRvQ2hhbmdlID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgc3R5bGU7XG4gICAgICBpZiAoZGlzYWJsZVRyYW5zaXRpb24pIHtcbiAgICAgICAgc3R5bGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShDU1NfRElTQUJMRV9UUkFOUykpO1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGMgb2YgY2xhc3Nlc1RvQWRkKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGMgb2YgY2xhc3Nlc1RvUmVtb3ZlKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlVG9DaGFuZ2UpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvQ2hhbmdlLmtleSwgYXR0cmlidXRlVG9DaGFuZ2UudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVUcmFuc2l0aW9uKSB7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHN0eWxlKS5vcGFjaXR5O1xuICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGZ1bmN0aW9uIGRlZmF1bHRPbkNoYW5nZWQobW9kZSkge1xuICAgIHZhciBfYTtcbiAgICB1cGRhdGVIVE1MQXR0cnMoc2VsZWN0b3IsIGF0dHJpYnV0ZSwgKF9hID0gbW9kZXNbbW9kZV0pICE9IG51bGwgPyBfYSA6IG1vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIG9uQ2hhbmdlZChtb2RlKSB7XG4gICAgaWYgKG9wdGlvbnMub25DaGFuZ2VkKVxuICAgICAgb3B0aW9ucy5vbkNoYW5nZWQobW9kZSwgZGVmYXVsdE9uQ2hhbmdlZCk7XG4gICAgZWxzZVxuICAgICAgZGVmYXVsdE9uQ2hhbmdlZChtb2RlKTtcbiAgfVxuICB3YXRjaChzdGF0ZSwgb25DaGFuZ2VkLCB7IGZsdXNoOiBcInBvc3RcIiwgaW1tZWRpYXRlOiB0cnVlIH0pO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4gb25DaGFuZ2VkKHN0YXRlLnZhbHVlKSk7XG4gIGNvbnN0IGF1dG8gPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGVtaXRBdXRvID8gc3RvcmUudmFsdWUgOiBzdGF0ZS52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICBzdG9yZS52YWx1ZSA9IHY7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYXV0bywgeyBzdG9yZSwgc3lzdGVtLCBzdGF0ZSB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQ29uZmlybURpYWxvZyhyZXZlYWxlZCA9IHNoYWxsb3dSZWYoZmFsc2UpKSB7XG4gIGNvbnN0IGNvbmZpcm1Ib29rID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IGNhbmNlbEhvb2sgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgcmV2ZWFsSG9vayA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBsZXQgX3Jlc29sdmUgPSBub29wO1xuICBjb25zdCByZXZlYWwgPSAoZGF0YSkgPT4ge1xuICAgIHJldmVhbEhvb2sudHJpZ2dlcihkYXRhKTtcbiAgICByZXZlYWxlZC52YWx1ZSA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGNvbmZpcm0gPSAoZGF0YSkgPT4ge1xuICAgIHJldmVhbGVkLnZhbHVlID0gZmFsc2U7XG4gICAgY29uZmlybUhvb2sudHJpZ2dlcihkYXRhKTtcbiAgICBfcmVzb2x2ZSh7IGRhdGEsIGlzQ2FuY2VsZWQ6IGZhbHNlIH0pO1xuICB9O1xuICBjb25zdCBjYW5jZWwgPSAoZGF0YSkgPT4ge1xuICAgIHJldmVhbGVkLnZhbHVlID0gZmFsc2U7XG4gICAgY2FuY2VsSG9vay50cmlnZ2VyKGRhdGEpO1xuICAgIF9yZXNvbHZlKHsgZGF0YSwgaXNDYW5jZWxlZDogdHJ1ZSB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpc1JldmVhbGVkOiBjb21wdXRlZCgoKSA9PiByZXZlYWxlZC52YWx1ZSksXG4gICAgcmV2ZWFsLFxuICAgIGNvbmZpcm0sXG4gICAgY2FuY2VsLFxuICAgIG9uUmV2ZWFsOiByZXZlYWxIb29rLm9uLFxuICAgIG9uQ29uZmlybTogY29uZmlybUhvb2sub24sXG4gICAgb25DYW5jZWw6IGNhbmNlbEhvb2sub25cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQ291bnRkb3duKGluaXRpYWxDb3VudGRvd24sIG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcmVtYWluaW5nID0gc2hhbGxvd1JlZih0b1ZhbHVlKGluaXRpYWxDb3VudGRvd24pKTtcbiAgY29uc3QgaW50ZXJ2YWxDb250cm9sbGVyID0gdXNlSW50ZXJ2YWxGbigoKSA9PiB7XG4gICAgdmFyIF9hMiwgX2IyO1xuICAgIGNvbnN0IHZhbHVlID0gcmVtYWluaW5nLnZhbHVlIC0gMTtcbiAgICByZW1haW5pbmcudmFsdWUgPSB2YWx1ZSA8IDAgPyAwIDogdmFsdWU7XG4gICAgKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25UaWNrKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwob3B0aW9ucyk7XG4gICAgaWYgKHJlbWFpbmluZy52YWx1ZSA8PSAwKSB7XG4gICAgICBpbnRlcnZhbENvbnRyb2xsZXIucGF1c2UoKTtcbiAgICAgIChfYjIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uQ29tcGxldGUpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY2FsbChvcHRpb25zKTtcbiAgICB9XG4gIH0sIChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW50ZXJ2YWwpICE9IG51bGwgPyBfYSA6IDFlMywgeyBpbW1lZGlhdGU6IChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW1tZWRpYXRlKSAhPSBudWxsID8gX2IgOiBmYWxzZSB9KTtcbiAgY29uc3QgcmVzZXQgPSAoY291bnRkb3duKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZW1haW5pbmcudmFsdWUgPSAoX2EyID0gdG9WYWx1ZShjb3VudGRvd24pKSAhPSBudWxsID8gX2EyIDogdG9WYWx1ZShpbml0aWFsQ291bnRkb3duKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpbnRlcnZhbENvbnRyb2xsZXIucGF1c2UoKTtcbiAgICByZXNldCgpO1xuICB9O1xuICBjb25zdCByZXN1bWUgPSAoKSA9PiB7XG4gICAgaWYgKCFpbnRlcnZhbENvbnRyb2xsZXIuaXNBY3RpdmUudmFsdWUpIHtcbiAgICAgIGlmIChyZW1haW5pbmcudmFsdWUgPiAwKSB7XG4gICAgICAgIGludGVydmFsQ29udHJvbGxlci5yZXN1bWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gKGNvdW50ZG93bikgPT4ge1xuICAgIHJlc2V0KGNvdW50ZG93bik7XG4gICAgaW50ZXJ2YWxDb250cm9sbGVyLnJlc3VtZSgpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJlbWFpbmluZyxcbiAgICByZXNldCxcbiAgICBzdG9wLFxuICAgIHN0YXJ0LFxuICAgIHBhdXNlOiBpbnRlcnZhbENvbnRyb2xsZXIucGF1c2UsXG4gICAgcmVzdW1lLFxuICAgIGlzQWN0aXZlOiBpbnRlcnZhbENvbnRyb2xsZXIuaXNBY3RpdmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQ3NzVmFyKHByb3AsIHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgaW5pdGlhbFZhbHVlLCBvYnNlcnZlID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHZhcmlhYmxlID0gc2hhbGxvd1JlZihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBlbFJlZiA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHVucmVmRWxlbWVudCh0YXJnZXQpIHx8ICgoX2EgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRvY3VtZW50RWxlbWVudCk7XG4gIH0pO1xuICBmdW5jdGlvbiB1cGRhdGVDc3NWYXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGtleSA9IHRvVmFsdWUocHJvcCk7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKGVsUmVmKTtcbiAgICBpZiAoZWwgJiYgd2luZG93ICYmIGtleSkge1xuICAgICAgY29uc3QgdmFsdWUgPSAoX2EgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHJpbSgpO1xuICAgICAgdmFyaWFibGUudmFsdWUgPSB2YWx1ZSB8fCB2YXJpYWJsZS52YWx1ZSB8fCBpbml0aWFsVmFsdWU7XG4gICAgfVxuICB9XG4gIGlmIChvYnNlcnZlKSB7XG4gICAgdXNlTXV0YXRpb25PYnNlcnZlcihlbFJlZiwgdXBkYXRlQ3NzVmFyLCB7XG4gICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcInN0eWxlXCIsIFwiY2xhc3NcIl0sXG4gICAgICB3aW5kb3dcbiAgICB9KTtcbiAgfVxuICB3YXRjaChcbiAgICBbZWxSZWYsICgpID0+IHRvVmFsdWUocHJvcCldLFxuICAgIChfLCBvbGQpID0+IHtcbiAgICAgIGlmIChvbGRbMF0gJiYgb2xkWzFdKVxuICAgICAgICBvbGRbMF0uc3R5bGUucmVtb3ZlUHJvcGVydHkob2xkWzFdKTtcbiAgICAgIHVwZGF0ZUNzc1ZhcigpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICB3YXRjaChcbiAgICBbdmFyaWFibGUsIGVsUmVmXSxcbiAgICAoW3ZhbCwgZWxdKSA9PiB7XG4gICAgICBjb25zdCByYXdfcHJvcCA9IHRvVmFsdWUocHJvcCk7XG4gICAgICBpZiAoKGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5zdHlsZSkgJiYgcmF3X3Byb3ApIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KHJhd19wcm9wKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KHJhd19wcm9wLCB2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZUN1cnJlbnRFbGVtZW50KHJvb3RDb21wb25lbnQpIHtcbiAgY29uc3Qgdm0gPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBjb21wdXRlZFdpdGhDb250cm9sKFxuICAgICgpID0+IG51bGwsXG4gICAgKCkgPT4gcm9vdENvbXBvbmVudCA/IHVucmVmRWxlbWVudChyb290Q29tcG9uZW50KSA6IHZtLnByb3h5LiRlbFxuICApO1xuICBvblVwZGF0ZWQoY3VycmVudEVsZW1lbnQudHJpZ2dlcik7XG4gIG9uTW91bnRlZChjdXJyZW50RWxlbWVudC50cmlnZ2VyKTtcbiAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1c2VDeWNsZUxpc3QobGlzdCwgb3B0aW9ucykge1xuICBjb25zdCBzdGF0ZSA9IHNoYWxsb3dSZWYoZ2V0SW5pdGlhbFZhbHVlKCkpO1xuICBjb25zdCBsaXN0UmVmID0gdG9SZWYobGlzdCk7XG4gIGNvbnN0IGluZGV4ID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHRhcmdldExpc3QgPSBsaXN0UmVmLnZhbHVlO1xuICAgICAgbGV0IGluZGV4MiA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldEluZGV4T2YpID8gb3B0aW9ucy5nZXRJbmRleE9mKHN0YXRlLnZhbHVlLCB0YXJnZXRMaXN0KSA6IHRhcmdldExpc3QuaW5kZXhPZihzdGF0ZS52YWx1ZSk7XG4gICAgICBpZiAoaW5kZXgyIDwgMClcbiAgICAgICAgaW5kZXgyID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFja0luZGV4KSAhPSBudWxsID8gX2EgOiAwO1xuICAgICAgcmV0dXJuIGluZGV4MjtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICBzZXQodik7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gc2V0KGkpIHtcbiAgICBjb25zdCB0YXJnZXRMaXN0ID0gbGlzdFJlZi52YWx1ZTtcbiAgICBjb25zdCBsZW5ndGggPSB0YXJnZXRMaXN0Lmxlbmd0aDtcbiAgICBjb25zdCBpbmRleDIgPSAoaSAlIGxlbmd0aCArIGxlbmd0aCkgJSBsZW5ndGg7XG4gICAgY29uc3QgdmFsdWUgPSB0YXJnZXRMaXN0W2luZGV4Ml07XG4gICAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gc2hpZnQoZGVsdGEgPSAxKSB7XG4gICAgcmV0dXJuIHNldChpbmRleC52YWx1ZSArIGRlbHRhKTtcbiAgfVxuICBmdW5jdGlvbiBuZXh0KG4gPSAxKSB7XG4gICAgcmV0dXJuIHNoaWZ0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIHByZXYobiA9IDEpIHtcbiAgICByZXR1cm4gc2hpZnQoLW4pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSB0b1ZhbHVlKChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5pdGlhbFZhbHVlKSAhPSBudWxsID8gX2EgOiB0b1ZhbHVlKGxpc3QpWzBdKSkgIT0gbnVsbCA/IF9iIDogdm9pZCAwO1xuICB9XG4gIHdhdGNoKGxpc3RSZWYsICgpID0+IHNldChpbmRleC52YWx1ZSkpO1xuICByZXR1cm4ge1xuICAgIHN0YXRlLFxuICAgIGluZGV4LFxuICAgIG5leHQsXG4gICAgcHJldixcbiAgICBnbzogc2V0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURhcmsob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZURhcmsgPSBcImRhcmtcIixcbiAgICB2YWx1ZUxpZ2h0ID0gXCJcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbW9kZSA9IHVzZUNvbG9yTW9kZSh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBvbkNoYW5nZWQ6IChtb2RlMiwgZGVmYXVsdEhhbmRsZXIpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChvcHRpb25zLm9uQ2hhbmdlZClcbiAgICAgICAgKF9hID0gb3B0aW9ucy5vbkNoYW5nZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIG1vZGUyID09PSBcImRhcmtcIiwgZGVmYXVsdEhhbmRsZXIsIG1vZGUyKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZGVmYXVsdEhhbmRsZXIobW9kZTIpO1xuICAgIH0sXG4gICAgbW9kZXM6IHtcbiAgICAgIGRhcms6IHZhbHVlRGFyayxcbiAgICAgIGxpZ2h0OiB2YWx1ZUxpZ2h0XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3lzdGVtID0gY29tcHV0ZWQoKCkgPT4gbW9kZS5zeXN0ZW0udmFsdWUpO1xuICBjb25zdCBpc0RhcmsgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG1vZGUudmFsdWUgPT09IFwiZGFya1wiO1xuICAgIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIGNvbnN0IG1vZGVWYWwgPSB2ID8gXCJkYXJrXCIgOiBcImxpZ2h0XCI7XG4gICAgICBpZiAoc3lzdGVtLnZhbHVlID09PSBtb2RlVmFsKVxuICAgICAgICBtb2RlLnZhbHVlID0gXCJhdXRvXCI7XG4gICAgICBlbHNlXG4gICAgICAgIG1vZGUudmFsdWUgPSBtb2RlVmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpc0Rhcms7XG59XG5cbmZ1bmN0aW9uIGZuQnlwYXNzKHYpIHtcbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmblNldFNvdXJjZShzb3VyY2UsIHZhbHVlKSB7XG4gIHJldHVybiBzb3VyY2UudmFsdWUgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHREdW1wKGNsb25lKSB7XG4gIHJldHVybiBjbG9uZSA/IHR5cGVvZiBjbG9uZSA9PT0gXCJmdW5jdGlvblwiID8gY2xvbmUgOiBjbG9uZUZuSlNPTiA6IGZuQnlwYXNzO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBhcnNlKGNsb25lKSB7XG4gIHJldHVybiBjbG9uZSA/IHR5cGVvZiBjbG9uZSA9PT0gXCJmdW5jdGlvblwiID8gY2xvbmUgOiBjbG9uZUZuSlNPTiA6IGZuQnlwYXNzO1xufVxuZnVuY3Rpb24gdXNlTWFudWFsUmVmSGlzdG9yeShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY2xvbmUgPSBmYWxzZSxcbiAgICBkdW1wID0gZGVmYXVsdER1bXAoY2xvbmUpLFxuICAgIHBhcnNlID0gZGVmYXVsdFBhcnNlKGNsb25lKSxcbiAgICBzZXRTb3VyY2UgPSBmblNldFNvdXJjZVxuICB9ID0gb3B0aW9ucztcbiAgZnVuY3Rpb24gX2NyZWF0ZUhpc3RvcnlSZWNvcmQoKSB7XG4gICAgcmV0dXJuIG1hcmtSYXcoe1xuICAgICAgc25hcHNob3Q6IGR1bXAoc291cmNlLnZhbHVlKSxcbiAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wKClcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsYXN0ID0gcmVmKF9jcmVhdGVIaXN0b3J5UmVjb3JkKCkpO1xuICBjb25zdCB1bmRvU3RhY2sgPSByZWYoW10pO1xuICBjb25zdCByZWRvU3RhY2sgPSByZWYoW10pO1xuICBjb25zdCBfc2V0U291cmNlID0gKHJlY29yZCkgPT4ge1xuICAgIHNldFNvdXJjZShzb3VyY2UsIHBhcnNlKHJlY29yZC5zbmFwc2hvdCkpO1xuICAgIGxhc3QudmFsdWUgPSByZWNvcmQ7XG4gIH07XG4gIGNvbnN0IGNvbW1pdCA9ICgpID0+IHtcbiAgICB1bmRvU3RhY2sudmFsdWUudW5zaGlmdChsYXN0LnZhbHVlKTtcbiAgICBsYXN0LnZhbHVlID0gX2NyZWF0ZUhpc3RvcnlSZWNvcmQoKTtcbiAgICBpZiAob3B0aW9ucy5jYXBhY2l0eSAmJiB1bmRvU3RhY2sudmFsdWUubGVuZ3RoID4gb3B0aW9ucy5jYXBhY2l0eSlcbiAgICAgIHVuZG9TdGFjay52YWx1ZS5zcGxpY2Uob3B0aW9ucy5jYXBhY2l0eSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBpZiAocmVkb1N0YWNrLnZhbHVlLmxlbmd0aClcbiAgICAgIHJlZG9TdGFjay52YWx1ZS5zcGxpY2UoMCwgcmVkb1N0YWNrLnZhbHVlLmxlbmd0aCk7XG4gIH07XG4gIGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICAgIHVuZG9TdGFjay52YWx1ZS5zcGxpY2UoMCwgdW5kb1N0YWNrLnZhbHVlLmxlbmd0aCk7XG4gICAgcmVkb1N0YWNrLnZhbHVlLnNwbGljZSgwLCByZWRvU3RhY2sudmFsdWUubGVuZ3RoKTtcbiAgfTtcbiAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHVuZG9TdGFjay52YWx1ZS5zaGlmdCgpO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgcmVkb1N0YWNrLnZhbHVlLnVuc2hpZnQobGFzdC52YWx1ZSk7XG4gICAgICBfc2V0U291cmNlKHN0YXRlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlZG8gPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSByZWRvU3RhY2sudmFsdWUuc2hpZnQoKTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHVuZG9TdGFjay52YWx1ZS51bnNoaWZ0KGxhc3QudmFsdWUpO1xuICAgICAgX3NldFNvdXJjZShzdGF0ZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBfc2V0U291cmNlKGxhc3QudmFsdWUpO1xuICB9O1xuICBjb25zdCBoaXN0b3J5ID0gY29tcHV0ZWQoKCkgPT4gW2xhc3QudmFsdWUsIC4uLnVuZG9TdGFjay52YWx1ZV0pO1xuICBjb25zdCBjYW5VbmRvID0gY29tcHV0ZWQoKCkgPT4gdW5kb1N0YWNrLnZhbHVlLmxlbmd0aCA+IDApO1xuICBjb25zdCBjYW5SZWRvID0gY29tcHV0ZWQoKCkgPT4gcmVkb1N0YWNrLnZhbHVlLmxlbmd0aCA+IDApO1xuICByZXR1cm4ge1xuICAgIHNvdXJjZSxcbiAgICB1bmRvU3RhY2ssXG4gICAgcmVkb1N0YWNrLFxuICAgIGxhc3QsXG4gICAgaGlzdG9yeSxcbiAgICBjYW5VbmRvLFxuICAgIGNhblJlZG8sXG4gICAgY2xlYXIsXG4gICAgY29tbWl0LFxuICAgIHJlc2V0LFxuICAgIHVuZG8sXG4gICAgcmVkb1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VSZWZIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkZWVwID0gZmFsc2UsXG4gICAgZmx1c2ggPSBcInByZVwiLFxuICAgIGV2ZW50RmlsdGVyXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB7XG4gICAgZXZlbnRGaWx0ZXI6IGNvbXBvc2VkRmlsdGVyLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZTogcmVzdW1lVHJhY2tpbmcsXG4gICAgaXNBY3RpdmU6IGlzVHJhY2tpbmdcbiAgfSA9IHBhdXNhYmxlRmlsdGVyKGV2ZW50RmlsdGVyKTtcbiAgY29uc3Qge1xuICAgIGlnbm9yZVVwZGF0ZXMsXG4gICAgaWdub3JlUHJldkFzeW5jVXBkYXRlcyxcbiAgICBzdG9wXG4gIH0gPSB3YXRjaElnbm9yYWJsZShcbiAgICBzb3VyY2UsXG4gICAgY29tbWl0LFxuICAgIHsgZGVlcCwgZmx1c2gsIGV2ZW50RmlsdGVyOiBjb21wb3NlZEZpbHRlciB9XG4gICk7XG4gIGZ1bmN0aW9uIHNldFNvdXJjZShzb3VyY2UyLCB2YWx1ZSkge1xuICAgIGlnbm9yZVByZXZBc3luY1VwZGF0ZXMoKTtcbiAgICBpZ25vcmVVcGRhdGVzKCgpID0+IHtcbiAgICAgIHNvdXJjZTIudmFsdWUgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtYW51YWxIaXN0b3J5ID0gdXNlTWFudWFsUmVmSGlzdG9yeShzb3VyY2UsIHsgLi4ub3B0aW9ucywgY2xvbmU6IG9wdGlvbnMuY2xvbmUgfHwgZGVlcCwgc2V0U291cmNlIH0pO1xuICBjb25zdCB7IGNsZWFyLCBjb21taXQ6IG1hbnVhbENvbW1pdCB9ID0gbWFudWFsSGlzdG9yeTtcbiAgZnVuY3Rpb24gY29tbWl0KCkge1xuICAgIGlnbm9yZVByZXZBc3luY1VwZGF0ZXMoKTtcbiAgICBtYW51YWxDb21taXQoKTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoY29tbWl0Tm93KSB7XG4gICAgcmVzdW1lVHJhY2tpbmcoKTtcbiAgICBpZiAoY29tbWl0Tm93KVxuICAgICAgY29tbWl0KCk7XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goZm4pIHtcbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiBjYW5jZWxlZCA9IHRydWU7XG4gICAgaWdub3JlVXBkYXRlcygoKSA9PiB7XG4gICAgICBmbihjYW5jZWwpO1xuICAgIH0pO1xuICAgIGlmICghY2FuY2VsZWQpXG4gICAgICBjb21taXQoKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHN0b3AoKTtcbiAgICBjbGVhcigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ubWFudWFsSGlzdG9yeSxcbiAgICBpc1RyYWNraW5nLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBjb21taXQsXG4gICAgYmF0Y2gsXG4gICAgZGlzcG9zZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZWJvdW5jZWRSZWZIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZpbHRlciA9IG9wdGlvbnMuZGVib3VuY2UgPyBkZWJvdW5jZUZpbHRlcihvcHRpb25zLmRlYm91bmNlKSA6IHZvaWQgMDtcbiAgY29uc3QgaGlzdG9yeSA9IHVzZVJlZkhpc3Rvcnkoc291cmNlLCB7IC4uLm9wdGlvbnMsIGV2ZW50RmlsdGVyOiBmaWx0ZXIgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uaGlzdG9yeVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZXZpY2VNb3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIHJlcXVlc3RQZXJtaXNzaW9ucyA9IGZhbHNlLFxuICAgIGV2ZW50RmlsdGVyID0gYnlwYXNzRmlsdGVyXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB0eXBlb2YgRGV2aWNlTW90aW9uRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpO1xuICBjb25zdCByZXF1aXJlUGVybWlzc2lvbnMgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gaXNTdXBwb3J0ZWQudmFsdWUgJiYgXCJyZXF1ZXN0UGVybWlzc2lvblwiIGluIERldmljZU1vdGlvbkV2ZW50ICYmIHR5cGVvZiBEZXZpY2VNb3Rpb25FdmVudC5yZXF1ZXN0UGVybWlzc2lvbiA9PT0gXCJmdW5jdGlvblwiKTtcbiAgY29uc3QgcGVybWlzc2lvbkdyYW50ZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgYWNjZWxlcmF0aW9uID0gcmVmKHsgeDogbnVsbCwgeTogbnVsbCwgejogbnVsbCB9KTtcbiAgY29uc3Qgcm90YXRpb25SYXRlID0gcmVmKHsgYWxwaGE6IG51bGwsIGJldGE6IG51bGwsIGdhbW1hOiBudWxsIH0pO1xuICBjb25zdCBpbnRlcnZhbCA9IHNoYWxsb3dSZWYoMCk7XG4gIGNvbnN0IGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgPSByZWYoe1xuICAgIHg6IG51bGwsXG4gICAgeTogbnVsbCxcbiAgICB6OiBudWxsXG4gIH0pO1xuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIGNvbnN0IG9uRGV2aWNlTW90aW9uID0gY3JlYXRlRmlsdGVyV3JhcHBlcihcbiAgICAgICAgZXZlbnRGaWx0ZXIsXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pO1xuICAgICAgICAgIGFjY2VsZXJhdGlvbi52YWx1ZSA9IHtcbiAgICAgICAgICAgIHg6ICgoX2EgPSBldmVudC5hY2NlbGVyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS54KSB8fCBudWxsLFxuICAgICAgICAgICAgeTogKChfYiA9IGV2ZW50LmFjY2VsZXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnkpIHx8IG51bGwsXG4gICAgICAgICAgICB6OiAoKF9jID0gZXZlbnQuYWNjZWxlcmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2MueikgfHwgbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS52YWx1ZSA9IHtcbiAgICAgICAgICAgIHg6ICgoX2QgPSBldmVudC5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5KSA9PSBudWxsID8gdm9pZCAwIDogX2QueCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHk6ICgoX2UgPSBldmVudC5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5KSA9PSBudWxsID8gdm9pZCAwIDogX2UueSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHo6ICgoX2YgPSBldmVudC5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5KSA9PSBudWxsID8gdm9pZCAwIDogX2YueikgfHwgbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgcm90YXRpb25SYXRlLnZhbHVlID0ge1xuICAgICAgICAgICAgYWxwaGE6ICgoX2cgPSBldmVudC5yb3RhdGlvblJhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfZy5hbHBoYSkgfHwgbnVsbCxcbiAgICAgICAgICAgIGJldGE6ICgoX2ggPSBldmVudC5yb3RhdGlvblJhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfaC5iZXRhKSB8fCBudWxsLFxuICAgICAgICAgICAgZ2FtbWE6ICgoX2kgPSBldmVudC5yb3RhdGlvblJhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfaS5nYW1tYSkgfHwgbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgaW50ZXJ2YWwudmFsdWUgPSBldmVudC5pbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImRldmljZW1vdGlvblwiLCBvbkRldmljZU1vdGlvbiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBlbnN1cmVQZXJtaXNzaW9ucyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXJlcXVpcmVQZXJtaXNzaW9ucy52YWx1ZSlcbiAgICAgIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlID0gdHJ1ZTtcbiAgICBpZiAocGVybWlzc2lvbkdyYW50ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlcXVpcmVQZXJtaXNzaW9ucy52YWx1ZSkge1xuICAgICAgY29uc3QgcmVxdWVzdFBlcm1pc3Npb24gPSBEZXZpY2VNb3Rpb25FdmVudC5yZXF1ZXN0UGVybWlzc2lvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFBlcm1pc3Npb24oKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlID09PSBcImdyYW50ZWRcIikge1xuICAgICAgICAgIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICBpbml0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgaWYgKHJlcXVlc3RQZXJtaXNzaW9ucyAmJiByZXF1aXJlUGVybWlzc2lvbnMudmFsdWUpIHtcbiAgICAgIGVuc3VyZVBlcm1pc3Npb25zKCkudGhlbigoKSA9PiBpbml0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYWNjZWxlcmF0aW9uLFxuICAgIGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHksXG4gICAgcm90YXRpb25SYXRlLFxuICAgIGludGVydmFsLFxuICAgIGlzU3VwcG9ydGVkLFxuICAgIHJlcXVpcmVQZXJtaXNzaW9ucyxcbiAgICBlbnN1cmVQZXJtaXNzaW9ucyxcbiAgICBwZXJtaXNzaW9uR3JhbnRlZFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZXZpY2VPcmllbnRhdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJEZXZpY2VPcmllbnRhdGlvbkV2ZW50XCIgaW4gd2luZG93KTtcbiAgY29uc3QgaXNBYnNvbHV0ZSA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBhbHBoYSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGJldGEgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBnYW1tYSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGlmICh3aW5kb3cgJiYgaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJkZXZpY2VvcmllbnRhdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlzQWJzb2x1dGUudmFsdWUgPSBldmVudC5hYnNvbHV0ZTtcbiAgICAgIGFscGhhLnZhbHVlID0gZXZlbnQuYWxwaGE7XG4gICAgICBiZXRhLnZhbHVlID0gZXZlbnQuYmV0YTtcbiAgICAgIGdhbW1hLnZhbHVlID0gZXZlbnQuZ2FtbWE7XG4gICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNBYnNvbHV0ZSxcbiAgICBhbHBoYSxcbiAgICBiZXRhLFxuICAgIGdhbW1hXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURldmljZVBpeGVsUmF0aW8ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwaXhlbFJhdGlvID0gc2hhbGxvd1JlZigxKTtcbiAgY29uc3QgcXVlcnkgPSB1c2VNZWRpYVF1ZXJ5KCgpID0+IGAocmVzb2x1dGlvbjogJHtwaXhlbFJhdGlvLnZhbHVlfWRwcHgpYCwgb3B0aW9ucyk7XG4gIGxldCBzdG9wID0gbm9vcDtcbiAgaWYgKHdpbmRvdykge1xuICAgIHN0b3AgPSB3YXRjaEltbWVkaWF0ZShxdWVyeSwgKCkgPT4gcGl4ZWxSYXRpby52YWx1ZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBpeGVsUmF0aW86IHJlYWRvbmx5KHBpeGVsUmF0aW8pLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGV2aWNlc0xpc3Qob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yLFxuICAgIHJlcXVlc3RQZXJtaXNzaW9ucyA9IGZhbHNlLFxuICAgIGNvbnN0cmFpbnRzID0geyBhdWRpbzogdHJ1ZSwgdmlkZW86IHRydWUgfSxcbiAgICBvblVwZGF0ZWRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRldmljZXMgPSByZWYoW10pO1xuICBjb25zdCB2aWRlb0lucHV0cyA9IGNvbXB1dGVkKCgpID0+IGRldmljZXMudmFsdWUuZmlsdGVyKChpKSA9PiBpLmtpbmQgPT09IFwidmlkZW9pbnB1dFwiKSk7XG4gIGNvbnN0IGF1ZGlvSW5wdXRzID0gY29tcHV0ZWQoKCkgPT4gZGV2aWNlcy52YWx1ZS5maWx0ZXIoKGkpID0+IGkua2luZCA9PT0gXCJhdWRpb2lucHV0XCIpKTtcbiAgY29uc3QgYXVkaW9PdXRwdXRzID0gY29tcHV0ZWQoKCkgPT4gZGV2aWNlcy52YWx1ZS5maWx0ZXIoKGkpID0+IGkua2luZCA9PT0gXCJhdWRpb291dHB1dFwiKSk7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyk7XG4gIGNvbnN0IHBlcm1pc3Npb25HcmFudGVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGxldCBzdHJlYW07XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGRldmljZXMudmFsdWUgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICBvblVwZGF0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVXBkYXRlZChkZXZpY2VzLnZhbHVlKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdC5zdG9wKCkpO1xuICAgICAgc3RyZWFtID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZW5zdXJlUGVybWlzc2lvbnMoKSB7XG4gICAgY29uc3QgZGV2aWNlTmFtZSA9IGNvbnN0cmFpbnRzLnZpZGVvID8gXCJjYW1lcmFcIiA6IFwibWljcm9waG9uZVwiO1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHBlcm1pc3Npb25HcmFudGVkLnZhbHVlKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgeyBzdGF0ZSwgcXVlcnkgfSA9IHVzZVBlcm1pc3Npb24oZGV2aWNlTmFtZSwgeyBjb250cm9sczogdHJ1ZSB9KTtcbiAgICBhd2FpdCBxdWVyeSgpO1xuICAgIGlmIChzdGF0ZS52YWx1ZSAhPT0gXCJncmFudGVkXCIpIHtcbiAgICAgIGxldCBncmFudGVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RyZWFtID0gbnVsbDtcbiAgICAgICAgZ3JhbnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgICBwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSA9IGdyYW50ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlO1xuICB9XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIGlmIChyZXF1ZXN0UGVybWlzc2lvbnMpXG4gICAgICBlbnN1cmVQZXJtaXNzaW9ucygpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIobmF2aWdhdG9yLm1lZGlhRGV2aWNlcywgXCJkZXZpY2VjaGFuZ2VcIiwgdXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdXBkYXRlKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZXZpY2VzLFxuICAgIGVuc3VyZVBlcm1pc3Npb25zLFxuICAgIHBlcm1pc3Npb25HcmFudGVkLFxuICAgIHZpZGVvSW5wdXRzLFxuICAgIGF1ZGlvSW5wdXRzLFxuICAgIGF1ZGlvT3V0cHV0cyxcbiAgICBpc1N1cHBvcnRlZFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEaXNwbGF5TWVkaWEob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgZW5hYmxlZCA9IHNoYWxsb3dSZWYoKF9hID0gb3B0aW9ucy5lbmFibGVkKSAhPSBudWxsID8gX2EgOiBmYWxzZSk7XG4gIGNvbnN0IHZpZGVvID0gb3B0aW9ucy52aWRlbztcbiAgY29uc3QgYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICBjb25zdCB7IG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoX2EyID0gbmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldERpc3BsYXlNZWRpYTtcbiAgfSk7XG4gIGNvbnN0IGNvbnN0cmFpbnQgPSB7IGF1ZGlvLCB2aWRlbyB9O1xuICBjb25zdCBzdHJlYW0gPSBzaGFsbG93UmVmKCk7XG4gIGFzeW5jIGZ1bmN0aW9uIF9zdGFydCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgc3RyZWFtLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHN0cmVhbS52YWx1ZSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnQpO1xuICAgIChfYTIgPSBzdHJlYW0udmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdXNlRXZlbnRMaXN0ZW5lcih0LCBcImVuZGVkXCIsIHN0b3AsIHsgcGFzc2l2ZTogdHJ1ZSB9KSk7XG4gICAgcmV0dXJuIHN0cmVhbS52YWx1ZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBfc3RvcCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIChfYTIgPSBzdHJlYW0udmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdC5zdG9wKCkpO1xuICAgIHN0cmVhbS52YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIF9zdG9wKCk7XG4gICAgZW5hYmxlZC52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGF3YWl0IF9zdGFydCgpO1xuICAgIGlmIChzdHJlYW0udmFsdWUpXG4gICAgICBlbmFibGVkLnZhbHVlID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RyZWFtLnZhbHVlO1xuICB9XG4gIHdhdGNoKFxuICAgIGVuYWJsZWQsXG4gICAgKHYpID0+IHtcbiAgICAgIGlmICh2KVxuICAgICAgICBfc3RhcnQoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgX3N0b3AoKTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBzdHJlYW0sXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICBlbmFibGVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURvY3VtZW50VmlzaWJpbGl0eShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCB9ID0gb3B0aW9ucztcbiAgaWYgKCFkb2N1bWVudClcbiAgICByZXR1cm4gc2hhbGxvd1JlZihcInZpc2libGVcIik7XG4gIGNvbnN0IHZpc2liaWxpdHkgPSBzaGFsbG93UmVmKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgdmlzaWJpbGl0eS52YWx1ZSA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtcbiAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICByZXR1cm4gdmlzaWJpbGl0eTtcbn1cblxuZnVuY3Rpb24gdXNlRHJhZ2dhYmxlKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3Qge1xuICAgIHBvaW50ZXJUeXBlcyxcbiAgICBwcmV2ZW50RGVmYXVsdCxcbiAgICBzdG9wUHJvcGFnYXRpb24sXG4gICAgZXhhY3QsXG4gICAgb25Nb3ZlLFxuICAgIG9uRW5kLFxuICAgIG9uU3RhcnQsXG4gICAgaW5pdGlhbFZhbHVlLFxuICAgIGF4aXMgPSBcImJvdGhcIixcbiAgICBkcmFnZ2luZ0VsZW1lbnQgPSBkZWZhdWx0V2luZG93LFxuICAgIGNvbnRhaW5lckVsZW1lbnQsXG4gICAgaGFuZGxlOiBkcmFnZ2luZ0hhbmRsZSA9IHRhcmdldCxcbiAgICBidXR0b25zID0gWzBdXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwb3NpdGlvbiA9IHJlZihcbiAgICAoX2EgPSB0b1ZhbHVlKGluaXRpYWxWYWx1ZSkpICE9IG51bGwgPyBfYSA6IHsgeDogMCwgeTogMCB9XG4gICk7XG4gIGNvbnN0IHByZXNzZWREZWx0YSA9IHJlZigpO1xuICBjb25zdCBmaWx0ZXJFdmVudCA9IChlKSA9PiB7XG4gICAgaWYgKHBvaW50ZXJUeXBlcylcbiAgICAgIHJldHVybiBwb2ludGVyVHlwZXMuaW5jbHVkZXMoZS5wb2ludGVyVHlwZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUV2ZW50ID0gKGUpID0+IHtcbiAgICBpZiAodG9WYWx1ZShwcmV2ZW50RGVmYXVsdCkpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHRvVmFsdWUoc3RvcFByb3BhZ2F0aW9uKSlcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gKGUpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghdG9WYWx1ZShidXR0b25zKS5pbmNsdWRlcyhlLmJ1dHRvbikpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRvVmFsdWUob3B0aW9ucy5kaXNhYmxlZCkgfHwgIWZpbHRlckV2ZW50KGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0b1ZhbHVlKGV4YWN0KSAmJiBlLnRhcmdldCAhPT0gdG9WYWx1ZSh0YXJnZXQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRvVmFsdWUoY29udGFpbmVyRWxlbWVudCk7XG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IChfYTIgPSBjb250YWluZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChjb250YWluZXIpO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0b1ZhbHVlKHRhcmdldCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcG9zID0ge1xuICAgICAgeDogZS5jbGllbnRYIC0gKGNvbnRhaW5lciA/IHRhcmdldFJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QubGVmdCArIGNvbnRhaW5lci5zY3JvbGxMZWZ0IDogdGFyZ2V0UmVjdC5sZWZ0KSxcbiAgICAgIHk6IGUuY2xpZW50WSAtIChjb250YWluZXIgPyB0YXJnZXRSZWN0LnRvcCAtIGNvbnRhaW5lclJlY3QudG9wICsgY29udGFpbmVyLnNjcm9sbFRvcCA6IHRhcmdldFJlY3QudG9wKVxuICAgIH07XG4gICAgaWYgKChvblN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblN0YXJ0KHBvcywgZSkpID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICBwcmVzc2VkRGVsdGEudmFsdWUgPSBwb3M7XG4gICAgaGFuZGxlRXZlbnQoZSk7XG4gIH07XG4gIGNvbnN0IG1vdmUgPSAoZSkgPT4ge1xuICAgIGlmICh0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpIHx8ICFmaWx0ZXJFdmVudChlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXByZXNzZWREZWx0YS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjb250YWluZXIgPSB0b1ZhbHVlKGNvbnRhaW5lckVsZW1lbnQpO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0b1ZhbHVlKHRhcmdldCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHsgeCwgeSB9ID0gcG9zaXRpb24udmFsdWU7XG4gICAgaWYgKGF4aXMgPT09IFwieFwiIHx8IGF4aXMgPT09IFwiYm90aFwiKSB7XG4gICAgICB4ID0gZS5jbGllbnRYIC0gcHJlc3NlZERlbHRhLnZhbHVlLng7XG4gICAgICBpZiAoY29udGFpbmVyKVxuICAgICAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgeCksIGNvbnRhaW5lci5zY3JvbGxXaWR0aCAtIHRhcmdldFJlY3Qud2lkdGgpO1xuICAgIH1cbiAgICBpZiAoYXhpcyA9PT0gXCJ5XCIgfHwgYXhpcyA9PT0gXCJib3RoXCIpIHtcbiAgICAgIHkgPSBlLmNsaWVudFkgLSBwcmVzc2VkRGVsdGEudmFsdWUueTtcbiAgICAgIGlmIChjb250YWluZXIpXG4gICAgICAgIHkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB5KSwgY29udGFpbmVyLnNjcm9sbEhlaWdodCAtIHRhcmdldFJlY3QuaGVpZ2h0KTtcbiAgICB9XG4gICAgcG9zaXRpb24udmFsdWUgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgb25Nb3ZlID09IG51bGwgPyB2b2lkIDAgOiBvbk1vdmUocG9zaXRpb24udmFsdWUsIGUpO1xuICAgIGhhbmRsZUV2ZW50KGUpO1xuICB9O1xuICBjb25zdCBlbmQgPSAoZSkgPT4ge1xuICAgIGlmICh0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpIHx8ICFmaWx0ZXJFdmVudChlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXByZXNzZWREZWx0YS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBwcmVzc2VkRGVsdGEudmFsdWUgPSB2b2lkIDA7XG4gICAgb25FbmQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRW5kKHBvc2l0aW9uLnZhbHVlLCBlKTtcbiAgICBoYW5kbGVFdmVudChlKTtcbiAgfTtcbiAgaWYgKGlzQ2xpZW50KSB7XG4gICAgY29uc3QgY29uZmlnID0gKCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhcHR1cmU6IChfYTIgPSBvcHRpb25zLmNhcHR1cmUpICE9IG51bGwgPyBfYTIgOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiAhdG9WYWx1ZShwcmV2ZW50RGVmYXVsdClcbiAgICAgIH07XG4gICAgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRyYWdnaW5nSGFuZGxlLCBcInBvaW50ZXJkb3duXCIsIHN0YXJ0LCBjb25maWcpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZHJhZ2dpbmdFbGVtZW50LCBcInBvaW50ZXJtb3ZlXCIsIG1vdmUsIGNvbmZpZyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkcmFnZ2luZ0VsZW1lbnQsIFwicG9pbnRlcnVwXCIsIGVuZCwgY29uZmlnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnRvUmVmcyhwb3NpdGlvbiksXG4gICAgcG9zaXRpb24sXG4gICAgaXNEcmFnZ2luZzogY29tcHV0ZWQoKCkgPT4gISFwcmVzc2VkRGVsdGEudmFsdWUpLFxuICAgIHN0eWxlOiBjb21wdXRlZChcbiAgICAgICgpID0+IGBsZWZ0OiR7cG9zaXRpb24udmFsdWUueH1weDt0b3A6JHtwb3NpdGlvbi52YWx1ZS55fXB4O2BcbiAgICApXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURyb3Bab25lKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGlzT3ZlckRyb3Bab25lID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGZpbGVzID0gc2hhbGxvd1JlZihudWxsKTtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gIGlmIChpc0NsaWVudCkge1xuICAgIGNvbnN0IF9vcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgb25Ecm9wOiBvcHRpb25zIH0gOiBvcHRpb25zO1xuICAgIGNvbnN0IG11bHRpcGxlID0gKF9hID0gX29wdGlvbnMubXVsdGlwbGUpICE9IG51bGwgPyBfYSA6IHRydWU7XG4gICAgY29uc3QgcHJldmVudERlZmF1bHRGb3JVbmhhbmRsZWQgPSAoX2IgPSBfb3B0aW9ucy5wcmV2ZW50RGVmYXVsdEZvclVuaGFuZGxlZCkgIT0gbnVsbCA/IF9iIDogZmFsc2U7XG4gICAgY29uc3QgZ2V0RmlsZXMgPSAoZXZlbnQpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iMjtcbiAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5mcm9tKChfYjIgPSAoX2EyID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZpbGVzKSAhPSBudWxsID8gX2IyIDogW10pO1xuICAgICAgcmV0dXJuIGxpc3QubGVuZ3RoID09PSAwID8gbnVsbCA6IG11bHRpcGxlID8gbGlzdCA6IFtsaXN0WzBdXTtcbiAgICB9O1xuICAgIGNvbnN0IGNoZWNrRGF0YVR5cGVzID0gKHR5cGVzKSA9PiB7XG4gICAgICBjb25zdCBkYXRhVHlwZXMgPSB1bnJlZihfb3B0aW9ucy5kYXRhVHlwZXMpO1xuICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZXMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGRhdGFUeXBlcyh0eXBlcyk7XG4gICAgICBpZiAoIShkYXRhVHlwZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGFUeXBlcy5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0eXBlcy5ldmVyeShcbiAgICAgICAgKHR5cGUpID0+IGRhdGFUeXBlcy5zb21lKChhbGxvd2VkVHlwZSkgPT4gdHlwZS5pbmNsdWRlcyhhbGxvd2VkVHlwZSkpXG4gICAgICApO1xuICAgIH07XG4gICAgY29uc3QgY2hlY2tWYWxpZGl0eSA9IChpdGVtcykgPT4ge1xuICAgICAgY29uc3QgdHlwZXMgPSBBcnJheS5mcm9tKGl0ZW1zICE9IG51bGwgPyBpdGVtcyA6IFtdKS5tYXAoKGl0ZW0pID0+IGl0ZW0udHlwZSk7XG4gICAgICBjb25zdCBkYXRhVHlwZXNWYWxpZCA9IGNoZWNrRGF0YVR5cGVzKHR5cGVzKTtcbiAgICAgIGNvbnN0IG11bHRpcGxlRmlsZXNWYWxpZCA9IG11bHRpcGxlIHx8IGl0ZW1zLmxlbmd0aCA8PSAxO1xuICAgICAgcmV0dXJuIGRhdGFUeXBlc1ZhbGlkICYmIG11bHRpcGxlRmlsZXNWYWxpZDtcbiAgICB9O1xuICAgIGNvbnN0IGlzU2FmYXJpID0gKCkgPT4gL14oPzooPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEoXCJjaHJvbWVcIiBpbiB3aW5kb3cpO1xuICAgIGNvbnN0IGhhbmRsZURyYWdFdmVudCA9IChldmVudCwgZXZlbnRUeXBlKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjIsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgY29uc3QgZGF0YVRyYW5zZmVySXRlbUxpc3QgPSAoX2EyID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLml0ZW1zO1xuICAgICAgaXNWYWxpZCA9IChfYjIgPSBkYXRhVHJhbnNmZXJJdGVtTGlzdCAmJiBjaGVja1ZhbGlkaXR5KGRhdGFUcmFuc2Zlckl0ZW1MaXN0KSkgIT0gbnVsbCA/IF9iMiA6IGZhbHNlO1xuICAgICAgaWYgKHByZXZlbnREZWZhdWx0Rm9yVW5oYW5kbGVkKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FmYXJpKCkgJiYgIWlzVmFsaWQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcImNvcHlcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRGaWxlcyA9IGdldEZpbGVzKGV2ZW50KTtcbiAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJlbnRlclwiOlxuICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgICBpc092ZXJEcm9wWm9uZS52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgKF9jID0gX29wdGlvbnMub25FbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoX29wdGlvbnMsIG51bGwsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm92ZXJcIjpcbiAgICAgICAgICAoX2QgPSBfb3B0aW9ucy5vbk92ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKF9vcHRpb25zLCBudWxsLCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWF2ZVwiOlxuICAgICAgICAgIGNvdW50ZXIgLT0gMTtcbiAgICAgICAgICBpZiAoY291bnRlciA9PT0gMClcbiAgICAgICAgICAgIGlzT3ZlckRyb3Bab25lLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgKF9lID0gX29wdGlvbnMub25MZWF2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNhbGwoX29wdGlvbnMsIG51bGwsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRyb3BcIjpcbiAgICAgICAgICBjb3VudGVyID0gMDtcbiAgICAgICAgICBpc092ZXJEcm9wWm9uZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICBmaWxlcy52YWx1ZSA9IGN1cnJlbnRGaWxlcztcbiAgICAgICAgICAgIChfZiA9IF9vcHRpb25zLm9uRHJvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmNhbGwoX29wdGlvbnMsIGN1cnJlbnRGaWxlcywgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyYWdlbnRlclwiLCAoZXZlbnQpID0+IGhhbmRsZURyYWdFdmVudChldmVudCwgXCJlbnRlclwiKSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZHJhZ292ZXJcIiwgKGV2ZW50KSA9PiBoYW5kbGVEcmFnRXZlbnQoZXZlbnQsIFwib3ZlclwiKSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZHJhZ2xlYXZlXCIsIChldmVudCkgPT4gaGFuZGxlRHJhZ0V2ZW50KGV2ZW50LCBcImxlYXZlXCIpKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJkcm9wXCIsIChldmVudCkgPT4gaGFuZGxlRHJhZ0V2ZW50KGV2ZW50LCBcImRyb3BcIikpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsZXMsXG4gICAgaXNPdmVyRHJvcFpvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUmVzaXplT2JzZXJ2ZXIodGFyZ2V0LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgLi4ub2JzZXJ2ZXJPcHRpb25zIH0gPSBvcHRpb25zO1xuICBsZXQgb2JzZXJ2ZXI7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIlJlc2l6ZU9ic2VydmVyXCIgaW4gd2luZG93KTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG9ic2VydmVyID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdGFyZ2V0cyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCBfdGFyZ2V0cyA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShfdGFyZ2V0cykgPyBfdGFyZ2V0cy5tYXAoKGVsKSA9PiB1bnJlZkVsZW1lbnQoZWwpKSA6IFt1bnJlZkVsZW1lbnQoX3RhcmdldHMpXTtcbiAgfSk7XG4gIGNvbnN0IHN0b3BXYXRjaCA9IHdhdGNoKFxuICAgIHRhcmdldHMsXG4gICAgKGVscykgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHdpbmRvdykge1xuICAgICAgICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihjYWxsYmFjayk7XG4gICAgICAgIGZvciAoY29uc3QgX2VsIG9mIGVscykge1xuICAgICAgICAgIGlmIChfZWwpXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKF9lbCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUsIGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgY2xlYW51cCgpO1xuICAgIHN0b3BXYXRjaCgpO1xuICB9O1xuICB0cnlPblNjb3BlRGlzcG9zZShzdG9wKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUVsZW1lbnRCb3VuZGluZyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcmVzZXQgPSB0cnVlLFxuICAgIHdpbmRvd1Jlc2l6ZSA9IHRydWUsXG4gICAgd2luZG93U2Nyb2xsID0gdHJ1ZSxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIHVwZGF0ZVRpbWluZyA9IFwic3luY1wiXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBoZWlnaHQgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBib3R0b20gPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBsZWZ0ID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgcmlnaHQgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCB0b3AgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCB3aWR0aCA9IHNoYWxsb3dSZWYoMCk7XG4gIGNvbnN0IHggPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCB5ID0gc2hhbGxvd1JlZigwKTtcbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGUoKSB7XG4gICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaGVpZ2h0LnZhbHVlID0gMDtcbiAgICAgICAgYm90dG9tLnZhbHVlID0gMDtcbiAgICAgICAgbGVmdC52YWx1ZSA9IDA7XG4gICAgICAgIHJpZ2h0LnZhbHVlID0gMDtcbiAgICAgICAgdG9wLnZhbHVlID0gMDtcbiAgICAgICAgd2lkdGgudmFsdWUgPSAwO1xuICAgICAgICB4LnZhbHVlID0gMDtcbiAgICAgICAgeS52YWx1ZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBoZWlnaHQudmFsdWUgPSByZWN0LmhlaWdodDtcbiAgICBib3R0b20udmFsdWUgPSByZWN0LmJvdHRvbTtcbiAgICBsZWZ0LnZhbHVlID0gcmVjdC5sZWZ0O1xuICAgIHJpZ2h0LnZhbHVlID0gcmVjdC5yaWdodDtcbiAgICB0b3AudmFsdWUgPSByZWN0LnRvcDtcbiAgICB3aWR0aC52YWx1ZSA9IHJlY3Qud2lkdGg7XG4gICAgeC52YWx1ZSA9IHJlY3QueDtcbiAgICB5LnZhbHVlID0gcmVjdC55O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBpZiAodXBkYXRlVGltaW5nID09PSBcInN5bmNcIilcbiAgICAgIHJlY2FsY3VsYXRlKCk7XG4gICAgZWxzZSBpZiAodXBkYXRlVGltaW5nID09PSBcIm5leHQtZnJhbWVcIilcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiByZWNhbGN1bGF0ZSgpKTtcbiAgfVxuICB1c2VSZXNpemVPYnNlcnZlcih0YXJnZXQsIHVwZGF0ZSk7XG4gIHdhdGNoKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpLCAoZWxlKSA9PiAhZWxlICYmIHVwZGF0ZSgpKTtcbiAgdXNlTXV0YXRpb25PYnNlcnZlcih0YXJnZXQsIHVwZGF0ZSwge1xuICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wic3R5bGVcIiwgXCJjbGFzc1wiXVxuICB9KTtcbiAgaWYgKHdpbmRvd1Njcm9sbClcbiAgICB1c2VFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHVwZGF0ZSwgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pO1xuICBpZiAod2luZG93UmVzaXplKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgaWYgKGltbWVkaWF0ZSlcbiAgICAgIHVwZGF0ZSgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgdG9wLFxuICAgIHdpZHRoLFxuICAgIHgsXG4gICAgeSxcbiAgICB1cGRhdGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRWxlbWVudEJ5UG9pbnQob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50LFxuICAgIG11bHRpcGxlLFxuICAgIGludGVydmFsID0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICBpbW1lZGlhdGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB7XG4gICAgaWYgKHRvVmFsdWUobXVsdGlwbGUpKVxuICAgICAgcmV0dXJuIGRvY3VtZW50ICYmIFwiZWxlbWVudHNGcm9tUG9pbnRcIiBpbiBkb2N1bWVudDtcbiAgICByZXR1cm4gZG9jdW1lbnQgJiYgXCJlbGVtZW50RnJvbVBvaW50XCIgaW4gZG9jdW1lbnQ7XG4gIH0pO1xuICBjb25zdCBlbGVtZW50ID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgY2IgPSAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBlbGVtZW50LnZhbHVlID0gdG9WYWx1ZShtdWx0aXBsZSkgPyAoX2EgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQodG9WYWx1ZSh4KSwgdG9WYWx1ZSh5KSkpICE9IG51bGwgPyBfYSA6IFtdIDogKF9iID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG9WYWx1ZSh4KSwgdG9WYWx1ZSh5KSkpICE9IG51bGwgPyBfYiA6IG51bGw7XG4gIH07XG4gIGNvbnN0IGNvbnRyb2xzID0gaW50ZXJ2YWwgPT09IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIgPyB1c2VSYWZGbihjYiwgeyBpbW1lZGlhdGUgfSkgOiB1c2VJbnRlcnZhbEZuKGNiLCBpbnRlcnZhbCwgeyBpbW1lZGlhdGUgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgZWxlbWVudCxcbiAgICAuLi5jb250cm9sc1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50SG92ZXIoZWwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZGVsYXlFbnRlciA9IDAsXG4gICAgZGVsYXlMZWF2ZSA9IDAsXG4gICAgdHJpZ2dlck9uUmVtb3ZhbCA9IGZhbHNlLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzSG92ZXJlZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBsZXQgdGltZXI7XG4gIGNvbnN0IHRvZ2dsZSA9IChlbnRlcmluZykgPT4ge1xuICAgIGNvbnN0IGRlbGF5ID0gZW50ZXJpbmcgPyBkZWxheUVudGVyIDogZGVsYXlMZWF2ZTtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGRlbGF5KVxuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGlzSG92ZXJlZC52YWx1ZSA9IGVudGVyaW5nLCBkZWxheSk7XG4gICAgZWxzZVxuICAgICAgaXNIb3ZlcmVkLnZhbHVlID0gZW50ZXJpbmc7XG4gIH07XG4gIGlmICghd2luZG93KVxuICAgIHJldHVybiBpc0hvdmVyZWQ7XG4gIHVzZUV2ZW50TGlzdGVuZXIoZWwsIFwibW91c2VlbnRlclwiLCAoKSA9PiB0b2dnbGUodHJ1ZSksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihlbCwgXCJtb3VzZWxlYXZlXCIsICgpID0+IHRvZ2dsZShmYWxzZSksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgaWYgKHRyaWdnZXJPblJlbW92YWwpIHtcbiAgICBvbkVsZW1lbnRSZW1vdmFsKFxuICAgICAgY29tcHV0ZWQoKCkgPT4gdW5yZWZFbGVtZW50KGVsKSksXG4gICAgICAoKSA9PiB0b2dnbGUoZmFsc2UpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gaXNIb3ZlcmVkO1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50U2l6ZSh0YXJnZXQsIGluaXRpYWxTaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIGJveCA9IFwiY29udGVudC1ib3hcIiB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTVkcgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdW5yZWZFbGVtZW50KHRhcmdldCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lc3BhY2VVUkkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhcInN2Z1wiKTtcbiAgfSk7XG4gIGNvbnN0IHdpZHRoID0gc2hhbGxvd1JlZihpbml0aWFsU2l6ZS53aWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IHNoYWxsb3dSZWYoaW5pdGlhbFNpemUuaGVpZ2h0KTtcbiAgY29uc3QgeyBzdG9wOiBzdG9wMSB9ID0gdXNlUmVzaXplT2JzZXJ2ZXIoXG4gICAgdGFyZ2V0LFxuICAgIChbZW50cnldKSA9PiB7XG4gICAgICBjb25zdCBib3hTaXplID0gYm94ID09PSBcImJvcmRlci1ib3hcIiA/IGVudHJ5LmJvcmRlckJveFNpemUgOiBib3ggPT09IFwiY29udGVudC1ib3hcIiA/IGVudHJ5LmNvbnRlbnRCb3hTaXplIDogZW50cnkuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTtcbiAgICAgIGlmICh3aW5kb3cgJiYgaXNTVkcudmFsdWUpIHtcbiAgICAgICAgY29uc3QgJGVsZW0gPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCRlbGVtKSB7XG4gICAgICAgICAgY29uc3QgcmVjdCA9ICRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHdpZHRoLnZhbHVlID0gcmVjdC53aWR0aDtcbiAgICAgICAgICBoZWlnaHQudmFsdWUgPSByZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJveFNpemUpIHtcbiAgICAgICAgICBjb25zdCBmb3JtYXRCb3hTaXplID0gdG9BcnJheShib3hTaXplKTtcbiAgICAgICAgICB3aWR0aC52YWx1ZSA9IGZvcm1hdEJveFNpemUucmVkdWNlKChhY2MsIHsgaW5saW5lU2l6ZSB9KSA9PiBhY2MgKyBpbmxpbmVTaXplLCAwKTtcbiAgICAgICAgICBoZWlnaHQudmFsdWUgPSBmb3JtYXRCb3hTaXplLnJlZHVjZSgoYWNjLCB7IGJsb2NrU2l6ZSB9KSA9PiBhY2MgKyBibG9ja1NpemUsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoLnZhbHVlID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0LnZhbHVlID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgY29uc3QgZWxlID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgaWYgKGVsZSkge1xuICAgICAgd2lkdGgudmFsdWUgPSBcIm9mZnNldFdpZHRoXCIgaW4gZWxlID8gZWxlLm9mZnNldFdpZHRoIDogaW5pdGlhbFNpemUud2lkdGg7XG4gICAgICBoZWlnaHQudmFsdWUgPSBcIm9mZnNldEhlaWdodFwiIGluIGVsZSA/IGVsZS5vZmZzZXRIZWlnaHQgOiBpbml0aWFsU2l6ZS5oZWlnaHQ7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RvcDIgPSB3YXRjaChcbiAgICAoKSA9PiB1bnJlZkVsZW1lbnQodGFyZ2V0KSxcbiAgICAoZWxlKSA9PiB7XG4gICAgICB3aWR0aC52YWx1ZSA9IGVsZSA/IGluaXRpYWxTaXplLndpZHRoIDogMDtcbiAgICAgIGhlaWdodC52YWx1ZSA9IGVsZSA/IGluaXRpYWxTaXplLmhlaWdodCA6IDA7XG4gICAgfVxuICApO1xuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHN0b3AxKCk7XG4gICAgc3RvcDIoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbk9ic2VydmVyKHRhcmdldCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcm9vdCxcbiAgICByb290TWFyZ2luID0gXCIwcHhcIixcbiAgICB0aHJlc2hvbGQgPSAwLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgaW1tZWRpYXRlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcIiBpbiB3aW5kb3cpO1xuICBjb25zdCB0YXJnZXRzID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IF90YXJnZXQgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgcmV0dXJuIHRvQXJyYXkoX3RhcmdldCkubWFwKHVucmVmRWxlbWVudCkuZmlsdGVyKG5vdE51bGxpc2gpO1xuICB9KTtcbiAgbGV0IGNsZWFudXAgPSBub29wO1xuICBjb25zdCBpc0FjdGl2ZSA9IHNoYWxsb3dSZWYoaW1tZWRpYXRlKTtcbiAgY29uc3Qgc3RvcFdhdGNoID0gaXNTdXBwb3J0ZWQudmFsdWUgPyB3YXRjaChcbiAgICAoKSA9PiBbdGFyZ2V0cy52YWx1ZSwgdW5yZWZFbGVtZW50KHJvb3QpLCBpc0FjdGl2ZS52YWx1ZV0sXG4gICAgKFt0YXJnZXRzMiwgcm9vdDJdKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpZiAoIWlzQWN0aXZlLnZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIXRhcmdldHMyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICB7XG4gICAgICAgICAgcm9vdDogdW5yZWZFbGVtZW50KHJvb3QyKSxcbiAgICAgICAgICByb290TWFyZ2luLFxuICAgICAgICAgIHRocmVzaG9sZFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGFyZ2V0czIuZm9yRWFjaCgoZWwpID0+IGVsICYmIG9ic2VydmVyLm9ic2VydmUoZWwpKTtcbiAgICAgIGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgY2xlYW51cCA9IG5vb3A7XG4gICAgICB9O1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGUsIGZsdXNoOiBcInBvc3RcIiB9XG4gICkgOiBub29wO1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgICBzdG9wV2F0Y2goKTtcbiAgICBpc0FjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICB0cnlPblNjb3BlRGlzcG9zZShzdG9wKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc0FjdGl2ZSxcbiAgICBwYXVzZSgpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGlzQWN0aXZlLnZhbHVlID0gZmFsc2U7XG4gICAgfSxcbiAgICByZXN1bWUoKSB7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IHRydWU7XG4gICAgfSxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUVsZW1lbnRWaXNpYmlsaXR5KGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBzY3JvbGxUYXJnZXQsXG4gICAgdGhyZXNob2xkID0gMCxcbiAgICByb290TWFyZ2luLFxuICAgIG9uY2UgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZWxlbWVudElzVmlzaWJsZSA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCB7IHN0b3AgfSA9IHVzZUludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgIGVsZW1lbnQsXG4gICAgKGludGVyc2VjdGlvbk9ic2VydmVyRW50cmllcykgPT4ge1xuICAgICAgbGV0IGlzSW50ZXJzZWN0aW5nID0gZWxlbWVudElzVmlzaWJsZS52YWx1ZTtcbiAgICAgIGxldCBsYXRlc3RUaW1lID0gMDtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyaWVzKSB7XG4gICAgICAgIGlmIChlbnRyeS50aW1lID49IGxhdGVzdFRpbWUpIHtcbiAgICAgICAgICBsYXRlc3RUaW1lID0gZW50cnkudGltZTtcbiAgICAgICAgICBpc0ludGVyc2VjdGluZyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbGVtZW50SXNWaXNpYmxlLnZhbHVlID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICBpZiAob25jZSkge1xuICAgICAgICB3YXRjaE9uY2UoZWxlbWVudElzVmlzaWJsZSwgKCkgPT4ge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICByb290OiBzY3JvbGxUYXJnZXQsXG4gICAgICB3aW5kb3csXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICByb290TWFyZ2luOiB0b1ZhbHVlKHJvb3RNYXJnaW4pXG4gICAgfVxuICApO1xuICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcbn1cblxuY29uc3QgZXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gdXNlRXZlbnRCdXMoa2V5KSB7XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGZ1bmN0aW9uIG9uKGxpc3RlbmVyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGV2ZW50cy5nZXQoa2V5KSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIGV2ZW50cy5zZXQoa2V5LCBsaXN0ZW5lcnMpO1xuICAgIGNvbnN0IF9vZmYgPSAoKSA9PiBvZmYobGlzdGVuZXIpO1xuICAgIChfYSA9IHNjb3BlID09IG51bGwgPyB2b2lkIDAgOiBzY29wZS5jbGVhbnVwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnB1c2goX29mZik7XG4gICAgcmV0dXJuIF9vZmY7XG4gIH1cbiAgZnVuY3Rpb24gb25jZShsaXN0ZW5lcikge1xuICAgIGZ1bmN0aW9uIF9saXN0ZW5lciguLi5hcmdzKSB7XG4gICAgICBvZmYoX2xpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gb24oX2xpc3RlbmVyKTtcbiAgfVxuICBmdW5jdGlvbiBvZmYobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBldmVudHMuZ2V0KGtleSk7XG4gICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICByZXR1cm47XG4gICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgaWYgKCFsaXN0ZW5lcnMuc2l6ZSlcbiAgICAgIHJlc2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZXZlbnRzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXQoZXZlbnQsIHBheWxvYWQpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gZXZlbnRzLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9yRWFjaCgodikgPT4gdihldmVudCwgcGF5bG9hZCkpO1xuICB9XG4gIHJldHVybiB7IG9uLCBvbmNlLCBvZmYsIGVtaXQsIHJlc2V0IH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOZXN0ZWRPcHRpb25zJDEob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSlcbiAgICByZXR1cm4ge307XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gdXNlRXZlbnRTb3VyY2UodXJsLCBldmVudHMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGV2ZW50ID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgZGF0YSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IHN0YXR1cyA9IHNoYWxsb3dSZWYoXCJDT05ORUNUSU5HXCIpO1xuICBjb25zdCBldmVudFNvdXJjZSA9IHJlZihudWxsKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCB1cmxSZWYgPSB0b1JlZih1cmwpO1xuICBjb25zdCBsYXN0RXZlbnRJZCA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGxldCBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gIGxldCByZXRyaWVkID0gMDtcbiAgY29uc3Qge1xuICAgIHdpdGhDcmVkZW50aWFscyA9IGZhbHNlLFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgYXV0b0Nvbm5lY3QgPSB0cnVlLFxuICAgIGF1dG9SZWNvbm5lY3RcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgIGlmIChpc0NsaWVudCAmJiBldmVudFNvdXJjZS52YWx1ZSkge1xuICAgICAgZXZlbnRTb3VyY2UudmFsdWUuY2xvc2UoKTtcbiAgICAgIGV2ZW50U291cmNlLnZhbHVlID0gbnVsbDtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiQ0xPU0VEXCI7XG4gICAgICBleHBsaWNpdGx5Q2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IF9pbml0ID0gKCkgPT4ge1xuICAgIGlmIChleHBsaWNpdGx5Q2xvc2VkIHx8IHR5cGVvZiB1cmxSZWYudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXMgPSBuZXcgRXZlbnRTb3VyY2UodXJsUmVmLnZhbHVlLCB7IHdpdGhDcmVkZW50aWFscyB9KTtcbiAgICBzdGF0dXMudmFsdWUgPSBcIkNPTk5FQ1RJTkdcIjtcbiAgICBldmVudFNvdXJjZS52YWx1ZSA9IGVzO1xuICAgIGVzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiT1BFTlwiO1xuICAgICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgIH07XG4gICAgZXMub25lcnJvciA9IChlKSA9PiB7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcIkNMT1NFRFwiO1xuICAgICAgZXJyb3IudmFsdWUgPSBlO1xuICAgICAgaWYgKGVzLnJlYWR5U3RhdGUgPT09IDIgJiYgIWV4cGxpY2l0bHlDbG9zZWQgJiYgYXV0b1JlY29ubmVjdCkge1xuICAgICAgICBlcy5jbG9zZSgpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmV0cmllcyA9IC0xLFxuICAgICAgICAgIGRlbGF5ID0gMWUzLFxuICAgICAgICAgIG9uRmFpbGVkXG4gICAgICAgIH0gPSByZXNvbHZlTmVzdGVkT3B0aW9ucyQxKGF1dG9SZWNvbm5lY3QpO1xuICAgICAgICByZXRyaWVkICs9IDE7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0cmllcyA9PT0gXCJudW1iZXJcIiAmJiAocmV0cmllcyA8IDAgfHwgcmV0cmllZCA8IHJldHJpZXMpKVxuICAgICAgICAgIHNldFRpbWVvdXQoX2luaXQsIGRlbGF5KTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJldHJpZXMgPT09IFwiZnVuY3Rpb25cIiAmJiByZXRyaWVzKCkpXG4gICAgICAgICAgc2V0VGltZW91dChfaW5pdCwgZGVsYXkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb25GYWlsZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmFpbGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBlcy5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgZXZlbnQudmFsdWUgPSBudWxsO1xuICAgICAgZGF0YS52YWx1ZSA9IGUuZGF0YTtcbiAgICAgIGxhc3RFdmVudElkLnZhbHVlID0gZS5sYXN0RXZlbnRJZDtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZXZlbnRfbmFtZSBvZiBldmVudHMpIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoZXMsIGV2ZW50X25hbWUsIChlKSA9PiB7XG4gICAgICAgIGV2ZW50LnZhbHVlID0gZXZlbnRfbmFtZTtcbiAgICAgICAgZGF0YS52YWx1ZSA9IGUuZGF0YSB8fCBudWxsO1xuICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb3BlbiA9ICgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNsb3NlKCk7XG4gICAgZXhwbGljaXRseUNsb3NlZCA9IGZhbHNlO1xuICAgIHJldHJpZWQgPSAwO1xuICAgIF9pbml0KCk7XG4gIH07XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgb3BlbigpO1xuICBpZiAoYXV0b0Nvbm5lY3QpXG4gICAgd2F0Y2godXJsUmVmLCBvcGVuKTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoY2xvc2UpO1xuICByZXR1cm4ge1xuICAgIGV2ZW50U291cmNlLFxuICAgIGV2ZW50LFxuICAgIGRhdGEsXG4gICAgc3RhdHVzLFxuICAgIGVycm9yLFxuICAgIG9wZW4sXG4gICAgY2xvc2UsXG4gICAgbGFzdEV2ZW50SWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRXllRHJvcHBlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBpbml0aWFsVmFsdWUgPSBcIlwiIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwiRXllRHJvcHBlclwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IHNSR0JIZXggPSBzaGFsbG93UmVmKGluaXRpYWxWYWx1ZSk7XG4gIGFzeW5jIGZ1bmN0aW9uIG9wZW4ob3Blbk9wdGlvbnMpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGV5ZURyb3BwZXIgPSBuZXcgd2luZG93LkV5ZURyb3BwZXIoKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleWVEcm9wcGVyLm9wZW4ob3Blbk9wdGlvbnMpO1xuICAgIHNSR0JIZXgudmFsdWUgPSByZXN1bHQuc1JHQkhleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiB7IGlzU3VwcG9ydGVkLCBzUkdCSGV4LCBvcGVuIH07XG59XG5cbmZ1bmN0aW9uIHVzZUZhdmljb24obmV3SWNvbiA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCA9IFwiXCIsXG4gICAgcmVsID0gXCJpY29uXCIsXG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZhdmljb24gPSB0b1JlZihuZXdJY29uKTtcbiAgY29uc3QgYXBwbHlJY29uID0gKGljb24pID0+IHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoYGxpbmtbcmVsKj1cIiR7cmVsfVwiXWApO1xuICAgIGlmICghZWxlbWVudHMgfHwgZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgbGluay5yZWwgPSByZWw7XG4gICAgICAgIGxpbmsuaHJlZiA9IGAke2Jhc2VVcmx9JHtpY29ufWA7XG4gICAgICAgIGxpbmsudHlwZSA9IGBpbWFnZS8ke2ljb24uc3BsaXQoXCIuXCIpLnBvcCgpfWA7XG4gICAgICAgIGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5oZWFkLmFwcGVuZChsaW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudHMgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiBlbC5ocmVmID0gYCR7YmFzZVVybH0ke2ljb259YCk7XG4gIH07XG4gIHdhdGNoKFxuICAgIGZhdmljb24sXG4gICAgKGksIG8pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaSA9PT0gXCJzdHJpbmdcIiAmJiBpICE9PSBvKVxuICAgICAgICBhcHBseUljb24oaSk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHJldHVybiBmYXZpY29uO1xufVxuXG5jb25zdCBwYXlsb2FkTWFwcGluZyA9IHtcbiAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gIHRleHQ6IFwidGV4dC9wbGFpblwiXG59O1xuZnVuY3Rpb24gaXNGZXRjaE9wdGlvbnMob2JqKSB7XG4gIHJldHVybiBvYmogJiYgY29udGFpbnNQcm9wKG9iaiwgXCJpbW1lZGlhdGVcIiwgXCJyZWZldGNoXCIsIFwiaW5pdGlhbERhdGFcIiwgXCJ0aW1lb3V0XCIsIFwiYmVmb3JlRmV0Y2hcIiwgXCJhZnRlckZldGNoXCIsIFwib25GZXRjaEVycm9yXCIsIFwiZmV0Y2hcIiwgXCJ1cGRhdGVEYXRhT25FcnJvclwiKTtcbn1cbmNvbnN0IHJlQWJzb2x1dGUgPSAvXig/OlthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC8vaTtcbmZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIHJldHVybiByZUFic29sdXRlLnRlc3QodXJsKTtcbn1cbmZ1bmN0aW9uIGhlYWRlcnNUb09iamVjdChoZWFkZXJzKSB7XG4gIGlmICh0eXBlb2YgSGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycylcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMuZW50cmllcygpKTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBjb21iaW5lQ2FsbGJhY2tzKGNvbWJpbmF0aW9uLCAuLi5jYWxsYmFja3MpIHtcbiAgaWYgKGNvbWJpbmF0aW9uID09PSBcIm92ZXJ3cml0ZVwiKSB7XG4gICAgcmV0dXJuIGFzeW5jIChjdHgpID0+IHtcbiAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgIGZvciAobGV0IGkgPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrc1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHsgLi4uY3R4LCAuLi5hd2FpdCBjYWxsYmFjayhjdHgpIH07XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzeW5jIChjdHgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICBjdHggPSB7IC4uLmN0eCwgLi4uYXdhaXQgY2FsbGJhY2soY3R4KSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaChjb25maWcgPSB7fSkge1xuICBjb25zdCBfY29tYmluYXRpb24gPSBjb25maWcuY29tYmluYXRpb24gfHwgXCJjaGFpblwiO1xuICBjb25zdCBfb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IHt9O1xuICBjb25zdCBfZmV0Y2hPcHRpb25zID0gY29uZmlnLmZldGNoT3B0aW9ucyB8fCB7fTtcbiAgZnVuY3Rpb24gdXNlRmFjdG9yeUZldGNoKHVybCwgLi4uYXJncykge1xuICAgIGNvbnN0IGNvbXB1dGVkVXJsID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgY29uc3QgYmFzZVVybCA9IHRvVmFsdWUoY29uZmlnLmJhc2VVcmwpO1xuICAgICAgY29uc3QgdGFyZ2V0VXJsID0gdG9WYWx1ZSh1cmwpO1xuICAgICAgcmV0dXJuIGJhc2VVcmwgJiYgIWlzQWJzb2x1dGVVUkwodGFyZ2V0VXJsKSA/IGpvaW5QYXRocyhiYXNlVXJsLCB0YXJnZXRVcmwpIDogdGFyZ2V0VXJsO1xuICAgIH0pO1xuICAgIGxldCBvcHRpb25zID0gX29wdGlvbnM7XG4gICAgbGV0IGZldGNoT3B0aW9ucyA9IF9mZXRjaE9wdGlvbnM7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGlzRmV0Y2hPcHRpb25zKGFyZ3NbMF0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5hcmdzWzBdLFxuICAgICAgICAgIGJlZm9yZUZldGNoOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMuYmVmb3JlRmV0Y2gsIGFyZ3NbMF0uYmVmb3JlRmV0Y2gpLFxuICAgICAgICAgIGFmdGVyRmV0Y2g6IGNvbWJpbmVDYWxsYmFja3MoX2NvbWJpbmF0aW9uLCBfb3B0aW9ucy5hZnRlckZldGNoLCBhcmdzWzBdLmFmdGVyRmV0Y2gpLFxuICAgICAgICAgIG9uRmV0Y2hFcnJvcjogY29tYmluZUNhbGxiYWNrcyhfY29tYmluYXRpb24sIF9vcHRpb25zLm9uRmV0Y2hFcnJvciwgYXJnc1swXS5vbkZldGNoRXJyb3IpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgICAgIC4uLmFyZ3NbMF0sXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uaGVhZGVyc1RvT2JqZWN0KGZldGNoT3B0aW9ucy5oZWFkZXJzKSB8fCB7fSxcbiAgICAgICAgICAgIC4uLmhlYWRlcnNUb09iamVjdChhcmdzWzBdLmhlYWRlcnMpIHx8IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPiAxICYmIGlzRmV0Y2hPcHRpb25zKGFyZ3NbMV0pKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5hcmdzWzFdLFxuICAgICAgICBiZWZvcmVGZXRjaDogY29tYmluZUNhbGxiYWNrcyhfY29tYmluYXRpb24sIF9vcHRpb25zLmJlZm9yZUZldGNoLCBhcmdzWzFdLmJlZm9yZUZldGNoKSxcbiAgICAgICAgYWZ0ZXJGZXRjaDogY29tYmluZUNhbGxiYWNrcyhfY29tYmluYXRpb24sIF9vcHRpb25zLmFmdGVyRmV0Y2gsIGFyZ3NbMV0uYWZ0ZXJGZXRjaCksXG4gICAgICAgIG9uRmV0Y2hFcnJvcjogY29tYmluZUNhbGxiYWNrcyhfY29tYmluYXRpb24sIF9vcHRpb25zLm9uRmV0Y2hFcnJvciwgYXJnc1sxXS5vbkZldGNoRXJyb3IpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdXNlRmV0Y2goY29tcHV0ZWRVcmwsIGZldGNoT3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHVzZUZhY3RvcnlGZXRjaDtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoKHVybCwgLi4uYXJncykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHN1cHBvcnRzQWJvcnQgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSBcImZ1bmN0aW9uXCI7XG4gIGxldCBmZXRjaE9wdGlvbnMgPSB7fTtcbiAgbGV0IG9wdGlvbnMgPSB7XG4gICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgIHJlZmV0Y2g6IGZhbHNlLFxuICAgIHRpbWVvdXQ6IDAsXG4gICAgdXBkYXRlRGF0YU9uRXJyb3I6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgcGF5bG9hZDogdm9pZCAwXG4gIH07XG4gIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoaXNGZXRjaE9wdGlvbnMoYXJnc1swXSkpXG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCAuLi5hcmdzWzBdIH07XG4gICAgZWxzZVxuICAgICAgZmV0Y2hPcHRpb25zID0gYXJnc1swXTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGlzRmV0Y2hPcHRpb25zKGFyZ3NbMV0pKVxuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgLi4uYXJnc1sxXSB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBmZXRjaCA9IChfYSA9IGRlZmF1bHRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mZXRjaCxcbiAgICBpbml0aWFsRGF0YSxcbiAgICB0aW1lb3V0XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXNwb25zZUV2ZW50ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IGVycm9yRXZlbnQgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgZmluYWxseUV2ZW50ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IGlzRmluaXNoZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgaXNGZXRjaGluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBhYm9ydGVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHN0YXR1c0NvZGUgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCByZXNwb25zZSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgZGF0YSA9IHNoYWxsb3dSZWYoaW5pdGlhbERhdGEgfHwgbnVsbCk7XG4gIGNvbnN0IGNhbkFib3J0ID0gY29tcHV0ZWQoKCkgPT4gc3VwcG9ydHNBYm9ydCAmJiBpc0ZldGNoaW5nLnZhbHVlKTtcbiAgbGV0IGNvbnRyb2xsZXI7XG4gIGxldCB0aW1lcjtcbiAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgaWYgKHN1cHBvcnRzQWJvcnQpIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb250cm9sbGVyLnNpZ25hbC5vbmFib3J0ID0gKCkgPT4gYWJvcnRlZC52YWx1ZSA9IHRydWU7XG4gICAgICBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxvYWRpbmcgPSAoaXNMb2FkaW5nKSA9PiB7XG4gICAgaXNGZXRjaGluZy52YWx1ZSA9IGlzTG9hZGluZztcbiAgICBpc0ZpbmlzaGVkLnZhbHVlID0gIWlzTG9hZGluZztcbiAgfTtcbiAgaWYgKHRpbWVvdXQpXG4gICAgdGltZXIgPSB1c2VUaW1lb3V0Rm4oYWJvcnQsIHRpbWVvdXQsIHsgaW1tZWRpYXRlOiBmYWxzZSB9KTtcbiAgbGV0IGV4ZWN1dGVDb3VudGVyID0gMDtcbiAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jICh0aHJvd09uRmFpbGVkID0gZmFsc2UpID0+IHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBhYm9ydCgpO1xuICAgIGxvYWRpbmcodHJ1ZSk7XG4gICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgIHN0YXR1c0NvZGUudmFsdWUgPSBudWxsO1xuICAgIGFib3J0ZWQudmFsdWUgPSBmYWxzZTtcbiAgICBleGVjdXRlQ291bnRlciArPSAxO1xuICAgIGNvbnN0IGN1cnJlbnRFeGVjdXRlQ291bnRlciA9IGV4ZWN1dGVDb3VudGVyO1xuICAgIGNvbnN0IGRlZmF1bHRGZXRjaE9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6IGNvbmZpZy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB7fVxuICAgIH07XG4gICAgY29uc3QgcGF5bG9hZCA9IHRvVmFsdWUoY29uZmlnLnBheWxvYWQpO1xuICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gaGVhZGVyc1RvT2JqZWN0KGRlZmF1bHRGZXRjaE9wdGlvbnMuaGVhZGVycyk7XG4gICAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXlsb2FkKTtcbiAgICAgIGlmICghY29uZmlnLnBheWxvYWRUeXBlICYmIHBheWxvYWQgJiYgKHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8IEFycmF5LmlzQXJyYXkocHJvdG8pKSAmJiAhKHBheWxvYWQgaW5zdGFuY2VvZiBGb3JtRGF0YSkpXG4gICAgICAgIGNvbmZpZy5wYXlsb2FkVHlwZSA9IFwianNvblwiO1xuICAgICAgaWYgKGNvbmZpZy5wYXlsb2FkVHlwZSlcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IChfYTIgPSBwYXlsb2FkTWFwcGluZ1tjb25maWcucGF5bG9hZFR5cGVdKSAhPSBudWxsID8gX2EyIDogY29uZmlnLnBheWxvYWRUeXBlO1xuICAgICAgZGVmYXVsdEZldGNoT3B0aW9ucy5ib2R5ID0gY29uZmlnLnBheWxvYWRUeXBlID09PSBcImpzb25cIiA/IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpIDogcGF5bG9hZDtcbiAgICB9XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgdXJsOiB0b1ZhbHVlKHVybCksXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC4uLmRlZmF1bHRGZXRjaE9wdGlvbnMsXG4gICAgICAgIC4uLmZldGNoT3B0aW9uc1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICBpc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmJlZm9yZUZldGNoKVxuICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LCBhd2FpdCBvcHRpb25zLmJlZm9yZUZldGNoKGNvbnRleHQpKTtcbiAgICBpZiAoaXNDYW5jZWxlZCB8fCAhZmV0Y2gpIHtcbiAgICAgIGxvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlRGF0YSA9IG51bGw7XG4gICAgaWYgKHRpbWVyKVxuICAgICAgdGltZXIuc3RhcnQoKTtcbiAgICByZXR1cm4gZmV0Y2goXG4gICAgICBjb250ZXh0LnVybCxcbiAgICAgIHtcbiAgICAgICAgLi4uZGVmYXVsdEZldGNoT3B0aW9ucyxcbiAgICAgICAgLi4uY29udGV4dC5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVyc1RvT2JqZWN0KGRlZmF1bHRGZXRjaE9wdGlvbnMuaGVhZGVycyksXG4gICAgICAgICAgLi4uaGVhZGVyc1RvT2JqZWN0KChfYiA9IGNvbnRleHQub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlYWRlcnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApLnRoZW4oYXN5bmMgKGZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgIHJlc3BvbnNlLnZhbHVlID0gZmV0Y2hSZXNwb25zZTtcbiAgICAgIHN0YXR1c0NvZGUudmFsdWUgPSBmZXRjaFJlc3BvbnNlLnN0YXR1cztcbiAgICAgIHJlc3BvbnNlRGF0YSA9IGF3YWl0IGZldGNoUmVzcG9uc2UuY2xvbmUoKVtjb25maWcudHlwZV0oKTtcbiAgICAgIGlmICghZmV0Y2hSZXNwb25zZS5vaykge1xuICAgICAgICBkYXRhLnZhbHVlID0gaW5pdGlhbERhdGEgfHwgbnVsbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZldGNoUmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hZnRlckZldGNoKSB7XG4gICAgICAgICh7IGRhdGE6IHJlc3BvbnNlRGF0YSB9ID0gYXdhaXQgb3B0aW9ucy5hZnRlckZldGNoKHtcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgcmVzcG9uc2U6IGZldGNoUmVzcG9uc2UsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBleGVjdXRlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGRhdGEudmFsdWUgPSByZXNwb25zZURhdGE7XG4gICAgICByZXNwb25zZUV2ZW50LnRyaWdnZXIoZmV0Y2hSZXNwb25zZSk7XG4gICAgICByZXR1cm4gZmV0Y2hSZXNwb25zZTtcbiAgICB9KS5jYXRjaChhc3luYyAoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgbGV0IGVycm9yRGF0YSA9IGZldGNoRXJyb3IubWVzc2FnZSB8fCBmZXRjaEVycm9yLm5hbWU7XG4gICAgICBpZiAob3B0aW9ucy5vbkZldGNoRXJyb3IpIHtcbiAgICAgICAgKHsgZXJyb3I6IGVycm9yRGF0YSwgZGF0YTogcmVzcG9uc2VEYXRhIH0gPSBhd2FpdCBvcHRpb25zLm9uRmV0Y2hFcnJvcih7XG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgIGVycm9yOiBmZXRjaEVycm9yLFxuICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS52YWx1ZSxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGV4ZWN1dGVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgZXJyb3IudmFsdWUgPSBlcnJvckRhdGE7XG4gICAgICBpZiAob3B0aW9ucy51cGRhdGVEYXRhT25FcnJvcilcbiAgICAgICAgZGF0YS52YWx1ZSA9IHJlc3BvbnNlRGF0YTtcbiAgICAgIGVycm9yRXZlbnQudHJpZ2dlcihmZXRjaEVycm9yKTtcbiAgICAgIGlmICh0aHJvd09uRmFpbGVkKVxuICAgICAgICB0aHJvdyBmZXRjaEVycm9yO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBpZiAoY3VycmVudEV4ZWN1dGVDb3VudGVyID09PSBleGVjdXRlQ291bnRlcilcbiAgICAgICAgbG9hZGluZyhmYWxzZSk7XG4gICAgICBpZiAodGltZXIpXG4gICAgICAgIHRpbWVyLnN0b3AoKTtcbiAgICAgIGZpbmFsbHlFdmVudC50cmlnZ2VyKG51bGwpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCByZWZldGNoID0gdG9SZWYob3B0aW9ucy5yZWZldGNoKTtcbiAgd2F0Y2goXG4gICAgW1xuICAgICAgcmVmZXRjaCxcbiAgICAgIHRvUmVmKHVybClcbiAgICBdLFxuICAgIChbcmVmZXRjaDJdKSA9PiByZWZldGNoMiAmJiBleGVjdXRlKCksXG4gICAgeyBkZWVwOiB0cnVlIH1cbiAgKTtcbiAgY29uc3Qgc2hlbGwgPSB7XG4gICAgaXNGaW5pc2hlZDogcmVhZG9ubHkoaXNGaW5pc2hlZCksXG4gICAgaXNGZXRjaGluZzogcmVhZG9ubHkoaXNGZXRjaGluZyksXG4gICAgc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZSxcbiAgICBlcnJvcixcbiAgICBkYXRhLFxuICAgIGNhbkFib3J0LFxuICAgIGFib3J0ZWQsXG4gICAgYWJvcnQsXG4gICAgZXhlY3V0ZSxcbiAgICBvbkZldGNoUmVzcG9uc2U6IHJlc3BvbnNlRXZlbnQub24sXG4gICAgb25GZXRjaEVycm9yOiBlcnJvckV2ZW50Lm9uLFxuICAgIG9uRmV0Y2hGaW5hbGx5OiBmaW5hbGx5RXZlbnQub24sXG4gICAgLy8gbWV0aG9kXG4gICAgZ2V0OiBzZXRNZXRob2QoXCJHRVRcIiksXG4gICAgcHV0OiBzZXRNZXRob2QoXCJQVVRcIiksXG4gICAgcG9zdDogc2V0TWV0aG9kKFwiUE9TVFwiKSxcbiAgICBkZWxldGU6IHNldE1ldGhvZChcIkRFTEVURVwiKSxcbiAgICBwYXRjaDogc2V0TWV0aG9kKFwiUEFUQ0hcIiksXG4gICAgaGVhZDogc2V0TWV0aG9kKFwiSEVBRFwiKSxcbiAgICBvcHRpb25zOiBzZXRNZXRob2QoXCJPUFRJT05TXCIpLFxuICAgIC8vIHR5cGVcbiAgICBqc29uOiBzZXRUeXBlKFwianNvblwiKSxcbiAgICB0ZXh0OiBzZXRUeXBlKFwidGV4dFwiKSxcbiAgICBibG9iOiBzZXRUeXBlKFwiYmxvYlwiKSxcbiAgICBhcnJheUJ1ZmZlcjogc2V0VHlwZShcImFycmF5QnVmZmVyXCIpLFxuICAgIGZvcm1EYXRhOiBzZXRUeXBlKFwiZm9ybURhdGFcIilcbiAgfTtcbiAgZnVuY3Rpb24gc2V0TWV0aG9kKG1ldGhvZCkge1xuICAgIHJldHVybiAocGF5bG9hZCwgcGF5bG9hZFR5cGUpID0+IHtcbiAgICAgIGlmICghaXNGZXRjaGluZy52YWx1ZSkge1xuICAgICAgICBjb25maWcubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBjb25maWcucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIGNvbmZpZy5wYXlsb2FkVHlwZSA9IHBheWxvYWRUeXBlO1xuICAgICAgICBpZiAoaXNSZWYoY29uZmlnLnBheWxvYWQpKSB7XG4gICAgICAgICAgd2F0Y2goXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIHJlZmV0Y2gsXG4gICAgICAgICAgICAgIHRvUmVmKGNvbmZpZy5wYXlsb2FkKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIChbcmVmZXRjaDJdKSA9PiByZWZldGNoMiAmJiBleGVjdXRlKCksXG4gICAgICAgICAgICB7IGRlZXA6IHRydWUgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zaGVsbCxcbiAgICAgICAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdFVudGlsRmluaXNoZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gd2FpdFVudGlsRmluaXNoZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHVudGlsKGlzRmluaXNoZWQpLnRvQmUodHJ1ZSkudGhlbigoKSA9PiByZXNvbHZlKHNoZWxsKSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFpc0ZldGNoaW5nLnZhbHVlKSB7XG4gICAgICAgIGNvbmZpZy50eXBlID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zaGVsbCxcbiAgICAgICAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdFVudGlsRmluaXNoZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKVxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZXhlY3V0ZSgpKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zaGVsbCxcbiAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gd2FpdFVudGlsRmluaXNoZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBqb2luUGF0aHMoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0LmVuZHNXaXRoKFwiL1wiKSAmJiAhZW5kLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGAke3N0YXJ0fS8ke2VuZH1gO1xuICB9XG4gIGlmIChzdGFydC5lbmRzV2l0aChcIi9cIikgJiYgZW5kLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGAke3N0YXJ0LnNsaWNlKDAsIC0xKX0ke2VuZH1gO1xuICB9XG4gIHJldHVybiBgJHtzdGFydH0ke2VuZH1gO1xufVxuXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIG11bHRpcGxlOiB0cnVlLFxuICBhY2NlcHQ6IFwiKlwiLFxuICByZXNldDogZmFsc2UsXG4gIGRpcmVjdG9yeTogZmFsc2Vcbn07XG5mdW5jdGlvbiBwcmVwYXJlSW5pdGlhbEZpbGVzKGZpbGVzKSB7XG4gIGlmICghZmlsZXMpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChmaWxlcyBpbnN0YW5jZW9mIEZpbGVMaXN0KVxuICAgIHJldHVybiBmaWxlcztcbiAgY29uc3QgZHQgPSBuZXcgRGF0YVRyYW5zZmVyKCk7XG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGR0Lml0ZW1zLmFkZChmaWxlKTtcbiAgfVxuICByZXR1cm4gZHQuZmlsZXM7XG59XG5mdW5jdGlvbiB1c2VGaWxlRGlhbG9nKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZpbGVzID0gcmVmKHByZXBhcmVJbml0aWFsRmlsZXMob3B0aW9ucy5pbml0aWFsRmlsZXMpKTtcbiAgY29uc3QgeyBvbjogb25DaGFuZ2UsIHRyaWdnZXI6IGNoYW5nZVRyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvbkNhbmNlbCwgdHJpZ2dlcjogY2FuY2VsVHJpZ2dlciB9ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGxldCBpbnB1dDtcbiAgaWYgKGRvY3VtZW50KSB7XG4gICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgIGlucHV0Lm9uY2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBldmVudC50YXJnZXQ7XG4gICAgICBmaWxlcy52YWx1ZSA9IHJlc3VsdC5maWxlcztcbiAgICAgIGNoYW5nZVRyaWdnZXIoZmlsZXMudmFsdWUpO1xuICAgIH07XG4gICAgaW5wdXQub25jYW5jZWwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxUcmlnZ2VyKCk7XG4gICAgfTtcbiAgfVxuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBmaWxlcy52YWx1ZSA9IG51bGw7XG4gICAgaWYgKGlucHV0ICYmIGlucHV0LnZhbHVlKSB7XG4gICAgICBpbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICBjaGFuZ2VUcmlnZ2VyKG51bGwpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb3BlbiA9IChsb2NhbE9wdGlvbnMpID0+IHtcbiAgICBpZiAoIWlucHV0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IF9vcHRpb25zID0ge1xuICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC4uLmxvY2FsT3B0aW9uc1xuICAgIH07XG4gICAgaW5wdXQubXVsdGlwbGUgPSBfb3B0aW9ucy5tdWx0aXBsZTtcbiAgICBpbnB1dC5hY2NlcHQgPSBfb3B0aW9ucy5hY2NlcHQ7XG4gICAgaW5wdXQud2Via2l0ZGlyZWN0b3J5ID0gX29wdGlvbnMuZGlyZWN0b3J5O1xuICAgIGlmIChoYXNPd24oX29wdGlvbnMsIFwiY2FwdHVyZVwiKSlcbiAgICAgIGlucHV0LmNhcHR1cmUgPSBfb3B0aW9ucy5jYXB0dXJlO1xuICAgIGlmIChfb3B0aW9ucy5yZXNldClcbiAgICAgIHJlc2V0KCk7XG4gICAgaW5wdXQuY2xpY2soKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBmaWxlczogcmVhZG9ubHkoZmlsZXMpLFxuICAgIG9wZW4sXG4gICAgcmVzZXQsXG4gICAgb25DYW5jZWwsXG4gICAgb25DaGFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRmlsZVN5c3RlbUFjY2VzcyhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdzogX3dpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgZGF0YVR5cGUgPSBcIlRleHRcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgd2luZG93ID0gX3dpbmRvdztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwic2hvd1NhdmVGaWxlUGlja2VyXCIgaW4gd2luZG93ICYmIFwic2hvd09wZW5GaWxlUGlja2VyXCIgaW4gd2luZG93KTtcbiAgY29uc3QgZmlsZUhhbmRsZSA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgZGF0YSA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgZmlsZSA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgZmlsZU5hbWUgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZmlsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWUpICE9IG51bGwgPyBfYiA6IFwiXCI7XG4gIH0pO1xuICBjb25zdCBmaWxlTUlNRSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZSkgIT0gbnVsbCA/IF9iIDogXCJcIjtcbiAgfSk7XG4gIGNvbnN0IGZpbGVTaXplID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGZpbGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaXplKSAhPSBudWxsID8gX2IgOiAwO1xuICB9KTtcbiAgY29uc3QgZmlsZUxhc3RNb2RpZmllZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGFzdE1vZGlmaWVkKSAhPSBudWxsID8gX2IgOiAwO1xuICB9KTtcbiAgYXN5bmMgZnVuY3Rpb24gb3Blbihfb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbaGFuZGxlXSA9IGF3YWl0IHdpbmRvdy5zaG93T3BlbkZpbGVQaWNrZXIoeyAuLi50b1ZhbHVlKG9wdGlvbnMpLCAuLi5fb3B0aW9ucyB9KTtcbiAgICBmaWxlSGFuZGxlLnZhbHVlID0gaGFuZGxlO1xuICAgIGF3YWl0IHVwZGF0ZURhdGEoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGUoX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgZmlsZUhhbmRsZS52YWx1ZSA9IGF3YWl0IHdpbmRvdy5zaG93U2F2ZUZpbGVQaWNrZXIoeyAuLi5vcHRpb25zLCAuLi5fb3B0aW9ucyB9KTtcbiAgICBkYXRhLnZhbHVlID0gdm9pZCAwO1xuICAgIGF3YWl0IHVwZGF0ZURhdGEoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzYXZlKF9vcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghZmlsZUhhbmRsZS52YWx1ZSlcbiAgICAgIHJldHVybiBzYXZlQXMoX29wdGlvbnMpO1xuICAgIGlmIChkYXRhLnZhbHVlKSB7XG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IGF3YWl0IGZpbGVIYW5kbGUudmFsdWUuY3JlYXRlV3JpdGFibGUoKTtcbiAgICAgIGF3YWl0IHdyaXRhYmxlU3RyZWFtLndyaXRlKGRhdGEudmFsdWUpO1xuICAgICAgYXdhaXQgd3JpdGFibGVTdHJlYW0uY2xvc2UoKTtcbiAgICB9XG4gICAgYXdhaXQgdXBkYXRlRmlsZSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHNhdmVBcyhfb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBmaWxlSGFuZGxlLnZhbHVlID0gYXdhaXQgd2luZG93LnNob3dTYXZlRmlsZVBpY2tlcih7IC4uLm9wdGlvbnMsIC4uLl9vcHRpb25zIH0pO1xuICAgIGlmIChkYXRhLnZhbHVlKSB7XG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IGF3YWl0IGZpbGVIYW5kbGUudmFsdWUuY3JlYXRlV3JpdGFibGUoKTtcbiAgICAgIGF3YWl0IHdyaXRhYmxlU3RyZWFtLndyaXRlKGRhdGEudmFsdWUpO1xuICAgICAgYXdhaXQgd3JpdGFibGVTdHJlYW0uY2xvc2UoKTtcbiAgICB9XG4gICAgYXdhaXQgdXBkYXRlRmlsZSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUZpbGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGZpbGUudmFsdWUgPSBhd2FpdCAoKF9hID0gZmlsZUhhbmRsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEZpbGUoKSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGF0YSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGF3YWl0IHVwZGF0ZUZpbGUoKTtcbiAgICBjb25zdCB0eXBlID0gdG9WYWx1ZShkYXRhVHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwiVGV4dFwiKVxuICAgICAgZGF0YS52YWx1ZSA9IGF3YWl0ICgoX2EgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dCgpKTtcbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5QnVmZmVyXCIpXG4gICAgICBkYXRhLnZhbHVlID0gYXdhaXQgKChfYiA9IGZpbGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hcnJheUJ1ZmZlcigpKTtcbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkJsb2JcIilcbiAgICAgIGRhdGEudmFsdWUgPSBmaWxlLnZhbHVlO1xuICB9XG4gIHdhdGNoKCgpID0+IHRvVmFsdWUoZGF0YVR5cGUpLCB1cGRhdGVEYXRhKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBkYXRhLFxuICAgIGZpbGUsXG4gICAgZmlsZU5hbWUsXG4gICAgZmlsZU1JTUUsXG4gICAgZmlsZVNpemUsXG4gICAgZmlsZUxhc3RNb2RpZmllZCxcbiAgICBvcGVuLFxuICAgIGNyZWF0ZSxcbiAgICBzYXZlLFxuICAgIHNhdmVBcyxcbiAgICB1cGRhdGVEYXRhXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUZvY3VzKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgaW5pdGlhbFZhbHVlID0gZmFsc2UsIGZvY3VzVmlzaWJsZSA9IGZhbHNlLCBwcmV2ZW50U2Nyb2xsID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyRm9jdXNlZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY29tcHV0ZWQoKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCkpO1xuICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBcImZvY3VzXCIsIChldmVudCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFmb2N1c1Zpc2libGUgfHwgKChfYiA9IChfYSA9IGV2ZW50LnRhcmdldCkubWF0Y2hlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIFwiOmZvY3VzLXZpc2libGVcIikpKVxuICAgICAgaW5uZXJGb2N1c2VkLnZhbHVlID0gdHJ1ZTtcbiAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBcImJsdXJcIiwgKCkgPT4gaW5uZXJGb2N1c2VkLnZhbHVlID0gZmFsc2UsIGxpc3RlbmVyT3B0aW9ucyk7XG4gIGNvbnN0IGZvY3VzZWQgPSBjb21wdXRlZCh7XG4gICAgZ2V0OiAoKSA9PiBpbm5lckZvY3VzZWQudmFsdWUsXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKCF2YWx1ZSAmJiBpbm5lckZvY3VzZWQudmFsdWUpXG4gICAgICAgIChfYSA9IHRhcmdldEVsZW1lbnQudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5ibHVyKCk7XG4gICAgICBlbHNlIGlmICh2YWx1ZSAmJiAhaW5uZXJGb2N1c2VkLnZhbHVlKVxuICAgICAgICAoX2IgPSB0YXJnZXRFbGVtZW50LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsIH0pO1xuICAgIH1cbiAgfSk7XG4gIHdhdGNoKFxuICAgIHRhcmdldEVsZW1lbnQsXG4gICAgKCkgPT4ge1xuICAgICAgZm9jdXNlZC52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlLCBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xuICByZXR1cm4geyBmb2N1c2VkIH07XG59XG5cbmNvbnN0IEVWRU5UX0ZPQ1VTX0lOID0gXCJmb2N1c2luXCI7XG5jb25zdCBFVkVOVF9GT0NVU19PVVQgPSBcImZvY3Vzb3V0XCI7XG5jb25zdCBQU0VVRE9fQ0xBU1NfRk9DVVNfV0lUSElOID0gXCI6Zm9jdXMtd2l0aGluXCI7XG5mdW5jdGlvbiB1c2VGb2N1c1dpdGhpbih0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBjb21wdXRlZCgoKSA9PiB1bnJlZkVsZW1lbnQodGFyZ2V0KSk7XG4gIGNvbnN0IF9mb2N1c2VkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGZvY3VzZWQgPSBjb21wdXRlZCgoKSA9PiBfZm9jdXNlZC52YWx1ZSk7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB1c2VBY3RpdmVFbGVtZW50KG9wdGlvbnMpO1xuICBpZiAoIXdpbmRvdyB8fCAhYWN0aXZlRWxlbWVudC52YWx1ZSkge1xuICAgIHJldHVybiB7IGZvY3VzZWQgfTtcbiAgfVxuICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBFVkVOVF9GT0NVU19JTiwgKCkgPT4gX2ZvY3VzZWQudmFsdWUgPSB0cnVlLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldEVsZW1lbnQsIEVWRU5UX0ZPQ1VTX09VVCwgKCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiBfZm9jdXNlZC52YWx1ZSA9IChfYyA9IChfYiA9IChfYSA9IHRhcmdldEVsZW1lbnQudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXRjaGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgUFNFVURPX0NMQVNTX0ZPQ1VTX1dJVEhJTikpICE9IG51bGwgPyBfYyA6IGZhbHNlO1xuICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICByZXR1cm4geyBmb2N1c2VkIH07XG59XG5cbmZ1bmN0aW9uIHVzZUZwcyhvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgZnBzID0gc2hhbGxvd1JlZigwKTtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm4gZnBzO1xuICBjb25zdCBldmVyeSA9IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlcnkpICE9IG51bGwgPyBfYSA6IDEwO1xuICBsZXQgbGFzdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBsZXQgdGlja3MgPSAwO1xuICB1c2VSYWZGbigoKSA9PiB7XG4gICAgdGlja3MgKz0gMTtcbiAgICBpZiAodGlja3MgPj0gZXZlcnkpIHtcbiAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZGlmZiA9IG5vdyAtIGxhc3Q7XG4gICAgICBmcHMudmFsdWUgPSBNYXRoLnJvdW5kKDFlMyAvIChkaWZmIC8gdGlja3MpKTtcbiAgICAgIGxhc3QgPSBub3c7XG4gICAgICB0aWNrcyA9IDA7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZwcztcbn1cblxuY29uc3QgZXZlbnRIYW5kbGVycyA9IFtcbiAgXCJmdWxsc2NyZWVuY2hhbmdlXCIsXG4gIFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICBcIndlYmtpdGVuZGZ1bGxzY3JlZW5cIixcbiAgXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsXG4gIFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCJcbl07XG5mdW5jdGlvbiB1c2VGdWxsc2NyZWVuKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBhdXRvRXhpdCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB0YXJnZXRSZWYgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KSkgIT0gbnVsbCA/IF9hIDogZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfSk7XG4gIGNvbnN0IGlzRnVsbHNjcmVlbiA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCByZXF1ZXN0TWV0aG9kID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICBcInJlcXVlc3RGdWxsc2NyZWVuXCIsXG4gICAgICBcIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuXCIsXG4gICAgICBcIndlYmtpdEVudGVyRnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRFbnRlckZ1bGxTY3JlZW5cIixcbiAgICAgIFwid2Via2l0UmVxdWVzdEZ1bGxTY3JlZW5cIixcbiAgICAgIFwibW96UmVxdWVzdEZ1bGxTY3JlZW5cIixcbiAgICAgIFwibXNSZXF1ZXN0RnVsbHNjcmVlblwiXG4gICAgXS5maW5kKChtKSA9PiBkb2N1bWVudCAmJiBtIGluIGRvY3VtZW50IHx8IHRhcmdldFJlZi52YWx1ZSAmJiBtIGluIHRhcmdldFJlZi52YWx1ZSk7XG4gIH0pO1xuICBjb25zdCBleGl0TWV0aG9kID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICBcImV4aXRGdWxsc2NyZWVuXCIsXG4gICAgICBcIndlYmtpdEV4aXRGdWxsc2NyZWVuXCIsXG4gICAgICBcIndlYmtpdEV4aXRGdWxsU2NyZWVuXCIsXG4gICAgICBcIndlYmtpdENhbmNlbEZ1bGxTY3JlZW5cIixcbiAgICAgIFwibW96Q2FuY2VsRnVsbFNjcmVlblwiLFxuICAgICAgXCJtc0V4aXRGdWxsc2NyZWVuXCJcbiAgICBdLmZpbmQoKG0pID0+IGRvY3VtZW50ICYmIG0gaW4gZG9jdW1lbnQgfHwgdGFyZ2V0UmVmLnZhbHVlICYmIG0gaW4gdGFyZ2V0UmVmLnZhbHVlKTtcbiAgfSk7XG4gIGNvbnN0IGZ1bGxzY3JlZW5FbmFibGVkID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICBcImZ1bGxTY3JlZW5cIixcbiAgICAgIFwid2Via2l0SXNGdWxsU2NyZWVuXCIsXG4gICAgICBcIndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuXCIsXG4gICAgICBcIm1vekZ1bGxTY3JlZW5cIixcbiAgICAgIFwibXNGdWxsc2NyZWVuRWxlbWVudFwiXG4gICAgXS5maW5kKChtKSA9PiBkb2N1bWVudCAmJiBtIGluIGRvY3VtZW50IHx8IHRhcmdldFJlZi52YWx1ZSAmJiBtIGluIHRhcmdldFJlZi52YWx1ZSk7XG4gIH0pO1xuICBjb25zdCBmdWxsc2NyZWVuRWxlbWVudE1ldGhvZCA9IFtcbiAgICBcImZ1bGxzY3JlZW5FbGVtZW50XCIsXG4gICAgXCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudFwiLFxuICAgIFwibW96RnVsbFNjcmVlbkVsZW1lbnRcIixcbiAgICBcIm1zRnVsbHNjcmVlbkVsZW1lbnRcIlxuICBdLmZpbmQoKG0pID0+IGRvY3VtZW50ICYmIG0gaW4gZG9jdW1lbnQpO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB0YXJnZXRSZWYudmFsdWUgJiYgZG9jdW1lbnQgJiYgcmVxdWVzdE1ldGhvZC52YWx1ZSAhPT0gdm9pZCAwICYmIGV4aXRNZXRob2QudmFsdWUgIT09IHZvaWQgMCAmJiBmdWxsc2NyZWVuRW5hYmxlZC52YWx1ZSAhPT0gdm9pZCAwKTtcbiAgY29uc3QgaXNDdXJyZW50RWxlbWVudEZ1bGxTY3JlZW4gPSAoKSA9PiB7XG4gICAgaWYgKGZ1bGxzY3JlZW5FbGVtZW50TWV0aG9kKVxuICAgICAgcmV0dXJuIChkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnRbZnVsbHNjcmVlbkVsZW1lbnRNZXRob2RdKSA9PT0gdGFyZ2V0UmVmLnZhbHVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgY29uc3QgaXNFbGVtZW50RnVsbFNjcmVlbiA9ICgpID0+IHtcbiAgICBpZiAoZnVsbHNjcmVlbkVuYWJsZWQudmFsdWUpIHtcbiAgICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudFtmdWxsc2NyZWVuRW5hYmxlZC52YWx1ZV0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRbZnVsbHNjcmVlbkVuYWJsZWQudmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0MiA9IHRhcmdldFJlZi52YWx1ZTtcbiAgICAgICAgaWYgKCh0YXJnZXQyID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQyW2Z1bGxzY3JlZW5FbmFibGVkLnZhbHVlXSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBCb29sZWFuKHRhcmdldDJbZnVsbHNjcmVlbkVuYWJsZWQudmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIGV4aXQoKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSB8fCAhaXNGdWxsc2NyZWVuLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChleGl0TWV0aG9kLnZhbHVlKSB7XG4gICAgICBpZiAoKGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudFtleGl0TWV0aG9kLnZhbHVlXSkgIT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBkb2N1bWVudFtleGl0TWV0aG9kLnZhbHVlXSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0MiA9IHRhcmdldFJlZi52YWx1ZTtcbiAgICAgICAgaWYgKCh0YXJnZXQyID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQyW2V4aXRNZXRob2QudmFsdWVdKSAhPSBudWxsKVxuICAgICAgICAgIGF3YWl0IHRhcmdldDJbZXhpdE1ldGhvZC52YWx1ZV0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXNGdWxsc2NyZWVuLnZhbHVlID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZW50ZXIoKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSB8fCBpc0Z1bGxzY3JlZW4udmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGlzRWxlbWVudEZ1bGxTY3JlZW4oKSlcbiAgICAgIGF3YWl0IGV4aXQoKTtcbiAgICBjb25zdCB0YXJnZXQyID0gdGFyZ2V0UmVmLnZhbHVlO1xuICAgIGlmIChyZXF1ZXN0TWV0aG9kLnZhbHVlICYmICh0YXJnZXQyID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQyW3JlcXVlc3RNZXRob2QudmFsdWVdKSAhPSBudWxsKSB7XG4gICAgICBhd2FpdCB0YXJnZXQyW3JlcXVlc3RNZXRob2QudmFsdWVdKCk7XG4gICAgICBpc0Z1bGxzY3JlZW4udmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgYXdhaXQgKGlzRnVsbHNjcmVlbi52YWx1ZSA/IGV4aXQoKSA6IGVudGVyKCkpO1xuICB9XG4gIGNvbnN0IGhhbmRsZXJDYWxsYmFjayA9ICgpID0+IHtcbiAgICBjb25zdCBpc0VsZW1lbnRGdWxsU2NyZWVuVmFsdWUgPSBpc0VsZW1lbnRGdWxsU2NyZWVuKCk7XG4gICAgaWYgKCFpc0VsZW1lbnRGdWxsU2NyZWVuVmFsdWUgfHwgaXNFbGVtZW50RnVsbFNjcmVlblZhbHVlICYmIGlzQ3VycmVudEVsZW1lbnRGdWxsU2NyZWVuKCkpXG4gICAgICBpc0Z1bGxzY3JlZW4udmFsdWUgPSBpc0VsZW1lbnRGdWxsU2NyZWVuVmFsdWU7XG4gIH07XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgY2FwdHVyZTogZmFsc2UsIHBhc3NpdmU6IHRydWUgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgZXZlbnRIYW5kbGVycywgaGFuZGxlckNhbGxiYWNrLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB1c2VFdmVudExpc3RlbmVyKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXRSZWYpLCBldmVudEhhbmRsZXJzLCBoYW5kbGVyQ2FsbGJhY2ssIGxpc3RlbmVyT3B0aW9ucyk7XG4gIGlmIChhdXRvRXhpdClcbiAgICB0cnlPblNjb3BlRGlzcG9zZShleGl0KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc0Z1bGxzY3JlZW4sXG4gICAgZW50ZXIsXG4gICAgZXhpdCxcbiAgICB0b2dnbGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFwR2FtZXBhZFRvWGJveDM2MENvbnRyb2xsZXIoZ2FtZXBhZCkge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChnYW1lcGFkLnZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgYTogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzBdLFxuICAgICAgICAgIGI6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxXSxcbiAgICAgICAgICB4OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMl0sXG4gICAgICAgICAgeTogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzNdXG4gICAgICAgIH0sXG4gICAgICAgIGJ1bXBlcjoge1xuICAgICAgICAgIGxlZnQ6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1s0XSxcbiAgICAgICAgICByaWdodDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzVdXG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgICAgbGVmdDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzZdLFxuICAgICAgICAgIHJpZ2h0OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbN11cbiAgICAgICAgfSxcbiAgICAgICAgc3RpY2s6IHtcbiAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICBob3Jpem9udGFsOiBnYW1lcGFkLnZhbHVlLmF4ZXNbMF0sXG4gICAgICAgICAgICB2ZXJ0aWNhbDogZ2FtZXBhZC52YWx1ZS5heGVzWzFdLFxuICAgICAgICAgICAgYnV0dG9uOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMTBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogZ2FtZXBhZC52YWx1ZS5heGVzWzJdLFxuICAgICAgICAgICAgdmVydGljYWw6IGdhbWVwYWQudmFsdWUuYXhlc1szXSxcbiAgICAgICAgICAgIGJ1dHRvbjogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzExXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZHBhZDoge1xuICAgICAgICAgIHVwOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMTJdLFxuICAgICAgICAgIGRvd246IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxM10sXG4gICAgICAgICAgbGVmdDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzE0XSxcbiAgICAgICAgICByaWdodDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzE1XVxuICAgICAgICB9LFxuICAgICAgICBiYWNrOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbOF0sXG4gICAgICAgIHN0YXJ0OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbOV1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUdhbWVwYWQob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJnZXRHYW1lcGFkc1wiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGdhbWVwYWRzID0gcmVmKFtdKTtcbiAgY29uc3Qgb25Db25uZWN0ZWRIb29rID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IG9uRGlzY29ubmVjdGVkSG9vayA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBzdGF0ZUZyb21HYW1lcGFkID0gKGdhbWVwYWQpID0+IHtcbiAgICBjb25zdCBoYXB0aWNBY3R1YXRvcnMgPSBbXTtcbiAgICBjb25zdCB2aWJyYXRpb25BY3R1YXRvciA9IFwidmlicmF0aW9uQWN0dWF0b3JcIiBpbiBnYW1lcGFkID8gZ2FtZXBhZC52aWJyYXRpb25BY3R1YXRvciA6IG51bGw7XG4gICAgaWYgKHZpYnJhdGlvbkFjdHVhdG9yKVxuICAgICAgaGFwdGljQWN0dWF0b3JzLnB1c2godmlicmF0aW9uQWN0dWF0b3IpO1xuICAgIGlmIChnYW1lcGFkLmhhcHRpY0FjdHVhdG9ycylcbiAgICAgIGhhcHRpY0FjdHVhdG9ycy5wdXNoKC4uLmdhbWVwYWQuaGFwdGljQWN0dWF0b3JzKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGdhbWVwYWQuaWQsXG4gICAgICBpbmRleDogZ2FtZXBhZC5pbmRleCxcbiAgICAgIGNvbm5lY3RlZDogZ2FtZXBhZC5jb25uZWN0ZWQsXG4gICAgICBtYXBwaW5nOiBnYW1lcGFkLm1hcHBpbmcsXG4gICAgICB0aW1lc3RhbXA6IGdhbWVwYWQudGltZXN0YW1wLFxuICAgICAgdmlicmF0aW9uQWN0dWF0b3I6IGdhbWVwYWQudmlicmF0aW9uQWN0dWF0b3IsXG4gICAgICBoYXB0aWNBY3R1YXRvcnMsXG4gICAgICBheGVzOiBnYW1lcGFkLmF4ZXMubWFwKChheGVzKSA9PiBheGVzKSxcbiAgICAgIGJ1dHRvbnM6IGdhbWVwYWQuYnV0dG9ucy5tYXAoKGJ1dHRvbikgPT4gKHsgcHJlc3NlZDogYnV0dG9uLnByZXNzZWQsIHRvdWNoZWQ6IGJ1dHRvbi50b3VjaGVkLCB2YWx1ZTogYnV0dG9uLnZhbHVlIH0pKVxuICAgIH07XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUdhbWVwYWRTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBfZ2FtZXBhZHMgPSAobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSkgfHwgW107XG4gICAgZm9yIChjb25zdCBnYW1lcGFkIG9mIF9nYW1lcGFkcykge1xuICAgICAgaWYgKGdhbWVwYWQgJiYgZ2FtZXBhZHMudmFsdWVbZ2FtZXBhZC5pbmRleF0pXG4gICAgICAgIGdhbWVwYWRzLnZhbHVlW2dhbWVwYWQuaW5kZXhdID0gc3RhdGVGcm9tR2FtZXBhZChnYW1lcGFkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHsgaXNBY3RpdmUsIHBhdXNlLCByZXN1bWUgfSA9IHVzZVJhZkZuKHVwZGF0ZUdhbWVwYWRTdGF0ZSk7XG4gIGNvbnN0IG9uR2FtZXBhZENvbm5lY3RlZCA9IChnYW1lcGFkKSA9PiB7XG4gICAgaWYgKCFnYW1lcGFkcy52YWx1ZS5zb21lKCh7IGluZGV4IH0pID0+IGluZGV4ID09PSBnYW1lcGFkLmluZGV4KSkge1xuICAgICAgZ2FtZXBhZHMudmFsdWUucHVzaChzdGF0ZUZyb21HYW1lcGFkKGdhbWVwYWQpKTtcbiAgICAgIG9uQ29ubmVjdGVkSG9vay50cmlnZ2VyKGdhbWVwYWQuaW5kZXgpO1xuICAgIH1cbiAgICByZXN1bWUoKTtcbiAgfTtcbiAgY29uc3Qgb25HYW1lcGFkRGlzY29ubmVjdGVkID0gKGdhbWVwYWQpID0+IHtcbiAgICBnYW1lcGFkcy52YWx1ZSA9IGdhbWVwYWRzLnZhbHVlLmZpbHRlcigoeCkgPT4geC5pbmRleCAhPT0gZ2FtZXBhZC5pbmRleCk7XG4gICAgb25EaXNjb25uZWN0ZWRIb29rLnRyaWdnZXIoZ2FtZXBhZC5pbmRleCk7XG4gIH07XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICB1c2VFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGNvbm5lY3RlZFwiLCAoZSkgPT4gb25HYW1lcGFkQ29ubmVjdGVkKGUuZ2FtZXBhZCksIGxpc3RlbmVyT3B0aW9ucyk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsIChlKSA9PiBvbkdhbWVwYWREaXNjb25uZWN0ZWQoZS5nYW1lcGFkKSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdHJ5T25Nb3VudGVkKCgpID0+IHtcbiAgICBjb25zdCBfZ2FtZXBhZHMgPSAobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSkgfHwgW107XG4gICAgZm9yIChjb25zdCBnYW1lcGFkIG9mIF9nYW1lcGFkcykge1xuICAgICAgaWYgKGdhbWVwYWQgJiYgZ2FtZXBhZHMudmFsdWVbZ2FtZXBhZC5pbmRleF0pXG4gICAgICAgIG9uR2FtZXBhZENvbm5lY3RlZChnYW1lcGFkKTtcbiAgICB9XG4gIH0pO1xuICBwYXVzZSgpO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIG9uQ29ubmVjdGVkOiBvbkNvbm5lY3RlZEhvb2sub24sXG4gICAgb25EaXNjb25uZWN0ZWQ6IG9uRGlzY29ubmVjdGVkSG9vay5vbixcbiAgICBnYW1lcGFkcyxcbiAgICBwYXVzZSxcbiAgICByZXN1bWUsXG4gICAgaXNBY3RpdmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlR2VvbG9jYXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVIaWdoQWNjdXJhY3kgPSB0cnVlLFxuICAgIG1heGltdW1BZ2UgPSAzZTQsXG4gICAgdGltZW91dCA9IDI3ZTMsXG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICBpbW1lZGlhdGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJnZW9sb2NhdGlvblwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGxvY2F0ZWRBdCA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgY29vcmRzID0gcmVmKHtcbiAgICBhY2N1cmFjeTogMCxcbiAgICBsYXRpdHVkZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGxvbmdpdHVkZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGFsdGl0dWRlOiBudWxsLFxuICAgIGFsdGl0dWRlQWNjdXJhY3k6IG51bGwsXG4gICAgaGVhZGluZzogbnVsbCxcbiAgICBzcGVlZDogbnVsbFxuICB9KTtcbiAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBsb2NhdGVkQXQudmFsdWUgPSBwb3NpdGlvbi50aW1lc3RhbXA7XG4gICAgY29vcmRzLnZhbHVlID0gcG9zaXRpb24uY29vcmRzO1xuICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgfVxuICBsZXQgd2F0Y2hlcjtcbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgICAgd2F0Y2hlciA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKFxuICAgICAgICB1cGRhdGVQb3NpdGlvbixcbiAgICAgICAgKGVycikgPT4gZXJyb3IudmFsdWUgPSBlcnIsXG4gICAgICAgIHtcbiAgICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3ksXG4gICAgICAgICAgbWF4aW11bUFnZSxcbiAgICAgICAgICB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgcmVzdW1lKCk7XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmICh3YXRjaGVyICYmIG5hdmlnYXRvcilcbiAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHdhdGNoZXIpO1xuICB9XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBwYXVzZSgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBjb29yZHMsXG4gICAgbG9jYXRlZEF0LFxuICAgIGVycm9yLFxuICAgIHJlc3VtZSxcbiAgICBwYXVzZVxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0RXZlbnRzJDEgPSBbXCJtb3VzZW1vdmVcIiwgXCJtb3VzZWRvd25cIiwgXCJyZXNpemVcIiwgXCJrZXlkb3duXCIsIFwidG91Y2hzdGFydFwiLCBcIndoZWVsXCJdO1xuY29uc3Qgb25lTWludXRlID0gNmU0O1xuZnVuY3Rpb24gdXNlSWRsZSh0aW1lb3V0ID0gb25lTWludXRlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGluaXRpYWxTdGF0ZSA9IGZhbHNlLFxuICAgIGxpc3RlbkZvclZpc2liaWxpdHlDaGFuZ2UgPSB0cnVlLFxuICAgIGV2ZW50cyA9IGRlZmF1bHRFdmVudHMkMSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGV2ZW50RmlsdGVyID0gdGhyb3R0bGVGaWx0ZXIoNTApXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpZGxlID0gc2hhbGxvd1JlZihpbml0aWFsU3RhdGUpO1xuICBjb25zdCBsYXN0QWN0aXZlID0gc2hhbGxvd1JlZih0aW1lc3RhbXAoKSk7XG4gIGxldCB0aW1lcjtcbiAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgaWRsZS52YWx1ZSA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGlkbGUudmFsdWUgPSB0cnVlLCB0aW1lb3V0KTtcbiAgfTtcbiAgY29uc3Qgb25FdmVudCA9IGNyZWF0ZUZpbHRlcldyYXBwZXIoXG4gICAgZXZlbnRGaWx0ZXIsXG4gICAgKCkgPT4ge1xuICAgICAgbGFzdEFjdGl2ZS52YWx1ZSA9IHRpbWVzdGFtcCgpO1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gICk7XG4gIGlmICh3aW5kb3cpIHtcbiAgICBjb25zdCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cylcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBldmVudCwgb25FdmVudCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICBpZiAobGlzdGVuRm9yVmlzaWJpbGl0eUNoYW5nZSkge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pXG4gICAgICAgICAgb25FdmVudCgpO1xuICAgICAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB9XG4gICAgcmVzZXQoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlkbGUsXG4gICAgbGFzdEFjdGl2ZSxcbiAgICByZXNldFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkSW1hZ2Uob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGNvbnN0IHsgc3JjLCBzcmNzZXQsIHNpemVzLCBjbGFzczogY2xhenosIGxvYWRpbmcsIGNyb3Nzb3JpZ2luLCByZWZlcnJlclBvbGljeSwgd2lkdGgsIGhlaWdodCwgZGVjb2RpbmcsIGZldGNoUHJpb3JpdHksIGlzbWFwLCB1c2VtYXAgfSA9IG9wdGlvbnM7XG4gICAgaW1nLnNyYyA9IHNyYztcbiAgICBpZiAoc3Jjc2V0ICE9IG51bGwpXG4gICAgICBpbWcuc3Jjc2V0ID0gc3Jjc2V0O1xuICAgIGlmIChzaXplcyAhPSBudWxsKVxuICAgICAgaW1nLnNpemVzID0gc2l6ZXM7XG4gICAgaWYgKGNsYXp6ICE9IG51bGwpXG4gICAgICBpbWcuY2xhc3NOYW1lID0gY2xheno7XG4gICAgaWYgKGxvYWRpbmcgIT0gbnVsbClcbiAgICAgIGltZy5sb2FkaW5nID0gbG9hZGluZztcbiAgICBpZiAoY3Jvc3NvcmlnaW4gIT0gbnVsbClcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3Nzb3JpZ2luO1xuICAgIGlmIChyZWZlcnJlclBvbGljeSAhPSBudWxsKVxuICAgICAgaW1nLnJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3k7XG4gICAgaWYgKHdpZHRoICE9IG51bGwpXG4gICAgICBpbWcud2lkdGggPSB3aWR0aDtcbiAgICBpZiAoaGVpZ2h0ICE9IG51bGwpXG4gICAgICBpbWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGlmIChkZWNvZGluZyAhPSBudWxsKVxuICAgICAgaW1nLmRlY29kaW5nID0gZGVjb2Rpbmc7XG4gICAgaWYgKGZldGNoUHJpb3JpdHkgIT0gbnVsbClcbiAgICAgIGltZy5mZXRjaFByaW9yaXR5ID0gZmV0Y2hQcmlvcml0eTtcbiAgICBpZiAoaXNtYXAgIT0gbnVsbClcbiAgICAgIGltZy5pc01hcCA9IGlzbWFwO1xuICAgIGlmICh1c2VtYXAgIT0gbnVsbClcbiAgICAgIGltZy51c2VNYXAgPSB1c2VtYXA7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcbiAgICBpbWcub25lcnJvciA9IHJlamVjdDtcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VJbWFnZShvcHRpb25zLCBhc3luY1N0YXRlT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0YXRlID0gdXNlQXN5bmNTdGF0ZShcbiAgICAoKSA9PiBsb2FkSW1hZ2UodG9WYWx1ZShvcHRpb25zKSksXG4gICAgdm9pZCAwLFxuICAgIHtcbiAgICAgIHJlc2V0T25FeGVjdXRlOiB0cnVlLFxuICAgICAgLi4uYXN5bmNTdGF0ZU9wdGlvbnNcbiAgICB9XG4gICk7XG4gIHdhdGNoKFxuICAgICgpID0+IHRvVmFsdWUob3B0aW9ucyksXG4gICAgKCkgPT4gc3RhdGUuZXhlY3V0ZShhc3luY1N0YXRlT3B0aW9ucy5kZWxheSksXG4gICAgeyBkZWVwOiB0cnVlIH1cbiAgKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRWxlbWVudChlbCkge1xuICBpZiAodHlwZW9mIFdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbCBpbnN0YW5jZW9mIFdpbmRvdylcbiAgICByZXR1cm4gZWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAodHlwZW9mIERvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGVsIGluc3RhbmNlb2YgRG9jdW1lbnQpXG4gICAgcmV0dXJuIGVsLmRvY3VtZW50RWxlbWVudDtcbiAgcmV0dXJuIGVsO1xufVxuXG5jb25zdCBBUlJJVkVEX1NUQVRFX1RIUkVTSE9MRF9QSVhFTFMgPSAxO1xuZnVuY3Rpb24gdXNlU2Nyb2xsKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGhyb3R0bGUgPSAwLFxuICAgIGlkbGUgPSAyMDAsXG4gICAgb25TdG9wID0gbm9vcCxcbiAgICBvblNjcm9sbCA9IG5vb3AsXG4gICAgb2Zmc2V0ID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSxcbiAgICBldmVudExpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0sXG4gICAgYmVoYXZpb3IgPSBcImF1dG9cIixcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIG9uRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpbnRlcm5hbFggPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBpbnRlcm5hbFkgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCB4ID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbFgudmFsdWU7XG4gICAgfSxcbiAgICBzZXQoeDIpIHtcbiAgICAgIHNjcm9sbFRvKHgyLCB2b2lkIDApO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHkgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGludGVybmFsWS52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh5Mikge1xuICAgICAgc2Nyb2xsVG8odm9pZCAwLCB5Mik7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gc2Nyb2xsVG8oX3gsIF95KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IF9lbGVtZW50ID0gdG9WYWx1ZShlbGVtZW50KTtcbiAgICBpZiAoIV9lbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIChfYyA9IF9lbGVtZW50IGluc3RhbmNlb2YgRG9jdW1lbnQgPyB3aW5kb3cuZG9jdW1lbnQuYm9keSA6IF9lbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2Nyb2xsVG8oe1xuICAgICAgdG9wOiAoX2EgPSB0b1ZhbHVlKF95KSkgIT0gbnVsbCA/IF9hIDogeS52YWx1ZSxcbiAgICAgIGxlZnQ6IChfYiA9IHRvVmFsdWUoX3gpKSAhPSBudWxsID8gX2IgOiB4LnZhbHVlLFxuICAgICAgYmVoYXZpb3I6IHRvVmFsdWUoYmVoYXZpb3IpXG4gICAgfSk7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gKChfZCA9IF9lbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudC5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmRvY3VtZW50RWxlbWVudCkgfHwgKF9lbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudC5kb2N1bWVudEVsZW1lbnQpIHx8IF9lbGVtZW50O1xuICAgIGlmICh4ICE9IG51bGwpXG4gICAgICBpbnRlcm5hbFgudmFsdWUgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICBpZiAoeSAhPSBudWxsKVxuICAgICAgaW50ZXJuYWxZLnZhbHVlID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgfVxuICBjb25zdCBpc1Njcm9sbGluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBhcnJpdmVkU3RhdGUgPSByZWFjdGl2ZSh7XG4gICAgbGVmdDogdHJ1ZSxcbiAgICByaWdodDogZmFsc2UsXG4gICAgdG9wOiB0cnVlLFxuICAgIGJvdHRvbTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGRpcmVjdGlvbnMgPSByZWFjdGl2ZSh7XG4gICAgbGVmdDogZmFsc2UsXG4gICAgcmlnaHQ6IGZhbHNlLFxuICAgIHRvcDogZmFsc2UsXG4gICAgYm90dG9tOiBmYWxzZVxuICB9KTtcbiAgY29uc3Qgb25TY3JvbGxFbmQgPSAoZSkgPT4ge1xuICAgIGlmICghaXNTY3JvbGxpbmcudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaXNTY3JvbGxpbmcudmFsdWUgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLmxlZnQgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLnJpZ2h0ID0gZmFsc2U7XG4gICAgZGlyZWN0aW9ucy50b3AgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLmJvdHRvbSA9IGZhbHNlO1xuICAgIG9uU3RvcChlKTtcbiAgfTtcbiAgY29uc3Qgb25TY3JvbGxFbmREZWJvdW5jZWQgPSB1c2VEZWJvdW5jZUZuKG9uU2Nyb2xsRW5kLCB0aHJvdHRsZSArIGlkbGUpO1xuICBjb25zdCBzZXRBcnJpdmVkU3RhdGUgPSAodGFyZ2V0KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsID0gKChfYSA9IHRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZG9jdW1lbnRFbGVtZW50KSB8fCAodGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQuZG9jdW1lbnRFbGVtZW50KSB8fCB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBjb25zdCB7IGRpc3BsYXksIGZsZXhEaXJlY3Rpb24sIGRpcmVjdGlvbiB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgY29uc3QgZGlyZWN0aW9uTXVsdGlwbGVyID0gZGlyZWN0aW9uID09PSBcInJ0bFwiID8gLTEgOiAxO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgIGRpcmVjdGlvbnMubGVmdCA9IHNjcm9sbExlZnQgPCBpbnRlcm5hbFgudmFsdWU7XG4gICAgZGlyZWN0aW9ucy5yaWdodCA9IHNjcm9sbExlZnQgPiBpbnRlcm5hbFgudmFsdWU7XG4gICAgY29uc3QgbGVmdCA9IE1hdGguYWJzKHNjcm9sbExlZnQgKiBkaXJlY3Rpb25NdWx0aXBsZXIpIDw9IChvZmZzZXQubGVmdCB8fCAwKTtcbiAgICBjb25zdCByaWdodCA9IE1hdGguYWJzKHNjcm9sbExlZnQgKiBkaXJlY3Rpb25NdWx0aXBsZXIpICsgZWwuY2xpZW50V2lkdGggPj0gZWwuc2Nyb2xsV2lkdGggLSAob2Zmc2V0LnJpZ2h0IHx8IDApIC0gQVJSSVZFRF9TVEFURV9USFJFU0hPTERfUElYRUxTO1xuICAgIGlmIChkaXNwbGF5ID09PSBcImZsZXhcIiAmJiBmbGV4RGlyZWN0aW9uID09PSBcInJvdy1yZXZlcnNlXCIpIHtcbiAgICAgIGFycml2ZWRTdGF0ZS5sZWZ0ID0gcmlnaHQ7XG4gICAgICBhcnJpdmVkU3RhdGUucmlnaHQgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJpdmVkU3RhdGUubGVmdCA9IGxlZnQ7XG4gICAgICBhcnJpdmVkU3RhdGUucmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgaW50ZXJuYWxYLnZhbHVlID0gc2Nyb2xsTGVmdDtcbiAgICBsZXQgc2Nyb2xsVG9wID0gZWwuc2Nyb2xsVG9wO1xuICAgIGlmICh0YXJnZXQgPT09IHdpbmRvdy5kb2N1bWVudCAmJiAhc2Nyb2xsVG9wKVxuICAgICAgc2Nyb2xsVG9wID0gd2luZG93LmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgIGRpcmVjdGlvbnMudG9wID0gc2Nyb2xsVG9wIDwgaW50ZXJuYWxZLnZhbHVlO1xuICAgIGRpcmVjdGlvbnMuYm90dG9tID0gc2Nyb2xsVG9wID4gaW50ZXJuYWxZLnZhbHVlO1xuICAgIGNvbnN0IHRvcCA9IE1hdGguYWJzKHNjcm9sbFRvcCkgPD0gKG9mZnNldC50b3AgfHwgMCk7XG4gICAgY29uc3QgYm90dG9tID0gTWF0aC5hYnMoc2Nyb2xsVG9wKSArIGVsLmNsaWVudEhlaWdodCA+PSBlbC5zY3JvbGxIZWlnaHQgLSAob2Zmc2V0LmJvdHRvbSB8fCAwKSAtIEFSUklWRURfU1RBVEVfVEhSRVNIT0xEX1BJWEVMUztcbiAgICBpZiAoZGlzcGxheSA9PT0gXCJmbGV4XCIgJiYgZmxleERpcmVjdGlvbiA9PT0gXCJjb2x1bW4tcmV2ZXJzZVwiKSB7XG4gICAgICBhcnJpdmVkU3RhdGUudG9wID0gYm90dG9tO1xuICAgICAgYXJyaXZlZFN0YXRlLmJvdHRvbSA9IHRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyaXZlZFN0YXRlLnRvcCA9IHRvcDtcbiAgICAgIGFycml2ZWRTdGF0ZS5ib3R0b20gPSBib3R0b207XG4gICAgfVxuICAgIGludGVybmFsWS52YWx1ZSA9IHNjcm9sbFRvcDtcbiAgfTtcbiAgY29uc3Qgb25TY3JvbGxIYW5kbGVyID0gKGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF3aW5kb3cpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXZlbnRUYXJnZXQgPSAoX2EgPSBlLnRhcmdldC5kb2N1bWVudEVsZW1lbnQpICE9IG51bGwgPyBfYSA6IGUudGFyZ2V0O1xuICAgIHNldEFycml2ZWRTdGF0ZShldmVudFRhcmdldCk7XG4gICAgaXNTY3JvbGxpbmcudmFsdWUgPSB0cnVlO1xuICAgIG9uU2Nyb2xsRW5kRGVib3VuY2VkKGUpO1xuICAgIG9uU2Nyb2xsKGUpO1xuICB9O1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIGVsZW1lbnQsXG4gICAgXCJzY3JvbGxcIixcbiAgICB0aHJvdHRsZSA/IHVzZVRocm90dGxlRm4ob25TY3JvbGxIYW5kbGVyLCB0aHJvdHRsZSwgdHJ1ZSwgZmFsc2UpIDogb25TY3JvbGxIYW5kbGVyLFxuICAgIGV2ZW50TGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IF9lbGVtZW50ID0gdG9WYWx1ZShlbGVtZW50KTtcbiAgICAgIGlmICghX2VsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHNldEFycml2ZWRTdGF0ZShfZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIGVsZW1lbnQsXG4gICAgXCJzY3JvbGxlbmRcIixcbiAgICBvblNjcm9sbEVuZCxcbiAgICBldmVudExpc3RlbmVyT3B0aW9uc1xuICApO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBpc1Njcm9sbGluZyxcbiAgICBhcnJpdmVkU3RhdGUsXG4gICAgZGlyZWN0aW9ucyxcbiAgICBtZWFzdXJlKCkge1xuICAgICAgY29uc3QgX2VsZW1lbnQgPSB0b1ZhbHVlKGVsZW1lbnQpO1xuICAgICAgaWYgKHdpbmRvdyAmJiBfZWxlbWVudClcbiAgICAgICAgc2V0QXJyaXZlZFN0YXRlKF9lbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUluZmluaXRlU2Nyb2xsKGVsZW1lbnQsIG9uTG9hZE1vcmUsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBkaXJlY3Rpb24gPSBcImJvdHRvbVwiLFxuICAgIGludGVydmFsID0gMTAwLFxuICAgIGNhbkxvYWRNb3JlID0gKCkgPT4gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc3RhdGUgPSByZWFjdGl2ZSh1c2VTY3JvbGwoXG4gICAgZWxlbWVudCxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIFtkaXJlY3Rpb25dOiAoX2EgPSBvcHRpb25zLmRpc3RhbmNlKSAhPSBudWxsID8gX2EgOiAwLFxuICAgICAgICAuLi5vcHRpb25zLm9mZnNldFxuICAgICAgfVxuICAgIH1cbiAgKSk7XG4gIGNvbnN0IHByb21pc2UgPSByZWYoKTtcbiAgY29uc3QgaXNMb2FkaW5nID0gY29tcHV0ZWQoKCkgPT4gISFwcm9taXNlLnZhbHVlKTtcbiAgY29uc3Qgb2JzZXJ2ZWRFbGVtZW50ID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiByZXNvbHZlRWxlbWVudCh0b1ZhbHVlKGVsZW1lbnQpKTtcbiAgfSk7XG4gIGNvbnN0IGlzRWxlbWVudFZpc2libGUgPSB1c2VFbGVtZW50VmlzaWJpbGl0eShvYnNlcnZlZEVsZW1lbnQpO1xuICBmdW5jdGlvbiBjaGVja0FuZExvYWQoKSB7XG4gICAgc3RhdGUubWVhc3VyZSgpO1xuICAgIGlmICghb2JzZXJ2ZWRFbGVtZW50LnZhbHVlIHx8ICFpc0VsZW1lbnRWaXNpYmxlLnZhbHVlIHx8ICFjYW5Mb2FkTW9yZShvYnNlcnZlZEVsZW1lbnQudmFsdWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQsIHNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aCB9ID0gb2JzZXJ2ZWRFbGVtZW50LnZhbHVlO1xuICAgIGNvbnN0IGlzTmFycm93ZXIgPSBkaXJlY3Rpb24gPT09IFwiYm90dG9tXCIgfHwgZGlyZWN0aW9uID09PSBcInRvcFwiID8gc2Nyb2xsSGVpZ2h0IDw9IGNsaWVudEhlaWdodCA6IHNjcm9sbFdpZHRoIDw9IGNsaWVudFdpZHRoO1xuICAgIGlmIChzdGF0ZS5hcnJpdmVkU3RhdGVbZGlyZWN0aW9uXSB8fCBpc05hcnJvd2VyKSB7XG4gICAgICBpZiAoIXByb21pc2UudmFsdWUpIHtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBvbkxvYWRNb3JlKHN0YXRlKSxcbiAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBpbnRlcnZhbCkpXG4gICAgICAgIF0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHByb21pc2UudmFsdWUgPSBudWxsO1xuICAgICAgICAgIG5leHRUaWNrKCgpID0+IGNoZWNrQW5kTG9hZCgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0b3AgPSB3YXRjaChcbiAgICAoKSA9PiBbc3RhdGUuYXJyaXZlZFN0YXRlW2RpcmVjdGlvbl0sIGlzRWxlbWVudFZpc2libGUudmFsdWVdLFxuICAgIGNoZWNrQW5kTG9hZCxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHRyeU9uVW5tb3VudGVkKHN0b3ApO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZyxcbiAgICByZXNldCgpIHtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNoZWNrQW5kTG9hZCgpKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRFdmVudHMgPSBbXCJtb3VzZWRvd25cIiwgXCJtb3VzZXVwXCIsIFwia2V5ZG93blwiLCBcImtleXVwXCJdO1xuZnVuY3Rpb24gdXNlS2V5TW9kaWZpZXIobW9kaWZpZXIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZXZlbnRzID0gZGVmYXVsdEV2ZW50cyxcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBpbml0aWFsID0gbnVsbFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc3RhdGUgPSBzaGFsbG93UmVmKGluaXRpYWwpO1xuICBpZiAoZG9jdW1lbnQpIHtcbiAgICBldmVudHMuZm9yRWFjaCgobGlzdGVuZXJFdmVudCkgPT4ge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgbGlzdGVuZXJFdmVudCwgKGV2dCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGV2dC5nZXRNb2RpZmllclN0YXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgc3RhdGUudmFsdWUgPSBldnQuZ2V0TW9kaWZpZXJTdGF0ZShtb2RpZmllcik7XG4gICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VMb2NhbFN0b3JhZ2Uoa2V5LCBpbml0aWFsVmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB1c2VTdG9yYWdlKGtleSwgaW5pdGlhbFZhbHVlLCB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhbFN0b3JhZ2UsIG9wdGlvbnMpO1xufVxuXG5jb25zdCBEZWZhdWx0TWFnaWNLZXlzQWxpYXNNYXAgPSB7XG4gIGN0cmw6IFwiY29udHJvbFwiLFxuICBjb21tYW5kOiBcIm1ldGFcIixcbiAgY21kOiBcIm1ldGFcIixcbiAgb3B0aW9uOiBcImFsdFwiLFxuICB1cDogXCJhcnJvd3VwXCIsXG4gIGRvd246IFwiYXJyb3dkb3duXCIsXG4gIGxlZnQ6IFwiYXJyb3dsZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93cmlnaHRcIlxufTtcblxuZnVuY3Rpb24gdXNlTWFnaWNLZXlzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcmVhY3RpdmU6IHVzZVJlYWN0aXZlID0gZmFsc2UsXG4gICAgdGFyZ2V0ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBhbGlhc01hcCA9IERlZmF1bHRNYWdpY0tleXNBbGlhc01hcCxcbiAgICBwYXNzaXZlID0gdHJ1ZSxcbiAgICBvbkV2ZW50RmlyZWQgPSBub29wXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjdXJyZW50ID0gcmVhY3RpdmUoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIGNvbnN0IG9iaiA9IHtcbiAgICB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICBjdXJyZW50XG4gIH07XG4gIGNvbnN0IHJlZnMgPSB1c2VSZWFjdGl2ZSA/IHJlYWN0aXZlKG9iaikgOiBvYmo7XG4gIGNvbnN0IG1ldGFEZXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdXNlZEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBzZXRSZWZzKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIHJlZnMpIHtcbiAgICAgIGlmICh1c2VSZWFjdGl2ZSlcbiAgICAgICAgcmVmc1trZXldID0gdmFsdWU7XG4gICAgICBlbHNlXG4gICAgICAgIHJlZnNba2V5XS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjdXJyZW50LmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdXNlZEtleXMpXG4gICAgICBzZXRSZWZzKGtleSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJlZnMoZSwgdmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGtleSA9IChfYSA9IGUua2V5KSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjb2RlID0gKF9iID0gZS5jb2RlKSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbY29kZSwga2V5XS5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHZhbHVlKVxuICAgICAgICBjdXJyZW50LmFkZChrZXkpO1xuICAgICAgZWxzZVxuICAgICAgICBjdXJyZW50LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleTIgb2YgdmFsdWVzKSB7XG4gICAgICB1c2VkS2V5cy5hZGQoa2V5Mik7XG4gICAgICBzZXRSZWZzKGtleTIsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gXCJtZXRhXCIgJiYgIXZhbHVlKSB7XG4gICAgICBtZXRhRGVwcy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICAgIGN1cnJlbnQuZGVsZXRlKGtleTIpO1xuICAgICAgICBzZXRSZWZzKGtleTIsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgbWV0YURlcHMuY2xlYXIoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlLmdldE1vZGlmaWVyU3RhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiBlLmdldE1vZGlmaWVyU3RhdGUoXCJNZXRhXCIpICYmIHZhbHVlKSB7XG4gICAgICBbLi4uY3VycmVudCwgLi4udmFsdWVzXS5mb3JFYWNoKChrZXkyKSA9PiBtZXRhRGVwcy5hZGQoa2V5MikpO1xuICAgIH1cbiAgfVxuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgdXBkYXRlUmVmcyhlLCB0cnVlKTtcbiAgICByZXR1cm4gb25FdmVudEZpcmVkKGUpO1xuICB9LCB7IHBhc3NpdmUgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImtleXVwXCIsIChlKSA9PiB7XG4gICAgdXBkYXRlUmVmcyhlLCBmYWxzZSk7XG4gICAgcmV0dXJuIG9uRXZlbnRGaXJlZChlKTtcbiAgfSwgeyBwYXNzaXZlIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKFwiYmx1clwiLCByZXNldCwgeyBwYXNzaXZlIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgcmVzZXQsIHsgcGFzc2l2ZSB9KTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoXG4gICAgcmVmcyxcbiAgICB7XG4gICAgICBnZXQodGFyZ2V0MiwgcHJvcCwgcmVjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0MiwgcHJvcCwgcmVjKTtcbiAgICAgICAgcHJvcCA9IHByb3AudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHByb3AgaW4gYWxpYXNNYXApXG4gICAgICAgICAgcHJvcCA9IGFsaWFzTWFwW3Byb3BdO1xuICAgICAgICBpZiAoIShwcm9wIGluIHJlZnMpKSB7XG4gICAgICAgICAgaWYgKC9bK18tXS8udGVzdChwcm9wKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHByb3Auc3BsaXQoL1srXy1dL2cpLm1hcCgoaSkgPT4gaS50cmltKCkpO1xuICAgICAgICAgICAgcmVmc1twcm9wXSA9IGNvbXB1dGVkKCgpID0+IGtleXMubWFwKChrZXkpID0+IHRvVmFsdWUocHJveHlba2V5XSkpLmV2ZXJ5KEJvb2xlYW4pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmc1twcm9wXSA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gUmVmbGVjdC5nZXQodGFyZ2V0MiwgcHJvcCwgcmVjKTtcbiAgICAgICAgcmV0dXJuIHVzZVJlYWN0aXZlID8gdG9WYWx1ZShyKSA6IHI7XG4gICAgICB9XG4gICAgfVxuICApO1xuICByZXR1cm4gcHJveHk7XG59XG5cbmZ1bmN0aW9uIHVzaW5nRWxSZWYoc291cmNlLCBjYikge1xuICBpZiAodG9WYWx1ZShzb3VyY2UpKVxuICAgIGNiKHRvVmFsdWUoc291cmNlKSk7XG59XG5mdW5jdGlvbiB0aW1lUmFuZ2VUb0FycmF5KHRpbWVSYW5nZXMpIHtcbiAgbGV0IHJhbmdlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZXMubGVuZ3RoOyArK2kpXG4gICAgcmFuZ2VzID0gWy4uLnJhbmdlcywgW3RpbWVSYW5nZXMuc3RhcnQoaSksIHRpbWVSYW5nZXMuZW5kKGkpXV07XG4gIHJldHVybiByYW5nZXM7XG59XG5mdW5jdGlvbiB0cmFja3NUb0FycmF5KHRyYWNrcykge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0cmFja3MpLm1hcCgoeyBsYWJlbCwga2luZCwgbGFuZ3VhZ2UsIG1vZGUsIGFjdGl2ZUN1ZXMsIGN1ZXMsIGluQmFuZE1ldGFkYXRhVHJhY2tEaXNwYXRjaFR5cGUgfSwgaWQpID0+ICh7IGlkLCBsYWJlbCwga2luZCwgbGFuZ3VhZ2UsIG1vZGUsIGFjdGl2ZUN1ZXMsIGN1ZXMsIGluQmFuZE1ldGFkYXRhVHJhY2tEaXNwYXRjaFR5cGUgfSkpO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHNyYzogXCJcIixcbiAgdHJhY2tzOiBbXVxufTtcbmZ1bmN0aW9uIHVzZU1lZGlhQ29udHJvbHModGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgdGFyZ2V0ID0gdG9SZWYodGFyZ2V0KTtcbiAgb3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgZHVyYXRpb24gPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBzZWVraW5nID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHZvbHVtZSA9IHNoYWxsb3dSZWYoMSk7XG4gIGNvbnN0IHdhaXRpbmcgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgZW5kZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgcGxheWluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCByYXRlID0gc2hhbGxvd1JlZigxKTtcbiAgY29uc3Qgc3RhbGxlZCA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBidWZmZXJlZCA9IHJlZihbXSk7XG4gIGNvbnN0IHRyYWNrcyA9IHJlZihbXSk7XG4gIGNvbnN0IHNlbGVjdGVkVHJhY2sgPSBzaGFsbG93UmVmKC0xKTtcbiAgY29uc3QgaXNQaWN0dXJlSW5QaWN0dXJlID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IG11dGVkID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHN1cHBvcnRzUGljdHVyZUluUGljdHVyZSA9IGRvY3VtZW50ICYmIFwicGljdHVyZUluUGljdHVyZUVuYWJsZWRcIiBpbiBkb2N1bWVudDtcbiAgY29uc3Qgc291cmNlRXJyb3JFdmVudCA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBwbGF5YmFja0Vycm9yRXZlbnQgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgZGlzYWJsZVRyYWNrID0gKHRyYWNrKSA9PiB7XG4gICAgdXNpbmdFbFJlZih0YXJnZXQsIChlbCkgPT4ge1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdHlwZW9mIHRyYWNrID09PSBcIm51bWJlclwiID8gdHJhY2sgOiB0cmFjay5pZDtcbiAgICAgICAgZWwudGV4dFRyYWNrc1tpZF0ubW9kZSA9IFwiZGlzYWJsZWRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWwudGV4dFRyYWNrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBlbC50ZXh0VHJhY2tzW2ldLm1vZGUgPSBcImRpc2FibGVkXCI7XG4gICAgICB9XG4gICAgICBzZWxlY3RlZFRyYWNrLnZhbHVlID0gLTE7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGVuYWJsZVRyYWNrID0gKHRyYWNrLCBkaXNhYmxlVHJhY2tzID0gdHJ1ZSkgPT4ge1xuICAgIHVzaW5nRWxSZWYodGFyZ2V0LCAoZWwpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gdHlwZW9mIHRyYWNrID09PSBcIm51bWJlclwiID8gdHJhY2sgOiB0cmFjay5pZDtcbiAgICAgIGlmIChkaXNhYmxlVHJhY2tzKVxuICAgICAgICBkaXNhYmxlVHJhY2soKTtcbiAgICAgIGVsLnRleHRUcmFja3NbaWRdLm1vZGUgPSBcInNob3dpbmdcIjtcbiAgICAgIHNlbGVjdGVkVHJhY2sudmFsdWUgPSBpZDtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdG9nZ2xlUGljdHVyZUluUGljdHVyZSA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdXNpbmdFbFJlZih0YXJnZXQsIGFzeW5jIChlbCkgPT4ge1xuICAgICAgICBpZiAoc3VwcG9ydHNQaWN0dXJlSW5QaWN0dXJlKSB7XG4gICAgICAgICAgaWYgKCFpc1BpY3R1cmVJblBpY3R1cmUudmFsdWUpIHtcbiAgICAgICAgICAgIGVsLnJlcXVlc3RQaWN0dXJlSW5QaWN0dXJlKCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5leGl0UGljdHVyZUluUGljdHVyZSgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNyYyA9IHRvVmFsdWUob3B0aW9ucy5zcmMpO1xuICAgIGxldCBzb3VyY2VzID0gW107XG4gICAgaWYgKCFzcmMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIpXG4gICAgICBzb3VyY2VzID0gW3sgc3JjIH1dO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgIHNvdXJjZXMgPSBzcmM7XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc3JjKSlcbiAgICAgIHNvdXJjZXMgPSBbc3JjXTtcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgc291cmNlcy5mb3JFYWNoKCh7IHNyYzogc3JjMiwgdHlwZSwgbWVkaWEgfSkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKTtcbiAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjMik7XG4gICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKFwidHlwZVwiLCB0eXBlIHx8IFwiXCIpO1xuICAgICAgc291cmNlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhIHx8IFwiXCIpO1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihzb3VyY2UsIFwiZXJyb3JcIiwgc291cmNlRXJyb3JFdmVudC50cmlnZ2VyLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgICB9KTtcbiAgICBlbC5sb2FkKCk7XG4gIH0pO1xuICB3YXRjaChbdGFyZ2V0LCB2b2x1bWVdLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC52b2x1bWUgPSB2b2x1bWUudmFsdWU7XG4gIH0pO1xuICB3YXRjaChbdGFyZ2V0LCBtdXRlZF0sICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLm11dGVkID0gbXV0ZWQudmFsdWU7XG4gIH0pO1xuICB3YXRjaChbdGFyZ2V0LCByYXRlXSwgKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgZWwucGxheWJhY2tSYXRlID0gcmF0ZS52YWx1ZTtcbiAgfSk7XG4gIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRleHRUcmFja3MgPSB0b1ZhbHVlKG9wdGlvbnMudHJhY2tzKTtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIXRleHRUcmFja3MgfHwgIXRleHRUcmFja3MubGVuZ3RoIHx8ICFlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwidHJhY2tcIikuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gICAgdGV4dFRyYWNrcy5mb3JFYWNoKCh7IGRlZmF1bHQ6IGlzRGVmYXVsdCwga2luZCwgbGFiZWwsIHNyYywgc3JjTGFuZyB9LCBpKSA9PiB7XG4gICAgICBjb25zdCB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0cmFja1wiKTtcbiAgICAgIHRyYWNrLmRlZmF1bHQgPSBpc0RlZmF1bHQgfHwgZmFsc2U7XG4gICAgICB0cmFjay5raW5kID0ga2luZDtcbiAgICAgIHRyYWNrLmxhYmVsID0gbGFiZWw7XG4gICAgICB0cmFjay5zcmMgPSBzcmM7XG4gICAgICB0cmFjay5zcmNsYW5nID0gc3JjTGFuZztcbiAgICAgIGlmICh0cmFjay5kZWZhdWx0KVxuICAgICAgICBzZWxlY3RlZFRyYWNrLnZhbHVlID0gaTtcbiAgICAgIGVsLmFwcGVuZENoaWxkKHRyYWNrKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHsgaWdub3JlVXBkYXRlczogaWdub3JlQ3VycmVudFRpbWVVcGRhdGVzIH0gPSB3YXRjaElnbm9yYWJsZShjdXJyZW50VGltZSwgKHRpbWUpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgfSk7XG4gIGNvbnN0IHsgaWdub3JlVXBkYXRlczogaWdub3JlUGxheWluZ1VwZGF0ZXMgfSA9IHdhdGNoSWdub3JhYmxlKHBsYXlpbmcsIChpc1BsYXlpbmcpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpc1BsYXlpbmcpIHtcbiAgICAgIGVsLnBsYXkoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBwbGF5YmFja0Vycm9yRXZlbnQudHJpZ2dlcihlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwidGltZXVwZGF0ZVwiLFxuICAgICgpID0+IGlnbm9yZUN1cnJlbnRUaW1lVXBkYXRlcygoKSA9PiBjdXJyZW50VGltZS52YWx1ZSA9IHRvVmFsdWUodGFyZ2V0KS5jdXJyZW50VGltZSksXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwiZHVyYXRpb25jaGFuZ2VcIixcbiAgICAoKSA9PiBkdXJhdGlvbi52YWx1ZSA9IHRvVmFsdWUodGFyZ2V0KS5kdXJhdGlvbixcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJwcm9ncmVzc1wiLFxuICAgICgpID0+IGJ1ZmZlcmVkLnZhbHVlID0gdGltZVJhbmdlVG9BcnJheSh0b1ZhbHVlKHRhcmdldCkuYnVmZmVyZWQpLFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcInNlZWtpbmdcIixcbiAgICAoKSA9PiBzZWVraW5nLnZhbHVlID0gdHJ1ZSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJzZWVrZWRcIixcbiAgICAoKSA9PiBzZWVraW5nLnZhbHVlID0gZmFsc2UsXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFtcIndhaXRpbmdcIiwgXCJsb2Fkc3RhcnRcIl0sXG4gICAgKCkgPT4ge1xuICAgICAgd2FpdGluZy52YWx1ZSA9IHRydWU7XG4gICAgICBpZ25vcmVQbGF5aW5nVXBkYXRlcygoKSA9PiBwbGF5aW5nLnZhbHVlID0gZmFsc2UpO1xuICAgIH0sXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwibG9hZGVkZGF0YVwiLFxuICAgICgpID0+IHdhaXRpbmcudmFsdWUgPSBmYWxzZSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJwbGF5aW5nXCIsXG4gICAgKCkgPT4ge1xuICAgICAgd2FpdGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgZW5kZWQudmFsdWUgPSBmYWxzZTtcbiAgICAgIGlnbm9yZVBsYXlpbmdVcGRhdGVzKCgpID0+IHBsYXlpbmcudmFsdWUgPSB0cnVlKTtcbiAgICB9LFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcInJhdGVjaGFuZ2VcIixcbiAgICAoKSA9PiByYXRlLnZhbHVlID0gdG9WYWx1ZSh0YXJnZXQpLnBsYXliYWNrUmF0ZSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJzdGFsbGVkXCIsXG4gICAgKCkgPT4gc3RhbGxlZC52YWx1ZSA9IHRydWUsXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwiZW5kZWRcIixcbiAgICAoKSA9PiBlbmRlZC52YWx1ZSA9IHRydWUsXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwicGF1c2VcIixcbiAgICAoKSA9PiBpZ25vcmVQbGF5aW5nVXBkYXRlcygoKSA9PiBwbGF5aW5nLnZhbHVlID0gZmFsc2UpLFxuICAgIGxpc3RlbmVyT3B0aW9uc1xuICApO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIHRhcmdldCxcbiAgICBcInBsYXlcIixcbiAgICAoKSA9PiBpZ25vcmVQbGF5aW5nVXBkYXRlcygoKSA9PiBwbGF5aW5nLnZhbHVlID0gdHJ1ZSksXG4gICAgbGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgdGFyZ2V0LFxuICAgIFwiZW50ZXJwaWN0dXJlaW5waWN0dXJlXCIsXG4gICAgKCkgPT4gaXNQaWN0dXJlSW5QaWN0dXJlLnZhbHVlID0gdHJ1ZSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJsZWF2ZXBpY3R1cmVpbnBpY3R1cmVcIixcbiAgICAoKSA9PiBpc1BpY3R1cmVJblBpY3R1cmUudmFsdWUgPSBmYWxzZSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgXCJ2b2x1bWVjaGFuZ2VcIixcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICAgIGlmICghZWwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZvbHVtZS52YWx1ZSA9IGVsLnZvbHVtZTtcbiAgICAgIG11dGVkLnZhbHVlID0gZWwubXV0ZWQ7XG4gICAgfSxcbiAgICBsaXN0ZW5lck9wdGlvbnNcbiAgKTtcbiAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gIGNvbnN0IHN0b3AgPSB3YXRjaChbdGFyZ2V0XSwgKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgc3RvcCgpO1xuICAgIGxpc3RlbmVyc1swXSA9IHVzZUV2ZW50TGlzdGVuZXIoZWwudGV4dFRyYWNrcywgXCJhZGR0cmFja1wiLCAoKSA9PiB0cmFja3MudmFsdWUgPSB0cmFja3NUb0FycmF5KGVsLnRleHRUcmFja3MpLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIGxpc3RlbmVyc1sxXSA9IHVzZUV2ZW50TGlzdGVuZXIoZWwudGV4dFRyYWNrcywgXCJyZW1vdmV0cmFja1wiLCAoKSA9PiB0cmFja3MudmFsdWUgPSB0cmFja3NUb0FycmF5KGVsLnRleHRUcmFja3MpLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIGxpc3RlbmVyc1syXSA9IHVzZUV2ZW50TGlzdGVuZXIoZWwudGV4dFRyYWNrcywgXCJjaGFuZ2VcIiwgKCkgPT4gdHJhY2tzLnZhbHVlID0gdHJhY2tzVG9BcnJheShlbC50ZXh0VHJhY2tzKSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfSk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSkpO1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnRUaW1lLFxuICAgIGR1cmF0aW9uLFxuICAgIHdhaXRpbmcsXG4gICAgc2Vla2luZyxcbiAgICBlbmRlZCxcbiAgICBzdGFsbGVkLFxuICAgIGJ1ZmZlcmVkLFxuICAgIHBsYXlpbmcsXG4gICAgcmF0ZSxcbiAgICAvLyBWb2x1bWVcbiAgICB2b2x1bWUsXG4gICAgbXV0ZWQsXG4gICAgLy8gVHJhY2tzXG4gICAgdHJhY2tzLFxuICAgIHNlbGVjdGVkVHJhY2ssXG4gICAgZW5hYmxlVHJhY2ssXG4gICAgZGlzYWJsZVRyYWNrLFxuICAgIC8vIFBpY3R1cmUgaW4gUGljdHVyZVxuICAgIHN1cHBvcnRzUGljdHVyZUluUGljdHVyZSxcbiAgICB0b2dnbGVQaWN0dXJlSW5QaWN0dXJlLFxuICAgIGlzUGljdHVyZUluUGljdHVyZSxcbiAgICAvLyBFdmVudHNcbiAgICBvblNvdXJjZUVycm9yOiBzb3VyY2VFcnJvckV2ZW50Lm9uLFxuICAgIG9uUGxheWJhY2tFcnJvcjogcGxheWJhY2tFcnJvckV2ZW50Lm9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9pemUocmVzb2x2ZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5pdENhY2hlID0gKCkgPT4ge1xuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNhY2hlKVxuICAgICAgcmV0dXJuIHNoYWxsb3dSZWFjdGl2ZShvcHRpb25zLmNhY2hlKTtcbiAgICByZXR1cm4gc2hhbGxvd1JlYWN0aXZlKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB9O1xuICBjb25zdCBjYWNoZSA9IGluaXRDYWNoZSgpO1xuICBjb25zdCBnZW5lcmF0ZUtleSA9ICguLi5hcmdzKSA9PiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRLZXkpID8gb3B0aW9ucy5nZXRLZXkoLi4uYXJncykgOiBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgY29uc3QgX2xvYWREYXRhID0gKGtleSwgLi4uYXJncykgPT4ge1xuICAgIGNhY2hlLnNldChrZXksIHJlc29sdmVyKC4uLmFyZ3MpKTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gIH07XG4gIGNvbnN0IGxvYWREYXRhID0gKC4uLmFyZ3MpID0+IF9sb2FkRGF0YShnZW5lcmF0ZUtleSguLi5hcmdzKSwgLi4uYXJncyk7XG4gIGNvbnN0IGRlbGV0ZURhdGEgPSAoLi4uYXJncykgPT4ge1xuICAgIGNhY2hlLmRlbGV0ZShnZW5lcmF0ZUtleSguLi5hcmdzKSk7XG4gIH07XG4gIGNvbnN0IGNsZWFyRGF0YSA9ICgpID0+IHtcbiAgICBjYWNoZS5jbGVhcigpO1xuICB9O1xuICBjb25zdCBtZW1vaXplZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXkoLi4uYXJncyk7XG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKVxuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIHJldHVybiBfbG9hZERhdGEoa2V5LCAuLi5hcmdzKTtcbiAgfTtcbiAgbWVtb2l6ZWQubG9hZCA9IGxvYWREYXRhO1xuICBtZW1vaXplZC5kZWxldGUgPSBkZWxldGVEYXRhO1xuICBtZW1vaXplZC5jbGVhciA9IGNsZWFyRGF0YTtcbiAgbWVtb2l6ZWQuZ2VuZXJhdGVLZXkgPSBnZW5lcmF0ZUtleTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG5mdW5jdGlvbiB1c2VNZW1vcnkob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IG1lbW9yeSA9IHJlZigpO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJtZW1vcnlcIiBpbiBwZXJmb3JtYW5jZSk7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIGNvbnN0IHsgaW50ZXJ2YWwgPSAxZTMgfSA9IG9wdGlvbnM7XG4gICAgdXNlSW50ZXJ2YWxGbigoKSA9PiB7XG4gICAgICBtZW1vcnkudmFsdWUgPSBwZXJmb3JtYW5jZS5tZW1vcnk7XG4gICAgfSwgaW50ZXJ2YWwsIHsgaW1tZWRpYXRlOiBvcHRpb25zLmltbWVkaWF0ZSwgaW1tZWRpYXRlQ2FsbGJhY2s6IG9wdGlvbnMuaW1tZWRpYXRlQ2FsbGJhY2sgfSk7XG4gIH1cbiAgcmV0dXJuIHsgaXNTdXBwb3J0ZWQsIG1lbW9yeSB9O1xufVxuXG5jb25zdCBVc2VNb3VzZUJ1aWx0aW5FeHRyYWN0b3JzID0ge1xuICBwYWdlOiAoZXZlbnQpID0+IFtldmVudC5wYWdlWCwgZXZlbnQucGFnZVldLFxuICBjbGllbnQ6IChldmVudCkgPT4gW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldLFxuICBzY3JlZW46IChldmVudCkgPT4gW2V2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblldLFxuICBtb3ZlbWVudDogKGV2ZW50KSA9PiBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBbZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFldIDogbnVsbFxufTtcbmZ1bmN0aW9uIHVzZU1vdXNlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdHlwZSA9IFwicGFnZVwiLFxuICAgIHRvdWNoID0gdHJ1ZSxcbiAgICByZXNldE9uVG91Y2hFbmRzID0gZmFsc2UsXG4gICAgaW5pdGlhbFZhbHVlID0geyB4OiAwLCB5OiAwIH0sXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICB0YXJnZXQgPSB3aW5kb3csXG4gICAgc2Nyb2xsID0gdHJ1ZSxcbiAgICBldmVudEZpbHRlclxuICB9ID0gb3B0aW9ucztcbiAgbGV0IF9wcmV2TW91c2VFdmVudCA9IG51bGw7XG4gIGxldCBfcHJldlNjcm9sbFggPSAwO1xuICBsZXQgX3ByZXZTY3JvbGxZID0gMDtcbiAgY29uc3QgeCA9IHNoYWxsb3dSZWYoaW5pdGlhbFZhbHVlLngpO1xuICBjb25zdCB5ID0gc2hhbGxvd1JlZihpbml0aWFsVmFsdWUueSk7XG4gIGNvbnN0IHNvdXJjZVR5cGUgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBleHRyYWN0b3IgPSB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiID8gdHlwZSA6IFVzZU1vdXNlQnVpbHRpbkV4dHJhY3RvcnNbdHlwZV07XG4gIGNvbnN0IG1vdXNlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4dHJhY3RvcihldmVudCk7XG4gICAgX3ByZXZNb3VzZUV2ZW50ID0gZXZlbnQ7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgW3gudmFsdWUsIHkudmFsdWVdID0gcmVzdWx0O1xuICAgICAgc291cmNlVHlwZS52YWx1ZSA9IFwibW91c2VcIjtcbiAgICB9XG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgX3ByZXZTY3JvbGxYID0gd2luZG93LnNjcm9sbFg7XG4gICAgICBfcHJldlNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRvdWNoSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4dHJhY3RvcihldmVudC50b3VjaGVzWzBdKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgW3gudmFsdWUsIHkudmFsdWVdID0gcmVzdWx0O1xuICAgICAgICBzb3VyY2VUeXBlLnZhbHVlID0gXCJ0b3VjaFwiO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2Nyb2xsSGFuZGxlciA9ICgpID0+IHtcbiAgICBpZiAoIV9wcmV2TW91c2VFdmVudCB8fCAhd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBvcyA9IGV4dHJhY3RvcihfcHJldk1vdXNlRXZlbnQpO1xuICAgIGlmIChfcHJldk1vdXNlRXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ICYmIHBvcykge1xuICAgICAgeC52YWx1ZSA9IHBvc1swXSArIHdpbmRvdy5zY3JvbGxYIC0gX3ByZXZTY3JvbGxYO1xuICAgICAgeS52YWx1ZSA9IHBvc1sxXSArIHdpbmRvdy5zY3JvbGxZIC0gX3ByZXZTY3JvbGxZO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgeC52YWx1ZSA9IGluaXRpYWxWYWx1ZS54O1xuICAgIHkudmFsdWUgPSBpbml0aWFsVmFsdWUueTtcbiAgfTtcbiAgY29uc3QgbW91c2VIYW5kbGVyV3JhcHBlciA9IGV2ZW50RmlsdGVyID8gKGV2ZW50KSA9PiBldmVudEZpbHRlcigoKSA9PiBtb3VzZUhhbmRsZXIoZXZlbnQpLCB7fSkgOiAoZXZlbnQpID0+IG1vdXNlSGFuZGxlcihldmVudCk7XG4gIGNvbnN0IHRvdWNoSGFuZGxlcldyYXBwZXIgPSBldmVudEZpbHRlciA/IChldmVudCkgPT4gZXZlbnRGaWx0ZXIoKCkgPT4gdG91Y2hIYW5kbGVyKGV2ZW50KSwge30pIDogKGV2ZW50KSA9PiB0b3VjaEhhbmRsZXIoZXZlbnQpO1xuICBjb25zdCBzY3JvbGxIYW5kbGVyV3JhcHBlciA9IGV2ZW50RmlsdGVyID8gKCkgPT4gZXZlbnRGaWx0ZXIoKCkgPT4gc2Nyb2xsSGFuZGxlcigpLCB7fSkgOiAoKSA9PiBzY3JvbGxIYW5kbGVyKCk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgW1wibW91c2Vtb3ZlXCIsIFwiZHJhZ292ZXJcIl0sIG1vdXNlSGFuZGxlcldyYXBwZXIsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgaWYgKHRvdWNoICYmIHR5cGUgIT09IFwibW92ZW1lbnRcIikge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFtcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaG1vdmVcIl0sIHRvdWNoSGFuZGxlcldyYXBwZXIsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgICBpZiAocmVzZXRPblRvdWNoRW5kcylcbiAgICAgICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidG91Y2hlbmRcIiwgcmVzZXQsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChzY3JvbGwgJiYgdHlwZSA9PT0gXCJwYWdlXCIpXG4gICAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJzY3JvbGxcIiwgc2Nyb2xsSGFuZGxlcldyYXBwZXIsIGxpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgc291cmNlVHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VNb3VzZUluRWxlbWVudCh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaGFuZGxlT3V0c2lkZSA9IHRydWUsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBcInBhZ2VcIjtcbiAgY29uc3QgeyB4LCB5LCBzb3VyY2VUeXBlIH0gPSB1c2VNb3VzZShvcHRpb25zKTtcbiAgY29uc3QgdGFyZ2V0UmVmID0gc2hhbGxvd1JlZih0YXJnZXQgIT0gbnVsbCA/IHRhcmdldCA6IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50LmJvZHkpO1xuICBjb25zdCBlbGVtZW50WCA9IHNoYWxsb3dSZWYoMCk7XG4gIGNvbnN0IGVsZW1lbnRZID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgZWxlbWVudFBvc2l0aW9uWCA9IHNoYWxsb3dSZWYoMCk7XG4gIGNvbnN0IGVsZW1lbnRQb3NpdGlvblkgPSBzaGFsbG93UmVmKDApO1xuICBjb25zdCBlbGVtZW50SGVpZ2h0ID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgZWxlbWVudFdpZHRoID0gc2hhbGxvd1JlZigwKTtcbiAgY29uc3QgaXNPdXRzaWRlID0gc2hhbGxvd1JlZih0cnVlKTtcbiAgbGV0IHN0b3AgPSAoKSA9PiB7XG4gIH07XG4gIGlmICh3aW5kb3cpIHtcbiAgICBzdG9wID0gd2F0Y2goXG4gICAgICBbdGFyZ2V0UmVmLCB4LCB5XSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0UmVmKTtcbiAgICAgICAgaWYgKCFlbCB8fCAhKGVsIGluc3RhbmNlb2YgRWxlbWVudCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgZWxlbWVudFBvc2l0aW9uWC52YWx1ZSA9IGxlZnQgKyAodHlwZSA9PT0gXCJwYWdlXCIgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiAwKTtcbiAgICAgICAgZWxlbWVudFBvc2l0aW9uWS52YWx1ZSA9IHRvcCArICh0eXBlID09PSBcInBhZ2VcIiA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IDApO1xuICAgICAgICBlbGVtZW50SGVpZ2h0LnZhbHVlID0gaGVpZ2h0O1xuICAgICAgICBlbGVtZW50V2lkdGgudmFsdWUgPSB3aWR0aDtcbiAgICAgICAgY29uc3QgZWxYID0geC52YWx1ZSAtIGVsZW1lbnRQb3NpdGlvblgudmFsdWU7XG4gICAgICAgIGNvbnN0IGVsWSA9IHkudmFsdWUgLSBlbGVtZW50UG9zaXRpb25ZLnZhbHVlO1xuICAgICAgICBpc091dHNpZGUudmFsdWUgPSB3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDAgfHwgZWxYIDwgMCB8fCBlbFkgPCAwIHx8IGVsWCA+IHdpZHRoIHx8IGVsWSA+IGhlaWdodDtcbiAgICAgICAgaWYgKGhhbmRsZU91dHNpZGUgfHwgIWlzT3V0c2lkZS52YWx1ZSkge1xuICAgICAgICAgIGVsZW1lbnRYLnZhbHVlID0gZWxYO1xuICAgICAgICAgIGVsZW1lbnRZLnZhbHVlID0gZWxZO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICAgICk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJtb3VzZWxlYXZlXCIsXG4gICAgICAoKSA9PiBpc091dHNpZGUudmFsdWUgPSB0cnVlLFxuICAgICAgeyBwYXNzaXZlOiB0cnVlIH1cbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHNvdXJjZVR5cGUsXG4gICAgZWxlbWVudFgsXG4gICAgZWxlbWVudFksXG4gICAgZWxlbWVudFBvc2l0aW9uWCxcbiAgICBlbGVtZW50UG9zaXRpb25ZLFxuICAgIGVsZW1lbnRIZWlnaHQsXG4gICAgZWxlbWVudFdpZHRoLFxuICAgIGlzT3V0c2lkZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1vdXNlUHJlc3NlZChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRvdWNoID0gdHJ1ZSxcbiAgICBkcmFnID0gdHJ1ZSxcbiAgICBjYXB0dXJlID0gZmFsc2UsXG4gICAgaW5pdGlhbFZhbHVlID0gZmFsc2UsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJlc3NlZCA9IHNoYWxsb3dSZWYoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgc291cmNlVHlwZSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZXNzZWQsXG4gICAgICBzb3VyY2VUeXBlXG4gICAgfTtcbiAgfVxuICBjb25zdCBvblByZXNzZWQgPSAoc3JjVHlwZSkgPT4gKGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHByZXNzZWQudmFsdWUgPSB0cnVlO1xuICAgIHNvdXJjZVR5cGUudmFsdWUgPSBzcmNUeXBlO1xuICAgIChfYSA9IG9wdGlvbnMub25QcmVzc2VkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBldmVudCk7XG4gIH07XG4gIGNvbnN0IG9uUmVsZWFzZWQgPSAoZXZlbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcHJlc3NlZC52YWx1ZSA9IGZhbHNlO1xuICAgIHNvdXJjZVR5cGUudmFsdWUgPSBudWxsO1xuICAgIChfYSA9IG9wdGlvbnMub25SZWxlYXNlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgZXZlbnQpO1xuICB9O1xuICBjb25zdCB0YXJnZXQgPSBjb21wdXRlZCgoKSA9PiB1bnJlZkVsZW1lbnQob3B0aW9ucy50YXJnZXQpIHx8IHdpbmRvdyk7XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9O1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJtb3VzZWRvd25cIiwgb25QcmVzc2VkKFwibW91c2VcIiksIGxpc3RlbmVyT3B0aW9ucyk7XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm1vdXNlbGVhdmVcIiwgb25SZWxlYXNlZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwibW91c2V1cFwiLCBvblJlbGVhc2VkLCBsaXN0ZW5lck9wdGlvbnMpO1xuICBpZiAoZHJhZykge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyYWdzdGFydFwiLCBvblByZXNzZWQoXCJtb3VzZVwiKSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJkcm9wXCIsIG9uUmVsZWFzZWQsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiZHJhZ2VuZFwiLCBvblJlbGVhc2VkLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIGlmICh0b3VjaCkge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInRvdWNoc3RhcnRcIiwgb25QcmVzc2VkKFwidG91Y2hcIiksIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hlbmRcIiwgb25SZWxlYXNlZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaGNhbmNlbFwiLCBvblJlbGVhc2VkLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJlc3NlZCxcbiAgICBzb3VyY2VUeXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU5hdmlnYXRvckxhbmd1YWdlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Lm5hdmlnYXRvcjtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwibGFuZ3VhZ2VcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBsYW5ndWFnZSA9IHNoYWxsb3dSZWYobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJsYW5ndWFnZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgaWYgKG5hdmlnYXRvcilcbiAgICAgIGxhbmd1YWdlLnZhbHVlID0gbmF2aWdhdG9yLmxhbmd1YWdlO1xuICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgbGFuZ3VhZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTmV0d29yayhvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImNvbm5lY3Rpb25cIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBpc09ubGluZSA9IHNoYWxsb3dSZWYodHJ1ZSk7XG4gIGNvbnN0IHNhdmVEYXRhID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IG9mZmxpbmVBdCA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3Qgb25saW5lQXQgPSBzaGFsbG93UmVmKHZvaWQgMCk7XG4gIGNvbnN0IGRvd25saW5rID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCBkb3dubGlua01heCA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3QgcnR0ID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCBlZmZlY3RpdmVUeXBlID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCB0eXBlID0gc2hhbGxvd1JlZihcInVua25vd25cIik7XG4gIGNvbnN0IGNvbm5lY3Rpb24gPSBpc1N1cHBvcnRlZC52YWx1ZSAmJiBuYXZpZ2F0b3IuY29ubmVjdGlvbjtcbiAgZnVuY3Rpb24gdXBkYXRlTmV0d29ya0luZm9ybWF0aW9uKCkge1xuICAgIGlmICghbmF2aWdhdG9yKVxuICAgICAgcmV0dXJuO1xuICAgIGlzT25saW5lLnZhbHVlID0gbmF2aWdhdG9yLm9uTGluZTtcbiAgICBvZmZsaW5lQXQudmFsdWUgPSBpc09ubGluZS52YWx1ZSA/IHZvaWQgMCA6IERhdGUubm93KCk7XG4gICAgb25saW5lQXQudmFsdWUgPSBpc09ubGluZS52YWx1ZSA/IERhdGUubm93KCkgOiB2b2lkIDA7XG4gICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgIGRvd25saW5rLnZhbHVlID0gY29ubmVjdGlvbi5kb3dubGluaztcbiAgICAgIGRvd25saW5rTWF4LnZhbHVlID0gY29ubmVjdGlvbi5kb3dubGlua01heDtcbiAgICAgIGVmZmVjdGl2ZVR5cGUudmFsdWUgPSBjb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGU7XG4gICAgICBydHQudmFsdWUgPSBjb25uZWN0aW9uLnJ0dDtcbiAgICAgIHNhdmVEYXRhLnZhbHVlID0gY29ubmVjdGlvbi5zYXZlRGF0YTtcbiAgICAgIHR5cGUudmFsdWUgPSBjb25uZWN0aW9uLnR5cGU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICBpZiAod2luZG93KSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICBpc09ubGluZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgb2ZmbGluZUF0LnZhbHVlID0gRGF0ZS5ub3coKTtcbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm9ubGluZVwiLCAoKSA9PiB7XG4gICAgICBpc09ubGluZS52YWx1ZSA9IHRydWU7XG4gICAgICBvbmxpbmVBdC52YWx1ZSA9IERhdGUubm93KCk7XG4gICAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICBpZiAoY29ubmVjdGlvbilcbiAgICB1c2VFdmVudExpc3RlbmVyKGNvbm5lY3Rpb24sIFwiY2hhbmdlXCIsIHVwZGF0ZU5ldHdvcmtJbmZvcm1hdGlvbiwgbGlzdGVuZXJPcHRpb25zKTtcbiAgdXBkYXRlTmV0d29ya0luZm9ybWF0aW9uKCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNPbmxpbmU6IHJlYWRvbmx5KGlzT25saW5lKSxcbiAgICBzYXZlRGF0YTogcmVhZG9ubHkoc2F2ZURhdGEpLFxuICAgIG9mZmxpbmVBdDogcmVhZG9ubHkob2ZmbGluZUF0KSxcbiAgICBvbmxpbmVBdDogcmVhZG9ubHkob25saW5lQXQpLFxuICAgIGRvd25saW5rOiByZWFkb25seShkb3dubGluayksXG4gICAgZG93bmxpbmtNYXg6IHJlYWRvbmx5KGRvd25saW5rTWF4KSxcbiAgICBlZmZlY3RpdmVUeXBlOiByZWFkb25seShlZmZlY3RpdmVUeXBlKSxcbiAgICBydHQ6IHJlYWRvbmx5KHJ0dCksXG4gICAgdHlwZTogcmVhZG9ubHkodHlwZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTm93KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHM6IGV4cG9zZUNvbnRyb2xzID0gZmFsc2UsXG4gICAgaW50ZXJ2YWwgPSBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBub3cgPSByZWYoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpO1xuICBjb25zdCB1cGRhdGUgPSAoKSA9PiBub3cudmFsdWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgY29uc3QgY29udHJvbHMgPSBpbnRlcnZhbCA9PT0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIiA/IHVzZVJhZkZuKHVwZGF0ZSwgeyBpbW1lZGlhdGU6IHRydWUgfSkgOiB1c2VJbnRlcnZhbEZuKHVwZGF0ZSwgaW50ZXJ2YWwsIHsgaW1tZWRpYXRlOiB0cnVlIH0pO1xuICBpZiAoZXhwb3NlQ29udHJvbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm93LFxuICAgICAgLi4uY29udHJvbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub3c7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlT2JqZWN0VXJsKG9iamVjdCkge1xuICBjb25zdCB1cmwgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IHJlbGVhc2UgPSAoKSA9PiB7XG4gICAgaWYgKHVybC52YWx1ZSlcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsLnZhbHVlKTtcbiAgICB1cmwudmFsdWUgPSB2b2lkIDA7XG4gIH07XG4gIHdhdGNoKFxuICAgICgpID0+IHRvVmFsdWUob2JqZWN0KSxcbiAgICAobmV3T2JqZWN0KSA9PiB7XG4gICAgICByZWxlYXNlKCk7XG4gICAgICBpZiAobmV3T2JqZWN0KVxuICAgICAgICB1cmwudmFsdWUgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ld09iamVjdCk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHJlbGVhc2UpO1xuICByZXR1cm4gcmVhZG9ubHkodXJsKTtcbn1cblxuZnVuY3Rpb24gdXNlQ2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fCBpc1JlYWRvbmx5KHZhbHVlKSlcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gY2xhbXAodG9WYWx1ZSh2YWx1ZSksIHRvVmFsdWUobWluKSwgdG9WYWx1ZShtYXgpKSk7XG4gIGNvbnN0IF92YWx1ZSA9IHJlZih2YWx1ZSk7XG4gIHJldHVybiBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIF92YWx1ZS52YWx1ZSA9IGNsYW1wKF92YWx1ZS52YWx1ZSwgdG9WYWx1ZShtaW4pLCB0b1ZhbHVlKG1heCkpO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlMikge1xuICAgICAgX3ZhbHVlLnZhbHVlID0gY2xhbXAodmFsdWUyLCB0b1ZhbHVlKG1pbiksIHRvVmFsdWUobWF4KSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlT2Zmc2V0UGFnaW5hdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0b3RhbCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBwYWdlU2l6ZSA9IDEwLFxuICAgIHBhZ2UgPSAxLFxuICAgIG9uUGFnZUNoYW5nZSA9IG5vb3AsXG4gICAgb25QYWdlU2l6ZUNoYW5nZSA9IG5vb3AsXG4gICAgb25QYWdlQ291bnRDaGFuZ2UgPSBub29wXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjdXJyZW50UGFnZVNpemUgPSB1c2VDbGFtcChwYWdlU2l6ZSwgMSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgY29uc3QgcGFnZUNvdW50ID0gY29tcHV0ZWQoKCkgPT4gTWF0aC5tYXgoXG4gICAgMSxcbiAgICBNYXRoLmNlaWwodG9WYWx1ZSh0b3RhbCkgLyB0b1ZhbHVlKGN1cnJlbnRQYWdlU2l6ZSkpXG4gICkpO1xuICBjb25zdCBjdXJyZW50UGFnZSA9IHVzZUNsYW1wKHBhZ2UsIDEsIHBhZ2VDb3VudCk7XG4gIGNvbnN0IGlzRmlyc3RQYWdlID0gY29tcHV0ZWQoKCkgPT4gY3VycmVudFBhZ2UudmFsdWUgPT09IDEpO1xuICBjb25zdCBpc0xhc3RQYWdlID0gY29tcHV0ZWQoKCkgPT4gY3VycmVudFBhZ2UudmFsdWUgPT09IHBhZ2VDb3VudC52YWx1ZSk7XG4gIGlmIChpc1JlZihwYWdlKSkge1xuICAgIHN5bmNSZWYocGFnZSwgY3VycmVudFBhZ2UsIHtcbiAgICAgIGRpcmVjdGlvbjogaXNSZWFkb25seShwYWdlKSA/IFwibHRyXCIgOiBcImJvdGhcIlxuICAgIH0pO1xuICB9XG4gIGlmIChpc1JlZihwYWdlU2l6ZSkpIHtcbiAgICBzeW5jUmVmKHBhZ2VTaXplLCBjdXJyZW50UGFnZVNpemUsIHtcbiAgICAgIGRpcmVjdGlvbjogaXNSZWFkb25seShwYWdlU2l6ZSkgPyBcImx0clwiIDogXCJib3RoXCJcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2KCkge1xuICAgIGN1cnJlbnRQYWdlLnZhbHVlLS07XG4gIH1cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBjdXJyZW50UGFnZS52YWx1ZSsrO1xuICB9XG4gIGNvbnN0IHJldHVyblZhbHVlID0ge1xuICAgIGN1cnJlbnRQYWdlLFxuICAgIGN1cnJlbnRQYWdlU2l6ZSxcbiAgICBwYWdlQ291bnQsXG4gICAgaXNGaXJzdFBhZ2UsXG4gICAgaXNMYXN0UGFnZSxcbiAgICBwcmV2LFxuICAgIG5leHRcbiAgfTtcbiAgd2F0Y2goY3VycmVudFBhZ2UsICgpID0+IHtcbiAgICBvblBhZ2VDaGFuZ2UocmVhY3RpdmUocmV0dXJuVmFsdWUpKTtcbiAgfSk7XG4gIHdhdGNoKGN1cnJlbnRQYWdlU2l6ZSwgKCkgPT4ge1xuICAgIG9uUGFnZVNpemVDaGFuZ2UocmVhY3RpdmUocmV0dXJuVmFsdWUpKTtcbiAgfSk7XG4gIHdhdGNoKHBhZ2VDb3VudCwgKCkgPT4ge1xuICAgIG9uUGFnZUNvdW50Q2hhbmdlKHJlYWN0aXZlKHJldHVyblZhbHVlKSk7XG4gIH0pO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZU9ubGluZShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBpc09ubGluZSB9ID0gdXNlTmV0d29yayhvcHRpb25zKTtcbiAgcmV0dXJuIGlzT25saW5lO1xufVxuXG5mdW5jdGlvbiB1c2VQYWdlTGVhdmUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNMZWZ0ID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIXdpbmRvdylcbiAgICAgIHJldHVybjtcbiAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICBjb25zdCBmcm9tID0gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50b0VsZW1lbnQ7XG4gICAgaXNMZWZ0LnZhbHVlID0gIWZyb207XG4gIH07XG4gIGlmICh3aW5kb3cpIHtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJtb3VzZW91dFwiLCBoYW5kbGVyLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LmRvY3VtZW50LCBcIm1vdXNlbGVhdmVcIiwgaGFuZGxlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdy5kb2N1bWVudCwgXCJtb3VzZWVudGVyXCIsIGhhbmRsZXIsIGxpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGlzTGVmdDtcbn1cblxuZnVuY3Rpb24gdXNlU2NyZWVuT3JpZW50YXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJzY3JlZW5cIiBpbiB3aW5kb3cgJiYgXCJvcmllbnRhdGlvblwiIGluIHdpbmRvdy5zY3JlZW4pO1xuICBjb25zdCBzY3JlZW5PcmllbnRhdGlvbiA9IGlzU3VwcG9ydGVkLnZhbHVlID8gd2luZG93LnNjcmVlbi5vcmllbnRhdGlvbiA6IHt9O1xuICBjb25zdCBvcmllbnRhdGlvbiA9IHJlZihzY3JlZW5PcmllbnRhdGlvbi50eXBlKTtcbiAgY29uc3QgYW5nbGUgPSBzaGFsbG93UmVmKHNjcmVlbk9yaWVudGF0aW9uLmFuZ2xlIHx8IDApO1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJvcmllbnRhdGlvbmNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBvcmllbnRhdGlvbi52YWx1ZSA9IHNjcmVlbk9yaWVudGF0aW9uLnR5cGU7XG4gICAgICBhbmdsZS52YWx1ZSA9IHNjcmVlbk9yaWVudGF0aW9uLmFuZ2xlO1xuICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuICBjb25zdCBsb2NrT3JpZW50YXRpb24gPSAodHlwZSkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB0eXBlb2Ygc2NyZWVuT3JpZW50YXRpb24ubG9jayA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIHNjcmVlbk9yaWVudGF0aW9uLmxvY2sodHlwZSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWRcIikpO1xuICB9O1xuICBjb25zdCB1bmxvY2tPcmllbnRhdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgdHlwZW9mIHNjcmVlbk9yaWVudGF0aW9uLnVubG9jayA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgc2NyZWVuT3JpZW50YXRpb24udW5sb2NrKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgb3JpZW50YXRpb24sXG4gICAgYW5nbGUsXG4gICAgbG9ja09yaWVudGF0aW9uLFxuICAgIHVubG9ja09yaWVudGF0aW9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVBhcmFsbGF4KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkZXZpY2VPcmllbnRhdGlvblRpbHRBZGp1c3QgPSAoaSkgPT4gaSxcbiAgICBkZXZpY2VPcmllbnRhdGlvblJvbGxBZGp1c3QgPSAoaSkgPT4gaSxcbiAgICBtb3VzZVRpbHRBZGp1c3QgPSAoaSkgPT4gaSxcbiAgICBtb3VzZVJvbGxBZGp1c3QgPSAoaSkgPT4gaSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBvcmllbnRhdGlvbiA9IHJlYWN0aXZlKHVzZURldmljZU9yaWVudGF0aW9uKHsgd2luZG93IH0pKTtcbiAgY29uc3Qgc2NyZWVuT3JpZW50YXRpb24gPSByZWFjdGl2ZSh1c2VTY3JlZW5PcmllbnRhdGlvbih7IHdpbmRvdyB9KSk7XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50WDogeCxcbiAgICBlbGVtZW50WTogeSxcbiAgICBlbGVtZW50V2lkdGg6IHdpZHRoLFxuICAgIGVsZW1lbnRIZWlnaHQ6IGhlaWdodFxuICB9ID0gdXNlTW91c2VJbkVsZW1lbnQodGFyZ2V0LCB7IGhhbmRsZU91dHNpZGU6IGZhbHNlLCB3aW5kb3cgfSk7XG4gIGNvbnN0IHNvdXJjZSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAob3JpZW50YXRpb24uaXNTdXBwb3J0ZWQgJiYgKG9yaWVudGF0aW9uLmFscGhhICE9IG51bGwgJiYgb3JpZW50YXRpb24uYWxwaGEgIT09IDAgfHwgb3JpZW50YXRpb24uZ2FtbWEgIT0gbnVsbCAmJiBvcmllbnRhdGlvbi5nYW1tYSAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBcImRldmljZU9yaWVudGF0aW9uXCI7XG4gICAgfVxuICAgIHJldHVybiBcIm1vdXNlXCI7XG4gIH0pO1xuICBjb25zdCByb2xsID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChzb3VyY2UudmFsdWUgPT09IFwiZGV2aWNlT3JpZW50YXRpb25cIikge1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgc3dpdGNoIChzY3JlZW5PcmllbnRhdGlvbi5vcmllbnRhdGlvbikge1xuICAgICAgICBjYXNlIFwibGFuZHNjYXBlLXByaW1hcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IG9yaWVudGF0aW9uLmdhbW1hIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsYW5kc2NhcGUtc2Vjb25kYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSAtb3JpZW50YXRpb24uZ2FtbWEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvcnRyYWl0LXByaW1hcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IC1vcmllbnRhdGlvbi5iZXRhIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3J0cmFpdC1zZWNvbmRhcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IG9yaWVudGF0aW9uLmJldGEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IC1vcmllbnRhdGlvbi5iZXRhIC8gOTA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlT3JpZW50YXRpb25Sb2xsQWRqdXN0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSAtKHkudmFsdWUgLSBoZWlnaHQudmFsdWUgLyAyKSAvIGhlaWdodC52YWx1ZTtcbiAgICAgIHJldHVybiBtb3VzZVJvbGxBZGp1c3QodmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRpbHQgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKHNvdXJjZS52YWx1ZSA9PT0gXCJkZXZpY2VPcmllbnRhdGlvblwiKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBzd2l0Y2ggKHNjcmVlbk9yaWVudGF0aW9uLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJsYW5kc2NhcGUtcHJpbWFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gb3JpZW50YXRpb24uYmV0YSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGFuZHNjYXBlLXNlY29uZGFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gLW9yaWVudGF0aW9uLmJldGEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvcnRyYWl0LXByaW1hcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IG9yaWVudGF0aW9uLmdhbW1hIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3J0cmFpdC1zZWNvbmRhcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IC1vcmllbnRhdGlvbi5nYW1tYSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbHVlID0gb3JpZW50YXRpb24uZ2FtbWEgLyA5MDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2VPcmllbnRhdGlvblRpbHRBZGp1c3QodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWx1ZSA9ICh4LnZhbHVlIC0gd2lkdGgudmFsdWUgLyAyKSAvIHdpZHRoLnZhbHVlO1xuICAgICAgcmV0dXJuIG1vdXNlVGlsdEFkanVzdCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgcm9sbCwgdGlsdCwgc291cmNlIH07XG59XG5cbmZ1bmN0aW9uIHVzZVBhcmVudEVsZW1lbnQoZWxlbWVudCA9IHVzZUN1cnJlbnRFbGVtZW50KCkpIHtcbiAgY29uc3QgcGFyZW50RWxlbWVudCA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmIChlbClcbiAgICAgIHBhcmVudEVsZW1lbnQudmFsdWUgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9O1xuICB0cnlPbk1vdW50ZWQodXBkYXRlKTtcbiAgd2F0Y2goKCkgPT4gdG9WYWx1ZShlbGVtZW50KSwgdXBkYXRlKTtcbiAgcmV0dXJuIHBhcmVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZVBlcmZvcm1hbmNlT2JzZXJ2ZXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICAuLi5wZXJmb3JtYW5jZU9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIlBlcmZvcm1hbmNlT2JzZXJ2ZXJcIiBpbiB3aW5kb3cpO1xuICBsZXQgb2JzZXJ2ZXI7XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgb2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfTtcbiAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgICBzdG9wKCk7XG4gICAgICBvYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUocGVyZm9ybWFuY2VPcHRpb25zKTtcbiAgICB9XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHN0b3ApO1xuICBpZiAoaW1tZWRpYXRlKVxuICAgIHN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RhcnQsXG4gICAgc3RvcFxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHBvaW50ZXJJZDogMCxcbiAgcHJlc3N1cmU6IDAsXG4gIHRpbHRYOiAwLFxuICB0aWx0WTogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgdHdpc3Q6IDAsXG4gIHBvaW50ZXJUeXBlOiBudWxsXG59O1xuY29uc3Qga2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3Qua2V5cyhkZWZhdWx0U3RhdGUpO1xuZnVuY3Rpb24gdXNlUG9pbnRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldCA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzSW5zaWRlID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHN0YXRlID0gcmVmKG9wdGlvbnMuaW5pdGlhbFZhbHVlIHx8IHt9KTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS52YWx1ZSwgZGVmYXVsdFN0YXRlLCBzdGF0ZS52YWx1ZSk7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBpc0luc2lkZS52YWx1ZSA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMucG9pbnRlclR5cGVzICYmICFvcHRpb25zLnBvaW50ZXJUeXBlcy5pbmNsdWRlcyhldmVudC5wb2ludGVyVHlwZSkpXG4gICAgICByZXR1cm47XG4gICAgc3RhdGUudmFsdWUgPSBvYmplY3RQaWNrKGV2ZW50LCBrZXlzLCBmYWxzZSk7XG4gIH07XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgW1wicG9pbnRlcmRvd25cIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJ1cFwiXSwgaGFuZGxlciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwb2ludGVybGVhdmVcIiwgKCkgPT4gaXNJbnNpZGUudmFsdWUgPSBmYWxzZSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnRvUmVmcyhzdGF0ZSksXG4gICAgaXNJbnNpZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUG9pbnRlckxvY2sodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gZG9jdW1lbnQgJiYgXCJwb2ludGVyTG9ja0VsZW1lbnRcIiBpbiBkb2N1bWVudCk7XG4gIGNvbnN0IGVsZW1lbnQgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IHRyaWdnZXJFbGVtZW50ID0gc2hhbGxvd1JlZigpO1xuICBsZXQgdGFyZ2V0RWxlbWVudDtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJwb2ludGVybG9ja2NoYW5nZVwiLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IChfYSA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCkgIT0gbnVsbCA/IF9hIDogZWxlbWVudC52YWx1ZTtcbiAgICAgIGlmICh0YXJnZXRFbGVtZW50ICYmIGN1cnJlbnRFbGVtZW50ID09PSB0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ7XG4gICAgICAgIGlmICghZWxlbWVudC52YWx1ZSlcbiAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gdHJpZ2dlckVsZW1lbnQudmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJwb2ludGVybG9ja2Vycm9yXCIsICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gKF9hID0gZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50KSAhPSBudWxsID8gX2EgOiBlbGVtZW50LnZhbHVlO1xuICAgICAgaWYgKHRhcmdldEVsZW1lbnQgJiYgY3VycmVudEVsZW1lbnQgPT09IHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50ID8gXCJyZWxlYXNlXCIgOiBcImFjcXVpcmVcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gJHthY3Rpb259IHBvaW50ZXIgbG9jay5gKTtcbiAgICAgIH1cbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvY2soZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9pbnRlciBMb2NrIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3Nlci5cIik7XG4gICAgdHJpZ2dlckVsZW1lbnQudmFsdWUgPSBlIGluc3RhbmNlb2YgRXZlbnQgPyBlLmN1cnJlbnRUYXJnZXQgOiBudWxsO1xuICAgIHRhcmdldEVsZW1lbnQgPSBlIGluc3RhbmNlb2YgRXZlbnQgPyAoX2EgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KSkgIT0gbnVsbCA/IF9hIDogdHJpZ2dlckVsZW1lbnQudmFsdWUgOiB1bnJlZkVsZW1lbnQoZSk7XG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IGVsZW1lbnQgdW5kZWZpbmVkLlwiKTtcbiAgICB0YXJnZXRFbGVtZW50LnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgIHJldHVybiBhd2FpdCB1bnRpbChlbGVtZW50KS50b0JlKHRhcmdldEVsZW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVubG9jaygpIHtcbiAgICBpZiAoIWVsZW1lbnQudmFsdWUpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG4gICAgYXdhaXQgdW50aWwoZWxlbWVudCkudG9CZU51bGwoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGVsZW1lbnQsXG4gICAgdHJpZ2dlckVsZW1lbnQsXG4gICAgbG9jayxcbiAgICB1bmxvY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUG9pbnRlclN3aXBlKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHRhcmdldFJlZiA9IHRvUmVmKHRhcmdldCk7XG4gIGNvbnN0IHtcbiAgICB0aHJlc2hvbGQgPSA1MCxcbiAgICBvblN3aXBlLFxuICAgIG9uU3dpcGVFbmQsXG4gICAgb25Td2lwZVN0YXJ0LFxuICAgIGRpc2FibGVUZXh0U2VsZWN0ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBvc1N0YXJ0ID0gcmVhY3RpdmUoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCB1cGRhdGVQb3NTdGFydCA9ICh4LCB5KSA9PiB7XG4gICAgcG9zU3RhcnQueCA9IHg7XG4gICAgcG9zU3RhcnQueSA9IHk7XG4gIH07XG4gIGNvbnN0IHBvc0VuZCA9IHJlYWN0aXZlKHsgeDogMCwgeTogMCB9KTtcbiAgY29uc3QgdXBkYXRlUG9zRW5kID0gKHgsIHkpID0+IHtcbiAgICBwb3NFbmQueCA9IHg7XG4gICAgcG9zRW5kLnkgPSB5O1xuICB9O1xuICBjb25zdCBkaXN0YW5jZVggPSBjb21wdXRlZCgoKSA9PiBwb3NTdGFydC54IC0gcG9zRW5kLngpO1xuICBjb25zdCBkaXN0YW5jZVkgPSBjb21wdXRlZCgoKSA9PiBwb3NTdGFydC55IC0gcG9zRW5kLnkpO1xuICBjb25zdCB7IG1heCwgYWJzIH0gPSBNYXRoO1xuICBjb25zdCBpc1RocmVzaG9sZEV4Y2VlZGVkID0gY29tcHV0ZWQoKCkgPT4gbWF4KGFicyhkaXN0YW5jZVgudmFsdWUpLCBhYnMoZGlzdGFuY2VZLnZhbHVlKSkgPj0gdGhyZXNob2xkKTtcbiAgY29uc3QgaXNTd2lwaW5nID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IGlzUG9pbnRlckRvd24gPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgZGlyZWN0aW9uID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmICghaXNUaHJlc2hvbGRFeGNlZWRlZC52YWx1ZSlcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICBpZiAoYWJzKGRpc3RhbmNlWC52YWx1ZSkgPiBhYnMoZGlzdGFuY2VZLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIGRpc3RhbmNlWC52YWx1ZSA+IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRpc3RhbmNlWS52YWx1ZSA+IDAgPyBcInVwXCIgOiBcImRvd25cIjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBldmVudElzQWxsb3dlZCA9IChlKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgaXNSZWxlYXNpbmdCdXR0b24gPSBlLmJ1dHRvbnMgPT09IDA7XG4gICAgY29uc3QgaXNQcmltYXJ5QnV0dG9uID0gZS5idXR0b25zID09PSAxO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zLnBvaW50ZXJUeXBlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKGUucG9pbnRlclR5cGUpKSAhPSBudWxsID8gX2IgOiBpc1JlbGVhc2luZ0J1dHRvbiB8fCBpc1ByaW1hcnlCdXR0b24pICE9IG51bGwgPyBfYyA6IHRydWU7XG4gIH07XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICBjb25zdCBzdG9wcyA9IFtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwb2ludGVyZG93blwiLCAoZSkgPT4ge1xuICAgICAgaWYgKCFldmVudElzQWxsb3dlZChlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaXNQb2ludGVyRG93bi52YWx1ZSA9IHRydWU7XG4gICAgICBjb25zdCBldmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgZXZlbnRUYXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICAgIGNvbnN0IHsgY2xpZW50WDogeCwgY2xpZW50WTogeSB9ID0gZTtcbiAgICAgIHVwZGF0ZVBvc1N0YXJ0KHgsIHkpO1xuICAgICAgdXBkYXRlUG9zRW5kKHgsIHkpO1xuICAgICAgb25Td2lwZVN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblN3aXBlU3RhcnQoZSk7XG4gICAgfSwgbGlzdGVuZXJPcHRpb25zKSxcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwb2ludGVybW92ZVwiLCAoZSkgPT4ge1xuICAgICAgaWYgKCFldmVudElzQWxsb3dlZChlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFpc1BvaW50ZXJEb3duLnZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IGNsaWVudFg6IHgsIGNsaWVudFk6IHkgfSA9IGU7XG4gICAgICB1cGRhdGVQb3NFbmQoeCwgeSk7XG4gICAgICBpZiAoIWlzU3dpcGluZy52YWx1ZSAmJiBpc1RocmVzaG9sZEV4Y2VlZGVkLnZhbHVlKVxuICAgICAgICBpc1N3aXBpbmcudmFsdWUgPSB0cnVlO1xuICAgICAgaWYgKGlzU3dpcGluZy52YWx1ZSlcbiAgICAgICAgb25Td2lwZSA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZShlKTtcbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBvaW50ZXJ1cFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKCFldmVudElzQWxsb3dlZChlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGlzU3dpcGluZy52YWx1ZSlcbiAgICAgICAgb25Td2lwZUVuZCA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZUVuZChlLCBkaXJlY3Rpb24udmFsdWUpO1xuICAgICAgaXNQb2ludGVyRG93bi52YWx1ZSA9IGZhbHNlO1xuICAgICAgaXNTd2lwaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgfSwgbGlzdGVuZXJPcHRpb25zKVxuICBdO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgKF9iID0gKF9hID0gdGFyZ2V0UmVmLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zZXRQcm9wZXJ0eShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIik7XG4gICAgaWYgKGRpc2FibGVUZXh0U2VsZWN0KSB7XG4gICAgICAoX2QgPSAoX2MgPSB0YXJnZXRSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnNldFByb3BlcnR5KFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiLCBcIm5vbmVcIik7XG4gICAgICAoX2YgPSAoX2UgPSB0YXJnZXRSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfZS5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnNldFByb3BlcnR5KFwiLW1zLXVzZXItc2VsZWN0XCIsIFwibm9uZVwiKTtcbiAgICAgIChfaCA9IChfZyA9IHRhcmdldFJlZi52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2guc2V0UHJvcGVydHkoXCJ1c2VyLXNlbGVjdFwiLCBcIm5vbmVcIik7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHN0b3BzLmZvckVhY2goKHMpID0+IHMoKSk7XG4gIHJldHVybiB7XG4gICAgaXNTd2lwaW5nOiByZWFkb25seShpc1N3aXBpbmcpLFxuICAgIGRpcmVjdGlvbjogcmVhZG9ubHkoZGlyZWN0aW9uKSxcbiAgICBwb3NTdGFydDogcmVhZG9ubHkocG9zU3RhcnQpLFxuICAgIHBvc0VuZDogcmVhZG9ubHkocG9zRW5kKSxcbiAgICBkaXN0YW5jZVgsXG4gICAgZGlzdGFuY2VZLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmVycmVkQ29sb3JTY2hlbWUob3B0aW9ucykge1xuICBjb25zdCBpc0xpZ2h0ID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHQpXCIsIG9wdGlvbnMpO1xuICBjb25zdCBpc0RhcmsgPSB1c2VNZWRpYVF1ZXJ5KFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoaXNEYXJrLnZhbHVlKVxuICAgICAgcmV0dXJuIFwiZGFya1wiO1xuICAgIGlmIChpc0xpZ2h0LnZhbHVlKVxuICAgICAgcmV0dXJuIFwibGlnaHRcIjtcbiAgICByZXR1cm4gXCJuby1wcmVmZXJlbmNlXCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWRDb250cmFzdChvcHRpb25zKSB7XG4gIGNvbnN0IGlzTW9yZSA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1jb250cmFzdDogbW9yZSlcIiwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzTGVzcyA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1jb250cmFzdDogbGVzcylcIiwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzQ3VzdG9tID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbnRyYXN0OiBjdXN0b20pXCIsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChpc01vcmUudmFsdWUpXG4gICAgICByZXR1cm4gXCJtb3JlXCI7XG4gICAgaWYgKGlzTGVzcy52YWx1ZSlcbiAgICAgIHJldHVybiBcImxlc3NcIjtcbiAgICBpZiAoaXNDdXN0b20udmFsdWUpXG4gICAgICByZXR1cm4gXCJjdXN0b21cIjtcbiAgICByZXR1cm4gXCJuby1wcmVmZXJlbmNlXCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWRMYW5ndWFnZXMob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgaWYgKCF3aW5kb3cpXG4gICAgcmV0dXJuIHJlZihbXCJlblwiXSk7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IHZhbHVlID0gcmVmKG5hdmlnYXRvci5sYW5ndWFnZXMpO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJsYW5ndWFnZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgdmFsdWUudmFsdWUgPSBuYXZpZ2F0b3IubGFuZ3VhZ2VzO1xuICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmVycmVkUmVkdWNlZE1vdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IGlzUmVkdWNlZCA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoaXNSZWR1Y2VkLnZhbHVlKVxuICAgICAgcmV0dXJuIFwicmVkdWNlXCI7XG4gICAgcmV0dXJuIFwibm8tcHJlZmVyZW5jZVwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmVycmVkUmVkdWNlZFRyYW5zcGFyZW5jeShvcHRpb25zKSB7XG4gIGNvbnN0IGlzUmVkdWNlZCA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1yZWR1Y2VkLXRyYW5zcGFyZW5jeTogcmVkdWNlKVwiLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoaXNSZWR1Y2VkLnZhbHVlKVxuICAgICAgcmV0dXJuIFwicmVkdWNlXCI7XG4gICAgcmV0dXJuIFwibm8tcHJlZmVyZW5jZVwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICBjb25zdCBwcmV2aW91cyA9IHNoYWxsb3dSZWYoaW5pdGlhbFZhbHVlKTtcbiAgd2F0Y2goXG4gICAgdG9SZWYodmFsdWUpLFxuICAgIChfLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgcHJldmlvdXMudmFsdWUgPSBvbGRWYWx1ZTtcbiAgICB9LFxuICAgIHsgZmx1c2g6IFwic3luY1wiIH1cbiAgKTtcbiAgcmV0dXJuIHJlYWRvbmx5KHByZXZpb3VzKTtcbn1cblxuY29uc3QgdG9wVmFyTmFtZSA9IFwiLS12dWV1c2Utc2FmZS1hcmVhLXRvcFwiO1xuY29uc3QgcmlnaHRWYXJOYW1lID0gXCItLXZ1ZXVzZS1zYWZlLWFyZWEtcmlnaHRcIjtcbmNvbnN0IGJvdHRvbVZhck5hbWUgPSBcIi0tdnVldXNlLXNhZmUtYXJlYS1ib3R0b21cIjtcbmNvbnN0IGxlZnRWYXJOYW1lID0gXCItLXZ1ZXVzZS1zYWZlLWFyZWEtbGVmdFwiO1xuZnVuY3Rpb24gdXNlU2NyZWVuU2FmZUFyZWEoKSB7XG4gIGNvbnN0IHRvcCA9IHNoYWxsb3dSZWYoXCJcIik7XG4gIGNvbnN0IHJpZ2h0ID0gc2hhbGxvd1JlZihcIlwiKTtcbiAgY29uc3QgYm90dG9tID0gc2hhbGxvd1JlZihcIlwiKTtcbiAgY29uc3QgbGVmdCA9IHNoYWxsb3dSZWYoXCJcIik7XG4gIGlmIChpc0NsaWVudCkge1xuICAgIGNvbnN0IHRvcENzc1ZhciA9IHVzZUNzc1Zhcih0b3BWYXJOYW1lKTtcbiAgICBjb25zdCByaWdodENzc1ZhciA9IHVzZUNzc1ZhcihyaWdodFZhck5hbWUpO1xuICAgIGNvbnN0IGJvdHRvbUNzc1ZhciA9IHVzZUNzc1Zhcihib3R0b21WYXJOYW1lKTtcbiAgICBjb25zdCBsZWZ0Q3NzVmFyID0gdXNlQ3NzVmFyKGxlZnRWYXJOYW1lKTtcbiAgICB0b3BDc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpXCI7XG4gICAgcmlnaHRDc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweClcIjtcbiAgICBib3R0b21Dc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpXCI7XG4gICAgbGVmdENzc1Zhci52YWx1ZSA9IFwiZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpXCI7XG4gICAgdXBkYXRlKCk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1c2VEZWJvdW5jZUZuKHVwZGF0ZSksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdG9wLnZhbHVlID0gZ2V0VmFsdWUodG9wVmFyTmFtZSk7XG4gICAgcmlnaHQudmFsdWUgPSBnZXRWYWx1ZShyaWdodFZhck5hbWUpO1xuICAgIGJvdHRvbS52YWx1ZSA9IGdldFZhbHVlKGJvdHRvbVZhck5hbWUpO1xuICAgIGxlZnQudmFsdWUgPSBnZXRWYWx1ZShsZWZ0VmFyTmFtZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgdXBkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShwb3NpdGlvbikge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiB1c2VTY3JpcHRUYWcoc3JjLCBvbkxvYWRlZCA9IG5vb3AsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBtYW51YWwgPSBmYWxzZSxcbiAgICB0eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIixcbiAgICBhc3luYyA9IHRydWUsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgcmVmZXJyZXJQb2xpY3ksXG4gICAgbm9Nb2R1bGUsXG4gICAgZGVmZXIsXG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgYXR0cnMgPSB7fVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2NyaXB0VGFnID0gc2hhbGxvd1JlZihudWxsKTtcbiAgbGV0IF9wcm9taXNlID0gbnVsbDtcbiAgY29uc3QgbG9hZFNjcmlwdCA9ICh3YWl0Rm9yU2NyaXB0TG9hZCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVXaXRoRWxlbWVudCA9IChlbDIpID0+IHtcbiAgICAgIHNjcmlwdFRhZy52YWx1ZSA9IGVsMjtcbiAgICAgIHJlc29sdmUoZWwyKTtcbiAgICAgIHJldHVybiBlbDI7XG4gICAgfTtcbiAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNob3VsZEFwcGVuZCA9IGZhbHNlO1xuICAgIGxldCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmM9XCIke3RvVmFsdWUoc3JjKX1cIl1gKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICBlbC50eXBlID0gdHlwZTtcbiAgICAgIGVsLmFzeW5jID0gYXN5bmM7XG4gICAgICBlbC5zcmMgPSB0b1ZhbHVlKHNyYyk7XG4gICAgICBpZiAoZGVmZXIpXG4gICAgICAgIGVsLmRlZmVyID0gZGVmZXI7XG4gICAgICBpZiAoY3Jvc3NPcmlnaW4pXG4gICAgICAgIGVsLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICBpZiAobm9Nb2R1bGUpXG4gICAgICAgIGVsLm5vTW9kdWxlID0gbm9Nb2R1bGU7XG4gICAgICBpZiAocmVmZXJyZXJQb2xpY3kpXG4gICAgICAgIGVsLnJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3k7XG4gICAgICBPYmplY3QuZW50cmllcyhhdHRycykuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpO1xuICAgICAgc2hvdWxkQXBwZW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVsLmhhc0F0dHJpYnV0ZShcImRhdGEtbG9hZGVkXCIpKSB7XG4gICAgICByZXNvbHZlV2l0aEVsZW1lbnQoZWwpO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGVsLCBcImVycm9yXCIsIChldmVudCkgPT4gcmVqZWN0KGV2ZW50KSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGVsLCBcImFib3J0XCIsIChldmVudCkgPT4gcmVqZWN0KGV2ZW50KSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGVsLCBcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sb2FkZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgb25Mb2FkZWQoZWwpO1xuICAgICAgcmVzb2x2ZVdpdGhFbGVtZW50KGVsKTtcbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIGlmIChzaG91bGRBcHBlbmQpXG4gICAgICBlbCA9IGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGlmICghd2FpdEZvclNjcmlwdExvYWQpXG4gICAgICByZXNvbHZlV2l0aEVsZW1lbnQoZWwpO1xuICB9KTtcbiAgY29uc3QgbG9hZCA9ICh3YWl0Rm9yU2NyaXB0TG9hZCA9IHRydWUpID0+IHtcbiAgICBpZiAoIV9wcm9taXNlKVxuICAgICAgX3Byb21pc2UgPSBsb2FkU2NyaXB0KHdhaXRGb3JTY3JpcHRMb2FkKTtcbiAgICByZXR1cm4gX3Byb21pc2U7XG4gIH07XG4gIGNvbnN0IHVubG9hZCA9ICgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIF9wcm9taXNlID0gbnVsbDtcbiAgICBpZiAoc2NyaXB0VGFnLnZhbHVlKVxuICAgICAgc2NyaXB0VGFnLnZhbHVlID0gbnVsbDtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmM9XCIke3RvVmFsdWUoc3JjKX1cIl1gKTtcbiAgICBpZiAoZWwpXG4gICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGVsKTtcbiAgfTtcbiAgaWYgKGltbWVkaWF0ZSAmJiAhbWFudWFsKVxuICAgIHRyeU9uTW91bnRlZChsb2FkKTtcbiAgaWYgKCFtYW51YWwpXG4gICAgdHJ5T25Vbm1vdW50ZWQodW5sb2FkKTtcbiAgcmV0dXJuIHsgc2NyaXB0VGFnLCBsb2FkLCB1bmxvYWQgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tPdmVyZmxvd1Njcm9sbChlbGUpIHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGUpO1xuICBpZiAoc3R5bGUub3ZlcmZsb3dYID09PSBcInNjcm9sbFwiIHx8IHN0eWxlLm92ZXJmbG93WSA9PT0gXCJzY3JvbGxcIiB8fCBzdHlsZS5vdmVyZmxvd1ggPT09IFwiYXV0b1wiICYmIGVsZS5jbGllbnRXaWR0aCA8IGVsZS5zY3JvbGxXaWR0aCB8fCBzdHlsZS5vdmVyZmxvd1kgPT09IFwiYXV0b1wiICYmIGVsZS5jbGllbnRIZWlnaHQgPCBlbGUuc2Nyb2xsSGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcGFyZW50ID0gZWxlLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LnRhZ05hbWUgPT09IFwiQk9EWVwiKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjaGVja092ZXJmbG93U2Nyb2xsKHBhcmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KHJhd0V2ZW50KSB7XG4gIGNvbnN0IGUgPSByYXdFdmVudCB8fCB3aW5kb3cuZXZlbnQ7XG4gIGNvbnN0IF90YXJnZXQgPSBlLnRhcmdldDtcbiAgaWYgKGNoZWNrT3ZlcmZsb3dTY3JvbGwoX3RhcmdldCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgZWxJbml0aWFsT3ZlcmZsb3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHVzZVNjcm9sbExvY2soZWxlbWVudCwgaW5pdGlhbFN0YXRlID0gZmFsc2UpIHtcbiAgY29uc3QgaXNMb2NrZWQgPSBzaGFsbG93UmVmKGluaXRpYWxTdGF0ZSk7XG4gIGxldCBzdG9wVG91Y2hNb3ZlTGlzdGVuZXIgPSBudWxsO1xuICBsZXQgaW5pdGlhbE92ZXJmbG93ID0gXCJcIjtcbiAgd2F0Y2godG9SZWYoZWxlbWVudCksIChlbCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHJlc29sdmVFbGVtZW50KHRvVmFsdWUoZWwpKTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBjb25zdCBlbGUgPSB0YXJnZXQ7XG4gICAgICBpZiAoIWVsSW5pdGlhbE92ZXJmbG93LmdldChlbGUpKVxuICAgICAgICBlbEluaXRpYWxPdmVyZmxvdy5zZXQoZWxlLCBlbGUuc3R5bGUub3ZlcmZsb3cpO1xuICAgICAgaWYgKGVsZS5zdHlsZS5vdmVyZmxvdyAhPT0gXCJoaWRkZW5cIilcbiAgICAgICAgaW5pdGlhbE92ZXJmbG93ID0gZWxlLnN0eWxlLm92ZXJmbG93O1xuICAgICAgaWYgKGVsZS5zdHlsZS5vdmVyZmxvdyA9PT0gXCJoaWRkZW5cIilcbiAgICAgICAgcmV0dXJuIGlzTG9ja2VkLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGlmIChpc0xvY2tlZC52YWx1ZSlcbiAgICAgICAgcmV0dXJuIGVsZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgfVxuICB9LCB7XG4gICAgaW1tZWRpYXRlOiB0cnVlXG4gIH0pO1xuICBjb25zdCBsb2NrID0gKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gcmVzb2x2ZUVsZW1lbnQodG9WYWx1ZShlbGVtZW50KSk7XG4gICAgaWYgKCFlbCB8fCBpc0xvY2tlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaXNJT1MpIHtcbiAgICAgIHN0b3BUb3VjaE1vdmVMaXN0ZW5lciA9IHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIGVsLFxuICAgICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9LFxuICAgICAgICB7IHBhc3NpdmU6IGZhbHNlIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBpc0xvY2tlZC52YWx1ZSA9IHRydWU7XG4gIH07XG4gIGNvbnN0IHVubG9jayA9ICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHJlc29sdmVFbGVtZW50KHRvVmFsdWUoZWxlbWVudCkpO1xuICAgIGlmICghZWwgfHwgIWlzTG9ja2VkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpc0lPUylcbiAgICAgIHN0b3BUb3VjaE1vdmVMaXN0ZW5lciA9PSBudWxsID8gdm9pZCAwIDogc3RvcFRvdWNoTW92ZUxpc3RlbmVyKCk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSBpbml0aWFsT3ZlcmZsb3c7XG4gICAgZWxJbml0aWFsT3ZlcmZsb3cuZGVsZXRlKGVsKTtcbiAgICBpc0xvY2tlZC52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICB0cnlPblNjb3BlRGlzcG9zZSh1bmxvY2spO1xuICByZXR1cm4gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBpc0xvY2tlZC52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICBpZiAodilcbiAgICAgICAgbG9jaygpO1xuICAgICAgZWxzZSB1bmxvY2soKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VTZXNzaW9uU3RvcmFnZShrZXksIGluaXRpYWxWYWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHVzZVN0b3JhZ2Uoa2V5LCBpbml0aWFsVmFsdWUsIHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LnNlc3Npb25TdG9yYWdlLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdXNlU2hhcmUoc2hhcmVPcHRpb25zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IF9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IF9uYXZpZ2F0b3IgJiYgXCJjYW5TaGFyZVwiIGluIF9uYXZpZ2F0b3IpO1xuICBjb25zdCBzaGFyZSA9IGFzeW5jIChvdmVycmlkZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgLi4udG9WYWx1ZShzaGFyZU9wdGlvbnMpLFxuICAgICAgICAuLi50b1ZhbHVlKG92ZXJyaWRlT3B0aW9ucylcbiAgICAgIH07XG4gICAgICBsZXQgZ3JhbnRlZCA9IHRydWU7XG4gICAgICBpZiAoZGF0YS5maWxlcyAmJiBfbmF2aWdhdG9yLmNhblNoYXJlKVxuICAgICAgICBncmFudGVkID0gX25hdmlnYXRvci5jYW5TaGFyZSh7IGZpbGVzOiBkYXRhLmZpbGVzIH0pO1xuICAgICAgaWYgKGdyYW50ZWQpXG4gICAgICAgIHJldHVybiBfbmF2aWdhdG9yLnNoYXJlKGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBzaGFyZVxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0U29ydEZuID0gKHNvdXJjZSwgY29tcGFyZUZuKSA9PiBzb3VyY2Uuc29ydChjb21wYXJlRm4pO1xuY29uc3QgZGVmYXVsdENvbXBhcmUgPSAoYSwgYikgPT4gYSAtIGI7XG5mdW5jdGlvbiB1c2VTb3J0ZWQoLi4uYXJncykge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IFtzb3VyY2VdID0gYXJncztcbiAgbGV0IGNvbXBhcmVGbiA9IGRlZmF1bHRDb21wYXJlO1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgICAgY29tcGFyZUZuID0gKF9hID0gb3B0aW9ucy5jb21wYXJlRm4pICE9IG51bGwgPyBfYSA6IGRlZmF1bHRDb21wYXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wYXJlRm4gPSAoX2IgPSBhcmdzWzFdKSAhPSBudWxsID8gX2IgOiBkZWZhdWx0Q29tcGFyZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgY29tcGFyZUZuID0gKF9jID0gYXJnc1sxXSkgIT0gbnVsbCA/IF9jIDogZGVmYXVsdENvbXBhcmU7XG4gICAgb3B0aW9ucyA9IChfZCA9IGFyZ3NbMl0pICE9IG51bGwgPyBfZCA6IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBkaXJ0eSA9IGZhbHNlLFxuICAgIHNvcnRGbiA9IGRlZmF1bHRTb3J0Rm5cbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghZGlydHkpXG4gICAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHNvcnRGbihbLi4udG9WYWx1ZShzb3VyY2UpXSwgY29tcGFyZUZuKSk7XG4gIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBzb3J0Rm4odG9WYWx1ZShzb3VyY2UpLCBjb21wYXJlRm4pO1xuICAgIGlmIChpc1JlZihzb3VyY2UpKVxuICAgICAgc291cmNlLnZhbHVlID0gcmVzdWx0O1xuICAgIGVsc2VcbiAgICAgIHNvdXJjZS5zcGxpY2UoMCwgc291cmNlLmxlbmd0aCwgLi4ucmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIHVzZVNwZWVjaFJlY29nbml0aW9uKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW50ZXJpbVJlc3VsdHMgPSB0cnVlLFxuICAgIGNvbnRpbnVvdXMgPSB0cnVlLFxuICAgIG1heEFsdGVybmF0aXZlcyA9IDEsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbGFuZyA9IHRvUmVmKG9wdGlvbnMubGFuZyB8fCBcImVuLVVTXCIpO1xuICBjb25zdCBpc0xpc3RlbmluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBpc0ZpbmFsID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHJlc3VsdCA9IHNoYWxsb3dSZWYoXCJcIik7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBsZXQgcmVjb2duaXRpb247XG4gIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgIGlzTGlzdGVuaW5nLnZhbHVlID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpc0xpc3RlbmluZy52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICBjb25zdCB0b2dnbGUgPSAodmFsdWUgPSAhaXNMaXN0ZW5pbmcudmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IFNwZWVjaFJlY29nbml0aW9uID0gd2luZG93ICYmICh3aW5kb3cuU3BlZWNoUmVjb2duaXRpb24gfHwgd2luZG93LndlYmtpdFNwZWVjaFJlY29nbml0aW9uKTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gU3BlZWNoUmVjb2duaXRpb24pO1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICByZWNvZ25pdGlvbiA9IG5ldyBTcGVlY2hSZWNvZ25pdGlvbigpO1xuICAgIHJlY29nbml0aW9uLmNvbnRpbnVvdXMgPSBjb250aW51b3VzO1xuICAgIHJlY29nbml0aW9uLmludGVyaW1SZXN1bHRzID0gaW50ZXJpbVJlc3VsdHM7XG4gICAgcmVjb2duaXRpb24ubGFuZyA9IHRvVmFsdWUobGFuZyk7XG4gICAgcmVjb2duaXRpb24ubWF4QWx0ZXJuYXRpdmVzID0gbWF4QWx0ZXJuYXRpdmVzO1xuICAgIHJlY29nbml0aW9uLm9uc3RhcnQgPSAoKSA9PiB7XG4gICAgICBpc0xpc3RlbmluZy52YWx1ZSA9IHRydWU7XG4gICAgICBpc0ZpbmFsLnZhbHVlID0gZmFsc2U7XG4gICAgfTtcbiAgICB3YXRjaChsYW5nLCAobGFuZzIpID0+IHtcbiAgICAgIGlmIChyZWNvZ25pdGlvbiAmJiAhaXNMaXN0ZW5pbmcudmFsdWUpXG4gICAgICAgIHJlY29nbml0aW9uLmxhbmcgPSBsYW5nMjtcbiAgICB9KTtcbiAgICByZWNvZ25pdGlvbi5vbnJlc3VsdCA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFJlc3VsdCA9IGV2ZW50LnJlc3VsdHNbZXZlbnQucmVzdWx0SW5kZXhdO1xuICAgICAgY29uc3QgeyB0cmFuc2NyaXB0IH0gPSBjdXJyZW50UmVzdWx0WzBdO1xuICAgICAgaXNGaW5hbC52YWx1ZSA9IGN1cnJlbnRSZXN1bHQuaXNGaW5hbDtcbiAgICAgIHJlc3VsdC52YWx1ZSA9IHRyYW5zY3JpcHQ7XG4gICAgICBlcnJvci52YWx1ZSA9IHZvaWQgMDtcbiAgICB9O1xuICAgIHJlY29nbml0aW9uLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIGVycm9yLnZhbHVlID0gZXZlbnQ7XG4gICAgfTtcbiAgICByZWNvZ25pdGlvbi5vbmVuZCA9ICgpID0+IHtcbiAgICAgIGlzTGlzdGVuaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICByZWNvZ25pdGlvbi5sYW5nID0gdG9WYWx1ZShsYW5nKTtcbiAgICB9O1xuICAgIHdhdGNoKGlzTGlzdGVuaW5nLCAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAobmV3VmFsdWUpXG4gICAgICAgIHJlY29nbml0aW9uLnN0YXJ0KCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlY29nbml0aW9uLnN0b3AoKTtcbiAgICB9KTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgc3RvcCgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc0xpc3RlbmluZyxcbiAgICBpc0ZpbmFsLFxuICAgIHJlY29nbml0aW9uLFxuICAgIHJlc3VsdCxcbiAgICBlcnJvcixcbiAgICB0b2dnbGUsXG4gICAgc3RhcnQsXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTcGVlY2hTeW50aGVzaXModGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwaXRjaCA9IDEsXG4gICAgcmF0ZSA9IDEsXG4gICAgdm9sdW1lID0gMSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzeW50aCA9IHdpbmRvdyAmJiB3aW5kb3cuc3BlZWNoU3ludGhlc2lzO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBzeW50aCk7XG4gIGNvbnN0IGlzUGxheWluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBzdGF0dXMgPSBzaGFsbG93UmVmKFwiaW5pdFwiKTtcbiAgY29uc3Qgc3Bva2VuVGV4dCA9IHRvUmVmKHRleHQgfHwgXCJcIik7XG4gIGNvbnN0IGxhbmcgPSB0b1JlZihvcHRpb25zLmxhbmcgfHwgXCJlbi1VU1wiKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKHZvaWQgMCk7XG4gIGNvbnN0IHRvZ2dsZSA9ICh2YWx1ZSA9ICFpc1BsYXlpbmcudmFsdWUpID0+IHtcbiAgICBpc1BsYXlpbmcudmFsdWUgPSB2YWx1ZTtcbiAgfTtcbiAgY29uc3QgYmluZEV2ZW50c0ZvclV0dGVyYW5jZSA9ICh1dHRlcmFuY2UyKSA9PiB7XG4gICAgdXR0ZXJhbmNlMi5sYW5nID0gdG9WYWx1ZShsYW5nKTtcbiAgICB1dHRlcmFuY2UyLnZvaWNlID0gdG9WYWx1ZShvcHRpb25zLnZvaWNlKSB8fCBudWxsO1xuICAgIHV0dGVyYW5jZTIucGl0Y2ggPSB0b1ZhbHVlKHBpdGNoKTtcbiAgICB1dHRlcmFuY2UyLnJhdGUgPSB0b1ZhbHVlKHJhdGUpO1xuICAgIHV0dGVyYW5jZTIudm9sdW1lID0gdm9sdW1lO1xuICAgIHV0dGVyYW5jZTIub25zdGFydCA9ICgpID0+IHtcbiAgICAgIGlzUGxheWluZy52YWx1ZSA9IHRydWU7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcInBsYXlcIjtcbiAgICB9O1xuICAgIHV0dGVyYW5jZTIub25wYXVzZSA9ICgpID0+IHtcbiAgICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJwYXVzZVwiO1xuICAgIH07XG4gICAgdXR0ZXJhbmNlMi5vbnJlc3VtZSA9ICgpID0+IHtcbiAgICAgIGlzUGxheWluZy52YWx1ZSA9IHRydWU7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcInBsYXlcIjtcbiAgICB9O1xuICAgIHV0dGVyYW5jZTIub25lbmQgPSAoKSA9PiB7XG4gICAgICBpc1BsYXlpbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiZW5kXCI7XG4gICAgfTtcbiAgICB1dHRlcmFuY2UyLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIGVycm9yLnZhbHVlID0gZXZlbnQ7XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgdXR0ZXJhbmNlID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICAgIHN0YXR1cy52YWx1ZSA9IFwiaW5pdFwiO1xuICAgIGNvbnN0IG5ld1V0dGVyYW5jZSA9IG5ldyBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2Uoc3Bva2VuVGV4dC52YWx1ZSk7XG4gICAgYmluZEV2ZW50c0ZvclV0dGVyYW5jZShuZXdVdHRlcmFuY2UpO1xuICAgIHJldHVybiBuZXdVdHRlcmFuY2U7XG4gIH0pO1xuICBjb25zdCBzcGVhayA9ICgpID0+IHtcbiAgICBzeW50aC5jYW5jZWwoKTtcbiAgICBpZiAodXR0ZXJhbmNlKVxuICAgICAgc3ludGguc3BlYWsodXR0ZXJhbmNlLnZhbHVlKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBzeW50aC5jYW5jZWwoKTtcbiAgICBpc1BsYXlpbmcudmFsdWUgPSBmYWxzZTtcbiAgfTtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgYmluZEV2ZW50c0ZvclV0dGVyYW5jZSh1dHRlcmFuY2UudmFsdWUpO1xuICAgIHdhdGNoKGxhbmcsIChsYW5nMikgPT4ge1xuICAgICAgaWYgKHV0dGVyYW5jZS52YWx1ZSAmJiAhaXNQbGF5aW5nLnZhbHVlKVxuICAgICAgICB1dHRlcmFuY2UudmFsdWUubGFuZyA9IGxhbmcyO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnZvaWNlKSB7XG4gICAgICB3YXRjaChvcHRpb25zLnZvaWNlLCAoKSA9PiB7XG4gICAgICAgIHN5bnRoLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHdhdGNoKGlzUGxheWluZywgKCkgPT4ge1xuICAgICAgaWYgKGlzUGxheWluZy52YWx1ZSlcbiAgICAgICAgc3ludGgucmVzdW1lKCk7XG4gICAgICBlbHNlXG4gICAgICAgIHN5bnRoLnBhdXNlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc1BsYXlpbmcsXG4gICAgc3RhdHVzLFxuICAgIHV0dGVyYW5jZSxcbiAgICBlcnJvcixcbiAgICBzdG9wLFxuICAgIHRvZ2dsZSxcbiAgICBzcGVha1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTdGVwcGVyKHN0ZXBzLCBpbml0aWFsU3RlcCkge1xuICBjb25zdCBzdGVwc1JlZiA9IHJlZihzdGVwcyk7XG4gIGNvbnN0IHN0ZXBOYW1lcyA9IGNvbXB1dGVkKCgpID0+IEFycmF5LmlzQXJyYXkoc3RlcHNSZWYudmFsdWUpID8gc3RlcHNSZWYudmFsdWUgOiBPYmplY3Qua2V5cyhzdGVwc1JlZi52YWx1ZSkpO1xuICBjb25zdCBpbmRleCA9IHJlZihzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihpbml0aWFsU3RlcCAhPSBudWxsID8gaW5pdGlhbFN0ZXAgOiBzdGVwTmFtZXMudmFsdWVbMF0pKTtcbiAgY29uc3QgY3VycmVudCA9IGNvbXB1dGVkKCgpID0+IGF0KGluZGV4LnZhbHVlKSk7XG4gIGNvbnN0IGlzRmlyc3QgPSBjb21wdXRlZCgoKSA9PiBpbmRleC52YWx1ZSA9PT0gMCk7XG4gIGNvbnN0IGlzTGFzdCA9IGNvbXB1dGVkKCgpID0+IGluZGV4LnZhbHVlID09PSBzdGVwTmFtZXMudmFsdWUubGVuZ3RoIC0gMSk7XG4gIGNvbnN0IG5leHQgPSBjb21wdXRlZCgoKSA9PiBzdGVwTmFtZXMudmFsdWVbaW5kZXgudmFsdWUgKyAxXSk7XG4gIGNvbnN0IHByZXZpb3VzID0gY29tcHV0ZWQoKCkgPT4gc3RlcE5hbWVzLnZhbHVlW2luZGV4LnZhbHVlIC0gMV0pO1xuICBmdW5jdGlvbiBhdChpbmRleDIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGVwc1JlZi52YWx1ZSkpXG4gICAgICByZXR1cm4gc3RlcHNSZWYudmFsdWVbaW5kZXgyXTtcbiAgICByZXR1cm4gc3RlcHNSZWYudmFsdWVbc3RlcE5hbWVzLnZhbHVlW2luZGV4Ml1dO1xuICB9XG4gIGZ1bmN0aW9uIGdldChzdGVwKSB7XG4gICAgaWYgKCFzdGVwTmFtZXMudmFsdWUuaW5jbHVkZXMoc3RlcCkpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIGF0KHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApKTtcbiAgfVxuICBmdW5jdGlvbiBnb1RvKHN0ZXApIHtcbiAgICBpZiAoc3RlcE5hbWVzLnZhbHVlLmluY2x1ZGVzKHN0ZXApKVxuICAgICAgaW5kZXgudmFsdWUgPSBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKTtcbiAgfVxuICBmdW5jdGlvbiBnb1RvTmV4dCgpIHtcbiAgICBpZiAoaXNMYXN0LnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGluZGV4LnZhbHVlKys7XG4gIH1cbiAgZnVuY3Rpb24gZ29Ub1ByZXZpb3VzKCkge1xuICAgIGlmIChpc0ZpcnN0LnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGluZGV4LnZhbHVlLS07XG4gIH1cbiAgZnVuY3Rpb24gZ29CYWNrVG8oc3RlcCkge1xuICAgIGlmIChpc0FmdGVyKHN0ZXApKVxuICAgICAgZ29UbyhzdGVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc05leHQoc3RlcCkge1xuICAgIHJldHVybiBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKSA9PT0gaW5kZXgudmFsdWUgKyAxO1xuICB9XG4gIGZ1bmN0aW9uIGlzUHJldmlvdXMoc3RlcCkge1xuICAgIHJldHVybiBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKSA9PT0gaW5kZXgudmFsdWUgLSAxO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ3VycmVudChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApID09PSBpbmRleC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBpc0JlZm9yZShzdGVwKSB7XG4gICAgcmV0dXJuIGluZGV4LnZhbHVlIDwgc3RlcE5hbWVzLnZhbHVlLmluZGV4T2Yoc3RlcCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBZnRlcihzdGVwKSB7XG4gICAgcmV0dXJuIGluZGV4LnZhbHVlID4gc3RlcE5hbWVzLnZhbHVlLmluZGV4T2Yoc3RlcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwczogc3RlcHNSZWYsXG4gICAgc3RlcE5hbWVzLFxuICAgIGluZGV4LFxuICAgIGN1cnJlbnQsXG4gICAgbmV4dCxcbiAgICBwcmV2aW91cyxcbiAgICBpc0ZpcnN0LFxuICAgIGlzTGFzdCxcbiAgICBhdCxcbiAgICBnZXQsXG4gICAgZ29UbyxcbiAgICBnb1RvTmV4dCxcbiAgICBnb1RvUHJldmlvdXMsXG4gICAgZ29CYWNrVG8sXG4gICAgaXNOZXh0LFxuICAgIGlzUHJldmlvdXMsXG4gICAgaXNDdXJyZW50LFxuICAgIGlzQmVmb3JlLFxuICAgIGlzQWZ0ZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU3RvcmFnZUFzeW5jKGtleSwgaW5pdGlhbFZhbHVlLCBzdG9yYWdlLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgZmx1c2ggPSBcInByZVwiLFxuICAgIGRlZXAgPSB0cnVlLFxuICAgIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMgPSB0cnVlLFxuICAgIHdyaXRlRGVmYXVsdHMgPSB0cnVlLFxuICAgIG1lcmdlRGVmYXVsdHMgPSBmYWxzZSxcbiAgICBzaGFsbG93LFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgZXZlbnRGaWx0ZXIsXG4gICAgb25FcnJvciA9IChlKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJhd0luaXQgPSB0b1ZhbHVlKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHR5cGUgPSBndWVzc1NlcmlhbGl6ZXJUeXBlKHJhd0luaXQpO1xuICBjb25zdCBkYXRhID0gKHNoYWxsb3cgPyBzaGFsbG93UmVmIDogcmVmKSh0b1ZhbHVlKGluaXRpYWxWYWx1ZSkpO1xuICBjb25zdCBzZXJpYWxpemVyID0gKF9hID0gb3B0aW9ucy5zZXJpYWxpemVyKSAhPSBudWxsID8gX2EgOiBTdG9yYWdlU2VyaWFsaXplcnNbdHlwZV07XG4gIGlmICghc3RvcmFnZSkge1xuICAgIHRyeSB7XG4gICAgICBzdG9yYWdlID0gZ2V0U1NSSGFuZGxlcihcImdldERlZmF1bHRTdG9yYWdlQXN5bmNcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKF9hMiA9IGRlZmF1bHRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9jYWxTdG9yYWdlO1xuICAgICAgfSkoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgaWYgKCFzdG9yYWdlIHx8IGV2ZW50ICYmIGV2ZW50LmtleSAhPT0ga2V5KVxuICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByYXdWYWx1ZSA9IGV2ZW50ID8gZXZlbnQubmV3VmFsdWUgOiBhd2FpdCBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGlmIChyYXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGEudmFsdWUgPSByYXdJbml0O1xuICAgICAgICBpZiAod3JpdGVEZWZhdWx0cyAmJiByYXdJbml0ICE9PSBudWxsKVxuICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0SXRlbShrZXksIGF3YWl0IHNlcmlhbGl6ZXIud3JpdGUocmF3SW5pdCkpO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZURlZmF1bHRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgc2VyaWFsaXplci5yZWFkKHJhd1ZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXJnZURlZmF1bHRzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgZGF0YS52YWx1ZSA9IG1lcmdlRGVmYXVsdHModmFsdWUsIHJhd0luaXQpO1xuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICBkYXRhLnZhbHVlID0geyAuLi5yYXdJbml0LCAuLi52YWx1ZSB9O1xuICAgICAgICBlbHNlIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudmFsdWUgPSBhd2FpdCBzZXJpYWxpemVyLnJlYWQocmF3VmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlYWQoKTtcbiAgaWYgKHdpbmRvdyAmJiBsaXN0ZW5Ub1N0b3JhZ2VDaGFuZ2VzKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInN0b3JhZ2VcIiwgKGUpID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gcmVhZChlKSksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgaWYgKHN0b3JhZ2UpIHtcbiAgICB3YXRjaFdpdGhGaWx0ZXIoXG4gICAgICBkYXRhLFxuICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChkYXRhLnZhbHVlID09IG51bGwpXG4gICAgICAgICAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBhd2FpdCBzdG9yYWdlLnNldEl0ZW0oa2V5LCBhd2FpdCBzZXJpYWxpemVyLndyaXRlKGRhdGEudmFsdWUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGZsdXNoLFxuICAgICAgICBkZWVwLFxuICAgICAgICBldmVudEZpbHRlclxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmxldCBfaWQgPSAwO1xuZnVuY3Rpb24gdXNlU3R5bGVUYWcoY3NzLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaXNMb2FkZWQgPSBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50LFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgbWFudWFsID0gZmFsc2UsXG4gICAgaWQgPSBgdnVldXNlX3N0eWxldGFnXyR7KytfaWR9YFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY3NzUmVmID0gc2hhbGxvd1JlZihjc3MpO1xuICBsZXQgc3RvcCA9ICgpID0+IHtcbiAgfTtcbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBpZiAoIWVsLmlzQ29ubmVjdGVkKSB7XG4gICAgICBlbC5pZCA9IGlkO1xuICAgICAgaWYgKG9wdGlvbnMubWVkaWEpXG4gICAgICAgIGVsLm1lZGlhID0gb3B0aW9ucy5tZWRpYTtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBpZiAoaXNMb2FkZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RvcCA9IHdhdGNoKFxuICAgICAgY3NzUmVmLFxuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICAgICk7XG4gICAgaXNMb2FkZWQudmFsdWUgPSB0cnVlO1xuICB9O1xuICBjb25zdCB1bmxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudCB8fCAhaXNMb2FkZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgc3RvcCgpO1xuICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpc0xvYWRlZC52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICBpZiAoaW1tZWRpYXRlICYmICFtYW51YWwpXG4gICAgdHJ5T25Nb3VudGVkKGxvYWQpO1xuICBpZiAoIW1hbnVhbClcbiAgICB0cnlPblNjb3BlRGlzcG9zZSh1bmxvYWQpO1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIGNzczogY3NzUmVmLFxuICAgIHVubG9hZCxcbiAgICBsb2FkLFxuICAgIGlzTG9hZGVkOiByZWFkb25seShpc0xvYWRlZClcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU3dpcGUodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRocmVzaG9sZCA9IDUwLFxuICAgIG9uU3dpcGUsXG4gICAgb25Td2lwZUVuZCxcbiAgICBvblN3aXBlU3RhcnQsXG4gICAgcGFzc2l2ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNvb3Jkc1N0YXJ0ID0gcmVhY3RpdmUoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCBjb29yZHNFbmQgPSByZWFjdGl2ZSh7IHg6IDAsIHk6IDAgfSk7XG4gIGNvbnN0IGRpZmZYID0gY29tcHV0ZWQoKCkgPT4gY29vcmRzU3RhcnQueCAtIGNvb3Jkc0VuZC54KTtcbiAgY29uc3QgZGlmZlkgPSBjb21wdXRlZCgoKSA9PiBjb29yZHNTdGFydC55IC0gY29vcmRzRW5kLnkpO1xuICBjb25zdCB7IG1heCwgYWJzIH0gPSBNYXRoO1xuICBjb25zdCBpc1RocmVzaG9sZEV4Y2VlZGVkID0gY29tcHV0ZWQoKCkgPT4gbWF4KGFicyhkaWZmWC52YWx1ZSksIGFicyhkaWZmWS52YWx1ZSkpID49IHRocmVzaG9sZCk7XG4gIGNvbnN0IGlzU3dpcGluZyA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBjb25zdCBkaXJlY3Rpb24gPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKCFpc1RocmVzaG9sZEV4Y2VlZGVkLnZhbHVlKVxuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIGlmIChhYnMoZGlmZlgudmFsdWUpID4gYWJzKGRpZmZZLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIGRpZmZYLnZhbHVlID4gMCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlmZlkudmFsdWUgPiAwID8gXCJ1cFwiIDogXCJkb3duXCI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZ2V0VG91Y2hFdmVudENvb3JkcyA9IChlKSA9PiBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXTtcbiAgY29uc3QgdXBkYXRlQ29vcmRzU3RhcnQgPSAoeCwgeSkgPT4ge1xuICAgIGNvb3Jkc1N0YXJ0LnggPSB4O1xuICAgIGNvb3Jkc1N0YXJ0LnkgPSB5O1xuICB9O1xuICBjb25zdCB1cGRhdGVDb29yZHNFbmQgPSAoeCwgeSkgPT4ge1xuICAgIGNvb3Jkc0VuZC54ID0geDtcbiAgICBjb29yZHNFbmQueSA9IHk7XG4gIH07XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZSwgY2FwdHVyZTogIXBhc3NpdmUgfTtcbiAgY29uc3Qgb25Ub3VjaEVuZCA9IChlKSA9PiB7XG4gICAgaWYgKGlzU3dpcGluZy52YWx1ZSlcbiAgICAgIG9uU3dpcGVFbmQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3dpcGVFbmQoZSwgZGlyZWN0aW9uLnZhbHVlKTtcbiAgICBpc1N3aXBpbmcudmFsdWUgPSBmYWxzZTtcbiAgfTtcbiAgY29uc3Qgc3RvcHMgPSBbXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidG91Y2hzdGFydFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGdldFRvdWNoRXZlbnRDb29yZHMoZSk7XG4gICAgICB1cGRhdGVDb29yZHNTdGFydCh4LCB5KTtcbiAgICAgIHVwZGF0ZUNvb3Jkc0VuZCh4LCB5KTtcbiAgICAgIG9uU3dpcGVTdGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZVN0YXJ0KGUpO1xuICAgIH0sIGxpc3RlbmVyT3B0aW9ucyksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwidG91Y2htb3ZlXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgW3gsIHldID0gZ2V0VG91Y2hFdmVudENvb3JkcyhlKTtcbiAgICAgIHVwZGF0ZUNvb3Jkc0VuZCh4LCB5KTtcbiAgICAgIGlmIChsaXN0ZW5lck9wdGlvbnMuY2FwdHVyZSAmJiAhbGlzdGVuZXJPcHRpb25zLnBhc3NpdmUgJiYgTWF0aC5hYnMoZGlmZlgudmFsdWUpID4gTWF0aC5hYnMoZGlmZlkudmFsdWUpKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlzU3dpcGluZy52YWx1ZSAmJiBpc1RocmVzaG9sZEV4Y2VlZGVkLnZhbHVlKVxuICAgICAgICBpc1N3aXBpbmcudmFsdWUgPSB0cnVlO1xuICAgICAgaWYgKGlzU3dpcGluZy52YWx1ZSlcbiAgICAgICAgb25Td2lwZSA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZShlKTtcbiAgICB9LCBsaXN0ZW5lck9wdGlvbnMpLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBbXCJ0b3VjaGVuZFwiLCBcInRvdWNoY2FuY2VsXCJdLCBvblRvdWNoRW5kLCBsaXN0ZW5lck9wdGlvbnMpXG4gIF07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiBzdG9wcy5mb3JFYWNoKChzKSA9PiBzKCkpO1xuICByZXR1cm4ge1xuICAgIGlzU3dpcGluZyxcbiAgICBkaXJlY3Rpb24sXG4gICAgY29vcmRzU3RhcnQsXG4gICAgY29vcmRzRW5kLFxuICAgIGxlbmd0aFg6IGRpZmZYLFxuICAgIGxlbmd0aFk6IGRpZmZZLFxuICAgIHN0b3AsXG4gICAgLy8gVE9ETzogUmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbiAgICBpc1Bhc3NpdmVFdmVudFN1cHBvcnRlZDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUZW1wbGF0ZVJlZnNMaXN0KCkge1xuICBjb25zdCByZWZzID0gcmVmKFtdKTtcbiAgcmVmcy52YWx1ZS5zZXQgPSAoZWwpID0+IHtcbiAgICBpZiAoZWwpXG4gICAgICByZWZzLnZhbHVlLnB1c2goZWwpO1xuICB9O1xuICBvbkJlZm9yZVVwZGF0ZSgoKSA9PiB7XG4gICAgcmVmcy52YWx1ZS5sZW5ndGggPSAwO1xuICB9KTtcbiAgcmV0dXJuIHJlZnM7XG59XG5cbmZ1bmN0aW9uIHVzZVRleHREaXJlY3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBzZWxlY3RvciA9IFwiaHRtbFwiLFxuICAgIG9ic2VydmUgPSBmYWxzZSxcbiAgICBpbml0aWFsVmFsdWUgPSBcImx0clwiXG4gIH0gPSBvcHRpb25zO1xuICBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRBdHRyaWJ1dGUoXCJkaXJcIikpICE9IG51bGwgPyBfYiA6IGluaXRpYWxWYWx1ZTtcbiAgfVxuICBjb25zdCBkaXIgPSByZWYoZ2V0VmFsdWUoKSk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiBkaXIudmFsdWUgPSBnZXRWYWx1ZSgpKTtcbiAgaWYgKG9ic2VydmUgJiYgZG9jdW1lbnQpIHtcbiAgICB1c2VNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gICAgICAoKSA9PiBkaXIudmFsdWUgPSBnZXRWYWx1ZSgpLFxuICAgICAgeyBhdHRyaWJ1dGVzOiB0cnVlIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGRpci52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgZGlyLnZhbHVlID0gdjtcbiAgICAgIGlmICghZG9jdW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChkaXIudmFsdWUpXG4gICAgICAgIChfYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0QXR0cmlidXRlKFwiZGlyXCIsIGRpci52YWx1ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIChfYiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2IucmVtb3ZlQXR0cmlidXRlKFwiZGlyXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlc0Zyb21TZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmFuZ2VDb3VudCA9IChfYSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50KSAhPSBudWxsID8gX2EgOiAwO1xuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogcmFuZ2VDb3VudCB9LCAoXywgaSkgPT4gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkpO1xufVxuZnVuY3Rpb24gdXNlVGV4dFNlbGVjdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHJlZihudWxsKTtcbiAgY29uc3QgdGV4dCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBzZWxlY3Rpb24udmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICB9KTtcbiAgY29uc3QgcmFuZ2VzID0gY29tcHV0ZWQoKCkgPT4gc2VsZWN0aW9uLnZhbHVlID8gZ2V0UmFuZ2VzRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24udmFsdWUpIDogW10pO1xuICBjb25zdCByZWN0cyA9IGNvbXB1dGVkKCgpID0+IHJhbmdlcy52YWx1ZS5tYXAoKHJhbmdlKSA9PiByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpO1xuICBmdW5jdGlvbiBvblNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBzZWxlY3Rpb24udmFsdWUgPSBudWxsO1xuICAgIGlmICh3aW5kb3cpXG4gICAgICBzZWxlY3Rpb24udmFsdWUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIH1cbiAgaWYgKHdpbmRvdylcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdy5kb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgb25TZWxlY3Rpb25DaGFuZ2UsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0LFxuICAgIHJlY3RzLFxuICAgIHJhbmdlcyxcbiAgICBzZWxlY3Rpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJ5UmVxdWVzdEFuaW1hdGlvbkZyYW1lKHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIGZuKSB7XG4gIGlmICh3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICB9IGVsc2Uge1xuICAgIGZuKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVRleHRhcmVhQXV0b3NpemUob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGV4dGFyZWEgPSB0b1JlZihvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmVsZW1lbnQpO1xuICBjb25zdCBpbnB1dCA9IHRvUmVmKChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5wdXQpICE9IG51bGwgPyBfYSA6IFwiXCIpO1xuICBjb25zdCBzdHlsZVByb3AgPSAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0eWxlUHJvcCkgIT0gbnVsbCA/IF9iIDogXCJoZWlnaHRcIjtcbiAgY29uc3QgdGV4dGFyZWFTY3JvbGxIZWlnaHQgPSBzaGFsbG93UmVmKDEpO1xuICBjb25zdCB0ZXh0YXJlYU9sZFdpZHRoID0gc2hhbGxvd1JlZigwKTtcbiAgZnVuY3Rpb24gdHJpZ2dlclJlc2l6ZSgpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghdGV4dGFyZWEudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGhlaWdodCA9IFwiXCI7XG4gICAgdGV4dGFyZWEudmFsdWUuc3R5bGVbc3R5bGVQcm9wXSA9IFwiMXB4XCI7XG4gICAgdGV4dGFyZWFTY3JvbGxIZWlnaHQudmFsdWUgPSAoX2EyID0gdGV4dGFyZWEudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Nyb2xsSGVpZ2h0O1xuICAgIGNvbnN0IF9zdHlsZVRhcmdldCA9IHRvVmFsdWUob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zdHlsZVRhcmdldCk7XG4gICAgaWYgKF9zdHlsZVRhcmdldClcbiAgICAgIF9zdHlsZVRhcmdldC5zdHlsZVtzdHlsZVByb3BdID0gYCR7dGV4dGFyZWFTY3JvbGxIZWlnaHQudmFsdWV9cHhgO1xuICAgIGVsc2VcbiAgICAgIGhlaWdodCA9IGAke3RleHRhcmVhU2Nyb2xsSGVpZ2h0LnZhbHVlfXB4YDtcbiAgICB0ZXh0YXJlYS52YWx1ZS5zdHlsZVtzdHlsZVByb3BdID0gaGVpZ2h0O1xuICB9XG4gIHdhdGNoKFtpbnB1dCwgdGV4dGFyZWFdLCAoKSA9PiBuZXh0VGljayh0cmlnZ2VyUmVzaXplKSwgeyBpbW1lZGlhdGU6IHRydWUgfSk7XG4gIHdhdGNoKHRleHRhcmVhU2Nyb2xsSGVpZ2h0LCAoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXNpemUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKTtcbiAgfSk7XG4gIHVzZVJlc2l6ZU9ic2VydmVyKHRleHRhcmVhLCAoW3sgY29udGVudFJlY3QgfV0pID0+IHtcbiAgICBpZiAodGV4dGFyZWFPbGRXaWR0aC52YWx1ZSA9PT0gY29udGVudFJlY3Qud2lkdGgpXG4gICAgICByZXR1cm47XG4gICAgdHJ5UmVxdWVzdEFuaW1hdGlvbkZyYW1lKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGV4dGFyZWFPbGRXaWR0aC52YWx1ZSA9IGNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgdHJpZ2dlclJlc2l6ZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMud2F0Y2gpXG4gICAgd2F0Y2gob3B0aW9ucy53YXRjaCwgdHJpZ2dlclJlc2l6ZSwgeyBpbW1lZGlhdGU6IHRydWUsIGRlZXA6IHRydWUgfSk7XG4gIHJldHVybiB7XG4gICAgdGV4dGFyZWEsXG4gICAgaW5wdXQsXG4gICAgdHJpZ2dlclJlc2l6ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUaHJvdHRsZWRSZWZIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgdGhyb3R0bGUgPSAyMDAsIHRyYWlsaW5nID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmlsdGVyID0gdGhyb3R0bGVGaWx0ZXIodGhyb3R0bGUsIHRyYWlsaW5nKTtcbiAgY29uc3QgaGlzdG9yeSA9IHVzZVJlZkhpc3Rvcnkoc291cmNlLCB7IC4uLm9wdGlvbnMsIGV2ZW50RmlsdGVyOiBmaWx0ZXIgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uaGlzdG9yeVxuICB9O1xufVxuXG5jb25zdCBERUZBVUxUX1VOSVRTID0gW1xuICB7IG1heDogNmU0LCB2YWx1ZTogMWUzLCBuYW1lOiBcInNlY29uZFwiIH0sXG4gIHsgbWF4OiAyNzZlNCwgdmFsdWU6IDZlNCwgbmFtZTogXCJtaW51dGVcIiB9LFxuICB7IG1heDogNzJlNiwgdmFsdWU6IDM2ZTUsIG5hbWU6IFwiaG91clwiIH0sXG4gIHsgbWF4OiA1MTg0ZTUsIHZhbHVlOiA4NjRlNSwgbmFtZTogXCJkYXlcIiB9LFxuICB7IG1heDogMjQxOTJlNSwgdmFsdWU6IDYwNDhlNSwgbmFtZTogXCJ3ZWVrXCIgfSxcbiAgeyBtYXg6IDI4NTEyZTYsIHZhbHVlOiAyNTkyZTYsIG5hbWU6IFwibW9udGhcIiB9LFxuICB7IG1heDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB2YWx1ZTogMzE1MzZlNiwgbmFtZTogXCJ5ZWFyXCIgfVxuXTtcbmNvbnN0IERFRkFVTFRfTUVTU0FHRVMgPSB7XG4gIGp1c3ROb3c6IFwianVzdCBub3dcIixcbiAgcGFzdDogKG4pID0+IG4ubWF0Y2goL1xcZC8pID8gYCR7bn0gYWdvYCA6IG4sXG4gIGZ1dHVyZTogKG4pID0+IG4ubWF0Y2goL1xcZC8pID8gYGluICR7bn1gIDogbixcbiAgbW9udGg6IChuLCBwYXN0KSA9PiBuID09PSAxID8gcGFzdCA/IFwibGFzdCBtb250aFwiIDogXCJuZXh0IG1vbnRoXCIgOiBgJHtufSBtb250aCR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgeWVhcjogKG4sIHBhc3QpID0+IG4gPT09IDEgPyBwYXN0ID8gXCJsYXN0IHllYXJcIiA6IFwibmV4dCB5ZWFyXCIgOiBgJHtufSB5ZWFyJHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICBkYXk6IChuLCBwYXN0KSA9PiBuID09PSAxID8gcGFzdCA/IFwieWVzdGVyZGF5XCIgOiBcInRvbW9ycm93XCIgOiBgJHtufSBkYXkke24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIHdlZWs6IChuLCBwYXN0KSA9PiBuID09PSAxID8gcGFzdCA/IFwibGFzdCB3ZWVrXCIgOiBcIm5leHQgd2Vla1wiIDogYCR7bn0gd2VlayR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgaG91cjogKG4pID0+IGAke259IGhvdXIke24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIG1pbnV0ZTogKG4pID0+IGAke259IG1pbnV0ZSR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgc2Vjb25kOiAobikgPT4gYCR7bn0gc2Vjb25kJHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICBpbnZhbGlkOiBcIlwiXG59O1xuZnVuY3Rpb24gREVGQVVMVF9GT1JNQVRURVIoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKTtcbn1cbmZ1bmN0aW9uIHVzZVRpbWVBZ28odGltZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBjb250cm9sczogZXhwb3NlQ29udHJvbHMgPSBmYWxzZSxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IDNlNFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBub3csIC4uLmNvbnRyb2xzIH0gPSB1c2VOb3coeyBpbnRlcnZhbDogdXBkYXRlSW50ZXJ2YWwsIGNvbnRyb2xzOiB0cnVlIH0pO1xuICBjb25zdCB0aW1lQWdvID0gY29tcHV0ZWQoKCkgPT4gZm9ybWF0VGltZUFnbyhuZXcgRGF0ZSh0b1ZhbHVlKHRpbWUpKSwgb3B0aW9ucywgdG9WYWx1ZShub3cpKSk7XG4gIGlmIChleHBvc2VDb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lQWdvLFxuICAgICAgLi4uY29udHJvbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aW1lQWdvO1xuICB9XG59XG5mdW5jdGlvbiBmb3JtYXRUaW1lQWdvKGZyb20sIG9wdGlvbnMgPSB7fSwgbm93ID0gRGF0ZS5ub3coKSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBtYXgsXG4gICAgbWVzc2FnZXMgPSBERUZBVUxUX01FU1NBR0VTLFxuICAgIGZ1bGxEYXRlRm9ybWF0dGVyID0gREVGQVVMVF9GT1JNQVRURVIsXG4gICAgdW5pdHMgPSBERUZBVUxUX1VOSVRTLFxuICAgIHNob3dTZWNvbmQgPSBmYWxzZSxcbiAgICByb3VuZGluZyA9IFwicm91bmRcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgcm91bmRGbiA9IHR5cGVvZiByb3VuZGluZyA9PT0gXCJudW1iZXJcIiA/IChuKSA9PiArbi50b0ZpeGVkKHJvdW5kaW5nKSA6IE1hdGhbcm91bmRpbmddO1xuICBjb25zdCBkaWZmID0gK25vdyAtICtmcm9tO1xuICBjb25zdCBhYnNEaWZmID0gTWF0aC5hYnMoZGlmZik7XG4gIGZ1bmN0aW9uIGdldFZhbHVlKGRpZmYyLCB1bml0KSB7XG4gICAgcmV0dXJuIHJvdW5kRm4oTWF0aC5hYnMoZGlmZjIpIC8gdW5pdC52YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0KGRpZmYyLCB1bml0KSB7XG4gICAgY29uc3QgdmFsID0gZ2V0VmFsdWUoZGlmZjIsIHVuaXQpO1xuICAgIGNvbnN0IHBhc3QgPSBkaWZmMiA+IDA7XG4gICAgY29uc3Qgc3RyID0gYXBwbHlGb3JtYXQodW5pdC5uYW1lLCB2YWwsIHBhc3QpO1xuICAgIHJldHVybiBhcHBseUZvcm1hdChwYXN0ID8gXCJwYXN0XCIgOiBcImZ1dHVyZVwiLCBzdHIsIHBhc3QpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5Rm9ybWF0KG5hbWUsIHZhbCwgaXNQYXN0KSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gbWVzc2FnZXNbbmFtZV07XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsLCBpc1Bhc3QpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucmVwbGFjZShcInswfVwiLCB2YWwudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKGFic0RpZmYgPCA2ZTQgJiYgIXNob3dTZWNvbmQpXG4gICAgcmV0dXJuIG1lc3NhZ2VzLmp1c3ROb3c7XG4gIGlmICh0eXBlb2YgbWF4ID09PSBcIm51bWJlclwiICYmIGFic0RpZmYgPiBtYXgpXG4gICAgcmV0dXJuIGZ1bGxEYXRlRm9ybWF0dGVyKG5ldyBEYXRlKGZyb20pKTtcbiAgaWYgKHR5cGVvZiBtYXggPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCB1bml0TWF4ID0gKF9hID0gdW5pdHMuZmluZCgoaSkgPT4gaS5uYW1lID09PSBtYXgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWF4O1xuICAgIGlmICh1bml0TWF4ICYmIGFic0RpZmYgPiB1bml0TWF4KVxuICAgICAgcmV0dXJuIGZ1bGxEYXRlRm9ybWF0dGVyKG5ldyBEYXRlKGZyb20pKTtcbiAgfVxuICBmb3IgKGNvbnN0IFtpZHgsIHVuaXRdIG9mIHVuaXRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IHZhbCA9IGdldFZhbHVlKGRpZmYsIHVuaXQpO1xuICAgIGlmICh2YWwgPD0gMCAmJiB1bml0c1tpZHggLSAxXSlcbiAgICAgIHJldHVybiBmb3JtYXQoZGlmZiwgdW5pdHNbaWR4IC0gMV0pO1xuICAgIGlmIChhYnNEaWZmIDwgdW5pdC5tYXgpXG4gICAgICByZXR1cm4gZm9ybWF0KGRpZmYsIHVuaXQpO1xuICB9XG4gIHJldHVybiBtZXNzYWdlcy5pbnZhbGlkO1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lb3V0UG9sbChmbiwgaW50ZXJ2YWwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBpbW1lZGlhdGVDYWxsYmFjayA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IHN0YXJ0IH0gPSB1c2VUaW1lb3V0Rm4obG9vcCwgaW50ZXJ2YWwsIHsgaW1tZWRpYXRlIH0pO1xuICBjb25zdCBpc0FjdGl2ZSA9IHNoYWxsb3dSZWYoZmFsc2UpO1xuICBhc3luYyBmdW5jdGlvbiBsb29wKCkge1xuICAgIGlmICghaXNBY3RpdmUudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgZm4oKTtcbiAgICBzdGFydCgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBpZiAoIWlzQWN0aXZlLnZhbHVlKSB7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IHRydWU7XG4gICAgICBpZiAoaW1tZWRpYXRlQ2FsbGJhY2spXG4gICAgICAgIGZuKCk7XG4gICAgICBzdGFydCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpc0FjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpbW1lZGlhdGUgJiYgaXNDbGllbnQpXG4gICAgcmVzdW1lKCk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHBhdXNlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZSxcbiAgICBwYXVzZSxcbiAgICByZXN1bWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVGltZXN0YW1wKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHM6IGV4cG9zZUNvbnRyb2xzID0gZmFsc2UsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGludGVydmFsID0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICBjYWxsYmFja1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdHMgPSBzaGFsbG93UmVmKHRpbWVzdGFtcCgpICsgb2Zmc2V0KTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4gdHMudmFsdWUgPSB0aW1lc3RhbXAoKSArIG9mZnNldDtcbiAgY29uc3QgY2IgPSBjYWxsYmFjayA/ICgpID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgICBjYWxsYmFjayh0cy52YWx1ZSk7XG4gIH0gOiB1cGRhdGU7XG4gIGNvbnN0IGNvbnRyb2xzID0gaW50ZXJ2YWwgPT09IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIgPyB1c2VSYWZGbihjYiwgeyBpbW1lZGlhdGUgfSkgOiB1c2VJbnRlcnZhbEZuKGNiLCBpbnRlcnZhbCwgeyBpbW1lZGlhdGUgfSk7XG4gIGlmIChleHBvc2VDb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXA6IHRzLFxuICAgICAgLi4uY29udHJvbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cztcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VUaXRsZShuZXdUaXRsZSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50LFxuICAgIHJlc3RvcmVPblVubW91bnQgPSAodCkgPT4gdFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgb3JpZ2luYWxUaXRsZSA9IChfYSA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC50aXRsZSkgIT0gbnVsbCA/IF9hIDogXCJcIjtcbiAgY29uc3QgdGl0bGUgPSB0b1JlZigoX2IgPSBuZXdUaXRsZSAhPSBudWxsID8gbmV3VGl0bGUgOiBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQudGl0bGUpICE9IG51bGwgPyBfYiA6IG51bGwpO1xuICBjb25zdCBpc1JlYWRvbmx5ID0gISEobmV3VGl0bGUgJiYgdHlwZW9mIG5ld1RpdGxlID09PSBcImZ1bmN0aW9uXCIpO1xuICBmdW5jdGlvbiBmb3JtYXQodCkge1xuICAgIGlmICghKFwidGl0bGVUZW1wbGF0ZVwiIGluIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBvcHRpb25zLnRpdGxlVGVtcGxhdGUgfHwgXCIlc1wiO1xuICAgIHJldHVybiB0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHRlbXBsYXRlKHQpIDogdG9WYWx1ZSh0ZW1wbGF0ZSkucmVwbGFjZSgvJXMvZywgdCk7XG4gIH1cbiAgd2F0Y2goXG4gICAgdGl0bGUsXG4gICAgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSAmJiBkb2N1bWVudClcbiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSBmb3JtYXQobmV3VmFsdWUgIT0gbnVsbCA/IG5ld1ZhbHVlIDogXCJcIik7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIGlmIChvcHRpb25zLm9ic2VydmUgJiYgIW9wdGlvbnMudGl0bGVUZW1wbGF0ZSAmJiBkb2N1bWVudCAmJiAhaXNSZWFkb25seSkge1xuICAgIHVzZU11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICAoX2MgPSBkb2N1bWVudC5oZWFkKSA9PSBudWxsID8gdm9pZCAwIDogX2MucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQudGl0bGUgIT09IHRpdGxlLnZhbHVlKVxuICAgICAgICAgIHRpdGxlLnZhbHVlID0gZm9ybWF0KGRvY3VtZW50LnRpdGxlKTtcbiAgICAgIH0sXG4gICAgICB7IGNoaWxkTGlzdDogdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgaWYgKHJlc3RvcmVPblVubW91bnQpIHtcbiAgICAgIGNvbnN0IHJlc3RvcmVkVGl0bGUgPSByZXN0b3JlT25Vbm1vdW50KG9yaWdpbmFsVGl0bGUsIHRpdGxlLnZhbHVlIHx8IFwiXCIpO1xuICAgICAgaWYgKHJlc3RvcmVkVGl0bGUgIT0gbnVsbCAmJiBkb2N1bWVudClcbiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSByZXN0b3JlZFRpdGxlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aXRsZTtcbn1cblxuY29uc3QgX1RyYW5zaXRpb25QcmVzZXRzID0ge1xuICBlYXNlSW5TaW5lOiBbMC4xMiwgMCwgMC4zOSwgMF0sXG4gIGVhc2VPdXRTaW5lOiBbMC42MSwgMSwgMC44OCwgMV0sXG4gIGVhc2VJbk91dFNpbmU6IFswLjM3LCAwLCAwLjYzLCAxXSxcbiAgZWFzZUluUXVhZDogWzAuMTEsIDAsIDAuNSwgMF0sXG4gIGVhc2VPdXRRdWFkOiBbMC41LCAxLCAwLjg5LCAxXSxcbiAgZWFzZUluT3V0UXVhZDogWzAuNDUsIDAsIDAuNTUsIDFdLFxuICBlYXNlSW5DdWJpYzogWzAuMzIsIDAsIDAuNjcsIDBdLFxuICBlYXNlT3V0Q3ViaWM6IFswLjMzLCAxLCAwLjY4LCAxXSxcbiAgZWFzZUluT3V0Q3ViaWM6IFswLjY1LCAwLCAwLjM1LCAxXSxcbiAgZWFzZUluUXVhcnQ6IFswLjUsIDAsIDAuNzUsIDBdLFxuICBlYXNlT3V0UXVhcnQ6IFswLjI1LCAxLCAwLjUsIDFdLFxuICBlYXNlSW5PdXRRdWFydDogWzAuNzYsIDAsIDAuMjQsIDFdLFxuICBlYXNlSW5RdWludDogWzAuNjQsIDAsIDAuNzgsIDBdLFxuICBlYXNlT3V0UXVpbnQ6IFswLjIyLCAxLCAwLjM2LCAxXSxcbiAgZWFzZUluT3V0UXVpbnQ6IFswLjgzLCAwLCAwLjE3LCAxXSxcbiAgZWFzZUluRXhwbzogWzAuNywgMCwgMC44NCwgMF0sXG4gIGVhc2VPdXRFeHBvOiBbMC4xNiwgMSwgMC4zLCAxXSxcbiAgZWFzZUluT3V0RXhwbzogWzAuODcsIDAsIDAuMTMsIDFdLFxuICBlYXNlSW5DaXJjOiBbMC41NSwgMCwgMSwgMC40NV0sXG4gIGVhc2VPdXRDaXJjOiBbMCwgMC41NSwgMC40NSwgMV0sXG4gIGVhc2VJbk91dENpcmM6IFswLjg1LCAwLCAwLjE1LCAxXSxcbiAgZWFzZUluQmFjazogWzAuMzYsIDAsIDAuNjYsIC0wLjU2XSxcbiAgZWFzZU91dEJhY2s6IFswLjM0LCAxLjU2LCAwLjY0LCAxXSxcbiAgZWFzZUluT3V0QmFjazogWzAuNjgsIC0wLjYsIDAuMzIsIDEuNl1cbn07XG5jb25zdCBUcmFuc2l0aW9uUHJlc2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKHt9LCB7IGxpbmVhcjogaWRlbnRpdHkgfSwgX1RyYW5zaXRpb25QcmVzZXRzKTtcbmZ1bmN0aW9uIGNyZWF0ZUVhc2luZ0Z1bmN0aW9uKFtwMCwgcDEsIHAyLCBwM10pIHtcbiAgY29uc3QgYSA9IChhMSwgYTIpID0+IDEgLSAzICogYTIgKyAzICogYTE7XG4gIGNvbnN0IGIgPSAoYTEsIGEyKSA9PiAzICogYTIgLSA2ICogYTE7XG4gIGNvbnN0IGMgPSAoYTEpID0+IDMgKiBhMTtcbiAgY29uc3QgY2FsY0JlemllciA9ICh0LCBhMSwgYTIpID0+ICgoYShhMSwgYTIpICogdCArIGIoYTEsIGEyKSkgKiB0ICsgYyhhMSkpICogdDtcbiAgY29uc3QgZ2V0U2xvcGUgPSAodCwgYTEsIGEyKSA9PiAzICogYShhMSwgYTIpICogdCAqIHQgKyAyICogYihhMSwgYTIpICogdCArIGMoYTEpO1xuICBjb25zdCBnZXRUZm9yWCA9ICh4KSA9PiB7XG4gICAgbGV0IGFHdWVzc1QgPSB4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBjb25zdCBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBwMCwgcDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgcDAsIHAyKSAtIHg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfTtcbiAgcmV0dXJuICh4KSA9PiBwMCA9PT0gcDEgJiYgcDIgPT09IHAzID8geCA6IGNhbGNCZXppZXIoZ2V0VGZvclgoeCksIHAxLCBwMyk7XG59XG5mdW5jdGlvbiBsZXJwKGEsIGIsIGFscGhhKSB7XG4gIHJldHVybiBhICsgYWxwaGEgKiAoYiAtIGEpO1xufVxuZnVuY3Rpb24gdG9WZWModCkge1xuICByZXR1cm4gKHR5cGVvZiB0ID09PSBcIm51bWJlclwiID8gW3RdIDogdCkgfHwgW107XG59XG5mdW5jdGlvbiBleGVjdXRlVHJhbnNpdGlvbihzb3VyY2UsIGZyb20sIHRvLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZnJvbVZhbCA9IHRvVmFsdWUoZnJvbSk7XG4gIGNvbnN0IHRvVmFsID0gdG9WYWx1ZSh0byk7XG4gIGNvbnN0IHYxID0gdG9WZWMoZnJvbVZhbCk7XG4gIGNvbnN0IHYyID0gdG9WZWModG9WYWwpO1xuICBjb25zdCBkdXJhdGlvbiA9IChfYSA9IHRvVmFsdWUob3B0aW9ucy5kdXJhdGlvbikpICE9IG51bGwgPyBfYSA6IDFlMztcbiAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgZW5kQXQgPSBEYXRlLm5vdygpICsgZHVyYXRpb247XG4gIGNvbnN0IHRyYW5zID0gdHlwZW9mIG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy50cmFuc2l0aW9uIDogKF9iID0gdG9WYWx1ZShvcHRpb25zLnRyYW5zaXRpb24pKSAhPSBudWxsID8gX2IgOiBpZGVudGl0eTtcbiAgY29uc3QgZWFzZSA9IHR5cGVvZiB0cmFucyA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnMgOiBjcmVhdGVFYXNpbmdGdW5jdGlvbih0cmFucyk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHNvdXJjZS52YWx1ZSA9IGZyb21WYWw7XG4gICAgY29uc3QgdGljayA9ICgpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoKF9hMiA9IG9wdGlvbnMuYWJvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBhbHBoYSA9IGVhc2UoKG5vdyAtIHN0YXJ0ZWRBdCkgLyBkdXJhdGlvbik7XG4gICAgICBjb25zdCBhcnIgPSB0b1ZlYyhzb3VyY2UudmFsdWUpLm1hcCgobiwgaSkgPT4gbGVycCh2MVtpXSwgdjJbaV0sIGFscGhhKSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UudmFsdWUpKVxuICAgICAgICBzb3VyY2UudmFsdWUgPSBhcnIubWFwKChuLCBpKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMywgX2IyO1xuICAgICAgICAgIHJldHVybiBsZXJwKChfYTMgPSB2MVtpXSkgIT0gbnVsbCA/IF9hMyA6IDAsIChfYjIgPSB2MltpXSkgIT0gbnVsbCA/IF9iMiA6IDAsIGFscGhhKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlLnZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICBzb3VyY2UudmFsdWUgPSBhcnJbMF07XG4gICAgICBpZiAobm93IDwgZW5kQXQpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlLnZhbHVlID0gdG9WYWw7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRpY2soKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjdXJyZW50SWQgPSAwO1xuICBjb25zdCBzb3VyY2VWYWwgPSAoKSA9PiB7XG4gICAgY29uc3QgdiA9IHRvVmFsdWUoc291cmNlKTtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyB2IDogdi5tYXAodG9WYWx1ZSk7XG4gIH07XG4gIGNvbnN0IG91dHB1dFJlZiA9IHJlZihzb3VyY2VWYWwoKSk7XG4gIHdhdGNoKHNvdXJjZVZhbCwgYXN5bmMgKHRvKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodG9WYWx1ZShvcHRpb25zLmRpc2FibGVkKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpZCA9ICsrY3VycmVudElkO1xuICAgIGlmIChvcHRpb25zLmRlbGF5KVxuICAgICAgYXdhaXQgcHJvbWlzZVRpbWVvdXQodG9WYWx1ZShvcHRpb25zLmRlbGF5KSk7XG4gICAgaWYgKGlkICE9PSBjdXJyZW50SWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdG9WYWwgPSBBcnJheS5pc0FycmF5KHRvKSA/IHRvLm1hcCh0b1ZhbHVlKSA6IHRvVmFsdWUodG8pO1xuICAgIChfYSA9IG9wdGlvbnMub25TdGFydGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zKTtcbiAgICBhd2FpdCBleGVjdXRlVHJhbnNpdGlvbihvdXRwdXRSZWYsIG91dHB1dFJlZi52YWx1ZSwgdG9WYWwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gaWQgIT09IGN1cnJlbnRJZCB8fCAoKF9hMiA9IG9wdGlvbnMuYWJvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgKF9iID0gb3B0aW9ucy5vbkZpbmlzaGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zKTtcbiAgfSwgeyBkZWVwOiB0cnVlIH0pO1xuICB3YXRjaCgoKSA9PiB0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpLCAoZGlzYWJsZWQpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIGN1cnJlbnRJZCsrO1xuICAgICAgb3V0cHV0UmVmLnZhbHVlID0gc291cmNlVmFsKCk7XG4gICAgfVxuICB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIGN1cnJlbnRJZCsrO1xuICB9KTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUob3B0aW9ucy5kaXNhYmxlZCkgPyBzb3VyY2VWYWwoKSA6IG91dHB1dFJlZi52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVVybFNlYXJjaFBhcmFtcyhtb2RlID0gXCJoaXN0b3J5XCIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW5pdGlhbFZhbHVlID0ge30sXG4gICAgcmVtb3ZlTnVsbGlzaFZhbHVlcyA9IHRydWUsXG4gICAgcmVtb3ZlRmFsc3lWYWx1ZXMgPSBmYWxzZSxcbiAgICB3cml0ZTogZW5hYmxlV3JpdGUgPSB0cnVlLFxuICAgIHdyaXRlTW9kZSA9IFwicmVwbGFjZVwiLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93KVxuICAgIHJldHVybiByZWFjdGl2ZShpbml0aWFsVmFsdWUpO1xuICBjb25zdCBzdGF0ZSA9IHJlYWN0aXZlKHt9KTtcbiAgZnVuY3Rpb24gZ2V0UmF3UGFyYW1zKCkge1xuICAgIGlmIChtb2RlID09PSBcImhpc3RvcnlcIikge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIjtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiaGFzaFwiKSB7XG4gICAgICBjb25zdCBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2ggfHwgXCJcIjtcbiAgICAgIGNvbnN0IGluZGV4ID0gaGFzaC5pbmRleE9mKFwiP1wiKTtcbiAgICAgIHJldHVybiBpbmRleCA+IDAgPyBoYXNoLnNsaWNlKGluZGV4KSA6IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAod2luZG93LmxvY2F0aW9uLmhhc2ggfHwgXCJcIikucmVwbGFjZSgvXiMvLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29uc3RydWN0UXVlcnkocGFyYW1zKSB7XG4gICAgY29uc3Qgc3RyaW5naWZpZWQgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICBpZiAobW9kZSA9PT0gXCJoaXN0b3J5XCIpXG4gICAgICByZXR1cm4gYCR7c3RyaW5naWZpZWQgPyBgPyR7c3RyaW5naWZpZWR9YCA6IFwiXCJ9JHt3aW5kb3cubG9jYXRpb24uaGFzaCB8fCBcIlwifWA7XG4gICAgaWYgKG1vZGUgPT09IFwiaGFzaC1wYXJhbXNcIilcbiAgICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8IFwiXCJ9JHtzdHJpbmdpZmllZCA/IGAjJHtzdHJpbmdpZmllZH1gIDogXCJcIn1gO1xuICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaCB8fCBcIiNcIjtcbiAgICBjb25zdCBpbmRleCA9IGhhc2guaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKGluZGV4ID4gMClcbiAgICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8IFwiXCJ9JHtoYXNoLnNsaWNlKDAsIGluZGV4KX0ke3N0cmluZ2lmaWVkID8gYD8ke3N0cmluZ2lmaWVkfWAgOiBcIlwifWA7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIn0ke2hhc2h9JHtzdHJpbmdpZmllZCA/IGA/JHtzdHJpbmdpZmllZH1gIDogXCJcIn1gO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoZ2V0UmF3UGFyYW1zKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHVudXNlZEtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHN0YXRlKSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGFyYW1zLmtleXMoKSkge1xuICAgICAgY29uc3QgcGFyYW1zRm9yS2V5ID0gcGFyYW1zLmdldEFsbChrZXkpO1xuICAgICAgc3RhdGVba2V5XSA9IHBhcmFtc0ZvcktleS5sZW5ndGggPiAxID8gcGFyYW1zRm9yS2V5IDogcGFyYW1zLmdldChrZXkpIHx8IFwiXCI7XG4gICAgICB1bnVzZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBBcnJheS5mcm9tKHVudXNlZEtleXMpLmZvckVhY2goKGtleSkgPT4gZGVsZXRlIHN0YXRlW2tleV0pO1xuICB9XG4gIGNvbnN0IHsgcGF1c2UsIHJlc3VtZSB9ID0gcGF1c2FibGVXYXRjaChcbiAgICBzdGF0ZSxcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFwiXCIpO1xuICAgICAgT2JqZWN0LmtleXMoc3RhdGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHN0YXRlW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hcEVudHJ5KSlcbiAgICAgICAgICBtYXBFbnRyeS5mb3JFYWNoKCh2YWx1ZSkgPT4gcGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlbW92ZU51bGxpc2hWYWx1ZXMgJiYgbWFwRW50cnkgPT0gbnVsbClcbiAgICAgICAgICBwYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2UgaWYgKHJlbW92ZUZhbHN5VmFsdWVzICYmICFtYXBFbnRyeSlcbiAgICAgICAgICBwYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwYXJhbXMuc2V0KGtleSwgbWFwRW50cnkpO1xuICAgICAgfSk7XG4gICAgICB3cml0ZShwYXJhbXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIHsgZGVlcDogdHJ1ZSB9XG4gICk7XG4gIGZ1bmN0aW9uIHdyaXRlKHBhcmFtcywgc2hvdWxkVXBkYXRlKSB7XG4gICAgcGF1c2UoKTtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKVxuICAgICAgdXBkYXRlU3RhdGUocGFyYW1zKTtcbiAgICBpZiAod3JpdGVNb2RlID09PSBcInJlcGxhY2VcIikge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5zdGF0ZSxcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnRpdGxlLFxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyBjb25zdHJ1Y3RRdWVyeShwYXJhbXMpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnN0YXRlLFxuICAgICAgICB3aW5kb3cuZG9jdW1lbnQudGl0bGUsXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIGNvbnN0cnVjdFF1ZXJ5KHBhcmFtcylcbiAgICAgICk7XG4gICAgfVxuICAgIHJlc3VtZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG9uQ2hhbmdlZCgpIHtcbiAgICBpZiAoIWVuYWJsZVdyaXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHdyaXRlKHJlYWQoKSwgdHJ1ZSk7XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInBvcHN0YXRlXCIsIG9uQ2hhbmdlZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgaWYgKG1vZGUgIT09IFwiaGlzdG9yeVwiKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImhhc2hjaGFuZ2VcIiwgb25DaGFuZ2VkLCBsaXN0ZW5lck9wdGlvbnMpO1xuICBjb25zdCBpbml0aWFsID0gcmVhZCgpO1xuICBpZiAoaW5pdGlhbC5rZXlzKCkubmV4dCgpLnZhbHVlKVxuICAgIHVwZGF0ZVN0YXRlKGluaXRpYWwpO1xuICBlbHNlXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwgaW5pdGlhbFZhbHVlKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VVc2VyTWVkaWEob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGVuYWJsZWQgPSBzaGFsbG93UmVmKChfYSA9IG9wdGlvbnMuZW5hYmxlZCkgIT0gbnVsbCA/IF9hIDogZmFsc2UpO1xuICBjb25zdCBhdXRvU3dpdGNoID0gc2hhbGxvd1JlZigoX2IgPSBvcHRpb25zLmF1dG9Td2l0Y2gpICE9IG51bGwgPyBfYiA6IHRydWUpO1xuICBjb25zdCBjb25zdHJhaW50cyA9IHJlZihvcHRpb25zLmNvbnN0cmFpbnRzKTtcbiAgY29uc3QgeyBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRVc2VyTWVkaWE7XG4gIH0pO1xuICBjb25zdCBzdHJlYW0gPSBzaGFsbG93UmVmKCk7XG4gIGZ1bmN0aW9uIGdldERldmljZU9wdGlvbnModHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInZpZGVvXCI6IHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnZhbHVlKVxuICAgICAgICAgIHJldHVybiBjb25zdHJhaW50cy52YWx1ZS52aWRlbyB8fCBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXVkaW9cIjoge1xuICAgICAgICBpZiAoY29uc3RyYWludHMudmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzLnZhbHVlLmF1ZGlvIHx8IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gX3N0YXJ0KCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgc3RyZWFtLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHN0cmVhbS52YWx1ZSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgIHZpZGVvOiBnZXREZXZpY2VPcHRpb25zKFwidmlkZW9cIiksXG4gICAgICBhdWRpbzogZ2V0RGV2aWNlT3B0aW9ucyhcImF1ZGlvXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbS52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBfc3RvcCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIChfYTIgPSBzdHJlYW0udmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdC5zdG9wKCkpO1xuICAgIHN0cmVhbS52YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIF9zdG9wKCk7XG4gICAgZW5hYmxlZC52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGF3YWl0IF9zdGFydCgpO1xuICAgIGlmIChzdHJlYW0udmFsdWUpXG4gICAgICBlbmFibGVkLnZhbHVlID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RyZWFtLnZhbHVlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgX3N0b3AoKTtcbiAgICByZXR1cm4gYXdhaXQgc3RhcnQoKTtcbiAgfVxuICB3YXRjaChcbiAgICBlbmFibGVkLFxuICAgICh2KSA9PiB7XG4gICAgICBpZiAodilcbiAgICAgICAgX3N0YXJ0KCk7XG4gICAgICBlbHNlIF9zdG9wKCk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHdhdGNoKFxuICAgIGNvbnN0cmFpbnRzLFxuICAgICgpID0+IHtcbiAgICAgIGlmIChhdXRvU3dpdGNoLnZhbHVlICYmIHN0cmVhbS52YWx1ZSlcbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgc3RvcCgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBzdHJlYW0sXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICByZXN0YXJ0LFxuICAgIGNvbnN0cmFpbnRzLFxuICAgIGVuYWJsZWQsXG4gICAgYXV0b1N3aXRjaFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VWTW9kZWwocHJvcHMsIGtleSwgZW1pdCwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCB7XG4gICAgY2xvbmUgPSBmYWxzZSxcbiAgICBwYXNzaXZlID0gZmFsc2UsXG4gICAgZXZlbnROYW1lLFxuICAgIGRlZXAgPSBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWUsXG4gICAgc2hvdWxkRW1pdFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgdm0gPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgX2VtaXQgPSBlbWl0IHx8ICh2bSA9PSBudWxsID8gdm9pZCAwIDogdm0uZW1pdCkgfHwgKChfYSA9IHZtID09IG51bGwgPyB2b2lkIDAgOiB2bS4kZW1pdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJpbmQodm0pKSB8fCAoKF9jID0gKF9iID0gdm0gPT0gbnVsbCA/IHZvaWQgMCA6IHZtLnByb3h5KSA9PSBudWxsID8gdm9pZCAwIDogX2IuJGVtaXQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5iaW5kKHZtID09IG51bGwgPyB2b2lkIDAgOiB2bS5wcm94eSkpO1xuICBsZXQgZXZlbnQgPSBldmVudE5hbWU7XG4gIGlmICgha2V5KSB7XG4gICAga2V5ID0gXCJtb2RlbFZhbHVlXCI7XG4gIH1cbiAgZXZlbnQgPSBldmVudCB8fCBgdXBkYXRlOiR7a2V5LnRvU3RyaW5nKCl9YDtcbiAgY29uc3QgY2xvbmVGbiA9ICh2YWwpID0+ICFjbG9uZSA/IHZhbCA6IHR5cGVvZiBjbG9uZSA9PT0gXCJmdW5jdGlvblwiID8gY2xvbmUodmFsKSA6IGNsb25lRm5KU09OKHZhbCk7XG4gIGNvbnN0IGdldFZhbHVlID0gKCkgPT4gaXNEZWYocHJvcHNba2V5XSkgPyBjbG9uZUZuKHByb3BzW2tleV0pIDogZGVmYXVsdFZhbHVlO1xuICBjb25zdCB0cmlnZ2VyRW1pdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICBpZiAoc2hvdWxkRW1pdCh2YWx1ZSkpXG4gICAgICAgIF9lbWl0KGV2ZW50LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9lbWl0KGV2ZW50LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBpZiAocGFzc2l2ZSkge1xuICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldFZhbHVlKCk7XG4gICAgY29uc3QgcHJveHkgPSByZWYoaW5pdGlhbFZhbHVlKTtcbiAgICBsZXQgaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gcHJvcHNba2V5XSxcbiAgICAgICh2KSA9PiB7XG4gICAgICAgIGlmICghaXNVcGRhdGluZykge1xuICAgICAgICAgIGlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHByb3h5LnZhbHVlID0gY2xvbmVGbih2KTtcbiAgICAgICAgICBuZXh0VGljaygoKSA9PiBpc1VwZGF0aW5nID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB3YXRjaChcbiAgICAgIHByb3h5LFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgaWYgKCFpc1VwZGF0aW5nICYmICh2ICE9PSBwcm9wc1trZXldIHx8IGRlZXApKVxuICAgICAgICAgIHRyaWdnZXJFbWl0KHYpO1xuICAgICAgfSxcbiAgICAgIHsgZGVlcCB9XG4gICAgKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkKHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKCk7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHRyaWdnZXJFbWl0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VWTW9kZWxzKHByb3BzLCBlbWl0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgcmV0W2tleV0gPSB1c2VWTW9kZWwoXG4gICAgICBwcm9wcyxcbiAgICAgIGtleSxcbiAgICAgIGVtaXQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1c2VWaWJyYXRlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBhdHRlcm4gPSBbXSxcbiAgICBpbnRlcnZhbCA9IDAsXG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvclxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcInZpYnJhdGVcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBwYXR0ZXJuUmVmID0gdG9SZWYocGF0dGVybik7XG4gIGxldCBpbnRlcnZhbENvbnRyb2xzO1xuICBjb25zdCB2aWJyYXRlID0gKHBhdHRlcm4yID0gcGF0dGVyblJlZi52YWx1ZSkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIG5hdmlnYXRvci52aWJyYXRlKHBhdHRlcm4yKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICBuYXZpZ2F0b3IudmlicmF0ZSgwKTtcbiAgICBpbnRlcnZhbENvbnRyb2xzID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcnZhbENvbnRyb2xzLnBhdXNlKCk7XG4gIH07XG4gIGlmIChpbnRlcnZhbCA+IDApIHtcbiAgICBpbnRlcnZhbENvbnRyb2xzID0gdXNlSW50ZXJ2YWxGbihcbiAgICAgIHZpYnJhdGUsXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIHtcbiAgICAgICAgaW1tZWRpYXRlOiBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlQ2FsbGJhY2s6IGZhbHNlXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHBhdHRlcm4sXG4gICAgaW50ZXJ2YWxDb250cm9scyxcbiAgICB2aWJyYXRlLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVmlydHVhbExpc3QobGlzdCwgb3B0aW9ucykge1xuICBjb25zdCB7IGNvbnRhaW5lclN0eWxlLCB3cmFwcGVyUHJvcHMsIHNjcm9sbFRvLCBjYWxjdWxhdGVSYW5nZSwgY3VycmVudExpc3QsIGNvbnRhaW5lclJlZiB9ID0gXCJpdGVtSGVpZ2h0XCIgaW4gb3B0aW9ucyA/IHVzZVZlcnRpY2FsVmlydHVhbExpc3Qob3B0aW9ucywgbGlzdCkgOiB1c2VIb3Jpem9udGFsVmlydHVhbExpc3Qob3B0aW9ucywgbGlzdCk7XG4gIHJldHVybiB7XG4gICAgbGlzdDogY3VycmVudExpc3QsXG4gICAgc2Nyb2xsVG8sXG4gICAgY29udGFpbmVyUHJvcHM6IHtcbiAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgb25TY3JvbGw6ICgpID0+IHtcbiAgICAgICAgY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZTogY29udGFpbmVyU3R5bGVcbiAgICB9LFxuICAgIHdyYXBwZXJQcm9wc1xuICB9O1xufVxuZnVuY3Rpb24gdXNlVmlydHVhbExpc3RSZXNvdXJjZXMobGlzdCkge1xuICBjb25zdCBjb250YWluZXJSZWYgPSBzaGFsbG93UmVmKG51bGwpO1xuICBjb25zdCBzaXplID0gdXNlRWxlbWVudFNpemUoY29udGFpbmVyUmVmKTtcbiAgY29uc3QgY3VycmVudExpc3QgPSByZWYoW10pO1xuICBjb25zdCBzb3VyY2UgPSBzaGFsbG93UmVmKGxpc3QpO1xuICBjb25zdCBzdGF0ZSA9IHJlZih7IHN0YXJ0OiAwLCBlbmQ6IDEwIH0pO1xuICByZXR1cm4geyBzdGF0ZSwgc291cmNlLCBjdXJyZW50TGlzdCwgc2l6ZSwgY29udGFpbmVyUmVmIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHZXRWaWV3Q2FwYWNpdHkoc3RhdGUsIHNvdXJjZSwgaXRlbVNpemUpIHtcbiAgcmV0dXJuIChjb250YWluZXJTaXplKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtU2l6ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoY29udGFpbmVyU2l6ZSAvIGl0ZW1TaXplKTtcbiAgICBjb25zdCB7IHN0YXJ0ID0gMCB9ID0gc3RhdGUudmFsdWU7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGNhcGFjaXR5ID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzb3VyY2UudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpdGVtU2l6ZShpKTtcbiAgICAgIHN1bSArPSBzaXplO1xuICAgICAgY2FwYWNpdHkgPSBpO1xuICAgICAgaWYgKHN1bSA+IGNvbnRhaW5lclNpemUpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWNpdHkgLSBzdGFydDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdldE9mZnNldChzb3VyY2UsIGl0ZW1TaXplKSB7XG4gIHJldHVybiAoc2Nyb2xsRGlyZWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtU2l6ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHNjcm9sbERpcmVjdGlvbiAvIGl0ZW1TaXplKSArIDE7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpdGVtU2l6ZShpKTtcbiAgICAgIHN1bSArPSBzaXplO1xuICAgICAgaWYgKHN1bSA+PSBzY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgb2Zmc2V0ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsY3VsYXRlUmFuZ2UodHlwZSwgb3ZlcnNjYW4sIGdldE9mZnNldCwgZ2V0Vmlld0NhcGFjaXR5LCB7IGNvbnRhaW5lclJlZiwgc3RhdGUsIGN1cnJlbnRMaXN0LCBzb3VyY2UgfSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjb250YWluZXJSZWYudmFsdWU7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGdldE9mZnNldCh0eXBlID09PSBcInZlcnRpY2FsXCIgPyBlbGVtZW50LnNjcm9sbFRvcCA6IGVsZW1lbnQuc2Nyb2xsTGVmdCk7XG4gICAgICBjb25zdCB2aWV3Q2FwYWNpdHkgPSBnZXRWaWV3Q2FwYWNpdHkodHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gZWxlbWVudC5jbGllbnRIZWlnaHQgOiBlbGVtZW50LmNsaWVudFdpZHRoKTtcbiAgICAgIGNvbnN0IGZyb20gPSBvZmZzZXQgLSBvdmVyc2NhbjtcbiAgICAgIGNvbnN0IHRvID0gb2Zmc2V0ICsgdmlld0NhcGFjaXR5ICsgb3ZlcnNjYW47XG4gICAgICBzdGF0ZS52YWx1ZSA9IHtcbiAgICAgICAgc3RhcnQ6IGZyb20gPCAwID8gMCA6IGZyb20sXG4gICAgICAgIGVuZDogdG8gPiBzb3VyY2UudmFsdWUubGVuZ3RoID8gc291cmNlLnZhbHVlLmxlbmd0aCA6IHRvXG4gICAgICB9O1xuICAgICAgY3VycmVudExpc3QudmFsdWUgPSBzb3VyY2UudmFsdWUuc2xpY2Uoc3RhdGUudmFsdWUuc3RhcnQsIHN0YXRlLnZhbHVlLmVuZCkubWFwKChlbGUsIGluZGV4KSA9PiAoe1xuICAgICAgICBkYXRhOiBlbGUsXG4gICAgICAgIGluZGV4OiBpbmRleCArIHN0YXRlLnZhbHVlLnN0YXJ0XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlR2V0RGlzdGFuY2UoaXRlbVNpemUsIHNvdXJjZSkge1xuICByZXR1cm4gKGluZGV4KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtU2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgc2l6ZTIgPSBpbmRleCAqIGl0ZW1TaXplO1xuICAgICAgcmV0dXJuIHNpemUyO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gc291cmNlLnZhbHVlLnNsaWNlKDAsIGluZGV4KS5yZWR1Y2UoKHN1bSwgXywgaSkgPT4gc3VtICsgaXRlbVNpemUoaSksIDApO1xuICAgIHJldHVybiBzaXplO1xuICB9O1xufVxuZnVuY3Rpb24gdXNlV2F0Y2hGb3JTaXplcyhzaXplLCBsaXN0LCBjb250YWluZXJSZWYsIGNhbGN1bGF0ZVJhbmdlKSB7XG4gIHdhdGNoKFtzaXplLndpZHRoLCBzaXplLmhlaWdodCwgbGlzdCwgY29udGFpbmVyUmVmXSwgKCkgPT4ge1xuICAgIGNhbGN1bGF0ZVJhbmdlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRUb3RhbFNpemUoaXRlbVNpemUsIHNvdXJjZSkge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgaXRlbVNpemUgPT09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc291cmNlLnZhbHVlLmxlbmd0aCAqIGl0ZW1TaXplO1xuICAgIHJldHVybiBzb3VyY2UudmFsdWUucmVkdWNlKChzdW0sIF8sIGluZGV4KSA9PiBzdW0gKyBpdGVtU2l6ZShpbmRleCksIDApO1xuICB9KTtcbn1cbmNvbnN0IHNjcm9sbFRvRGljdGlvbmFyeUZvckVsZW1lbnRTY3JvbGxLZXkgPSB7XG4gIGhvcml6b250YWw6IFwic2Nyb2xsTGVmdFwiLFxuICB2ZXJ0aWNhbDogXCJzY3JvbGxUb3BcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVNjcm9sbFRvKHR5cGUsIGNhbGN1bGF0ZVJhbmdlLCBnZXREaXN0YW5jZSwgY29udGFpbmVyUmVmKSB7XG4gIHJldHVybiAoaW5kZXgpID0+IHtcbiAgICBpZiAoY29udGFpbmVyUmVmLnZhbHVlKSB7XG4gICAgICBjb250YWluZXJSZWYudmFsdWVbc2Nyb2xsVG9EaWN0aW9uYXJ5Rm9yRWxlbWVudFNjcm9sbEtleVt0eXBlXV0gPSBnZXREaXN0YW5jZShpbmRleCk7XG4gICAgICBjYWxjdWxhdGVSYW5nZSgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUhvcml6b250YWxWaXJ0dWFsTGlzdChvcHRpb25zLCBsaXN0KSB7XG4gIGNvbnN0IHJlc291cmNlcyA9IHVzZVZpcnR1YWxMaXN0UmVzb3VyY2VzKGxpc3QpO1xuICBjb25zdCB7IHN0YXRlLCBzb3VyY2UsIGN1cnJlbnRMaXN0LCBzaXplLCBjb250YWluZXJSZWYgfSA9IHJlc291cmNlcztcbiAgY29uc3QgY29udGFpbmVyU3R5bGUgPSB7IG92ZXJmbG93WDogXCJhdXRvXCIgfTtcbiAgY29uc3QgeyBpdGVtV2lkdGgsIG92ZXJzY2FuID0gNSB9ID0gb3B0aW9ucztcbiAgY29uc3QgZ2V0Vmlld0NhcGFjaXR5ID0gY3JlYXRlR2V0Vmlld0NhcGFjaXR5KHN0YXRlLCBzb3VyY2UsIGl0ZW1XaWR0aCk7XG4gIGNvbnN0IGdldE9mZnNldCA9IGNyZWF0ZUdldE9mZnNldChzb3VyY2UsIGl0ZW1XaWR0aCk7XG4gIGNvbnN0IGNhbGN1bGF0ZVJhbmdlID0gY3JlYXRlQ2FsY3VsYXRlUmFuZ2UoXCJob3Jpem9udGFsXCIsIG92ZXJzY2FuLCBnZXRPZmZzZXQsIGdldFZpZXdDYXBhY2l0eSwgcmVzb3VyY2VzKTtcbiAgY29uc3QgZ2V0RGlzdGFuY2VMZWZ0ID0gY3JlYXRlR2V0RGlzdGFuY2UoaXRlbVdpZHRoLCBzb3VyY2UpO1xuICBjb25zdCBvZmZzZXRMZWZ0ID0gY29tcHV0ZWQoKCkgPT4gZ2V0RGlzdGFuY2VMZWZ0KHN0YXRlLnZhbHVlLnN0YXJ0KSk7XG4gIGNvbnN0IHRvdGFsV2lkdGggPSBjcmVhdGVDb21wdXRlZFRvdGFsU2l6ZShpdGVtV2lkdGgsIHNvdXJjZSk7XG4gIHVzZVdhdGNoRm9yU2l6ZXMoc2l6ZSwgbGlzdCwgY29udGFpbmVyUmVmLCBjYWxjdWxhdGVSYW5nZSk7XG4gIGNvbnN0IHNjcm9sbFRvID0gY3JlYXRlU2Nyb2xsVG8oXCJob3Jpem9udGFsXCIsIGNhbGN1bGF0ZVJhbmdlLCBnZXREaXN0YW5jZUxlZnQsIGNvbnRhaW5lclJlZik7XG4gIGNvbnN0IHdyYXBwZXJQcm9wcyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgd2lkdGg6IGAke3RvdGFsV2lkdGgudmFsdWUgLSBvZmZzZXRMZWZ0LnZhbHVlfXB4YCxcbiAgICAgICAgbWFyZ2luTGVmdDogYCR7b2Zmc2V0TGVmdC52YWx1ZX1weGAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsVG8sXG4gICAgY2FsY3VsYXRlUmFuZ2UsXG4gICAgd3JhcHBlclByb3BzLFxuICAgIGNvbnRhaW5lclN0eWxlLFxuICAgIGN1cnJlbnRMaXN0LFxuICAgIGNvbnRhaW5lclJlZlxuICB9O1xufVxuZnVuY3Rpb24gdXNlVmVydGljYWxWaXJ0dWFsTGlzdChvcHRpb25zLCBsaXN0KSB7XG4gIGNvbnN0IHJlc291cmNlcyA9IHVzZVZpcnR1YWxMaXN0UmVzb3VyY2VzKGxpc3QpO1xuICBjb25zdCB7IHN0YXRlLCBzb3VyY2UsIGN1cnJlbnRMaXN0LCBzaXplLCBjb250YWluZXJSZWYgfSA9IHJlc291cmNlcztcbiAgY29uc3QgY29udGFpbmVyU3R5bGUgPSB7IG92ZXJmbG93WTogXCJhdXRvXCIgfTtcbiAgY29uc3QgeyBpdGVtSGVpZ2h0LCBvdmVyc2NhbiA9IDUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGdldFZpZXdDYXBhY2l0eSA9IGNyZWF0ZUdldFZpZXdDYXBhY2l0eShzdGF0ZSwgc291cmNlLCBpdGVtSGVpZ2h0KTtcbiAgY29uc3QgZ2V0T2Zmc2V0ID0gY3JlYXRlR2V0T2Zmc2V0KHNvdXJjZSwgaXRlbUhlaWdodCk7XG4gIGNvbnN0IGNhbGN1bGF0ZVJhbmdlID0gY3JlYXRlQ2FsY3VsYXRlUmFuZ2UoXCJ2ZXJ0aWNhbFwiLCBvdmVyc2NhbiwgZ2V0T2Zmc2V0LCBnZXRWaWV3Q2FwYWNpdHksIHJlc291cmNlcyk7XG4gIGNvbnN0IGdldERpc3RhbmNlVG9wID0gY3JlYXRlR2V0RGlzdGFuY2UoaXRlbUhlaWdodCwgc291cmNlKTtcbiAgY29uc3Qgb2Zmc2V0VG9wID0gY29tcHV0ZWQoKCkgPT4gZ2V0RGlzdGFuY2VUb3Aoc3RhdGUudmFsdWUuc3RhcnQpKTtcbiAgY29uc3QgdG90YWxIZWlnaHQgPSBjcmVhdGVDb21wdXRlZFRvdGFsU2l6ZShpdGVtSGVpZ2h0LCBzb3VyY2UpO1xuICB1c2VXYXRjaEZvclNpemVzKHNpemUsIGxpc3QsIGNvbnRhaW5lclJlZiwgY2FsY3VsYXRlUmFuZ2UpO1xuICBjb25zdCBzY3JvbGxUbyA9IGNyZWF0ZVNjcm9sbFRvKFwidmVydGljYWxcIiwgY2FsY3VsYXRlUmFuZ2UsIGdldERpc3RhbmNlVG9wLCBjb250YWluZXJSZWYpO1xuICBjb25zdCB3cmFwcGVyUHJvcHMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBgJHt0b3RhbEhlaWdodC52YWx1ZSAtIG9mZnNldFRvcC52YWx1ZX1weGAsXG4gICAgICAgIG1hcmdpblRvcDogYCR7b2Zmc2V0VG9wLnZhbHVlfXB4YFxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNhbGN1bGF0ZVJhbmdlLFxuICAgIHNjcm9sbFRvLFxuICAgIGNvbnRhaW5lclN0eWxlLFxuICAgIHdyYXBwZXJQcm9wcyxcbiAgICBjdXJyZW50TGlzdCxcbiAgICBjb250YWluZXJSZWZcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlV2FrZUxvY2sob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yLFxuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXF1ZXN0ZWRUeXBlID0gc2hhbGxvd1JlZihmYWxzZSk7XG4gIGNvbnN0IHNlbnRpbmVsID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgZG9jdW1lbnRWaXNpYmlsaXR5ID0gdXNlRG9jdW1lbnRWaXNpYmlsaXR5KHsgZG9jdW1lbnQgfSk7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcIndha2VMb2NrXCIgaW4gbmF2aWdhdG9yKTtcbiAgY29uc3QgaXNBY3RpdmUgPSBjb21wdXRlZCgoKSA9PiAhIXNlbnRpbmVsLnZhbHVlICYmIGRvY3VtZW50VmlzaWJpbGl0eS52YWx1ZSA9PT0gXCJ2aXNpYmxlXCIpO1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICB1c2VFdmVudExpc3RlbmVyKHNlbnRpbmVsLCBcInJlbGVhc2VcIiwgKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJlcXVlc3RlZFR5cGUudmFsdWUgPSAoX2IgPSAoX2EgPSBzZW50aW5lbC52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUpICE9IG51bGwgPyBfYiA6IGZhbHNlO1xuICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB3aGVuZXZlcihcbiAgICAgICgpID0+IGRvY3VtZW50VmlzaWJpbGl0eS52YWx1ZSA9PT0gXCJ2aXNpYmxlXCIgJiYgKGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpID09PSBcInZpc2libGVcIiAmJiByZXF1ZXN0ZWRUeXBlLnZhbHVlLFxuICAgICAgKHR5cGUpID0+IHtcbiAgICAgICAgcmVxdWVzdGVkVHlwZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgICBmb3JjZVJlcXVlc3QodHlwZSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmb3JjZVJlcXVlc3QodHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBhd2FpdCAoKF9hID0gc2VudGluZWwudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWxlYXNlKCkpO1xuICAgIHNlbnRpbmVsLnZhbHVlID0gaXNTdXBwb3J0ZWQudmFsdWUgPyBhd2FpdCBuYXZpZ2F0b3Iud2FrZUxvY2sucmVxdWVzdCh0eXBlKSA6IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdCh0eXBlKSB7XG4gICAgaWYgKGRvY3VtZW50VmlzaWJpbGl0eS52YWx1ZSA9PT0gXCJ2aXNpYmxlXCIpXG4gICAgICBhd2FpdCBmb3JjZVJlcXVlc3QodHlwZSk7XG4gICAgZWxzZVxuICAgICAgcmVxdWVzdGVkVHlwZS52YWx1ZSA9IHR5cGU7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICByZXF1ZXN0ZWRUeXBlLnZhbHVlID0gZmFsc2U7XG4gICAgY29uc3QgcyA9IHNlbnRpbmVsLnZhbHVlO1xuICAgIHNlbnRpbmVsLnZhbHVlID0gbnVsbDtcbiAgICBhd2FpdCAocyA9PSBudWxsID8gdm9pZCAwIDogcy5yZWxlYXNlKCkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2VudGluZWwsXG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNBY3RpdmUsXG4gICAgcmVxdWVzdCxcbiAgICBmb3JjZVJlcXVlc3QsXG4gICAgcmVsZWFzZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VXZWJOb3RpZmljYXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIHJlcXVlc3RQZXJtaXNzaW9uczogX3JlcXVlc3RGb3JQZXJtaXNzaW9ucyA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRlZmF1bHRXZWJOb3RpZmljYXRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4ge1xuICAgIGlmICghd2luZG93IHx8ICEoXCJOb3RpZmljYXRpb25cIiBpbiB3aW5kb3cpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gXCJncmFudGVkXCIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgbm90aWZpY2F0aW9uMiA9IG5ldyBOb3RpZmljYXRpb24oXCJcIik7XG4gICAgICBub3RpZmljYXRpb24yLm9uc2hvdyA9ICgpID0+IHtcbiAgICAgICAgbm90aWZpY2F0aW9uMi5jbG9zZSgpO1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lID09PSBcIlR5cGVFcnJvclwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgY29uc3QgcGVybWlzc2lvbkdyYW50ZWQgPSBzaGFsbG93UmVmKGlzU3VwcG9ydGVkLnZhbHVlICYmIFwicGVybWlzc2lvblwiIGluIE5vdGlmaWNhdGlvbiAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gXCJncmFudGVkXCIpO1xuICBjb25zdCBub3RpZmljYXRpb24gPSByZWYobnVsbCk7XG4gIGNvbnN0IGVuc3VyZVBlcm1pc3Npb25zID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiAhPT0gXCJkZW5pZWRcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBcImdyYW50ZWRcIilcbiAgICAgICAgcGVybWlzc2lvbkdyYW50ZWQudmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGVybWlzc2lvbkdyYW50ZWQudmFsdWU7XG4gIH07XG4gIGNvbnN0IHsgb246IG9uQ2xpY2ssIHRyaWdnZXI6IGNsaWNrVHJpZ2dlciB9ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IHsgb246IG9uU2hvdywgdHJpZ2dlcjogc2hvd1RyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvbkVycm9yLCB0cmlnZ2VyOiBlcnJvclRyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvbkNsb3NlLCB0cmlnZ2VyOiBjbG9zZVRyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBzaG93ID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgIXBlcm1pc3Npb25HcmFudGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9wdGlvbnMyID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFdlYk5vdGlmaWNhdGlvbk9wdGlvbnMsIG92ZXJyaWRlcyk7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlID0gbmV3IE5vdGlmaWNhdGlvbihvcHRpb25zMi50aXRsZSB8fCBcIlwiLCBvcHRpb25zMik7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlLm9uY2xpY2sgPSBjbGlja1RyaWdnZXI7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlLm9uc2hvdyA9IHNob3dUcmlnZ2VyO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZS5vbmVycm9yID0gZXJyb3JUcmlnZ2VyO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZS5vbmNsb3NlID0gY2xvc2VUcmlnZ2VyO1xuICAgIHJldHVybiBub3RpZmljYXRpb24udmFsdWU7XG4gIH07XG4gIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgIGlmIChub3RpZmljYXRpb24udmFsdWUpXG4gICAgICBub3RpZmljYXRpb24udmFsdWUuY2xvc2UoKTtcbiAgICBub3RpZmljYXRpb24udmFsdWUgPSBudWxsO1xuICB9O1xuICBpZiAoX3JlcXVlc3RGb3JQZXJtaXNzaW9ucylcbiAgICB0cnlPbk1vdW50ZWQoZW5zdXJlUGVybWlzc2lvbnMpO1xuICB0cnlPblNjb3BlRGlzcG9zZShjbG9zZSk7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB3aW5kb3cpIHtcbiAgICBjb25zdCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInZpc2liaWxpdHljaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBub3RpZmljYXRpb24sXG4gICAgZW5zdXJlUGVybWlzc2lvbnMsXG4gICAgcGVybWlzc2lvbkdyYW50ZWQsXG4gICAgc2hvdyxcbiAgICBjbG9zZSxcbiAgICBvbkNsaWNrLFxuICAgIG9uU2hvdyxcbiAgICBvbkVycm9yLFxuICAgIG9uQ2xvc2VcbiAgfTtcbn1cblxuY29uc3QgREVGQVVMVF9QSU5HX01FU1NBR0UgPSBcInBpbmdcIjtcbmZ1bmN0aW9uIHJlc29sdmVOZXN0ZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpXG4gICAgcmV0dXJuIHt9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIHVzZVdlYlNvY2tldCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgb25Db25uZWN0ZWQsXG4gICAgb25EaXNjb25uZWN0ZWQsXG4gICAgb25FcnJvcixcbiAgICBvbk1lc3NhZ2UsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBhdXRvQ29ubmVjdCA9IHRydWUsXG4gICAgYXV0b0Nsb3NlID0gdHJ1ZSxcbiAgICBwcm90b2NvbHMgPSBbXVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZGF0YSA9IHJlZihudWxsKTtcbiAgY29uc3Qgc3RhdHVzID0gc2hhbGxvd1JlZihcIkNMT1NFRFwiKTtcbiAgY29uc3Qgd3NSZWYgPSByZWYoKTtcbiAgY29uc3QgdXJsUmVmID0gdG9SZWYodXJsKTtcbiAgbGV0IGhlYXJ0YmVhdFBhdXNlO1xuICBsZXQgaGVhcnRiZWF0UmVzdW1lO1xuICBsZXQgZXhwbGljaXRseUNsb3NlZCA9IGZhbHNlO1xuICBsZXQgcmV0cmllZCA9IDA7XG4gIGxldCBidWZmZXJlZERhdGEgPSBbXTtcbiAgbGV0IHJldHJ5VGltZW91dDtcbiAgbGV0IHBvbmdUaW1lb3V0V2FpdDtcbiAgY29uc3QgX3NlbmRCdWZmZXIgPSAoKSA9PiB7XG4gICAgaWYgKGJ1ZmZlcmVkRGF0YS5sZW5ndGggJiYgd3NSZWYudmFsdWUgJiYgc3RhdHVzLnZhbHVlID09PSBcIk9QRU5cIikge1xuICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVyZWREYXRhKVxuICAgICAgICB3c1JlZi52YWx1ZS5zZW5kKGJ1ZmZlcik7XG4gICAgICBidWZmZXJlZERhdGEgPSBbXTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlc2V0UmV0cnkgPSAoKSA9PiB7XG4gICAgaWYgKHJldHJ5VGltZW91dCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmV0cnlUaW1lb3V0KTtcbiAgICAgIHJldHJ5VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlc2V0SGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dChwb25nVGltZW91dFdhaXQpO1xuICAgIHBvbmdUaW1lb3V0V2FpdCA9IHZvaWQgMDtcbiAgfTtcbiAgY29uc3QgY2xvc2UgPSAoY29kZSA9IDFlMywgcmVhc29uKSA9PiB7XG4gICAgcmVzZXRSZXRyeSgpO1xuICAgIGlmICghaXNDbGllbnQgJiYgIWlzV29ya2VyIHx8ICF3c1JlZi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBleHBsaWNpdGx5Q2xvc2VkID0gdHJ1ZTtcbiAgICByZXNldEhlYXJ0YmVhdCgpO1xuICAgIGhlYXJ0YmVhdFBhdXNlID09IG51bGwgPyB2b2lkIDAgOiBoZWFydGJlYXRQYXVzZSgpO1xuICAgIHdzUmVmLnZhbHVlLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgd3NSZWYudmFsdWUgPSB2b2lkIDA7XG4gIH07XG4gIGNvbnN0IHNlbmQgPSAoZGF0YTIsIHVzZUJ1ZmZlciA9IHRydWUpID0+IHtcbiAgICBpZiAoIXdzUmVmLnZhbHVlIHx8IHN0YXR1cy52YWx1ZSAhPT0gXCJPUEVOXCIpIHtcbiAgICAgIGlmICh1c2VCdWZmZXIpXG4gICAgICAgIGJ1ZmZlcmVkRGF0YS5wdXNoKGRhdGEyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3NlbmRCdWZmZXIoKTtcbiAgICB3c1JlZi52YWx1ZS5zZW5kKGRhdGEyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgX2luaXQgPSAoKSA9PiB7XG4gICAgaWYgKGV4cGxpY2l0bHlDbG9zZWQgfHwgdHlwZW9mIHVybFJlZi52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQodXJsUmVmLnZhbHVlLCBwcm90b2NvbHMpO1xuICAgIHdzUmVmLnZhbHVlID0gd3M7XG4gICAgc3RhdHVzLnZhbHVlID0gXCJDT05ORUNUSU5HXCI7XG4gICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJPUEVOXCI7XG4gICAgICByZXRyaWVkID0gMDtcbiAgICAgIG9uQ29ubmVjdGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkNvbm5lY3RlZCh3cyk7XG4gICAgICBoZWFydGJlYXRSZXN1bWUgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYXJ0YmVhdFJlc3VtZSgpO1xuICAgICAgX3NlbmRCdWZmZXIoKTtcbiAgICB9O1xuICAgIHdzLm9uY2xvc2UgPSAoZXYpID0+IHtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiQ0xPU0VEXCI7XG4gICAgICByZXNldEhlYXJ0YmVhdCgpO1xuICAgICAgaGVhcnRiZWF0UGF1c2UgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYXJ0YmVhdFBhdXNlKCk7XG4gICAgICBvbkRpc2Nvbm5lY3RlZCA9PSBudWxsID8gdm9pZCAwIDogb25EaXNjb25uZWN0ZWQod3MsIGV2KTtcbiAgICAgIGlmICghZXhwbGljaXRseUNsb3NlZCAmJiBvcHRpb25zLmF1dG9SZWNvbm5lY3QgJiYgKHdzUmVmLnZhbHVlID09IG51bGwgfHwgd3MgPT09IHdzUmVmLnZhbHVlKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmV0cmllcyA9IC0xLFxuICAgICAgICAgIGRlbGF5ID0gMWUzLFxuICAgICAgICAgIG9uRmFpbGVkXG4gICAgICAgIH0gPSByZXNvbHZlTmVzdGVkT3B0aW9ucyhvcHRpb25zLmF1dG9SZWNvbm5lY3QpO1xuICAgICAgICBjb25zdCBjaGVja1JldGlyZXMgPSB0eXBlb2YgcmV0cmllcyA9PT0gXCJmdW5jdGlvblwiID8gcmV0cmllcyA6ICgpID0+IHR5cGVvZiByZXRyaWVzID09PSBcIm51bWJlclwiICYmIChyZXRyaWVzIDwgMCB8fCByZXRyaWVkIDwgcmV0cmllcyk7XG4gICAgICAgIGlmIChjaGVja1JldGlyZXMocmV0cmllZCkpIHtcbiAgICAgICAgICByZXRyaWVkICs9IDE7XG4gICAgICAgICAgcmV0cnlUaW1lb3V0ID0gc2V0VGltZW91dChfaW5pdCwgZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRmFpbGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkZhaWxlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3cy5vbmVycm9yID0gKGUpID0+IHtcbiAgICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3Iod3MsIGUpO1xuICAgIH07XG4gICAgd3Mub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLmhlYXJ0YmVhdCkge1xuICAgICAgICByZXNldEhlYXJ0YmVhdCgpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWVzc2FnZSA9IERFRkFVTFRfUElOR19NRVNTQUdFLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2VcbiAgICAgICAgfSA9IHJlc29sdmVOZXN0ZWRPcHRpb25zKG9wdGlvbnMuaGVhcnRiZWF0KTtcbiAgICAgICAgaWYgKGUuZGF0YSA9PT0gdG9WYWx1ZShyZXNwb25zZU1lc3NhZ2UpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGE7XG4gICAgICBvbk1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTWVzc2FnZSh3cywgZSk7XG4gICAgfTtcbiAgfTtcbiAgaWYgKG9wdGlvbnMuaGVhcnRiZWF0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZSA9IERFRkFVTFRfUElOR19NRVNTQUdFLFxuICAgICAgaW50ZXJ2YWwgPSAxZTMsXG4gICAgICBwb25nVGltZW91dCA9IDFlM1xuICAgIH0gPSByZXNvbHZlTmVzdGVkT3B0aW9ucyhvcHRpb25zLmhlYXJ0YmVhdCk7XG4gICAgY29uc3QgeyBwYXVzZSwgcmVzdW1lIH0gPSB1c2VJbnRlcnZhbEZuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzZW5kKHRvVmFsdWUobWVzc2FnZSksIGZhbHNlKTtcbiAgICAgICAgaWYgKHBvbmdUaW1lb3V0V2FpdCAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcG9uZ1RpbWVvdXRXYWl0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH0sIHBvbmdUaW1lb3V0KTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIHsgaW1tZWRpYXRlOiBmYWxzZSB9XG4gICAgKTtcbiAgICBoZWFydGJlYXRQYXVzZSA9IHBhdXNlO1xuICAgIGhlYXJ0YmVhdFJlc3VtZSA9IHJlc3VtZTtcbiAgfVxuICBpZiAoYXV0b0Nsb3NlKSB7XG4gICAgaWYgKGlzQ2xpZW50KVxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiBjbG9zZSgpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdHJ5T25TY29wZURpc3Bvc2UoY2xvc2UpO1xuICB9XG4gIGNvbnN0IG9wZW4gPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCAmJiAhaXNXb3JrZXIpXG4gICAgICByZXR1cm47XG4gICAgY2xvc2UoKTtcbiAgICBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgcmV0cmllZCA9IDA7XG4gICAgX2luaXQoKTtcbiAgfTtcbiAgaWYgKGltbWVkaWF0ZSlcbiAgICBvcGVuKCk7XG4gIGlmIChhdXRvQ29ubmVjdClcbiAgICB3YXRjaCh1cmxSZWYsIG9wZW4pO1xuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgc3RhdHVzLFxuICAgIGNsb3NlLFxuICAgIHNlbmQsXG4gICAgb3BlbixcbiAgICB3czogd3NSZWZcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlV2ViV29ya2VyKGFyZzAsIHdvcmtlck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgY29uc3QgZGF0YSA9IHJlZihudWxsKTtcbiAgY29uc3Qgd29ya2VyID0gc2hhbGxvd1JlZigpO1xuICBjb25zdCBwb3N0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIXdvcmtlci52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB3b3JrZXIudmFsdWUucG9zdE1lc3NhZ2UoLi4uYXJncyk7XG4gIH07XG4gIGNvbnN0IHRlcm1pbmF0ZSA9IGZ1bmN0aW9uIHRlcm1pbmF0ZTIoKSB7XG4gICAgaWYgKCF3b3JrZXIudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgd29ya2VyLnZhbHVlLnRlcm1pbmF0ZSgpO1xuICB9O1xuICBpZiAod2luZG93KSB7XG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSBcInN0cmluZ1wiKVxuICAgICAgd29ya2VyLnZhbHVlID0gbmV3IFdvcmtlcihhcmcwLCB3b3JrZXJPcHRpb25zKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgYXJnMCA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgd29ya2VyLnZhbHVlID0gYXJnMCgpO1xuICAgIGVsc2VcbiAgICAgIHdvcmtlci52YWx1ZSA9IGFyZzA7XG4gICAgd29ya2VyLnZhbHVlLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICBkYXRhLnZhbHVlID0gZS5kYXRhO1xuICAgIH07XG4gICAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgICAgaWYgKHdvcmtlci52YWx1ZSlcbiAgICAgICAgd29ya2VyLnZhbHVlLnRlcm1pbmF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBwb3N0LFxuICAgIHRlcm1pbmF0ZSxcbiAgICB3b3JrZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVwc1BhcnNlcihkZXBzLCBsb2NhbERlcHMpIHtcbiAgaWYgKGRlcHMubGVuZ3RoID09PSAwICYmIGxvY2FsRGVwcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IGRlcHNTdHJpbmcgPSBkZXBzLm1hcCgoZGVwKSA9PiBgJyR7ZGVwfSdgKS50b1N0cmluZygpO1xuICBjb25zdCBkZXBzRnVuY3Rpb25TdHJpbmcgPSBsb2NhbERlcHMuZmlsdGVyKChkZXApID0+IHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIikubWFwKChmbikgPT4ge1xuICAgIGNvbnN0IHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgaWYgKHN0ci50cmltKCkuc3RhcnRzV2l0aChcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lID0gZm4ubmFtZTtcbiAgICAgIHJldHVybiBgY29uc3QgJHtuYW1lfSA9ICR7c3RyfWA7XG4gICAgfVxuICB9KS5qb2luKFwiO1wiKTtcbiAgY29uc3QgaW1wb3J0U3RyaW5nID0gYGltcG9ydFNjcmlwdHMoJHtkZXBzU3RyaW5nfSk7YDtcbiAgcmV0dXJuIGAke2RlcHNTdHJpbmcudHJpbSgpID09PSBcIlwiID8gXCJcIiA6IGltcG9ydFN0cmluZ30gJHtkZXBzRnVuY3Rpb25TdHJpbmd9YDtcbn1cblxuZnVuY3Rpb24gam9iUnVubmVyKHVzZXJGdW5jKSB7XG4gIHJldHVybiAoZSkgPT4ge1xuICAgIGNvbnN0IHVzZXJGdW5jQXJncyA9IGUuZGF0YVswXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVzZXJGdW5jLmFwcGx5KHZvaWQgMCwgdXNlckZ1bmNBcmdzKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBwb3N0TWVzc2FnZShbXCJTVUNDRVNTXCIsIHJlc3VsdF0pO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgcG9zdE1lc3NhZ2UoW1wiRVJST1JcIiwgZXJyb3JdKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya2VyQmxvYlVybChmbiwgZGVwcywgbG9jYWxEZXBzKSB7XG4gIGNvbnN0IGJsb2JDb2RlID0gYCR7ZGVwc1BhcnNlcihkZXBzLCBsb2NhbERlcHMpfTsgb25tZXNzYWdlPSgke2pvYlJ1bm5lcn0pKCR7Zm59KWA7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYmxvYkNvZGVdLCB7IHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCIgfSk7XG4gIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIHVzZVdlYldvcmtlckZuKGZuLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGRlcGVuZGVuY2llcyA9IFtdLFxuICAgIGxvY2FsRGVwZW5kZW5jaWVzID0gW10sXG4gICAgdGltZW91dCxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB3b3JrZXIgPSByZWYoKTtcbiAgY29uc3Qgd29ya2VyU3RhdHVzID0gc2hhbGxvd1JlZihcIlBFTkRJTkdcIik7XG4gIGNvbnN0IHByb21pc2UgPSByZWYoe30pO1xuICBjb25zdCB0aW1lb3V0SWQgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IHdvcmtlclRlcm1pbmF0ZSA9IChzdGF0dXMgPSBcIlBFTkRJTkdcIikgPT4ge1xuICAgIGlmICh3b3JrZXIudmFsdWUgJiYgd29ya2VyLnZhbHVlLl91cmwgJiYgd2luZG93KSB7XG4gICAgICB3b3JrZXIudmFsdWUudGVybWluYXRlKCk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlci52YWx1ZS5fdXJsKTtcbiAgICAgIHByb21pc2UudmFsdWUgPSB7fTtcbiAgICAgIHdvcmtlci52YWx1ZSA9IHZvaWQgMDtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkLnZhbHVlKTtcbiAgICAgIHdvcmtlclN0YXR1cy52YWx1ZSA9IHN0YXR1cztcbiAgICB9XG4gIH07XG4gIHdvcmtlclRlcm1pbmF0ZSgpO1xuICB0cnlPblNjb3BlRGlzcG9zZSh3b3JrZXJUZXJtaW5hdGUpO1xuICBjb25zdCBnZW5lcmF0ZVdvcmtlciA9ICgpID0+IHtcbiAgICBjb25zdCBibG9iVXJsID0gY3JlYXRlV29ya2VyQmxvYlVybChmbiwgZGVwZW5kZW5jaWVzLCBsb2NhbERlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgbmV3V29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICBuZXdXb3JrZXIuX3VybCA9IGJsb2JVcmw7XG4gICAgbmV3V29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc29sdmUgPSAoKSA9PiB7XG4gICAgICB9LCByZWplY3QgPSAoKSA9PiB7XG4gICAgICB9IH0gPSBwcm9taXNlLnZhbHVlO1xuICAgICAgY29uc3QgW3N0YXR1cywgcmVzdWx0XSA9IGUuZGF0YTtcbiAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJTVUNDRVNTXCI6XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIHdvcmtlclRlcm1pbmF0ZShzdGF0dXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlamVjdChyZXN1bHQpO1xuICAgICAgICAgIHdvcmtlclRlcm1pbmF0ZShcIkVSUk9SXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgbmV3V29ya2VyLm9uZXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgeyByZWplY3QgPSAoKSA9PiB7XG4gICAgICB9IH0gPSBwcm9taXNlLnZhbHVlO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmVqZWN0KGUpO1xuICAgICAgd29ya2VyVGVybWluYXRlKFwiRVJST1JcIik7XG4gICAgfTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgdGltZW91dElkLnZhbHVlID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gd29ya2VyVGVybWluYXRlKFwiVElNRU9VVF9FWFBJUkVEXCIpLFxuICAgICAgICB0aW1lb3V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3V29ya2VyO1xuICB9O1xuICBjb25zdCBjYWxsV29ya2VyID0gKC4uLmZuQXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBwcm9taXNlLnZhbHVlID0ge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdFxuICAgIH07XG4gICAgKF9hID0gd29ya2VyLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UoW1suLi5mbkFyZ3NdXSk7XG4gICAgd29ya2VyU3RhdHVzLnZhbHVlID0gXCJSVU5OSU5HXCI7XG4gIH0pO1xuICBjb25zdCB3b3JrZXJGbiA9ICguLi5mbkFyZ3MpID0+IHtcbiAgICBpZiAod29ya2VyU3RhdHVzLnZhbHVlID09PSBcIlJVTk5JTkdcIikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJbdXNlV2ViV29ya2VyRm5dIFlvdSBjYW4gb25seSBydW4gb25lIGluc3RhbmNlIG9mIHRoZSB3b3JrZXIgYXQgYSB0aW1lLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgfVxuICAgIHdvcmtlci52YWx1ZSA9IGdlbmVyYXRlV29ya2VyKCk7XG4gICAgcmV0dXJuIGNhbGxXb3JrZXIoLi4uZm5BcmdzKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB3b3JrZXJGbixcbiAgICB3b3JrZXJTdGF0dXMsXG4gICAgd29ya2VyVGVybWluYXRlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVdpbmRvd0ZvY3VzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93KVxuICAgIHJldHVybiBzaGFsbG93UmVmKGZhbHNlKTtcbiAgY29uc3QgZm9jdXNlZCA9IHNoYWxsb3dSZWYod2luZG93LmRvY3VtZW50Lmhhc0ZvY3VzKCkpO1xuICBjb25zdCBsaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiYmx1clwiLCAoKSA9PiB7XG4gICAgZm9jdXNlZC52YWx1ZSA9IGZhbHNlO1xuICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgZm9jdXNlZC52YWx1ZSA9IHRydWU7XG4gIH0sIGxpc3RlbmVyT3B0aW9ucyk7XG4gIHJldHVybiBmb2N1c2VkO1xufVxuXG5mdW5jdGlvbiB1c2VXaW5kb3dTY3JvbGwob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHVzZVNjcm9sbCh3aW5kb3csIHJlc3QpO1xufVxuXG5mdW5jdGlvbiB1c2VXaW5kb3dTaXplKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBpbml0aWFsV2lkdGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgaW5pdGlhbEhlaWdodCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBsaXN0ZW5PcmllbnRhdGlvbiA9IHRydWUsXG4gICAgaW5jbHVkZVNjcm9sbGJhciA9IHRydWUsXG4gICAgdHlwZSA9IFwiaW5uZXJcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgd2lkdGggPSBzaGFsbG93UmVmKGluaXRpYWxXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IHNoYWxsb3dSZWYoaW5pdGlhbEhlaWdodCk7XG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICBpZiAod2luZG93KSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJvdXRlclwiKSB7XG4gICAgICAgIHdpZHRoLnZhbHVlID0gd2luZG93Lm91dGVyV2lkdGg7XG4gICAgICAgIGhlaWdodC52YWx1ZSA9IHdpbmRvdy5vdXRlckhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2aXN1YWxcIiAmJiB3aW5kb3cudmlzdWFsVmlld3BvcnQpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aDogdmlzdWFsVmlld3BvcnRXaWR0aCwgaGVpZ2h0OiB2aXN1YWxWaWV3cG9ydEhlaWdodCwgc2NhbGUgfSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbiAgICAgICAgd2lkdGgudmFsdWUgPSBNYXRoLnJvdW5kKHZpc3VhbFZpZXdwb3J0V2lkdGggKiBzY2FsZSk7XG4gICAgICAgIGhlaWdodC52YWx1ZSA9IE1hdGgucm91bmQodmlzdWFsVmlld3BvcnRIZWlnaHQgKiBzY2FsZSk7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVTY3JvbGxiYXIpIHtcbiAgICAgICAgd2lkdGgudmFsdWUgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgaGVpZ2h0LnZhbHVlID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGgudmFsdWUgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQudmFsdWUgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHVwZGF0ZSgpO1xuICB0cnlPbk1vdW50ZWQodXBkYXRlKTtcbiAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlLCBsaXN0ZW5lck9wdGlvbnMpO1xuICBpZiAod2luZG93ICYmIHR5cGUgPT09IFwidmlzdWFsXCIgJiYgd2luZG93LnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3cudmlzdWFsVmlld3BvcnQsIFwicmVzaXplXCIsIHVwZGF0ZSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICBpZiAobGlzdGVuT3JpZW50YXRpb24pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdXNlTWVkaWFRdWVyeShcIihvcmllbnRhdGlvbjogcG9ydHJhaXQpXCIpO1xuICAgIHdhdGNoKG1hdGNoZXMsICgpID0+IHVwZGF0ZSgpKTtcbiAgfVxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG59XG5cbmV4cG9ydCB7IERlZmF1bHRNYWdpY0tleXNBbGlhc01hcCwgU3RvcmFnZVNlcmlhbGl6ZXJzLCBUcmFuc2l0aW9uUHJlc2V0cywgY29tcHV0ZWRBc3luYyBhcyBhc3luY0NvbXB1dGVkLCBicmVha3BvaW50c0FudERlc2lnbiwgYnJlYWtwb2ludHNCb290c3RyYXBWNSwgYnJlYWtwb2ludHNFbGVtZW50LCBicmVha3BvaW50c01hc3RlckNzcywgYnJlYWtwb2ludHNQcmltZUZsZXgsIGJyZWFrcG9pbnRzUXVhc2FyLCBicmVha3BvaW50c1NlbWF0aWMsIGJyZWFrcG9pbnRzVGFpbHdpbmQsIGJyZWFrcG9pbnRzVnVldGlmeSwgYnJlYWtwb2ludHNWdWV0aWZ5VjIsIGJyZWFrcG9pbnRzVnVldGlmeVYzLCBjbG9uZUZuSlNPTiwgY29tcHV0ZWRBc3luYywgY29tcHV0ZWRJbmplY3QsIGNyZWF0ZUZldGNoLCBjcmVhdGVSZXVzYWJsZVRlbXBsYXRlLCBjcmVhdGVUZW1wbGF0ZVByb21pc2UsIGNyZWF0ZVVucmVmRm4sIGN1c3RvbVN0b3JhZ2VFdmVudE5hbWUsIGRlZmF1bHREb2N1bWVudCwgZGVmYXVsdExvY2F0aW9uLCBkZWZhdWx0TmF2aWdhdG9yLCBkZWZhdWx0V2luZG93LCBleGVjdXRlVHJhbnNpdGlvbiwgZm9ybWF0VGltZUFnbywgZ2V0U1NSSGFuZGxlciwgbWFwR2FtZXBhZFRvWGJveDM2MENvbnRyb2xsZXIsIG9uQ2xpY2tPdXRzaWRlLCBvbkVsZW1lbnRSZW1vdmFsLCBvbktleURvd24sIG9uS2V5UHJlc3NlZCwgb25LZXlTdHJva2UsIG9uS2V5VXAsIG9uTG9uZ1ByZXNzLCBvblN0YXJ0VHlwaW5nLCBwcm92aWRlU1NSV2lkdGgsIHNldFNTUkhhbmRsZXIsIHRlbXBsYXRlUmVmLCB1bnJlZkVsZW1lbnQsIHVzZUFjdGl2ZUVsZW1lbnQsIHVzZUFuaW1hdGUsIHVzZUFzeW5jUXVldWUsIHVzZUFzeW5jU3RhdGUsIHVzZUJhc2U2NCwgdXNlQmF0dGVyeSwgdXNlQmx1ZXRvb3RoLCB1c2VCcmVha3BvaW50cywgdXNlQnJvYWRjYXN0Q2hhbm5lbCwgdXNlQnJvd3NlckxvY2F0aW9uLCB1c2VDYWNoZWQsIHVzZUNsaXBib2FyZCwgdXNlQ2xpcGJvYXJkSXRlbXMsIHVzZUNsb25lZCwgdXNlQ29sb3JNb2RlLCB1c2VDb25maXJtRGlhbG9nLCB1c2VDb3VudGRvd24sIHVzZUNzc1ZhciwgdXNlQ3VycmVudEVsZW1lbnQsIHVzZUN5Y2xlTGlzdCwgdXNlRGFyaywgdXNlRGVib3VuY2VkUmVmSGlzdG9yeSwgdXNlRGV2aWNlTW90aW9uLCB1c2VEZXZpY2VPcmllbnRhdGlvbiwgdXNlRGV2aWNlUGl4ZWxSYXRpbywgdXNlRGV2aWNlc0xpc3QsIHVzZURpc3BsYXlNZWRpYSwgdXNlRG9jdW1lbnRWaXNpYmlsaXR5LCB1c2VEcmFnZ2FibGUsIHVzZURyb3Bab25lLCB1c2VFbGVtZW50Qm91bmRpbmcsIHVzZUVsZW1lbnRCeVBvaW50LCB1c2VFbGVtZW50SG92ZXIsIHVzZUVsZW1lbnRTaXplLCB1c2VFbGVtZW50VmlzaWJpbGl0eSwgdXNlRXZlbnRCdXMsIHVzZUV2ZW50TGlzdGVuZXIsIHVzZUV2ZW50U291cmNlLCB1c2VFeWVEcm9wcGVyLCB1c2VGYXZpY29uLCB1c2VGZXRjaCwgdXNlRmlsZURpYWxvZywgdXNlRmlsZVN5c3RlbUFjY2VzcywgdXNlRm9jdXMsIHVzZUZvY3VzV2l0aGluLCB1c2VGcHMsIHVzZUZ1bGxzY3JlZW4sIHVzZUdhbWVwYWQsIHVzZUdlb2xvY2F0aW9uLCB1c2VJZGxlLCB1c2VJbWFnZSwgdXNlSW5maW5pdGVTY3JvbGwsIHVzZUludGVyc2VjdGlvbk9ic2VydmVyLCB1c2VLZXlNb2RpZmllciwgdXNlTG9jYWxTdG9yYWdlLCB1c2VNYWdpY0tleXMsIHVzZU1hbnVhbFJlZkhpc3RvcnksIHVzZU1lZGlhQ29udHJvbHMsIHVzZU1lZGlhUXVlcnksIHVzZU1lbW9pemUsIHVzZU1lbW9yeSwgdXNlTW91bnRlZCwgdXNlTW91c2UsIHVzZU1vdXNlSW5FbGVtZW50LCB1c2VNb3VzZVByZXNzZWQsIHVzZU11dGF0aW9uT2JzZXJ2ZXIsIHVzZU5hdmlnYXRvckxhbmd1YWdlLCB1c2VOZXR3b3JrLCB1c2VOb3csIHVzZU9iamVjdFVybCwgdXNlT2Zmc2V0UGFnaW5hdGlvbiwgdXNlT25saW5lLCB1c2VQYWdlTGVhdmUsIHVzZVBhcmFsbGF4LCB1c2VQYXJlbnRFbGVtZW50LCB1c2VQZXJmb3JtYW5jZU9ic2VydmVyLCB1c2VQZXJtaXNzaW9uLCB1c2VQb2ludGVyLCB1c2VQb2ludGVyTG9jaywgdXNlUG9pbnRlclN3aXBlLCB1c2VQcmVmZXJyZWRDb2xvclNjaGVtZSwgdXNlUHJlZmVycmVkQ29udHJhc3QsIHVzZVByZWZlcnJlZERhcmssIHVzZVByZWZlcnJlZExhbmd1YWdlcywgdXNlUHJlZmVycmVkUmVkdWNlZE1vdGlvbiwgdXNlUHJlZmVycmVkUmVkdWNlZFRyYW5zcGFyZW5jeSwgdXNlUHJldmlvdXMsIHVzZVJhZkZuLCB1c2VSZWZIaXN0b3J5LCB1c2VSZXNpemVPYnNlcnZlciwgdXNlU1NSV2lkdGgsIHVzZVNjcmVlbk9yaWVudGF0aW9uLCB1c2VTY3JlZW5TYWZlQXJlYSwgdXNlU2NyaXB0VGFnLCB1c2VTY3JvbGwsIHVzZVNjcm9sbExvY2ssIHVzZVNlc3Npb25TdG9yYWdlLCB1c2VTaGFyZSwgdXNlU29ydGVkLCB1c2VTcGVlY2hSZWNvZ25pdGlvbiwgdXNlU3BlZWNoU3ludGhlc2lzLCB1c2VTdGVwcGVyLCB1c2VTdG9yYWdlLCB1c2VTdG9yYWdlQXN5bmMsIHVzZVN0eWxlVGFnLCB1c2VTdXBwb3J0ZWQsIHVzZVN3aXBlLCB1c2VUZW1wbGF0ZVJlZnNMaXN0LCB1c2VUZXh0RGlyZWN0aW9uLCB1c2VUZXh0U2VsZWN0aW9uLCB1c2VUZXh0YXJlYUF1dG9zaXplLCB1c2VUaHJvdHRsZWRSZWZIaXN0b3J5LCB1c2VUaW1lQWdvLCB1c2VUaW1lb3V0UG9sbCwgdXNlVGltZXN0YW1wLCB1c2VUaXRsZSwgdXNlVHJhbnNpdGlvbiwgdXNlVXJsU2VhcmNoUGFyYW1zLCB1c2VVc2VyTWVkaWEsIHVzZVZNb2RlbCwgdXNlVk1vZGVscywgdXNlVmlicmF0ZSwgdXNlVmlydHVhbExpc3QsIHVzZVdha2VMb2NrLCB1c2VXZWJOb3RpZmljYXRpb24sIHVzZVdlYlNvY2tldCwgdXNlV2ViV29ya2VyLCB1c2VXZWJXb3JrZXJGbiwgdXNlV2luZG93Rm9jdXMsIHVzZVdpbmRvd1Njcm9sbCwgdXNlV2luZG93U2l6ZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLE1BQU0sb0JBQW9CLFVBQVUsVUFBVSxTQUFTLGdCQUFnQixVQUFVLG1CQUFtQixPQUFPLFlBQVksY0FBYyxZQUFZLGdCQUFnQixPQUFPLGFBQWEsY0FBYyxTQUFTLGtCQUFrQixlQUFlLFdBQVcsd0JBQXdCLGNBQWMsZUFBZSxPQUFPLGlCQUFpQixlQUFlLHFCQUFxQixXQUFXLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGNBQWMscUJBQXFCLFFBQVEsV0FBVyxjQUFjLFFBQVEsZ0JBQWdCLGVBQWUsZUFBZSxnQkFBZ0IsT0FBTyxTQUFTLFlBQVksaUJBQWlCLFVBQVUsT0FBTyxVQUFVLGdCQUFnQjtBQUMvb0IsY0FBYztBQUNkLFNBQVMsT0FBTyxZQUFZLEtBQUssYUFBYSxVQUFVLFFBQVEsaUJBQWlCLEdBQUcsaUJBQWlCLGlCQUFpQixVQUFVLFNBQVMsT0FBTyxvQkFBb0IsV0FBVyxPQUFPLFdBQVcsV0FBVyxVQUFVLFVBQVUscUJBQXFCLE9BQU8sVUFBVSxTQUFTLGlCQUFpQixZQUFZLHNCQUFzQjtBQUVsVSxTQUFTLGNBQWMsb0JBQW9CLGNBQWMsY0FBYztBQUNyRSxNQUFJO0FBQ0osTUFBSSxNQUFNLFlBQVksR0FBRztBQUN2QixjQUFVO0FBQUEsTUFDUixZ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QUFtQjtBQUNyQixVQUFNLFVBQVUsY0FBYyx5QkFBeUI7QUFDdkQsVUFBTSxTQUFTLE1BQU0sT0FBTyxDQUFDO0FBQUEsRUFDL0I7QUFDQSxTQUFPLEVBQUUsT0FBTyxPQUFPO0FBQ3pCO0FBRUEsU0FBUywwQkFBMEIsb0JBQW9CLG1CQUFtQixpQkFBaUIsZUFBZSxzQkFBc0Isd0JBQXdCLG9CQUFvQixzQkFBc0Isc0JBQXNCLG1CQUFtQixvQkFBb0IscUJBQXFCLG9CQUFvQixzQkFBc0Isc0JBQXNCLGFBQWEsZUFBZSxnQkFBZ0IsYUFBYSx3QkFBd0IsdUJBQXVCLGVBQWUsd0JBQXdCLGlCQUFpQixpQkFBaUIsa0JBQWtCLGVBQWUsbUJBQW1CLGVBQWUsZUFBZSwrQkFBK0IsZ0JBQWdCLGtCQUFrQixXQUFXLGNBQWMsYUFBYSxTQUFTLGFBQWEsZUFBZSxpQkFBaUIsZUFBZSxhQUFhLGNBQWMsa0JBQWtCLFlBQVksZUFBZSxlQUFlLFdBQVcsWUFBWSxjQUFjLGdCQUFnQixxQkFBcUIsb0JBQW9CLFdBQVcsY0FBYyxtQkFBbUIsV0FBVyxjQUFjLGtCQUFrQixjQUFjLFdBQVcsbUJBQW1CLGNBQWMsU0FBUyx3QkFBd0IsaUJBQWlCLHNCQUFzQixxQkFBcUIsZ0JBQWdCLGlCQUFpQix1QkFBdUIsY0FBYyxhQUFhLG9CQUFvQixtQkFBbUIsaUJBQWlCLGdCQUFnQixzQkFBc0IsYUFBYSxrQkFBa0IsZ0JBQWdCLGVBQWUsWUFBWSxVQUFVLGVBQWUscUJBQXFCLFVBQVUsZ0JBQWdCLFFBQVEsZUFBZSxZQUFZLGdCQUFnQixTQUFTLFVBQVUsbUJBQW1CLHlCQUF5QixnQkFBZ0IsaUJBQWlCLGNBQWMscUJBQXFCLGtCQUFrQixlQUFlLFlBQVksV0FBVyxZQUFZLFVBQVUsbUJBQW1CLGlCQUFpQixxQkFBcUIsc0JBQXNCLFlBQVksUUFBUSxjQUFjLHFCQUFxQixXQUFXLGNBQWMsYUFBYSxrQkFBa0Isd0JBQXdCLGVBQWUsWUFBWSxnQkFBZ0IsaUJBQWlCLHlCQUF5QixzQkFBc0Isa0JBQWtCLHVCQUF1QiwyQkFBMkIsaUNBQWlDLGFBQWEsVUFBVSxlQUFlLG1CQUFtQixhQUFhLHNCQUFzQixtQkFBbUIsY0FBYyxXQUFXLGVBQWUsbUJBQW1CLFVBQVUsV0FBVyxzQkFBc0Isb0JBQW9CLFlBQVksWUFBWSxpQkFBaUIsYUFBYSxjQUFjLFVBQVUscUJBQXFCLGtCQUFrQixrQkFBa0IscUJBQXFCLHdCQUF3QixZQUFZLGdCQUFnQixjQUFjLFVBQVUsZUFBZSxvQkFBb0IsY0FBYyxXQUFXLFlBQVksWUFBWSxnQkFBZ0IsYUFBYSxvQkFBb0IsY0FBYyxjQUFjLGdCQUFnQixnQkFBZ0IsaUJBQWlCOyIsIm5hbWVzIjpbIndpbmRvdyIsImRvY3VtZW50IiwidGltZXN0YW1wIiwibmF2aWdhdG9yIiwiZXZlbnRzIiwiZ2V0VmFsdWUiLCJyZWYiLCJkZWZhdWx0cyIsIm9uVXBkYXRlZCIsInByZXZlbnREZWZhdWx0Iiwia2V5cyIsImlzUmVhZG9ubHkiXSwieF9nb29nbGVfaWdub3JlTGlzdCI6WzBdfQ==